

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image1.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Hello! I am &lt;code&gt;millet&lt;/code&gt;, a new member who recently joined Hackyboiz.&lt;/p&gt;
&lt;p&gt;While solving wargame challenges in the past, I came across something called ASan. At the time, I only glanced over it briefly, but using this research article as an excuse, I decided to properly study it and chose it as my topic.&lt;/p&gt;
&lt;p&gt;In this article, I will take a look at what Address Sanitizer is and how it is implemented.&lt;/p&gt;
&lt;h2 id=&#34;1-About-Address-Sanitizer&#34;&gt;&lt;a href=&#34;#1-About-Address-Sanitizer&#34; class=&#34;headerlink&#34; title=&#34;1. About Address Sanitizer&#34;&gt;&lt;/a&gt;1. About Address Sanitizer&lt;/h2&gt;&lt;p&gt;Address Sanitizer, often abbreviated as ASan, is a runtime error detection tool designed to dynamically detect memory errors that occur during program execution.&lt;/p&gt;
&lt;p&gt;You can think of it as a tool that automatically inserts code to catch memory-related bugs when writing programs in C or C++. It was initially developed and maintained by Google, but is now maintained as part of the LLVM project.&lt;/p&gt;
&lt;p&gt;ASan is provided through multiple implementations. Since I primarily work in Linux environments, this research article will focus on the Sanitizer provided by GCC.&lt;/p&gt;
&lt;p&gt;In most Linux distributions, when GCC is installed, the corresponding runtime package is installed together (typically the &lt;code&gt;libasan&lt;/code&gt; package).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ (dpkg -l | grep libasan) &amp;amp;&amp;amp; (gcc --version | head -1)
ii  libasan6:amd64                       11.4.0-1ubuntu1~22.04.2                    amd64        AddressSanitizer -- a fast memory error detector
gcc (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ASan implementation provided by GCC uses the same memory model and detection mechanisms as LLVM ASan, so conceptually there is no difference.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image2.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;ASan is currently supported on the following platforms.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OS&lt;/th&gt;
&lt;th&gt;x86&lt;/th&gt;
&lt;th&gt;x86_64&lt;/th&gt;
&lt;th&gt;ARM&lt;/th&gt;
&lt;th&gt;ARM64&lt;/th&gt;
&lt;th&gt;MIPS&lt;/th&gt;
&lt;th&gt;MIPS64&lt;/th&gt;
&lt;th&gt;PowerPC&lt;/th&gt;
&lt;th&gt;PowerPC64&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OS X&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iOS Simulator&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FreeBSD&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1-1-Detectable-memory-errors&#34;&gt;&lt;a href=&#34;#1-1-Detectable-memory-errors&#34; class=&#34;headerlink&#34; title=&#34;1.1 Detectable memory errors&#34;&gt;&lt;/a&gt;1.1 Detectable memory errors&lt;/h3&gt;&lt;p&gt;As its name suggests, ASan can detect most common memory errors. The detection scope and behavior can be configured using compile-time options and runtime flags. Some representative examples are listed below.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use After Free (Dangling Pointer Dereference)&lt;br&gt;Heap Buffer Overflow&lt;br&gt;Stack Buffer Overflow&lt;br&gt;Global Buffer Overflow&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;-fsanitize=address&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Use After Return&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=detect_stack_use_after_return=1&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This option incurs significant performance overhead because stack frames are moved to a separate virtual heap.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Use After Scope&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=detect_stack_use_after_scope=1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Initialization Order Bugs&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=check_initialization_order=1&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Applicable only to C++, where global object initialization order matters.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Memory Leaks&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=detect_leaks=1&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This functionality is actually handled by &lt;a href=&#34;https://clang.llvm.org/docs/LeakSanitizer.html&#34;&gt;LeakSanitizer&lt;/a&gt;, not ASAN itself.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are many more runtime flags available, but in this article, the focus will be on the core functionality enabled by &lt;code&gt;-fsanitize=address&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Additionally, ASan&amp;#x2019;s fast unwinder relies on frame pointer chains, so it is recommended to compile with the following option to ensure that the RBP register is used as a frame pointer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;-fno-omit-frame-pointer&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-ASAN-Monitoring-Mechanisms&#34;&gt;&lt;a href=&#34;#2-ASAN-Monitoring-Mechanisms&#34; class=&#34;headerlink&#34; title=&#34;2. ASAN Monitoring Mechanisms&#34;&gt;&lt;/a&gt;2. &lt;strong&gt;ASAN Monitoring Mechanisms&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;As seen above, simply using &lt;code&gt;-fsanitize=address&lt;/code&gt; enables a wide range of detections. How does ASan detect these memory errors?&lt;/p&gt;
&lt;p&gt;ASan primarily relies on three monitoring mechanisms:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shadow Memory-based Access Monitoring&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Poisoning / Unpoisoning for Lifetime Tracking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redzones for Boundary Detection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;These mechanisms are inserted into the program during compile-time instrumentation.&lt;/p&gt;
&lt;p&gt;Checks are inserted before every memory read, write, allocation, and deallocation, and when a policy violation is detected, an error message is printed and the program is terminated by default.&lt;/p&gt;
&lt;p&gt;Instrumentation is mainly inserted at the following points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Before memory read/write instructions&lt;/li&gt;
&lt;li&gt;At dynamic memory allocation&lt;/li&gt;
&lt;li&gt;At dynamic memory deallocation&lt;/li&gt;
&lt;li&gt;At function entry (stack frame setup)&lt;/li&gt;
&lt;li&gt;At function return (stack frame teardown)&lt;/li&gt;
&lt;li&gt;At global object initialization and destruction&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;byte *shadow_address = MemToShadow(address);
byte shadow_value = *shadow_address;
&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (shadow_value) {
		&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (SlowPathCheck(shadow_value, address, kAccessSize)) {
				ReportError(address, kAccessSize, kIsWrite);
		}
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let us examine each mechanism in detail.&lt;/p&gt;
&lt;h3 id=&#34;2-1-Shadow-Memory&#34;&gt;&lt;a href=&#34;#2-1-Shadow-Memory&#34; class=&#34;headerlink&#34; title=&#34;2.1 Shadow Memory&#34;&gt;&lt;/a&gt;2.1 Shadow Memory&lt;/h3&gt;&lt;p&gt;ASan maintains a separate memory region called shadow memory, which stores metadata for each byte of the program&amp;#x2019;s memory.&lt;/p&gt;
&lt;p&gt;The address of the shadow memory corresponding to a given memory address is calculated as follows.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;Shadow = (Mem &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + SHADOW_OFFSET&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Internally, this is implemented using the following macros.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_mapping.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; MEM_TO_SHADOW(mem) \&lt;/span&gt;
      ((STRIP_MTE_TAG(mem) &amp;gt;&amp;gt; ASAN_SHADOW_SCALE) + (ASAN_SHADOW_OFFSET))
&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; SHADOW_TO_MEM(mem) \&lt;/span&gt;
      (((mem) - (ASAN_SHADOW_OFFSET)) &amp;lt;&amp;lt; (ASAN_SHADOW_SCALE))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As shown above, 8 bytes of application memory correspond to 1 byte of shadow memory.&lt;/p&gt;
&lt;p&gt;The value of &lt;code&gt;SHADOW_OFFSET&lt;/code&gt; is platform- and architecture-dependent. On x86-64, it is defined as &lt;code&gt;0x7fff8000&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_mapping.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Typical shadow mapping on Linux/x86_64 with SHADOW_OFFSET == 0x00007fff8000:&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x10007fff8000, 0x7fffffffffff]` || HighMem    ||&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x02008fff7000, 0x10007fff7fff]` || HighShadow ||&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x00008fff7000, 0x02008fff6fff]` || ShadowGap  ||&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x00007fff8000, 0x00008fff6fff]` || LowShadow  ||&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x000000000000, 0x00007fff7fff]` || LowMem     ||&lt;/span&gt;
...
&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;if&lt;/span&gt; ASAN_SHADOW_SCALE != 3&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#      &lt;span class=&#34;hljs-meta-keyword&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;Value below is based on shadow scale = 3.&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#      &lt;span class=&#34;hljs-meta-keyword&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;Original formula was: 0x7FFFFFFF &amp;amp; (~0xFFFULL &amp;lt;&amp;lt; SHADOW_SCALE).&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_SHADOW_OFFSET_CONST 0x000000007fff8000&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#  &lt;span class=&#34;hljs-meta-keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AS documented in the source code, shadow memory and application memory are logically separated in the virtual address space. On x86-64, the layout is as follows.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Category&lt;/th&gt;
&lt;th&gt;Mapped Region&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HighMem&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x10007fff8000, 0x7fffffffffff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Virtual memory represented by 5 bytes or more&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HighShadow&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x02008fff7000, 0x10007fff7fff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Shadow Memory corresponding to HighMem&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ShadowGap&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x00008fff7000, 0x02008fff6fff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Gap region between Shadow Memory areas&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LowShadow&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x00007fff8000, 0x00008fff6fff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Shadow Memory corresponding to LowMem&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LowMem&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x000000000000, 0x00007fff7fff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Virtual memory represented by 4 bytes or less&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image3.png&#34; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The ShadowGap region exists solely to prevent interference between shadow regions and has no read or write permissions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image4.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Because shadow memory is mapped at an 8:1 ratio, certain unaligned memory accesses may not be detected. Consider the following example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// g++ oob.cpp -o oob -fsanitize=address&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; *x = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt;[&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;];                &lt;span class=&#34;hljs-comment&#34;&gt;// [0, 7]&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; *y = (&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; *)((&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *)x + &lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;);    &lt;span class=&#34;hljs-comment&#34;&gt;// [6, 9]&lt;/span&gt;
    *y = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;;                             &lt;span class=&#34;hljs-comment&#34;&gt;// OOB&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;delete&lt;/span&gt;[] x;

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although this is clearly an out-of-bounds access, ASAN does not detect it due to the 8:1 mapping granularity.&lt;/p&gt;
&lt;p&gt;To address such cases, it is recommended to enable additional sanitizers such as &lt;code&gt;-fsanitize=alignment&lt;/code&gt;, which is part of Undefined Behavior Sanitizer (UBSan).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image5.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Because the shadow memory is mapped at an 8:1 ratio, the result of the expression&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(v4 + 6) &amp;gt;&amp;gt; 3&lt;/code&gt; eventually becomes identical to &lt;code&gt;v4 &amp;gt;&amp;gt; 3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As a result, the same shadow memory byte is checked, which prevents ASan from detecting the out-of-bounds access.&lt;/p&gt;
&lt;p&gt;Due to this structural limitation, memory accesses that cross misaligned boundaries may not be properly detected by ASan.&lt;/p&gt;
&lt;p&gt;Reducing the mapping scale would allow stricter checks, but doing so would introduce inefficiencies in vectorized instructions and deviate from ASAN&amp;#x2019;s original design assumptions. For these reasons, the recommended approach is to apply an additional sanitizer that explicitly checks alignment violations, such as &lt;code&gt;-fsanitize=alignment&lt;/code&gt;. This option is part of Undefined Behavior Sanitizer (UBSan).&lt;/p&gt;
&lt;p&gt;When rebuilding the program with the &lt;code&gt;-fsanitize=alignment&lt;/code&gt; option enabled, the out-of-bounds access is correctly detected.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ g++ oob.cpp -o oob_aligned -fsanitize=address -fsanitize=alignment
$ ./oob_aligned
oob.cpp:7:8: runtime error: store to misaligned address 0x502000000016 &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;int&amp;apos;&lt;/span&gt;, &lt;span class=&#34;hljs-built_in&#34;&gt;which&lt;/span&gt; requires 4 byte alignment
0x502000000016: note: pointer points here
 be be be be be be  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00
             ^&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Examining the resulting binary shows that UBSan has inserted additional type-based checking functions. This topic will be covered in more detail in a future article.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image6.png&#34; alt&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-2-Poisoning-Unpoisoning&#34;&gt;&lt;a href=&#34;#2-2-Poisoning-Unpoisoning&#34; class=&#34;headerlink&#34; title=&#34;2.2 Poisoning / Unpoisoning&#34;&gt;&lt;/a&gt;2.2 Poisoning / Unpoisoning&lt;/h3&gt;&lt;p&gt;Shadow memory stores one byte of metadata per 8 bytes of application memory. ASan interprets this byte using several predefined values to represent memory accessibility.&lt;/p&gt;
&lt;p&gt;Accessible memory is referred to as &lt;strong&gt;unpoisoned&lt;/strong&gt;, while inaccessible memory is &lt;strong&gt;poisoned&lt;/strong&gt;. Read and write accesses are not distinguished at this level.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Shadow Byte&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;All 8 bytes accessible&lt;/td&gt;
&lt;td&gt;unpoison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt; 0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;All 8 bytes inaccessible&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;k (1~7)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;First &lt;code&gt;k&lt;/code&gt; bytes accessible&lt;/td&gt;
&lt;td&gt;&amp;#xBD80;&amp;#xBD84; unpoison&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;At process startup, shadow memory is initialized as poisoned. Known memory regions are unpoisoned before entering &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It can be summarized in a table as follows.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Region&lt;/th&gt;
&lt;th&gt;Initialized before main thread execution&lt;/th&gt;
&lt;th&gt;Modified during process execution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Global / static variables&lt;/td&gt;
&lt;td&gt;O (unpoison)&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Stack frame (main)&lt;/td&gt;
&lt;td&gt;O (partially unpoison)&lt;/td&gt;
&lt;td&gt;Updated on function call and return&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Heap&lt;/td&gt;
&lt;td&gt;X (poison)&lt;/td&gt;
&lt;td&gt;Managed by dedicated interceptor functions&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TLS&lt;/td&gt;
&lt;td&gt;O (unpoison)&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;Dynamic heap memory is managed via interceptor functions inserted by ASan, such as wrapped versions of &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/interception/interception.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; INTERCEPTOR(ret_type, func, ...)        \&lt;/span&gt;
  DEFINE_REAL(ret_type, func, __VA_ARGS__)      \
  DECLARE_WRAPPER(ret_type, func, __VA_ARGS__)  \
  &lt;span class=&#34;hljs-keyword&#34;&gt;extern&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;INTERCEPTOR_ATTRIBUTE ret_type &lt;span class=&#34;hljs-title&#34;&gt;WRAP&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(func)&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(__VA_ARGS__)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;...
INTERCEPTOR(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;, &lt;span class=&#34;hljs-built_in&#34;&gt;free&lt;/span&gt;, &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *ptr) {
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (DlsymAlloc::PointerIsMine(ptr))
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; DlsymAlloc::Free(ptr);
  GET_STACK_TRACE_FREE;
  asan_free(ptr, &amp;amp;&lt;span class=&#34;hljs-built_in&#34;&gt;stack&lt;/span&gt;);
}
...
INTERCEPTOR(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;*, &lt;span class=&#34;hljs-built_in&#34;&gt;malloc&lt;/span&gt;, uptr size) {
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (DlsymAlloc::Use())
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; DlsymAlloc::Allocate(size);
  GET_STACK_TRACE_MALLOC;
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; asan_malloc(size, &amp;amp;&lt;span class=&#34;hljs-built_in&#34;&gt;stack&lt;/span&gt;);
}
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ASan also provides explicit APIs to poison or unpoison memory regions.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/include/sanitizer/asan_interface.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;if&lt;/span&gt; __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_POISON_MEMORY_REGION(addr, size) \&lt;/span&gt;
  __asan_poison_memory_region((addr), (size))
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_UNPOISON_MEMORY_REGION(addr, size) \&lt;/span&gt;
  __asan_unpoison_memory_region((addr), (size))
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_POISON_MEMORY_REGION(addr, size) \&lt;/span&gt;
  ((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)(addr), (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)(size))
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_UNPOISON_MEMORY_REGION(addr, size) \&lt;/span&gt;
  ((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)(addr), (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)(size))
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;endif&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Explicit poisoning can be enabled or disabled through runtime flags.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=allow_user_poisoning=0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These can be useful for enforcing custom memory lifetimes. Let us verify this behavior using an example program.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// g++ unpoison.cpp -o unpoison -fsanitize=address&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;sanitizer/asan_interface.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *&lt;span class=&#34;hljs-title&#34;&gt;cus_alloc&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;size_t&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *p = &lt;span class=&#34;hljs-built_in&#34;&gt;malloc&lt;/span&gt;(size);
    ASAN_POISON_MEMORY_REGION(p, size);

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; p;
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;activate_p&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *p, &lt;span class=&#34;hljs-keyword&#34;&gt;size_t&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    ASAN_UNPOISON_MEMORY_REGION(p, size);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *p = (&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *)cus_alloc(&lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;);

    activate_p(p, &lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;);
    &lt;span class=&#34;hljs-built_in&#34;&gt;strcpy&lt;/span&gt;(p, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;millet&amp;quot;&lt;/span&gt;);

    &lt;span class=&#34;hljs-built_in&#34;&gt;puts&lt;/span&gt;(p);
    &lt;span class=&#34;hljs-built_in&#34;&gt;free&lt;/span&gt;(p);

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In ASan, the redefined &lt;code&gt;malloc()&lt;/code&gt; function manages newly allocated memory as unpoisoned by default. In this example, the memory region is first marked as inaccessible using &lt;code&gt;ASAN_POISON_MEMORY_REGION&lt;/code&gt;, and then explicitly unpoisoned only when it is actually used. This approach provides an additional layer of safety in memory management.&lt;/p&gt;
&lt;p&gt;If the memory is not explicitly unpoisoned, the program terminates with an error as shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;./unpoison
=================================================================
==1381294==ERROR: AddressSanitizer: use-after-poison on address 0x502000000010 at pc 0x7f0804f052c3 bp 0x7ffcc58dca60 sp 0x7ffcc58dc208
WRITE of size 7 at 0x502000000010 thread T0
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x7f0804f052c2 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#1 0x55577d55a300 in main (/root/asan/unpoison+0x1300)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#2 0x7f0804998d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#3 0x7f0804998e3f in __libc_start_main_impl ../csu/libc-start.c:392&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#4 0x55577d55a1a4 in _start (/root/asan/unpoison+0x11a4)&lt;/span&gt;

0x502000000010 is located 0 bytes inside of 8-byte region [0x502000000010,0x502000000018)
allocated by thread T0 here:
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x7f0804f7f887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#1 0x55577d55a284 in cus_alloc(unsigned long) (/root/asan/unpoison+0x1284)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#2 0x55577d55a2e1 in main (/root/asan/unpoison+0x12e1)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#3 0x7f0804998d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58&lt;/span&gt;

SUMMARY: AddressSanitizer: use-after-poison ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; __interceptor_memcpy
Shadow bytes around the buggy address:
  0x0a047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&amp;gt;0x0a047fff8000: fa fa[f7]fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after &lt;span class=&#34;hljs-built_in&#34;&gt;return&lt;/span&gt;:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      &lt;span class=&#34;hljs-built_in&#34;&gt;fc&lt;/span&gt;
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==1381294==ABORTING&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It clearly reports the issue as a &lt;strong&gt;use-after-poison&lt;/strong&gt; error.&lt;/p&gt;
&lt;h3 id=&#34;2-3-Redzone&#34;&gt;&lt;a href=&#34;#2-3-Redzone&#34; class=&#34;headerlink&#34; title=&#34;2.3 Redzone&#34;&gt;&lt;/a&gt;2.3 Redzone&lt;/h3&gt;&lt;p&gt;While poisoning tracks memory lifetime, redzones protect boundaries around memory objects. Redzones are regions of memory placed around the actual usable area of a memory object where access is explicitly forbidden.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image7.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Regions designated as redzones are always kept in a poisoned state. As a result, any read or write that crosses a boundary, or any logically invalid access, ends up touching a redzone, allowing ASan to detect heap buffer overflows or stack buffer overflows.&lt;/p&gt;
&lt;p&gt;Redzones are primarily placed around heap, stack, and global buffers, and all of them are represented as poisoned regions in shadow memory.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Shadow Byte&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xfa&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Heap left redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stack left redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stack mid redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stack right redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf5&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stack after return&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Global redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xca&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Left alloca redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xcb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Right alloca redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;Let us examine an example to observe the redzones inserted around heap allocations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// g++ redzone.cpp -o redzone -fsanitize=address&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *p = (&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *)&lt;span class=&#34;hljs-built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;);
    p[&lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;m&amp;apos;&lt;/span&gt;;

    &lt;span class=&#34;hljs-built_in&#34;&gt;free&lt;/span&gt;(p);

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In an x86-64 environment, ptmalloc2 allocates memory in 16-byte&amp;#x2013;aligned chunks.&lt;/p&gt;
&lt;p&gt;When &lt;code&gt;malloc(6)&lt;/code&gt; is called, ptmalloc2 actually allocates a total of 32 bytes.&lt;/p&gt;
&lt;p&gt;Except for the 6 bytes of user data, the remaining space must not be accessed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;...
   0x5555555551d1 &amp;lt;main+0008&amp;gt;      sub    rsp, 0x10
   0x5555555551d5 &amp;lt;main+000c&amp;gt;      mov    edi, 0x6
   0x5555555551da &amp;lt;main+0011&amp;gt;      call   0x5555555550b0 &amp;lt;malloc@plt&amp;gt;
 &amp;#x2192; 0x5555555551df &amp;lt;main+0016&amp;gt;      mov    QWORD PTR [rbp-0x8], rax
...
gef&amp;#x27A4;  x/4bx ((&lt;span class=&#34;hljs-variable&#34;&gt;$rax&lt;/span&gt; &amp;gt;&amp;gt; 3) + 0x7fff8000) - 2
0xa047fff8000:  0xfa    0xfa    0x06    0xfa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the memory allocation, the state appears as shown above. Only the shadow byte corresponding to the actually usable region is set to &lt;code&gt;0x06&lt;/code&gt;, while the remaining bytes are set to &lt;code&gt;0xfa&lt;/code&gt;, which represents the heap left redzone.&lt;/p&gt;
&lt;p&gt;Therefore, the following conditional check detects the invalid memory access.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image8.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;This time, let us examine a stack buffer overflow using an example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// g++ redzone.cpp -o redzone -fsanitize=address&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; sp[&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;] = {&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, };
    sp[&lt;span class=&#34;hljs-number&#34;&gt;17&lt;/span&gt;] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;i&amp;apos;&lt;/span&gt;;

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After compilation, the &lt;code&gt;main()&lt;/code&gt; function rewritten by ASan appears as follows.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __fastcall &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; **argv, &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; **envp)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
  &lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64 v3; &lt;span class=&#34;hljs-comment&#34;&gt;// rbx&lt;/span&gt;
  __int64 v4; &lt;span class=&#34;hljs-comment&#34;&gt;// rax&lt;/span&gt;
  _BYTE *v5; &lt;span class=&#34;hljs-comment&#34;&gt;// rdx&lt;/span&gt;
  __int64 v6; &lt;span class=&#34;hljs-comment&#34;&gt;// rax&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; v7; &lt;span class=&#34;hljs-comment&#34;&gt;// si&lt;/span&gt;
  _BYTE v9[&lt;span class=&#34;hljs-number&#34;&gt;88&lt;/span&gt;]; &lt;span class=&#34;hljs-comment&#34;&gt;// [rsp+0h] [rbp-70h] BYREF&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64 cnry; &lt;span class=&#34;hljs-comment&#34;&gt;// [rsp+58h] [rbp-18h]&lt;/span&gt;

  v3 = (&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64)v9;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( _TMC_END__ )
  {
    v4 = __asan_stack_malloc_0(&lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt;, argv, envp);
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v4 )
      v3 = v4;
  }
  v5 = (_BYTE *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;0x60&lt;/span&gt;);
  *(_QWORD *)v3 = &lt;span class=&#34;hljs-number&#34;&gt;0x41B58AB3&lt;/span&gt;;
  *(_QWORD *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;) = &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;1 32 16 4 sp:5&amp;quot;&lt;/span&gt;;
  *(_QWORD *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;) = main;
  v6 = v3 &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;;
  *(_DWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF1F1F1F1&lt;/span&gt;;
  *(_DWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8004&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF3F30000&lt;/span&gt;;
  cnry = __readfsqword(&lt;span class=&#34;hljs-number&#34;&gt;0x28&lt;/span&gt;u);
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( *(_WORD *)(((v3 + &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) )
    v6 = __asan_report_store16(v3 + &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;);
  *((_QWORD *)v5 - &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  *((_QWORD *)v5 - &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  v7 = *(_BYTE *)(((&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64)(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;);
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v7 != &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (((&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int8)v5 - &lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;17&lt;/span&gt;) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;) &amp;gt;= v7 )
    v6 = __asan_report_store1(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;);
  *(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;) = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;i&amp;apos;&lt;/span&gt;;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v9 == (_BYTE *)v3 )
  {
    *(_QWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
  {
    *(_QWORD *)v3 = &lt;span class=&#34;hljs-number&#34;&gt;0x45E0360E&lt;/span&gt;;
    *(_QWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF5F5F5F5F5F5F5F5&lt;/span&gt;LL;
    **(_BYTE **)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;0x38&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wow&amp;#x2026; quite a lot of code has been inserted.&lt;/p&gt;
&lt;p&gt;It may look complex at first glance, but if we apply the concepts discussed earlier, it is not particularly difficult to understand. Let us break it down step by step.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASan Stack Frame Setup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v9&lt;/code&gt; represents the top of the stack frame buffer set up by the compiler. To allow ASan to manage this stack frame, its value is moved into the variable &lt;code&gt;v3&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;v3 = (&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64)v9;
&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( _TMC_END__ )
{
  v4 = __asan_stack_malloc_0(&lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt;, argv, envp);
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v4 )
    v3 = v4;
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;There is logic that checks the value &lt;code&gt;_TMC_END__&lt;/code&gt; and reallocates the stack. This behavior is controlled by the &lt;code&gt;ASAN_OPTIONS=detect_stack_use_after_return&lt;/code&gt; option, which is used to detect stack reuse after a function has returned.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image9.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stack Frame Metadata Recording&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This code records separate metadata for the stack frame. Here, it stores information such as the current state of the stack frame and the intended layout of objects within the frame.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;v5 = (_BYTE *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;0x60&lt;/span&gt;);
*(_QWORD *)v3 = &lt;span class=&#34;hljs-number&#34;&gt;0x41B58AB3&lt;/span&gt;;
*(_QWORD *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;) = &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;1 32 16 4 sp:5&amp;quot;&lt;/span&gt;;
*(_QWORD *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;) = main;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0x41B58AB3&lt;/code&gt;: A magic number used to identify the stack frame. In this context, it indicates that the stack frame is valid.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_internal.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
  &lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; uptr kCurrentStackFrameMagic = &lt;span class=&#34;hljs-number&#34;&gt;0x41B58AB3&lt;/span&gt;;
&lt;span class=&#34;hljs-keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; uptr kRetiredStackFrameMagic = &lt;span class=&#34;hljs-number&#34;&gt;0x45E0360E&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;quot;1 32 16 4 sp:5&amp;quot;&lt;/code&gt;: one stack object, offset 32, size 16, internal name sp:5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;: records which function this stack frame belongs to&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Stack Redzone Setup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;After unpoisoning the two shadow bytes corresponding to the 16 bytes that will actually be used, the regions on both sides are set as the stack left redzone and the stack right redzone, respectively.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;v6 = v3 &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;;
*(_DWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF1F1F1F1&lt;/span&gt;;
*(_DWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8004&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF3F30000&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Pre-access Check &amp;#x2192; Access Logic&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This part follows the same shadow memory check mechanism discussed earlier.&lt;/p&gt;
&lt;p&gt;Here, the check begins at the &lt;code&gt;+32&lt;/code&gt; offset, which matches the information recorded in the stack frame metadata.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( *(_WORD *)(((v3 + &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) )
  v6 = __asan_report_store16(v3 + &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;);
*((_QWORD *)v5 - &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
*((_QWORD *)v5 - &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
v7 = *(_BYTE *)(((&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64)(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v7 != &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (((&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int8)v5 - &lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;17&lt;/span&gt;) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;) &amp;gt;= v7 )
  v6 = __asan_report_store1(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;);
*(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;) = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;i&amp;apos;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although the operations may look complex, it ultimately becomes clear that the access targets the &lt;code&gt;+32&lt;/code&gt; offset where the array is located. &lt;/p&gt;
&lt;p&gt;(The &lt;code&gt;__asan_report_storeX()&lt;/code&gt; functions will be examined in the next section.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cleanup Before Function Return&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;v9&lt;/code&gt; and &lt;code&gt;v3&lt;/code&gt; point to the same address, this indicates that the frame resides on the real stack, and the corresponding region is unpoisoned to allow subsequent function calls.&lt;/p&gt;
&lt;p&gt;Otherwise, the frame was allocated on ASan&amp;#x2019;s fake stack. In this case, the magic number is changed to &lt;code&gt;0x45E0360E&lt;/code&gt;, which corresponds to &lt;code&gt;kRetiredStackFrameMagic&lt;/code&gt;, and the region is poisoned with &lt;code&gt;0xf5&lt;/code&gt;, representing &lt;em&gt;stack after return&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;With the underlying concepts in mind, the code becomes much easier to understand.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v9 == (_BYTE *)v3 )
  {
    *(_QWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
  {
    *(_QWORD *)v3 = &lt;span class=&#34;hljs-number&#34;&gt;0x45E0360E&lt;/span&gt;;
    *(_QWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF5F5F5F5F5F5F5F5&lt;/span&gt;LL;
    **(_BYTE **)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;0x38&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-Error-Reporting&#34;&gt;&lt;a href=&#34;#3-Error-Reporting&#34; class=&#34;headerlink&#34; title=&#34;3. Error Reporting&#34;&gt;&lt;/a&gt;3. Error Reporting&lt;/h2&gt;&lt;h3 id=&#34;3-1-Error-Reporting-Functions&#34;&gt;&lt;a href=&#34;#3-1-Error-Reporting-Functions&#34; class=&#34;headerlink&#34; title=&#34;3.1 Error Reporting Functions&#34;&gt;&lt;/a&gt;3.1 Error Reporting Functions&lt;/h3&gt;&lt;p&gt;When a check in the instrumentation logic fails, the following reporting functions are invoked.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan_abi_asan_abi_shim.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Functions concerning memory load and store reporting&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load1(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load2(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load4(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load8(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load16(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load_n(uptr addr, uptr size) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, size, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store1(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store2(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store4(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store8(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store16(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store_n(uptr addr, uptr size) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, size, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the names suggest, reads are labeled as &lt;code&gt;load&lt;/code&gt;, writes as &lt;code&gt;store&lt;/code&gt;, and the suffix indicates the number of bytes accessed.&lt;/p&gt;
&lt;p&gt;The wrapped functions &lt;code&gt;__asan_abi_report_XXX_n&lt;/code&gt; ultimately invoke the &lt;code&gt;ReportGenericError()&lt;/code&gt; function.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_report.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; is_write,
                         uptr access_size, u32 &lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;) {
  ENABLE_FRAME_POINTER;
  &lt;span class=&#34;hljs-keyword&#34;&gt;bool&lt;/span&gt; fatal = flags()-&amp;gt;halt_on_error;
  ReportGenericError(pc, bp, sp, addr, is_write, access_size, &lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;, fatal);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;ReportGenericError&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(uptr pc, uptr bp, uptr sp, uptr addr, &lt;span class=&#34;hljs-keyword&#34;&gt;bool&lt;/span&gt; is_write,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                        uptr access_size, u32 &lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;, &lt;span class=&#34;hljs-keyword&#34;&gt;bool&lt;/span&gt; fatal)&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (__asan_test_only_reported_buggy_pointer) {
    *__asan_test_only_reported_buggy_pointer = addr;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!fatal &amp;amp;&amp;amp; SuppressErrorReport(pc)) &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
  ENABLE_FRAME_POINTER;

  &lt;span class=&#34;hljs-comment&#34;&gt;// Optimization experiments.&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// The experiments can be used to evaluate potential optimizations that remove&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// instrumentation (assess false negatives). Instead of completely removing&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// some instrumentation, compiler can emit special calls into runtime&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// (e.g. __asan_report_exp_load1 instead of __asan_report_load1) and pass&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// mask of experiments (exp).&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// The reaction to a non-zero value of exp is to be defined.&lt;/span&gt;
  (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;;

  &lt;span class=&#34;hljs-function&#34;&gt;ScopedInErrorReport &lt;span class=&#34;hljs-title&#34;&gt;in_report&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(fatal)&lt;/span&gt;&lt;/span&gt;;
  &lt;span class=&#34;hljs-function&#34;&gt;ErrorGeneric &lt;span class=&#34;hljs-title&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(GetCurrentTidOrInvalid(), pc, bp, sp, addr, is_write,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                     access_size)&lt;/span&gt;&lt;/span&gt;;
  in_report.ReportError(error);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;fatal&lt;/code&gt; value determines whether the program terminates after reporting an error. &lt;/p&gt;
&lt;p&gt;This behavior is also controlled by compile-time options and runtime flags.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;# Activate ASAN Recovery Mode&lt;/span&gt;
-fsanitize-recover=address
&lt;span class=&#34;hljs-comment&#34;&gt;# Runtime Flag&lt;/span&gt;
ASAN_OPTIONS=halt_on_error=0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we add a &lt;code&gt;getchar()&lt;/code&gt; call to the example code used in the redzone section and run it again, we can observe that the program does not terminate even after the error occurs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ g++ redzone.cpp -o redzone -fsanitize=address -fsanitize-recover=address &amp;amp;&amp;amp; ASAN_OPTIONS=halt_on_error=0 ./redzone
=================================================================
==1481048==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff00408791 at pc 0x5593d35b02fa bp 0x7fff00408750 sp 0x7fff00408740
WRITE of size 1 at 0x7fff00408791 thread T0
...

$ &lt;span class=&#34;hljs-built_in&#34;&gt;echo&lt;/span&gt; $? 
0&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-2-Interpreting-Erros&#34;&gt;&lt;a href=&#34;#3-2-Interpreting-Erros&#34; class=&#34;headerlink&#34; title=&#34;3.2 Interpreting Erros&#34;&gt;&lt;/a&gt;3.2 Interpreting Erros&lt;/h3&gt;&lt;p&gt;An ASan error report is generally composed of a summary, a call stack, memory information, and the state of the shadow bytes.&lt;/p&gt;
&lt;p&gt;Using the error message produced by running the previous example, let us examine each of these components in detail.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ ./redzone      
=================================================================
==1670382==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffaec08e11 at pc 0x5591367762fa bp 0x7fffaec08dd0 sp 0x7fffaec08dc0
WRITE of size 1 at 0x7fffaec08e11 thread T0
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x5591367762f9 in main (/root/asan/redzone+0x12f9)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#1 0x7fe1e1807d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#2 0x7fe1e1807e3f in __libc_start_main_impl ../csu/libc-start.c:392&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#3 0x559136776144 in _start (/root/asan/redzone+0x1144)&lt;/span&gt;

Address 0x7fffaec08e11 is located &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; stack of thread T0 at offset 49 &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; frame
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x559136776218 in main (/root/asan/redzone+0x1218)&lt;/span&gt;

  This frame has 1 object(s):
    [32, 48) &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;sp&amp;apos;&lt;/span&gt; (line 6) &amp;lt;== Memory access at offset 49 overflows this variable
HINT: this may be a &lt;span class=&#34;hljs-literal&#34;&gt;false&lt;/span&gt; positive &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow (/root/asan/redzone+0x12f9) &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; main
Shadow bytes around the buggy address:
  0x100075d79170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791b0: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
=&amp;gt;0x100075d791c0: 00 00[f3]f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79210: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after &lt;span class=&#34;hljs-built_in&#34;&gt;return&lt;/span&gt;:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      &lt;span class=&#34;hljs-built_in&#34;&gt;fc&lt;/span&gt;
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==1670382==ABORTING&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Error Overview&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The type of error is a &lt;em&gt;stack-buffer-overflow&lt;/em&gt;, and it occurred on thread T0 during a 1-byte write operation.&lt;/p&gt;
&lt;p&gt;Below this, the call stack is displayed, allowing us to trace the function call path that led to the error.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Faulting location: &lt;code&gt;0x5591367762fa&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;==1670382==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffaec08e11 at pc 0x5591367762fa bp 0x7fffaec08dd0 sp 0x7fffaec08dc0
WRITE of size 1 at 0x7fffaec08e11 thread T0
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x5591367762f9 in main (/root/asan/redzone+0x12f9)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#1 0x7fe1e1807d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#2 0x7fe1e1807e3f in __libc_start_main_impl ../csu/libc-start.c:392&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#3 0x559136776144 in _start (/root/asan/redzone+0x1144)&lt;/span&gt;
    
Address 0x7fffaec08e11 is located &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; stack of thread T0 at offset 49 &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; frame
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x559136776218 in main (/root/asan/redzone+0x1218)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Memory Frame Information&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The buffer named &lt;code&gt;sp&lt;/code&gt; is valid only within the range &lt;code&gt;[32, 48)&lt;/code&gt;&amp;#x2014;that is, 16 bytes&amp;#x2014;within the stack frame, but the reported access occurs at offset 49.&lt;/p&gt;
&lt;p&gt;From this information, we can determine that an out-of-bounds write has occurred.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;This frame has 1 object(s):
  [32, 48) &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;sp&amp;apos;&lt;/span&gt; (line 6) &amp;lt;== Memory access at offset 49 overflows this variable&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Shadow Bytes State&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The actual accessible range is from &lt;code&gt;0x100075d791c0&lt;/code&gt; to &lt;code&gt;0x100075d791c1&lt;/code&gt;, but the location marked with &lt;code&gt;=&amp;gt;&lt;/code&gt; indicates an access to a poisoned region labeled &lt;code&gt;0xf3&lt;/code&gt;, which represents the stack right redzone, as highlighted by the brackets &lt;code&gt;[ ]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;From this, we can clearly observe the overall memory access permission state.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;Shadow bytes around the buggy address:
  0x100075d79170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791b0: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
=&amp;gt;0x100075d791c0: 00 00[f3]f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79210: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These components clearly indicate the location, cause, and memory state of the error, making debugging significantly easier.&lt;/p&gt;
&lt;h2 id=&#34;Conclusion&#34;&gt;&lt;a href=&#34;#Conclusion&#34; class=&#34;headerlink&#34; title=&#34;Conclusion&#34;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;In this article, we briefly explored Address Sanitizer. While ASan is extremely effective at detecting memory errors, it introduces significant memory and performance overhead due to shadow memory checks, redzones, and frequent runtime instrumentation. For this reason, it is typically used during development, testing, fuzzing, and vulnerability research rather than in production environments.&lt;/p&gt;
&lt;p&gt;Although other sanitizers such as HWASan, UBSan, TSan, and LSan now exist, ASan remains a fundamental and essential tool for memory safety verification.&lt;/p&gt;
&lt;p&gt;In the next article, I plan to explore additional sanitizers in more detail. Thank you for reading! &amp;#x1FAC2;&lt;/p&gt;
&lt;h2 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/ko-kr/cpp/sanitizers/asan?view=msvc-170&#34;&gt;https://learn.microsoft.com/ko-kr/cpp/sanitizers/asan?view=msvc-170&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn&#34;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://clang.llvm.org/docs/AddressSanitizer.html&#34;&gt;https://clang.llvm.org/docs/AddressSanitizer.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/llvm/llvm-project/tree/main&#34;&gt;https://github.com/llvm/llvm-project/tree/main&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/sanitizers/issues/100&#34;&gt;https://github.com/google/sanitizers/issues/100&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://research.google/pubs/addresssanitizer-a-fast-address-sanity-checker/&#34;&gt;https://research.google/pubs/addresssanitizer-a-fast-address-sanity-checker/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://arxiv.org/pdf/2506.05022v2&#34;&gt;https://arxiv.org/pdf/2506.05022v2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] Address Sanitizer: Part 1 (EN) - hackyboiz">
  <meta property="og:description" content="&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image1.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Hello! I am &lt;code&gt;millet&lt;/code&gt;, a new member who recently joined Hackyboiz.&lt;/p&gt;
&lt;p&gt;While solving wargame challenges in the past, I came across something called ASan. At the time, I only glanced over it briefly, but using this research article as an excuse, I decided to properly study it and chose it as my topic.&lt;/p&gt;
&lt;p&gt;In this article, I will take a look at what Address Sanitizer is and how it is implemented.&lt;/p&gt;
&lt;h2 id=&#34;1-About-Address-Sanitizer&#34;&gt;&lt;a href=&#34;#1-About-Address-Sanitizer&#34; class=&#34;headerlink&#34; title=&#34;1. About Address Sanitizer&#34;&gt;&lt;/a&gt;1. About Address Sanitizer&lt;/h2&gt;&lt;p&gt;Address Sanitizer, often abbreviated as ASan, is a runtime error detection tool designed to dynamically detect memory errors that occur during program execution.&lt;/p&gt;
&lt;p&gt;You can think of it as a tool that automatically inserts code to catch memory-related bugs when writing programs in C or C++. It was initially developed and maintained by Google, but is now maintained as part of the LLVM project.&lt;/p&gt;
&lt;p&gt;ASan is provided through multiple implementations. Since I primarily work in Linux environments, this research article will focus on the Sanitizer provided by GCC.&lt;/p&gt;
&lt;p&gt;In most Linux distributions, when GCC is installed, the corresponding runtime package is installed together (typically the &lt;code&gt;libasan&lt;/code&gt; package).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ (dpkg -l | grep libasan) &amp;amp;&amp;amp; (gcc --version | head -1)
ii  libasan6:amd64                       11.4.0-1ubuntu1~22.04.2                    amd64        AddressSanitizer -- a fast memory error detector
gcc (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ASan implementation provided by GCC uses the same memory model and detection mechanisms as LLVM ASan, so conceptually there is no difference.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image2.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;ASan is currently supported on the following platforms.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OS&lt;/th&gt;
&lt;th&gt;x86&lt;/th&gt;
&lt;th&gt;x86_64&lt;/th&gt;
&lt;th&gt;ARM&lt;/th&gt;
&lt;th&gt;ARM64&lt;/th&gt;
&lt;th&gt;MIPS&lt;/th&gt;
&lt;th&gt;MIPS64&lt;/th&gt;
&lt;th&gt;PowerPC&lt;/th&gt;
&lt;th&gt;PowerPC64&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OS X&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iOS Simulator&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FreeBSD&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Android&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&#34;1-1-Detectable-memory-errors&#34;&gt;&lt;a href=&#34;#1-1-Detectable-memory-errors&#34; class=&#34;headerlink&#34; title=&#34;1.1 Detectable memory errors&#34;&gt;&lt;/a&gt;1.1 Detectable memory errors&lt;/h3&gt;&lt;p&gt;As its name suggests, ASan can detect most common memory errors. The detection scope and behavior can be configured using compile-time options and runtime flags. Some representative examples are listed below.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use After Free (Dangling Pointer Dereference)&lt;br&gt;Heap Buffer Overflow&lt;br&gt;Stack Buffer Overflow&lt;br&gt;Global Buffer Overflow&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;-fsanitize=address&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Use After Return&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=detect_stack_use_after_return=1&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This option incurs significant performance overhead because stack frames are moved to a separate virtual heap.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Use After Scope&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=detect_stack_use_after_scope=1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Initialization Order Bugs&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=check_initialization_order=1&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Applicable only to C++, where global object initialization order matters.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Memory Leaks&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=detect_leaks=1&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This functionality is actually handled by &lt;a href=&#34;https://clang.llvm.org/docs/LeakSanitizer.html&#34;&gt;LeakSanitizer&lt;/a&gt;, not ASAN itself.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are many more runtime flags available, but in this article, the focus will be on the core functionality enabled by &lt;code&gt;-fsanitize=address&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Additionally, ASan&amp;#x2019;s fast unwinder relies on frame pointer chains, so it is recommended to compile with the following option to ensure that the RBP register is used as a frame pointer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;-fno-omit-frame-pointer&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-ASAN-Monitoring-Mechanisms&#34;&gt;&lt;a href=&#34;#2-ASAN-Monitoring-Mechanisms&#34; class=&#34;headerlink&#34; title=&#34;2. ASAN Monitoring Mechanisms&#34;&gt;&lt;/a&gt;2. &lt;strong&gt;ASAN Monitoring Mechanisms&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;As seen above, simply using &lt;code&gt;-fsanitize=address&lt;/code&gt; enables a wide range of detections. How does ASan detect these memory errors?&lt;/p&gt;
&lt;p&gt;ASan primarily relies on three monitoring mechanisms:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shadow Memory-based Access Monitoring&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Poisoning / Unpoisoning for Lifetime Tracking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redzones for Boundary Detection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;These mechanisms are inserted into the program during compile-time instrumentation.&lt;/p&gt;
&lt;p&gt;Checks are inserted before every memory read, write, allocation, and deallocation, and when a policy violation is detected, an error message is printed and the program is terminated by default.&lt;/p&gt;
&lt;p&gt;Instrumentation is mainly inserted at the following points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Before memory read/write instructions&lt;/li&gt;
&lt;li&gt;At dynamic memory allocation&lt;/li&gt;
&lt;li&gt;At dynamic memory deallocation&lt;/li&gt;
&lt;li&gt;At function entry (stack frame setup)&lt;/li&gt;
&lt;li&gt;At function return (stack frame teardown)&lt;/li&gt;
&lt;li&gt;At global object initialization and destruction&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;byte *shadow_address = MemToShadow(address);
byte shadow_value = *shadow_address;
&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (shadow_value) {
		&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (SlowPathCheck(shadow_value, address, kAccessSize)) {
				ReportError(address, kAccessSize, kIsWrite);
		}
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let us examine each mechanism in detail.&lt;/p&gt;
&lt;h3 id=&#34;2-1-Shadow-Memory&#34;&gt;&lt;a href=&#34;#2-1-Shadow-Memory&#34; class=&#34;headerlink&#34; title=&#34;2.1 Shadow Memory&#34;&gt;&lt;/a&gt;2.1 Shadow Memory&lt;/h3&gt;&lt;p&gt;ASan maintains a separate memory region called shadow memory, which stores metadata for each byte of the program&amp;#x2019;s memory.&lt;/p&gt;
&lt;p&gt;The address of the shadow memory corresponding to a given memory address is calculated as follows.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;Shadow = (Mem &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + SHADOW_OFFSET&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Internally, this is implemented using the following macros.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_mapping.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; MEM_TO_SHADOW(mem) \&lt;/span&gt;
      ((STRIP_MTE_TAG(mem) &amp;gt;&amp;gt; ASAN_SHADOW_SCALE) + (ASAN_SHADOW_OFFSET))
&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; SHADOW_TO_MEM(mem) \&lt;/span&gt;
      (((mem) - (ASAN_SHADOW_OFFSET)) &amp;lt;&amp;lt; (ASAN_SHADOW_SCALE))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As shown above, 8 bytes of application memory correspond to 1 byte of shadow memory.&lt;/p&gt;
&lt;p&gt;The value of &lt;code&gt;SHADOW_OFFSET&lt;/code&gt; is platform- and architecture-dependent. On x86-64, it is defined as &lt;code&gt;0x7fff8000&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_mapping.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Typical shadow mapping on Linux/x86_64 with SHADOW_OFFSET == 0x00007fff8000:&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x10007fff8000, 0x7fffffffffff]` || HighMem    ||&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x02008fff7000, 0x10007fff7fff]` || HighShadow ||&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x00008fff7000, 0x02008fff6fff]` || ShadowGap  ||&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x00007fff8000, 0x00008fff6fff]` || LowShadow  ||&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// || `[0x000000000000, 0x00007fff7fff]` || LowMem     ||&lt;/span&gt;
...
&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;if&lt;/span&gt; ASAN_SHADOW_SCALE != 3&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#      &lt;span class=&#34;hljs-meta-keyword&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;Value below is based on shadow scale = 3.&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#      &lt;span class=&#34;hljs-meta-keyword&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;Original formula was: 0x7FFFFFFF &amp;amp; (~0xFFFULL &amp;lt;&amp;lt; SHADOW_SCALE).&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#    &lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_SHADOW_OFFSET_CONST 0x000000007fff8000&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#  &lt;span class=&#34;hljs-meta-keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AS documented in the source code, shadow memory and application memory are logically separated in the virtual address space. On x86-64, the layout is as follows.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Category&lt;/th&gt;
&lt;th&gt;Mapped Region&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HighMem&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x10007fff8000, 0x7fffffffffff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Virtual memory represented by 5 bytes or more&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HighShadow&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x02008fff7000, 0x10007fff7fff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Shadow Memory corresponding to HighMem&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ShadowGap&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x00008fff7000, 0x02008fff6fff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Gap region between Shadow Memory areas&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LowShadow&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x00007fff8000, 0x00008fff6fff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Shadow Memory corresponding to LowMem&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LowMem&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0x000000000000, 0x00007fff7fff]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Virtual memory represented by 4 bytes or less&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image3.png&#34; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The ShadowGap region exists solely to prevent interference between shadow regions and has no read or write permissions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image4.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Because shadow memory is mapped at an 8:1 ratio, certain unaligned memory accesses may not be detected. Consider the following example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// g++ oob.cpp -o oob -fsanitize=address&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; *x = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt;[&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;];                &lt;span class=&#34;hljs-comment&#34;&gt;// [0, 7]&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; *y = (&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; *)((&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *)x + &lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;);    &lt;span class=&#34;hljs-comment&#34;&gt;// [6, 9]&lt;/span&gt;
    *y = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;;                             &lt;span class=&#34;hljs-comment&#34;&gt;// OOB&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;delete&lt;/span&gt;[] x;

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although this is clearly an out-of-bounds access, ASAN does not detect it due to the 8:1 mapping granularity.&lt;/p&gt;
&lt;p&gt;To address such cases, it is recommended to enable additional sanitizers such as &lt;code&gt;-fsanitize=alignment&lt;/code&gt;, which is part of Undefined Behavior Sanitizer (UBSan).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image5.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Because the shadow memory is mapped at an 8:1 ratio, the result of the expression&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(v4 + 6) &amp;gt;&amp;gt; 3&lt;/code&gt; eventually becomes identical to &lt;code&gt;v4 &amp;gt;&amp;gt; 3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As a result, the same shadow memory byte is checked, which prevents ASan from detecting the out-of-bounds access.&lt;/p&gt;
&lt;p&gt;Due to this structural limitation, memory accesses that cross misaligned boundaries may not be properly detected by ASan.&lt;/p&gt;
&lt;p&gt;Reducing the mapping scale would allow stricter checks, but doing so would introduce inefficiencies in vectorized instructions and deviate from ASAN&amp;#x2019;s original design assumptions. For these reasons, the recommended approach is to apply an additional sanitizer that explicitly checks alignment violations, such as &lt;code&gt;-fsanitize=alignment&lt;/code&gt;. This option is part of Undefined Behavior Sanitizer (UBSan).&lt;/p&gt;
&lt;p&gt;When rebuilding the program with the &lt;code&gt;-fsanitize=alignment&lt;/code&gt; option enabled, the out-of-bounds access is correctly detected.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ g++ oob.cpp -o oob_aligned -fsanitize=address -fsanitize=alignment
$ ./oob_aligned
oob.cpp:7:8: runtime error: store to misaligned address 0x502000000016 &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;int&amp;apos;&lt;/span&gt;, &lt;span class=&#34;hljs-built_in&#34;&gt;which&lt;/span&gt; requires 4 byte alignment
0x502000000016: note: pointer points here
 be be be be be be  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00
             ^&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Examining the resulting binary shows that UBSan has inserted additional type-based checking functions. This topic will be covered in more detail in a future article.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image6.png&#34; alt&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-2-Poisoning-Unpoisoning&#34;&gt;&lt;a href=&#34;#2-2-Poisoning-Unpoisoning&#34; class=&#34;headerlink&#34; title=&#34;2.2 Poisoning / Unpoisoning&#34;&gt;&lt;/a&gt;2.2 Poisoning / Unpoisoning&lt;/h3&gt;&lt;p&gt;Shadow memory stores one byte of metadata per 8 bytes of application memory. ASan interprets this byte using several predefined values to represent memory accessibility.&lt;/p&gt;
&lt;p&gt;Accessible memory is referred to as &lt;strong&gt;unpoisoned&lt;/strong&gt;, while inaccessible memory is &lt;strong&gt;poisoned&lt;/strong&gt;. Read and write accesses are not distinguished at this level.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Shadow Byte&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;All 8 bytes accessible&lt;/td&gt;
&lt;td&gt;unpoison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt; 0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;All 8 bytes inaccessible&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;k (1~7)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;First &lt;code&gt;k&lt;/code&gt; bytes accessible&lt;/td&gt;
&lt;td&gt;&amp;#xBD80;&amp;#xBD84; unpoison&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;At process startup, shadow memory is initialized as poisoned. Known memory regions are unpoisoned before entering &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It can be summarized in a table as follows.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Region&lt;/th&gt;
&lt;th&gt;Initialized before main thread execution&lt;/th&gt;
&lt;th&gt;Modified during process execution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Global / static variables&lt;/td&gt;
&lt;td&gt;O (unpoison)&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Stack frame (main)&lt;/td&gt;
&lt;td&gt;O (partially unpoison)&lt;/td&gt;
&lt;td&gt;Updated on function call and return&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Heap&lt;/td&gt;
&lt;td&gt;X (poison)&lt;/td&gt;
&lt;td&gt;Managed by dedicated interceptor functions&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TLS&lt;/td&gt;
&lt;td&gt;O (unpoison)&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;Dynamic heap memory is managed via interceptor functions inserted by ASan, such as wrapped versions of &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/interception/interception.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; INTERCEPTOR(ret_type, func, ...)        \&lt;/span&gt;
  DEFINE_REAL(ret_type, func, __VA_ARGS__)      \
  DECLARE_WRAPPER(ret_type, func, __VA_ARGS__)  \
  &lt;span class=&#34;hljs-keyword&#34;&gt;extern&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class=&#34;hljs-function&#34;&gt;INTERCEPTOR_ATTRIBUTE ret_type &lt;span class=&#34;hljs-title&#34;&gt;WRAP&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(func)&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(__VA_ARGS__)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;...
INTERCEPTOR(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;, &lt;span class=&#34;hljs-built_in&#34;&gt;free&lt;/span&gt;, &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *ptr) {
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (DlsymAlloc::PointerIsMine(ptr))
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; DlsymAlloc::Free(ptr);
  GET_STACK_TRACE_FREE;
  asan_free(ptr, &amp;amp;&lt;span class=&#34;hljs-built_in&#34;&gt;stack&lt;/span&gt;);
}
...
INTERCEPTOR(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;*, &lt;span class=&#34;hljs-built_in&#34;&gt;malloc&lt;/span&gt;, uptr size) {
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (DlsymAlloc::Use())
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; DlsymAlloc::Allocate(size);
  GET_STACK_TRACE_MALLOC;
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; asan_malloc(size, &amp;amp;&lt;span class=&#34;hljs-built_in&#34;&gt;stack&lt;/span&gt;);
}
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ASan also provides explicit APIs to poison or unpoison memory regions.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/include/sanitizer/asan_interface.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;if&lt;/span&gt; __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_POISON_MEMORY_REGION(addr, size) \&lt;/span&gt;
  __asan_poison_memory_region((addr), (size))
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_UNPOISON_MEMORY_REGION(addr, size) \&lt;/span&gt;
  __asan_unpoison_memory_region((addr), (size))
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_POISON_MEMORY_REGION(addr, size) \&lt;/span&gt;
  ((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)(addr), (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)(size))
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ASAN_UNPOISON_MEMORY_REGION(addr, size) \&lt;/span&gt;
  ((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)(addr), (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)(size))
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;endif&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Explicit poisoning can be enabled or disabled through runtime flags.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;ASAN_OPTIONS=allow_user_poisoning=0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These can be useful for enforcing custom memory lifetimes. Let us verify this behavior using an example program.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// g++ unpoison.cpp -o unpoison -fsanitize=address&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;sanitizer/asan_interface.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *&lt;span class=&#34;hljs-title&#34;&gt;cus_alloc&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;size_t&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *p = &lt;span class=&#34;hljs-built_in&#34;&gt;malloc&lt;/span&gt;(size);
    ASAN_POISON_MEMORY_REGION(p, size);

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; p;
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;activate_p&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *p, &lt;span class=&#34;hljs-keyword&#34;&gt;size_t&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    ASAN_UNPOISON_MEMORY_REGION(p, size);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *p = (&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *)cus_alloc(&lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;);

    activate_p(p, &lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;);
    &lt;span class=&#34;hljs-built_in&#34;&gt;strcpy&lt;/span&gt;(p, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;millet&amp;quot;&lt;/span&gt;);

    &lt;span class=&#34;hljs-built_in&#34;&gt;puts&lt;/span&gt;(p);
    &lt;span class=&#34;hljs-built_in&#34;&gt;free&lt;/span&gt;(p);

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In ASan, the redefined &lt;code&gt;malloc()&lt;/code&gt; function manages newly allocated memory as unpoisoned by default. In this example, the memory region is first marked as inaccessible using &lt;code&gt;ASAN_POISON_MEMORY_REGION&lt;/code&gt;, and then explicitly unpoisoned only when it is actually used. This approach provides an additional layer of safety in memory management.&lt;/p&gt;
&lt;p&gt;If the memory is not explicitly unpoisoned, the program terminates with an error as shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;./unpoison
=================================================================
==1381294==ERROR: AddressSanitizer: use-after-poison on address 0x502000000010 at pc 0x7f0804f052c3 bp 0x7ffcc58dca60 sp 0x7ffcc58dc208
WRITE of size 7 at 0x502000000010 thread T0
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x7f0804f052c2 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#1 0x55577d55a300 in main (/root/asan/unpoison+0x1300)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#2 0x7f0804998d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#3 0x7f0804998e3f in __libc_start_main_impl ../csu/libc-start.c:392&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#4 0x55577d55a1a4 in _start (/root/asan/unpoison+0x11a4)&lt;/span&gt;

0x502000000010 is located 0 bytes inside of 8-byte region [0x502000000010,0x502000000018)
allocated by thread T0 here:
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x7f0804f7f887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#1 0x55577d55a284 in cus_alloc(unsigned long) (/root/asan/unpoison+0x1284)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#2 0x55577d55a2e1 in main (/root/asan/unpoison+0x12e1)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#3 0x7f0804998d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58&lt;/span&gt;

SUMMARY: AddressSanitizer: use-after-poison ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; __interceptor_memcpy
Shadow bytes around the buggy address:
  0x0a047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&amp;gt;0x0a047fff8000: fa fa[f7]fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after &lt;span class=&#34;hljs-built_in&#34;&gt;return&lt;/span&gt;:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      &lt;span class=&#34;hljs-built_in&#34;&gt;fc&lt;/span&gt;
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==1381294==ABORTING&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It clearly reports the issue as a &lt;strong&gt;use-after-poison&lt;/strong&gt; error.&lt;/p&gt;
&lt;h3 id=&#34;2-3-Redzone&#34;&gt;&lt;a href=&#34;#2-3-Redzone&#34; class=&#34;headerlink&#34; title=&#34;2.3 Redzone&#34;&gt;&lt;/a&gt;2.3 Redzone&lt;/h3&gt;&lt;p&gt;While poisoning tracks memory lifetime, redzones protect boundaries around memory objects. Redzones are regions of memory placed around the actual usable area of a memory object where access is explicitly forbidden.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image7.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Regions designated as redzones are always kept in a poisoned state. As a result, any read or write that crosses a boundary, or any logically invalid access, ends up touching a redzone, allowing ASan to detect heap buffer overflows or stack buffer overflows.&lt;/p&gt;
&lt;p&gt;Redzones are primarily placed around heap, stack, and global buffers, and all of them are represented as poisoned regions in shadow memory.&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Shadow Byte&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xfa&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Heap left redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stack left redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stack mid redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stack right redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf5&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Stack after return&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xf9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Global redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xca&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Left alloca redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xcb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Right alloca redzone&lt;/td&gt;
&lt;td&gt;poison&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;Let us examine an example to observe the redzones inserted around heap allocations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// g++ redzone.cpp -o redzone -fsanitize=address&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *p = (&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *)&lt;span class=&#34;hljs-built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;);
    p[&lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;m&amp;apos;&lt;/span&gt;;

    &lt;span class=&#34;hljs-built_in&#34;&gt;free&lt;/span&gt;(p);

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In an x86-64 environment, ptmalloc2 allocates memory in 16-byte&amp;#x2013;aligned chunks.&lt;/p&gt;
&lt;p&gt;When &lt;code&gt;malloc(6)&lt;/code&gt; is called, ptmalloc2 actually allocates a total of 32 bytes.&lt;/p&gt;
&lt;p&gt;Except for the 6 bytes of user data, the remaining space must not be accessed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;...
   0x5555555551d1 &amp;lt;main+0008&amp;gt;      sub    rsp, 0x10
   0x5555555551d5 &amp;lt;main+000c&amp;gt;      mov    edi, 0x6
   0x5555555551da &amp;lt;main+0011&amp;gt;      call   0x5555555550b0 &amp;lt;malloc@plt&amp;gt;
 &amp;#x2192; 0x5555555551df &amp;lt;main+0016&amp;gt;      mov    QWORD PTR [rbp-0x8], rax
...
gef&amp;#x27A4;  x/4bx ((&lt;span class=&#34;hljs-variable&#34;&gt;$rax&lt;/span&gt; &amp;gt;&amp;gt; 3) + 0x7fff8000) - 2
0xa047fff8000:  0xfa    0xfa    0x06    0xfa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the memory allocation, the state appears as shown above. Only the shadow byte corresponding to the actually usable region is set to &lt;code&gt;0x06&lt;/code&gt;, while the remaining bytes are set to &lt;code&gt;0xfa&lt;/code&gt;, which represents the heap left redzone.&lt;/p&gt;
&lt;p&gt;Therefore, the following conditional check detects the invalid memory access.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image8.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;This time, let us examine a stack buffer overflow using an example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// g++ redzone.cpp -o redzone -fsanitize=address&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; sp[&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;] = {&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, };
    sp[&lt;span class=&#34;hljs-number&#34;&gt;17&lt;/span&gt;] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;i&amp;apos;&lt;/span&gt;;

    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After compilation, the &lt;code&gt;main()&lt;/code&gt; function rewritten by ASan appears as follows.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __fastcall &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; **argv, &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; **envp)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
  &lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64 v3; &lt;span class=&#34;hljs-comment&#34;&gt;// rbx&lt;/span&gt;
  __int64 v4; &lt;span class=&#34;hljs-comment&#34;&gt;// rax&lt;/span&gt;
  _BYTE *v5; &lt;span class=&#34;hljs-comment&#34;&gt;// rdx&lt;/span&gt;
  __int64 v6; &lt;span class=&#34;hljs-comment&#34;&gt;// rax&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; v7; &lt;span class=&#34;hljs-comment&#34;&gt;// si&lt;/span&gt;
  _BYTE v9[&lt;span class=&#34;hljs-number&#34;&gt;88&lt;/span&gt;]; &lt;span class=&#34;hljs-comment&#34;&gt;// [rsp+0h] [rbp-70h] BYREF&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64 cnry; &lt;span class=&#34;hljs-comment&#34;&gt;// [rsp+58h] [rbp-18h]&lt;/span&gt;

  v3 = (&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64)v9;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( _TMC_END__ )
  {
    v4 = __asan_stack_malloc_0(&lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt;, argv, envp);
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v4 )
      v3 = v4;
  }
  v5 = (_BYTE *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;0x60&lt;/span&gt;);
  *(_QWORD *)v3 = &lt;span class=&#34;hljs-number&#34;&gt;0x41B58AB3&lt;/span&gt;;
  *(_QWORD *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;) = &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;1 32 16 4 sp:5&amp;quot;&lt;/span&gt;;
  *(_QWORD *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;) = main;
  v6 = v3 &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;;
  *(_DWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF1F1F1F1&lt;/span&gt;;
  *(_DWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8004&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF3F30000&lt;/span&gt;;
  cnry = __readfsqword(&lt;span class=&#34;hljs-number&#34;&gt;0x28&lt;/span&gt;u);
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( *(_WORD *)(((v3 + &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) )
    v6 = __asan_report_store16(v3 + &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;);
  *((_QWORD *)v5 - &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  *((_QWORD *)v5 - &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  v7 = *(_BYTE *)(((&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64)(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;);
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v7 != &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (((&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int8)v5 - &lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;17&lt;/span&gt;) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;) &amp;gt;= v7 )
    v6 = __asan_report_store1(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;);
  *(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;) = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;i&amp;apos;&lt;/span&gt;;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v9 == (_BYTE *)v3 )
  {
    *(_QWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
  {
    *(_QWORD *)v3 = &lt;span class=&#34;hljs-number&#34;&gt;0x45E0360E&lt;/span&gt;;
    *(_QWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF5F5F5F5F5F5F5F5&lt;/span&gt;LL;
    **(_BYTE **)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;0x38&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wow&amp;#x2026; quite a lot of code has been inserted.&lt;/p&gt;
&lt;p&gt;It may look complex at first glance, but if we apply the concepts discussed earlier, it is not particularly difficult to understand. Let us break it down step by step.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASan Stack Frame Setup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v9&lt;/code&gt; represents the top of the stack frame buffer set up by the compiler. To allow ASan to manage this stack frame, its value is moved into the variable &lt;code&gt;v3&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;v3 = (&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64)v9;
&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( _TMC_END__ )
{
  v4 = __asan_stack_malloc_0(&lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt;, argv, envp);
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v4 )
    v3 = v4;
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;There is logic that checks the value &lt;code&gt;_TMC_END__&lt;/code&gt; and reallocates the stack. This behavior is controlled by the &lt;code&gt;ASAN_OPTIONS=detect_stack_use_after_return&lt;/code&gt; option, which is used to detect stack reuse after a function has returned.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/25/millet/asan-pt1-en/image9.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stack Frame Metadata Recording&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This code records separate metadata for the stack frame. Here, it stores information such as the current state of the stack frame and the intended layout of objects within the frame.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;v5 = (_BYTE *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;0x60&lt;/span&gt;);
*(_QWORD *)v3 = &lt;span class=&#34;hljs-number&#34;&gt;0x41B58AB3&lt;/span&gt;;
*(_QWORD *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;) = &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;1 32 16 4 sp:5&amp;quot;&lt;/span&gt;;
*(_QWORD *)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;) = main;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0x41B58AB3&lt;/code&gt;: A magic number used to identify the stack frame. In this context, it indicates that the stack frame is valid.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_internal.h&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
  &lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; uptr kCurrentStackFrameMagic = &lt;span class=&#34;hljs-number&#34;&gt;0x41B58AB3&lt;/span&gt;;
&lt;span class=&#34;hljs-keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; uptr kRetiredStackFrameMagic = &lt;span class=&#34;hljs-number&#34;&gt;0x45E0360E&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;quot;1 32 16 4 sp:5&amp;quot;&lt;/code&gt;: one stack object, offset 32, size 16, internal name sp:5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;: records which function this stack frame belongs to&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Stack Redzone Setup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;After unpoisoning the two shadow bytes corresponding to the 16 bytes that will actually be used, the regions on both sides are set as the stack left redzone and the stack right redzone, respectively.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;v6 = v3 &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;;
*(_DWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF1F1F1F1&lt;/span&gt;;
*(_DWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8004&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF3F30000&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Pre-access Check &amp;#x2192; Access Logic&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This part follows the same shadow memory check mechanism discussed earlier.&lt;/p&gt;
&lt;p&gt;Here, the check begins at the &lt;code&gt;+32&lt;/code&gt; offset, which matches the information recorded in the stack frame metadata.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( *(_WORD *)(((v3 + &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) )
  v6 = __asan_report_store16(v3 + &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;);
*((_QWORD *)v5 - &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
*((_QWORD *)v5 - &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
v7 = *(_BYTE *)(((&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int64)(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;) + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v7 != &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (((&lt;span class=&#34;hljs-keyword&#34;&gt;unsigned&lt;/span&gt; __int8)v5 - &lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;17&lt;/span&gt;) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;) &amp;gt;= v7 )
  v6 = __asan_report_store1(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;);
*(v5 - &lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt;) = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;i&amp;apos;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although the operations may look complex, it ultimately becomes clear that the access targets the &lt;code&gt;+32&lt;/code&gt; offset where the array is located. &lt;/p&gt;
&lt;p&gt;(The &lt;code&gt;__asan_report_storeX()&lt;/code&gt; functions will be examined in the next section.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cleanup Before Function Return&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;v9&lt;/code&gt; and &lt;code&gt;v3&lt;/code&gt; point to the same address, this indicates that the frame resides on the real stack, and the corresponding region is unpoisoned to allow subsequent function calls.&lt;/p&gt;
&lt;p&gt;Otherwise, the frame was allocated on ASan&amp;#x2019;s fake stack. In this case, the magic number is changed to &lt;code&gt;0x45E0360E&lt;/code&gt;, which corresponds to &lt;code&gt;kRetiredStackFrameMagic&lt;/code&gt;, and the region is poisoned with &lt;code&gt;0xf5&lt;/code&gt;, representing &lt;em&gt;stack after return&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;With the underlying concepts in mind, the code becomes much easier to understand.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v9 == (_BYTE *)v3 )
  {
    *(_QWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
  {
    *(_QWORD *)v3 = &lt;span class=&#34;hljs-number&#34;&gt;0x45E0360E&lt;/span&gt;;
    *(_QWORD *)(v6 + &lt;span class=&#34;hljs-number&#34;&gt;0x7FFF8000&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0xF5F5F5F5F5F5F5F5&lt;/span&gt;LL;
    **(_BYTE **)(v3 + &lt;span class=&#34;hljs-number&#34;&gt;0x38&lt;/span&gt;) = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-Error-Reporting&#34;&gt;&lt;a href=&#34;#3-Error-Reporting&#34; class=&#34;headerlink&#34; title=&#34;3. Error Reporting&#34;&gt;&lt;/a&gt;3. Error Reporting&lt;/h2&gt;&lt;h3 id=&#34;3-1-Error-Reporting-Functions&#34;&gt;&lt;a href=&#34;#3-1-Error-Reporting-Functions&#34; class=&#34;headerlink&#34; title=&#34;3.1 Error Reporting Functions&#34;&gt;&lt;/a&gt;3.1 Error Reporting Functions&lt;/h3&gt;&lt;p&gt;When a check in the instrumentation logic fails, the following reporting functions are invoked.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan_abi_asan_abi_shim.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Functions concerning memory load and store reporting&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load1(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load2(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load4(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load8(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load16(uptr addr) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_load_n(uptr addr, uptr size) {
  __asan_abi_report_load_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, size, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store1(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store2(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store4(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store8(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store16(uptr addr) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}
&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_store_n(uptr addr, uptr size) {
  __asan_abi_report_store_n((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *)addr, size, &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the names suggest, reads are labeled as &lt;code&gt;load&lt;/code&gt;, writes as &lt;code&gt;store&lt;/code&gt;, and the suffix indicates the number of bytes accessed.&lt;/p&gt;
&lt;p&gt;The wrapped functions &lt;code&gt;__asan_abi_report_XXX_n&lt;/code&gt; ultimately invoke the &lt;code&gt;ReportGenericError()&lt;/code&gt; function.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;llvm-project/compiler-rt/lib/asan/asan_report.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; is_write,
                         uptr access_size, u32 &lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;) {
  ENABLE_FRAME_POINTER;
  &lt;span class=&#34;hljs-keyword&#34;&gt;bool&lt;/span&gt; fatal = flags()-&amp;gt;halt_on_error;
  ReportGenericError(pc, bp, sp, addr, is_write, access_size, &lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;, fatal);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;ReportGenericError&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(uptr pc, uptr bp, uptr sp, uptr addr, &lt;span class=&#34;hljs-keyword&#34;&gt;bool&lt;/span&gt; is_write,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                        uptr access_size, u32 &lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;, &lt;span class=&#34;hljs-keyword&#34;&gt;bool&lt;/span&gt; fatal)&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (__asan_test_only_reported_buggy_pointer) {
    *__asan_test_only_reported_buggy_pointer = addr;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
  }
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!fatal &amp;amp;&amp;amp; SuppressErrorReport(pc)) &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
  ENABLE_FRAME_POINTER;

  &lt;span class=&#34;hljs-comment&#34;&gt;// Optimization experiments.&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// The experiments can be used to evaluate potential optimizations that remove&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// instrumentation (assess false negatives). Instead of completely removing&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// some instrumentation, compiler can emit special calls into runtime&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// (e.g. __asan_report_exp_load1 instead of __asan_report_load1) and pass&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// mask of experiments (exp).&lt;/span&gt;
  &lt;span class=&#34;hljs-comment&#34;&gt;// The reaction to a non-zero value of exp is to be defined.&lt;/span&gt;
  (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;;

  &lt;span class=&#34;hljs-function&#34;&gt;ScopedInErrorReport &lt;span class=&#34;hljs-title&#34;&gt;in_report&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(fatal)&lt;/span&gt;&lt;/span&gt;;
  &lt;span class=&#34;hljs-function&#34;&gt;ErrorGeneric &lt;span class=&#34;hljs-title&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(GetCurrentTidOrInvalid(), pc, bp, sp, addr, is_write,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                     access_size)&lt;/span&gt;&lt;/span&gt;;
  in_report.ReportError(error);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;fatal&lt;/code&gt; value determines whether the program terminates after reporting an error. &lt;/p&gt;
&lt;p&gt;This behavior is also controlled by compile-time options and runtime flags.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;# Activate ASAN Recovery Mode&lt;/span&gt;
-fsanitize-recover=address
&lt;span class=&#34;hljs-comment&#34;&gt;# Runtime Flag&lt;/span&gt;
ASAN_OPTIONS=halt_on_error=0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we add a &lt;code&gt;getchar()&lt;/code&gt; call to the example code used in the redzone section and run it again, we can observe that the program does not terminate even after the error occurs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ g++ redzone.cpp -o redzone -fsanitize=address -fsanitize-recover=address &amp;amp;&amp;amp; ASAN_OPTIONS=halt_on_error=0 ./redzone
=================================================================
==1481048==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff00408791 at pc 0x5593d35b02fa bp 0x7fff00408750 sp 0x7fff00408740
WRITE of size 1 at 0x7fff00408791 thread T0
...

$ &lt;span class=&#34;hljs-built_in&#34;&gt;echo&lt;/span&gt; $? 
0&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-2-Interpreting-Erros&#34;&gt;&lt;a href=&#34;#3-2-Interpreting-Erros&#34; class=&#34;headerlink&#34; title=&#34;3.2 Interpreting Erros&#34;&gt;&lt;/a&gt;3.2 Interpreting Erros&lt;/h3&gt;&lt;p&gt;An ASan error report is generally composed of a summary, a call stack, memory information, and the state of the shadow bytes.&lt;/p&gt;
&lt;p&gt;Using the error message produced by running the previous example, let us examine each of these components in detail.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;$ ./redzone      
=================================================================
==1670382==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffaec08e11 at pc 0x5591367762fa bp 0x7fffaec08dd0 sp 0x7fffaec08dc0
WRITE of size 1 at 0x7fffaec08e11 thread T0
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x5591367762f9 in main (/root/asan/redzone+0x12f9)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#1 0x7fe1e1807d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#2 0x7fe1e1807e3f in __libc_start_main_impl ../csu/libc-start.c:392&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#3 0x559136776144 in _start (/root/asan/redzone+0x1144)&lt;/span&gt;

Address 0x7fffaec08e11 is located &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; stack of thread T0 at offset 49 &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; frame
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x559136776218 in main (/root/asan/redzone+0x1218)&lt;/span&gt;

  This frame has 1 object(s):
    [32, 48) &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;sp&amp;apos;&lt;/span&gt; (line 6) &amp;lt;== Memory access at offset 49 overflows this variable
HINT: this may be a &lt;span class=&#34;hljs-literal&#34;&gt;false&lt;/span&gt; positive &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow (/root/asan/redzone+0x12f9) &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; main
Shadow bytes around the buggy address:
  0x100075d79170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791b0: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
=&amp;gt;0x100075d791c0: 00 00[f3]f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79210: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after &lt;span class=&#34;hljs-built_in&#34;&gt;return&lt;/span&gt;:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      &lt;span class=&#34;hljs-built_in&#34;&gt;fc&lt;/span&gt;
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==1670382==ABORTING&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Error Overview&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The type of error is a &lt;em&gt;stack-buffer-overflow&lt;/em&gt;, and it occurred on thread T0 during a 1-byte write operation.&lt;/p&gt;
&lt;p&gt;Below this, the call stack is displayed, allowing us to trace the function call path that led to the error.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Faulting location: &lt;code&gt;0x5591367762fa&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;==1670382==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffaec08e11 at pc 0x5591367762fa bp 0x7fffaec08dd0 sp 0x7fffaec08dc0
WRITE of size 1 at 0x7fffaec08e11 thread T0
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x5591367762f9 in main (/root/asan/redzone+0x12f9)&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#1 0x7fe1e1807d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#2 0x7fe1e1807e3f in __libc_start_main_impl ../csu/libc-start.c:392&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;#3 0x559136776144 in _start (/root/asan/redzone+0x1144)&lt;/span&gt;
    
Address 0x7fffaec08e11 is located &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; stack of thread T0 at offset 49 &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; frame
    &lt;span class=&#34;hljs-comment&#34;&gt;#0 0x559136776218 in main (/root/asan/redzone+0x1218)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Memory Frame Information&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The buffer named &lt;code&gt;sp&lt;/code&gt; is valid only within the range &lt;code&gt;[32, 48)&lt;/code&gt;&amp;#x2014;that is, 16 bytes&amp;#x2014;within the stack frame, but the reported access occurs at offset 49.&lt;/p&gt;
&lt;p&gt;From this information, we can determine that an out-of-bounds write has occurred.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;This frame has 1 object(s):
  [32, 48) &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;sp&amp;apos;&lt;/span&gt; (line 6) &amp;lt;== Memory access at offset 49 overflows this variable&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Shadow Bytes State&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The actual accessible range is from &lt;code&gt;0x100075d791c0&lt;/code&gt; to &lt;code&gt;0x100075d791c1&lt;/code&gt;, but the location marked with &lt;code&gt;=&amp;gt;&lt;/code&gt; indicates an access to a poisoned region labeled &lt;code&gt;0xf3&lt;/code&gt;, which represents the stack right redzone, as highlighted by the brackets &lt;code&gt;[ ]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;From this, we can clearly observe the overall memory access permission state.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;Shadow bytes around the buggy address:
  0x100075d79170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791b0: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
=&amp;gt;0x100075d791c0: 00 00[f3]f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79210: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These components clearly indicate the location, cause, and memory state of the error, making debugging significantly easier.&lt;/p&gt;
&lt;h2 id=&#34;Conclusion&#34;&gt;&lt;a href=&#34;#Conclusion&#34; class=&#34;headerlink&#34; title=&#34;Conclusion&#34;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;In this article, we briefly explored Address Sanitizer. While ASan is extremely effective at detecting memory errors, it introduces significant memory and performance overhead due to shadow memory checks, redzones, and frequent runtime instrumentation. For this reason, it is typically used during development, testing, fuzzing, and vulnerability research rather than in production environments.&lt;/p&gt;
&lt;p&gt;Although other sanitizers such as HWASan, UBSan, TSan, and LSan now exist, ASan remains a fundamental and essential tool for memory safety verification.&lt;/p&gt;
&lt;p&gt;In the next article, I plan to explore additional sanitizers in more detail. Thank you for reading! &amp;#x1FAC2;&lt;/p&gt;
&lt;h2 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/ko-kr/cpp/sanitizers/asan?view=msvc-170&#34;&gt;https://learn.microsoft.com/ko-kr/cpp/sanitizers/asan?view=msvc-170&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn&#34;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://clang.llvm.org/docs/AddressSanitizer.html&#34;&gt;https://clang.llvm.org/docs/AddressSanitizer.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/llvm/llvm-project/tree/main&#34;&gt;https://github.com/llvm/llvm-project/tree/main&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/sanitizers/issues/100&#34;&gt;https://github.com/google/sanitizers/issues/100&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://research.google/pubs/addresssanitizer-a-fast-address-sanity-checker/&#34;&gt;https://research.google/pubs/addresssanitizer-a-fast-address-sanity-checker/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://arxiv.org/pdf/2506.05022v2&#34;&gt;https://arxiv.org/pdf/2506.05022v2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/12/25/millet/asan-pt1-en/image1.png">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/12/25/millet/asan-pt1-en/">

  <title>[Research] Address Sanitizer: Part 1 (EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!--  -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!--  -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-12-25 19:00" pubdate>
      2025 12 25 
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.7k 
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      93
       
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Address Sanitizer: Part 1 (EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <p><img src="/2025/12/25/millet/asan-pt1-en/image1.png" srcset="/img/loading.gif" alt></p>
<p>Hello! I am <code>millet</code>, a new member who recently joined Hackyboiz.</p>
<p>While solving wargame challenges in the past, I came across something called ASan. At the time, I only glanced over it briefly, but using this research article as an excuse, I decided to properly study it and chose it as my topic.</p>
<p>In this article, I will take a look at what Address Sanitizer is and how it is implemented.</p>
<h2 id="1-About-Address-Sanitizer"><a href="#1-About-Address-Sanitizer" class="headerlink" title="1. About Address Sanitizer"></a>1. About Address Sanitizer</h2><p>Address Sanitizer, often abbreviated as ASan, is a runtime error detection tool designed to dynamically detect memory errors that occur during program execution.</p>
<p>You can think of it as a tool that automatically inserts code to catch memory-related bugs when writing programs in C or C++. It was initially developed and maintained by Google, but is now maintained as part of the LLVM project.</p>
<p>ASan is provided through multiple implementations. Since I primarily work in Linux environments, this research article will focus on the Sanitizer provided by GCC.</p>
<p>In most Linux distributions, when GCC is installed, the corresponding runtime package is installed together (typically the <code>libasan</code> package).</p>
<pre><code class="hljs bash">$ (dpkg -l | grep libasan) &amp;&amp; (gcc --version | head -1)
ii  libasan6:amd64                       11.4.0-1ubuntu1~22.04.2                    amd64        AddressSanitizer -- a fast memory error detector
gcc (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0</code></pre>
<p>The ASan implementation provided by GCC uses the same memory model and detection mechanisms as LLVM ASan, so conceptually there is no difference.</p>
<p><img src="/2025/12/25/millet/asan-pt1-en/image2.png" srcset="/img/loading.gif" alt></p>
<p>ASan is currently supported on the following platforms.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>OS</th>
<th>x86</th>
<th>x86_64</th>
<th>ARM</th>
<th>ARM64</th>
<th>MIPS</th>
<th>MIPS64</th>
<th>PowerPC</th>
<th>PowerPC64</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux</td>
<td>O</td>
<td>O</td>
<td></td>
<td></td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>OS X</td>
<td>O</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>iOS Simulator</td>
<td>O</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>FreeBSD</td>
<td>O</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Android</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-1-Detectable-memory-errors"><a href="#1-1-Detectable-memory-errors" class="headerlink" title="1.1 Detectable memory errors"></a>1.1 Detectable memory errors</h3><p>As its name suggests, ASan can detect most common memory errors. The detection scope and behavior can be configured using compile-time options and runtime flags. Some representative examples are listed below.</p>
<p><strong>Use After Free (Dangling Pointer Dereference)<br>Heap Buffer Overflow<br>Stack Buffer Overflow<br>Global Buffer Overflow</strong></p>
<pre><code class="hljs bash">-fsanitize=address</code></pre>
<p><strong>Use After Return</strong></p>
<pre><code class="hljs bash">ASAN_OPTIONS=detect_stack_use_after_return=1</code></pre>
<ul>
<li>This option incurs significant performance overhead because stack frames are moved to a separate virtual heap.</li>
</ul>
<p><strong>Use After Scope</strong></p>
<pre><code class="hljs bash">ASAN_OPTIONS=detect_stack_use_after_scope=1</code></pre>
<p><strong>Initialization Order Bugs</strong></p>
<pre><code class="hljs bash">ASAN_OPTIONS=check_initialization_order=1</code></pre>
<ul>
<li>Applicable only to C++, where global object initialization order matters.</li>
</ul>
<p><strong>Memory Leaks</strong></p>
<pre><code class="hljs bash">ASAN_OPTIONS=detect_leaks=1</code></pre>
<ul>
<li>This functionality is actually handled by <a target="_blank" rel="external nofollow noopener noreferrer" href="https://clang.llvm.org/docs/LeakSanitizer.html">LeakSanitizer</a>, not ASAN itself.</li>
</ul>
<p>There are many more runtime flags available, but in this article, the focus will be on the core functionality enabled by <code>-fsanitize=address</code>.</p>
<p>Additionally, ASan&#x2019;s fast unwinder relies on frame pointer chains, so it is recommended to compile with the following option to ensure that the RBP register is used as a frame pointer.</p>
<pre><code class="hljs bash">-fno-omit-frame-pointer</code></pre>
<h2 id="2-ASAN-Monitoring-Mechanisms"><a href="#2-ASAN-Monitoring-Mechanisms" class="headerlink" title="2. ASAN Monitoring Mechanisms"></a>2. <strong>ASAN Monitoring Mechanisms</strong></h2><p>As seen above, simply using <code>-fsanitize=address</code> enables a wide range of detections. How does ASan detect these memory errors?</p>
<p>ASan primarily relies on three monitoring mechanisms:</p>
<p><strong>Shadow Memory-based Access Monitoring</strong></p>
<p><strong>Poisoning / Unpoisoning for Lifetime Tracking</strong></p>
<p><strong>Redzones for Boundary Detection</strong></p>
<p>These mechanisms are inserted into the program during compile-time instrumentation.</p>
<p>Checks are inserted before every memory read, write, allocation, and deallocation, and when a policy violation is detected, an error message is printed and the program is terminated by default.</p>
<p>Instrumentation is mainly inserted at the following points:</p>
<ul>
<li>Before memory read/write instructions</li>
<li>At dynamic memory allocation</li>
<li>At dynamic memory deallocation</li>
<li>At function entry (stack frame setup)</li>
<li>At function return (stack frame teardown)</li>
<li>At global object initialization and destruction</li>
</ul>
<pre><code class="hljs c">byte *shadow_address = MemToShadow(address);
byte shadow_value = *shadow_address;
<span class="hljs-keyword">if</span> (shadow_value) {
		<span class="hljs-keyword">if</span> (SlowPathCheck(shadow_value, address, kAccessSize)) {
				ReportError(address, kAccessSize, kIsWrite);
		}
}</code></pre>
<p>Let us examine each mechanism in detail.</p>
<h3 id="2-1-Shadow-Memory"><a href="#2-1-Shadow-Memory" class="headerlink" title="2.1 Shadow Memory"></a>2.1 Shadow Memory</h3><p>ASan maintains a separate memory region called shadow memory, which stores metadata for each byte of the program&#x2019;s memory.</p>
<p>The address of the shadow memory corresponding to a given memory address is calculated as follows.</p>
<pre><code class="hljs c">Shadow = (Mem &gt;&gt; <span class="hljs-number">3</span>) + SHADOW_OFFSET</code></pre>
<p>Internally, this is implemented using the following macros.</p>
<blockquote>
<p><strong>llvm-project/compiler-rt/lib/asan/asan_mapping.h</strong></p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-meta">#    <span class="hljs-meta-keyword">define</span> MEM_TO_SHADOW(mem) \</span>
      ((STRIP_MTE_TAG(mem) &gt;&gt; ASAN_SHADOW_SCALE) + (ASAN_SHADOW_OFFSET))
<span class="hljs-meta">#    <span class="hljs-meta-keyword">define</span> SHADOW_TO_MEM(mem) \</span>
      (((mem) - (ASAN_SHADOW_OFFSET)) &lt;&lt; (ASAN_SHADOW_SCALE))</code></pre>
<p>As shown above, 8 bytes of application memory correspond to 1 byte of shadow memory.</p>
<p>The value of <code>SHADOW_OFFSET</code> is platform- and architecture-dependent. On x86-64, it is defined as <code>0x7fff8000</code>.</p>
<blockquote>
<p><strong>llvm-project/compiler-rt/lib/asan/asan_mapping.h</strong></p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-comment">// Typical shadow mapping on Linux/x86_64 with SHADOW_OFFSET == 0x00007fff8000:</span>
<span class="hljs-comment">// || `[0x10007fff8000, 0x7fffffffffff]` || HighMem    ||</span>
<span class="hljs-comment">// || `[0x02008fff7000, 0x10007fff7fff]` || HighShadow ||</span>
<span class="hljs-comment">// || `[0x00008fff7000, 0x02008fff6fff]` || ShadowGap  ||</span>
<span class="hljs-comment">// || `[0x00007fff8000, 0x00008fff6fff]` || LowShadow  ||</span>
<span class="hljs-comment">// || `[0x000000000000, 0x00007fff7fff]` || LowMem     ||</span>
...
<span class="hljs-meta">#    <span class="hljs-meta-keyword">if</span> ASAN_SHADOW_SCALE != 3</span>
<span class="hljs-meta">#      <span class="hljs-meta-keyword">error</span> <span class="hljs-meta-string">&quot;Value below is based on shadow scale = 3.&quot;</span></span>
<span class="hljs-meta">#      <span class="hljs-meta-keyword">error</span> <span class="hljs-meta-string">&quot;Original formula was: 0x7FFFFFFF &amp; (~0xFFFULL &lt;&lt; SHADOW_SCALE).&quot;</span></span>
<span class="hljs-meta">#    <span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#    <span class="hljs-meta-keyword">define</span> ASAN_SHADOW_OFFSET_CONST 0x000000007fff8000</span>
<span class="hljs-meta">#  <span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
...</code></pre>
<p>AS documented in the source code, shadow memory and application memory are logically separated in the virtual address space. On x86-64, the layout is as follows.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Category</th>
<th>Mapped Region</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>HighMem</td>
<td><code>[0x10007fff8000, 0x7fffffffffff]</code></td>
<td><strong>Virtual memory represented by 5 bytes or more</strong></td>
</tr>
<tr>
<td>HighShadow</td>
<td><code>[0x02008fff7000, 0x10007fff7fff]</code></td>
<td><strong>Shadow Memory corresponding to HighMem</strong></td>
</tr>
<tr>
<td>ShadowGap</td>
<td><code>[0x00008fff7000, 0x02008fff6fff]</code></td>
<td><strong>Gap region between Shadow Memory areas</strong></td>
</tr>
<tr>
<td>LowShadow</td>
<td><code>[0x00007fff8000, 0x00008fff6fff]</code></td>
<td><strong>Shadow Memory corresponding to LowMem</strong></td>
</tr>
<tr>
<td>LowMem</td>
<td><code>[0x000000000000, 0x00007fff7fff]</code></td>
<td><strong>Virtual memory represented by 4 bytes or less</strong></td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2025/12/25/millet/asan-pt1-en/image3.png" srcset="/img/loading.gif" alt></p>
<ul>
<li>The ShadowGap region exists solely to prevent interference between shadow regions and has no read or write permissions.</li>
</ul>
<p><img src="/2025/12/25/millet/asan-pt1-en/image4.png" srcset="/img/loading.gif" alt></p>
<p>Because shadow memory is mapped at an 8:1 ratio, certain unaligned memory accesses may not be detected. Consider the following example.</p>
<pre><code class="hljs c"><span class="hljs-comment">// g++ oob.cpp -o oob -fsanitize=address</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">int</span> *x = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];                <span class="hljs-comment">// [0, 7]</span>
    <span class="hljs-keyword">int</span> *y = (<span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">char</span> *)x + <span class="hljs-number">6</span>);    <span class="hljs-comment">// [6, 9]</span>
    *y = <span class="hljs-number">1</span>;                             <span class="hljs-comment">// OOB</span>
    <span class="hljs-keyword">delete</span>[] x;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<p>Although this is clearly an out-of-bounds access, ASAN does not detect it due to the 8:1 mapping granularity.</p>
<p>To address such cases, it is recommended to enable additional sanitizers such as <code>-fsanitize=alignment</code>, which is part of Undefined Behavior Sanitizer (UBSan).</p>
<p><img src="/2025/12/25/millet/asan-pt1-en/image5.png" srcset="/img/loading.gif" alt></p>
<p>Because the shadow memory is mapped at an 8:1 ratio, the result of the expression</p>
<p><code>(v4 + 6) &gt;&gt; 3</code> eventually becomes identical to <code>v4 &gt;&gt; 3</code>.</p>
<p>As a result, the same shadow memory byte is checked, which prevents ASan from detecting the out-of-bounds access.</p>
<p>Due to this structural limitation, memory accesses that cross misaligned boundaries may not be properly detected by ASan.</p>
<p>Reducing the mapping scale would allow stricter checks, but doing so would introduce inefficiencies in vectorized instructions and deviate from ASAN&#x2019;s original design assumptions. For these reasons, the recommended approach is to apply an additional sanitizer that explicitly checks alignment violations, such as <code>-fsanitize=alignment</code>. This option is part of Undefined Behavior Sanitizer (UBSan).</p>
<p>When rebuilding the program with the <code>-fsanitize=alignment</code> option enabled, the out-of-bounds access is correctly detected.</p>
<pre><code class="hljs bash">$ g++ oob.cpp -o oob_aligned -fsanitize=address -fsanitize=alignment
$ ./oob_aligned
oob.cpp:7:8: runtime error: store to misaligned address 0x502000000016 <span class="hljs-keyword">for</span> <span class="hljs-built_in">type</span> <span class="hljs-string">&apos;int&apos;</span>, <span class="hljs-built_in">which</span> requires 4 byte alignment
0x502000000016: note: pointer points here
 be be be be be be  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00
             ^</code></pre>
<p>Examining the resulting binary shows that UBSan has inserted additional type-based checking functions. This topic will be covered in more detail in a future article.</p>
<p><img src="/2025/12/25/millet/asan-pt1-en/image6.png" srcset="/img/loading.gif" alt></p>
<h3 id="2-2-Poisoning-Unpoisoning"><a href="#2-2-Poisoning-Unpoisoning" class="headerlink" title="2.2 Poisoning / Unpoisoning"></a>2.2 Poisoning / Unpoisoning</h3><p>Shadow memory stores one byte of metadata per 8 bytes of application memory. ASan interprets this byte using several predefined values to represent memory accessibility.</p>
<p>Accessible memory is referred to as <strong>unpoisoned</strong>, while inaccessible memory is <strong>poisoned</strong>. Read and write accesses are not distinguished at this level.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Shadow Byte</th>
<th>Meaning</th>
<th>State</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td>All 8 bytes accessible</td>
<td>unpoison</td>
</tr>
<tr>
<td><code>&lt; 0</code></td>
<td>All 8 bytes inaccessible</td>
<td>poison</td>
</tr>
<tr>
<td><code>k (1~7)</code></td>
<td>First <code>k</code> bytes accessible</td>
<td>&#xBD80;&#xBD84; unpoison</td>
</tr>
</tbody>
</table>
</div>
<p>At process startup, shadow memory is initialized as poisoned. Known memory regions are unpoisoned before entering <code>main</code>.</p>
<p>It can be summarized in a table as follows.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Region</th>
<th>Initialized before main thread execution</th>
<th>Modified during process execution</th>
</tr>
</thead>
<tbody>
<tr>
<td>Global / static variables</td>
<td>O (unpoison)</td>
<td>X</td>
</tr>
<tr>
<td>Stack frame (main)</td>
<td>O (partially unpoison)</td>
<td>Updated on function call and return</td>
</tr>
<tr>
<td>Heap</td>
<td>X (poison)</td>
<td>Managed by dedicated interceptor functions</td>
</tr>
<tr>
<td>TLS</td>
<td>O (unpoison)</td>
<td>X</td>
</tr>
</tbody>
</table>
</div>
<p>Dynamic heap memory is managed via interceptor functions inserted by ASan, such as wrapped versions of <code>malloc</code> and <code>free</code>.</p>
<blockquote>
<p><strong>llvm-project/compiler-rt/lib/interception/interception.h</strong></p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTERCEPTOR(ret_type, func, ...)        \</span>
  DEFINE_REAL(ret_type, func, __VA_ARGS__)      \
  DECLARE_WRAPPER(ret_type, func, __VA_ARGS__)  \
  <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">INTERCEPTOR_ATTRIBUTE ret_type <span class="hljs-title">WRAP</span><span class="hljs-params">(func)</span><span class="hljs-params">(__VA_ARGS__)</span></span></code></pre>
<blockquote>
<p><strong>llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp</strong></p>
</blockquote>
<pre><code class="hljs c">...
INTERCEPTOR(<span class="hljs-keyword">void</span>, <span class="hljs-built_in">free</span>, <span class="hljs-keyword">void</span> *ptr) {
  <span class="hljs-keyword">if</span> (DlsymAlloc::PointerIsMine(ptr))
    <span class="hljs-keyword">return</span> DlsymAlloc::Free(ptr);
  GET_STACK_TRACE_FREE;
  asan_free(ptr, &amp;<span class="hljs-built_in">stack</span>);
}
...
INTERCEPTOR(<span class="hljs-keyword">void</span>*, <span class="hljs-built_in">malloc</span>, uptr size) {
  <span class="hljs-keyword">if</span> (DlsymAlloc::Use())
    <span class="hljs-keyword">return</span> DlsymAlloc::Allocate(size);
  GET_STACK_TRACE_MALLOC;
  <span class="hljs-keyword">return</span> asan_malloc(size, &amp;<span class="hljs-built_in">stack</span>);
}
...</code></pre>
<p>ASan also provides explicit APIs to poison or unpoison memory regions.</p>
<blockquote>
<p><strong>llvm-project/compiler-rt/include/sanitizer/asan_interface.h</strong></p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ASAN_POISON_MEMORY_REGION(addr, size) \</span>
  __asan_poison_memory_region((addr), (size))
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ASAN_UNPOISON_MEMORY_REGION(addr, size) \</span>
  __asan_unpoison_memory_region((addr), (size))
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ASAN_POISON_MEMORY_REGION(addr, size) \</span>
  ((<span class="hljs-keyword">void</span>)(addr), (<span class="hljs-keyword">void</span>)(size))
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ASAN_UNPOISON_MEMORY_REGION(addr, size) \</span>
  ((<span class="hljs-keyword">void</span>)(addr), (<span class="hljs-keyword">void</span>)(size))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span></code></pre>
<p>Explicit poisoning can be enabled or disabled through runtime flags.</p>
<pre><code class="hljs bash">ASAN_OPTIONS=allow_user_poisoning=0</code></pre>
<p>These can be useful for enforcing custom memory lifetimes. Let us verify this behavior using an example program.</p>
<pre><code class="hljs c"><span class="hljs-comment">// g++ unpoison.cpp -o unpoison -fsanitize=address</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sanitizer/asan_interface.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">cus_alloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">void</span> *p = <span class="hljs-built_in">malloc</span>(size);
    ASAN_POISON_MEMORY_REGION(p, size);

    <span class="hljs-keyword">return</span> p;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activate_p</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> size)</span></span>
<span class="hljs-function"></span>{
    ASAN_UNPOISON_MEMORY_REGION(p, size);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)cus_alloc(<span class="hljs-number">8</span>);

    activate_p(p, <span class="hljs-number">6</span>);
    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;millet&quot;</span>);

    <span class="hljs-built_in">puts</span>(p);
    <span class="hljs-built_in">free</span>(p);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<p>In ASan, the redefined <code>malloc()</code> function manages newly allocated memory as unpoisoned by default. In this example, the memory region is first marked as inaccessible using <code>ASAN_POISON_MEMORY_REGION</code>, and then explicitly unpoisoned only when it is actually used. This approach provides an additional layer of safety in memory management.</p>
<p>If the memory is not explicitly unpoisoned, the program terminates with an error as shown below.</p>
<pre><code class="hljs bash">./unpoison
=================================================================
==1381294==ERROR: AddressSanitizer: use-after-poison on address 0x502000000010 at pc 0x7f0804f052c3 bp 0x7ffcc58dca60 sp 0x7ffcc58dc208
WRITE of size 7 at 0x502000000010 thread T0
    <span class="hljs-comment">#0 0x7f0804f052c2 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827</span>
    <span class="hljs-comment">#1 0x55577d55a300 in main (/root/asan/unpoison+0x1300)</span>
    <span class="hljs-comment">#2 0x7f0804998d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span>
    <span class="hljs-comment">#3 0x7f0804998e3f in __libc_start_main_impl ../csu/libc-start.c:392</span>
    <span class="hljs-comment">#4 0x55577d55a1a4 in _start (/root/asan/unpoison+0x11a4)</span>

0x502000000010 is located 0 bytes inside of 8-byte region [0x502000000010,0x502000000018)
allocated by thread T0 here:
    <span class="hljs-comment">#0 0x7f0804f7f887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span>
    <span class="hljs-comment">#1 0x55577d55a284 in cus_alloc(unsigned long) (/root/asan/unpoison+0x1284)</span>
    <span class="hljs-comment">#2 0x55577d55a2e1 in main (/root/asan/unpoison+0x12e1)</span>
    <span class="hljs-comment">#3 0x7f0804998d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span>

SUMMARY: AddressSanitizer: use-after-poison ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 <span class="hljs-keyword">in</span> __interceptor_memcpy
Shadow bytes around the buggy address:
  0x0a047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0a047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x0a047fff8000: fa fa[f7]fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0a047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after <span class="hljs-built_in">return</span>:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      <span class="hljs-built_in">fc</span>
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==1381294==ABORTING</code></pre>
<p>It clearly reports the issue as a <strong>use-after-poison</strong> error.</p>
<h3 id="2-3-Redzone"><a href="#2-3-Redzone" class="headerlink" title="2.3 Redzone"></a>2.3 Redzone</h3><p>While poisoning tracks memory lifetime, redzones protect boundaries around memory objects. Redzones are regions of memory placed around the actual usable area of a memory object where access is explicitly forbidden.</p>
<p><img src="/2025/12/25/millet/asan-pt1-en/image7.png" srcset="/img/loading.gif" alt></p>
<p>Regions designated as redzones are always kept in a poisoned state. As a result, any read or write that crosses a boundary, or any logically invalid access, ends up touching a redzone, allowing ASan to detect heap buffer overflows or stack buffer overflows.</p>
<p>Redzones are primarily placed around heap, stack, and global buffers, and all of them are represented as poisoned regions in shadow memory.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Shadow Byte</th>
<th>Meaning</th>
<th>State</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0xfa</code></td>
<td>Heap left redzone</td>
<td>poison</td>
</tr>
<tr>
<td><code>0xf1</code></td>
<td>Stack left redzone</td>
<td>poison</td>
</tr>
<tr>
<td><code>0xf2</code></td>
<td>Stack mid redzone</td>
<td>poison</td>
</tr>
<tr>
<td><code>0xf3</code></td>
<td>Stack right redzone</td>
<td>poison</td>
</tr>
<tr>
<td><code>0xf5</code></td>
<td>Stack after return</td>
<td>poison</td>
</tr>
<tr>
<td><code>0xf9</code></td>
<td>Global redzone</td>
<td>poison</td>
</tr>
<tr>
<td><code>0xca</code></td>
<td>Left alloca redzone</td>
<td>poison</td>
</tr>
<tr>
<td><code>0xcb</code></td>
<td>Right alloca redzone</td>
<td>poison</td>
</tr>
</tbody>
</table>
</div>
<p>Let us examine an example to observe the redzones inserted around heap allocations.</p>
<pre><code class="hljs c"><span class="hljs-comment">// g++ redzone.cpp -o redzone -fsanitize=address</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6</span>);
    p[<span class="hljs-number">6</span>] = <span class="hljs-string">&apos;m&apos;</span>;

    <span class="hljs-built_in">free</span>(p);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<p>In an x86-64 environment, ptmalloc2 allocates memory in 16-byte&#x2013;aligned chunks.</p>
<p>When <code>malloc(6)</code> is called, ptmalloc2 actually allocates a total of 32 bytes.</p>
<p>Except for the 6 bytes of user data, the remaining space must not be accessed.</p>
<pre><code class="hljs bash">...
   0x5555555551d1 &lt;main+0008&gt;      sub    rsp, 0x10
   0x5555555551d5 &lt;main+000c&gt;      mov    edi, 0x6
   0x5555555551da &lt;main+0011&gt;      call   0x5555555550b0 &lt;malloc@plt&gt;
 &#x2192; 0x5555555551df &lt;main+0016&gt;      mov    QWORD PTR [rbp-0x8], rax
...
gef&#x27A4;  x/4bx ((<span class="hljs-variable">$rax</span> &gt;&gt; 3) + 0x7fff8000) - 2
0xa047fff8000:  0xfa    0xfa    0x06    0xfa</code></pre>
<p>After the memory allocation, the state appears as shown above. Only the shadow byte corresponding to the actually usable region is set to <code>0x06</code>, while the remaining bytes are set to <code>0xfa</code>, which represents the heap left redzone.</p>
<p>Therefore, the following conditional check detects the invalid memory access.</p>
<p><img src="/2025/12/25/millet/asan-pt1-en/image8.png" srcset="/img/loading.gif" alt></p>
<p>This time, let us examine a stack buffer overflow using an example.</p>
<pre><code class="hljs c"><span class="hljs-comment">// g++ redzone.cpp -o redzone -fsanitize=address</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">char</span> sp[<span class="hljs-number">16</span>] = {<span class="hljs-number">0</span>, };
    sp[<span class="hljs-number">17</span>] = <span class="hljs-string">&apos;i&apos;</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<p>After compilation, the <code>main()</code> function rewritten by ASan appears as follows.</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __fastcall <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>
<span class="hljs-function"></span>{
  <span class="hljs-keyword">unsigned</span> __int64 v3; <span class="hljs-comment">// rbx</span>
  __int64 v4; <span class="hljs-comment">// rax</span>
  _BYTE *v5; <span class="hljs-comment">// rdx</span>
  __int64 v6; <span class="hljs-comment">// rax</span>
  <span class="hljs-keyword">char</span> v7; <span class="hljs-comment">// si</span>
  _BYTE v9[<span class="hljs-number">88</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-70h] BYREF</span>
  <span class="hljs-keyword">unsigned</span> __int64 cnry; <span class="hljs-comment">// [rsp+58h] [rbp-18h]</span>

  v3 = (<span class="hljs-keyword">unsigned</span> __int64)v9;
  <span class="hljs-keyword">if</span> ( _TMC_END__ )
  {
    v4 = __asan_stack_malloc_0(<span class="hljs-number">64</span>, argv, envp);
    <span class="hljs-keyword">if</span> ( v4 )
      v3 = v4;
  }
  v5 = (_BYTE *)(v3 + <span class="hljs-number">0x60</span>);
  *(_QWORD *)v3 = <span class="hljs-number">0x41B58AB3</span>;
  *(_QWORD *)(v3 + <span class="hljs-number">8</span>) = <span class="hljs-string">&quot;1 32 16 4 sp:5&quot;</span>;
  *(_QWORD *)(v3 + <span class="hljs-number">16</span>) = main;
  v6 = v3 &gt;&gt; <span class="hljs-number">3</span>;
  *(_DWORD *)(v6 + <span class="hljs-number">0x7FFF8000</span>) = <span class="hljs-number">0xF1F1F1F1</span>;
  *(_DWORD *)(v6 + <span class="hljs-number">0x7FFF8004</span>) = <span class="hljs-number">0xF3F30000</span>;
  cnry = __readfsqword(<span class="hljs-number">0x28</span>u);
  <span class="hljs-keyword">if</span> ( *(_WORD *)(((v3 + <span class="hljs-number">32</span>) &gt;&gt; <span class="hljs-number">3</span>) + <span class="hljs-number">0x7FFF8000</span>) )
    v6 = __asan_report_store16(v3 + <span class="hljs-number">32</span>);
  *((_QWORD *)v5 - <span class="hljs-number">8</span>) = <span class="hljs-number">0</span>;
  *((_QWORD *)v5 - <span class="hljs-number">7</span>) = <span class="hljs-number">0</span>;
  v7 = *(_BYTE *)(((<span class="hljs-keyword">unsigned</span> __int64)(v5 - <span class="hljs-number">47</span>) &gt;&gt; <span class="hljs-number">3</span>) + <span class="hljs-number">0x7FFF8000</span>);
  <span class="hljs-keyword">if</span> ( v7 != <span class="hljs-number">0</span> &amp;&amp; (((<span class="hljs-keyword">unsigned</span> __int8)v5 - <span class="hljs-number">64</span> + <span class="hljs-number">17</span>) &amp; <span class="hljs-number">7</span>) &gt;= v7 )
    v6 = __asan_report_store1(v5 - <span class="hljs-number">47</span>);
  *(v5 - <span class="hljs-number">47</span>) = <span class="hljs-string">&apos;i&apos;</span>;
  <span class="hljs-keyword">if</span> ( v9 == (_BYTE *)v3 )
  {
    *(_QWORD *)(v6 + <span class="hljs-number">0x7FFF8000</span>) = <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">else</span>
  {
    *(_QWORD *)v3 = <span class="hljs-number">0x45E0360E</span>;
    *(_QWORD *)(v6 + <span class="hljs-number">0x7FFF8000</span>) = <span class="hljs-number">0xF5F5F5F5F5F5F5F5</span>LL;
    **(_BYTE **)(v3 + <span class="hljs-number">0x38</span>) = <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<p>Wow&#x2026; quite a lot of code has been inserted.</p>
<p>It may look complex at first glance, but if we apply the concepts discussed earlier, it is not particularly difficult to understand. Let us break it down step by step.</p>
<p><strong>ASan Stack Frame Setup</strong></p>
<p><code>v9</code> represents the top of the stack frame buffer set up by the compiler. To allow ASan to manage this stack frame, its value is moved into the variable <code>v3</code>.</p>
<pre><code class="hljs c">v3 = (<span class="hljs-keyword">unsigned</span> __int64)v9;
<span class="hljs-keyword">if</span> ( _TMC_END__ )
{
  v4 = __asan_stack_malloc_0(<span class="hljs-number">64</span>, argv, envp);
  <span class="hljs-keyword">if</span> ( v4 )
    v3 = v4;
}</code></pre>
<ul>
<li>There is logic that checks the value <code>_TMC_END__</code> and reallocates the stack. This behavior is controlled by the <code>ASAN_OPTIONS=detect_stack_use_after_return</code> option, which is used to detect stack reuse after a function has returned.</li>
</ul>
<p><img src="/2025/12/25/millet/asan-pt1-en/image9.png" srcset="/img/loading.gif" alt></p>
<p><strong>Stack Frame Metadata Recording</strong></p>
<p>This code records separate metadata for the stack frame. Here, it stores information such as the current state of the stack frame and the intended layout of objects within the frame.</p>
<pre><code class="hljs c">v5 = (_BYTE *)(v3 + <span class="hljs-number">0x60</span>);
*(_QWORD *)v3 = <span class="hljs-number">0x41B58AB3</span>;
*(_QWORD *)(v3 + <span class="hljs-number">8</span>) = <span class="hljs-string">&quot;1 32 16 4 sp:5&quot;</span>;
*(_QWORD *)(v3 + <span class="hljs-number">16</span>) = main;</code></pre>
<ul>
<li><p><code>0x41B58AB3</code>: A magic number used to identify the stack frame. In this context, it indicates that the stack frame is valid.</p>
<blockquote>
<p><strong>llvm-project/compiler-rt/lib/asan/asan_internal.h</strong></p>
</blockquote>
  <pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uptr kCurrentStackFrameMagic = <span class="hljs-number">0x41B58AB3</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> uptr kRetiredStackFrameMagic = <span class="hljs-number">0x45E0360E</span>;</code></pre>
</li>
<li><p><code>&quot;1 32 16 4 sp:5&quot;</code>: one stack object, offset 32, size 16, internal name sp:5</p>
</li>
<li><code>main</code>: records which function this stack frame belongs to</li>
</ul>
<p><strong>Stack Redzone Setup</strong></p>
<p>After unpoisoning the two shadow bytes corresponding to the 16 bytes that will actually be used, the regions on both sides are set as the stack left redzone and the stack right redzone, respectively.</p>
<pre><code class="hljs c">v6 = v3 &gt;&gt; <span class="hljs-number">3</span>;
*(_DWORD *)(v6 + <span class="hljs-number">0x7FFF8000</span>) = <span class="hljs-number">0xF1F1F1F1</span>;
*(_DWORD *)(v6 + <span class="hljs-number">0x7FFF8004</span>) = <span class="hljs-number">0xF3F30000</span>;</code></pre>
<p><strong>Pre-access Check &#x2192; Access Logic</strong></p>
<p>This part follows the same shadow memory check mechanism discussed earlier.</p>
<p>Here, the check begins at the <code>+32</code> offset, which matches the information recorded in the stack frame metadata.</p>
<pre><code class="hljs c"><span class="hljs-keyword">if</span> ( *(_WORD *)(((v3 + <span class="hljs-number">32</span>) &gt;&gt; <span class="hljs-number">3</span>) + <span class="hljs-number">0x7FFF8000</span>) )
  v6 = __asan_report_store16(v3 + <span class="hljs-number">32</span>);
*((_QWORD *)v5 - <span class="hljs-number">8</span>) = <span class="hljs-number">0</span>;
*((_QWORD *)v5 - <span class="hljs-number">7</span>) = <span class="hljs-number">0</span>;
v7 = *(_BYTE *)(((<span class="hljs-keyword">unsigned</span> __int64)(v5 - <span class="hljs-number">47</span>) &gt;&gt; <span class="hljs-number">3</span>) + <span class="hljs-number">0x7FFF8000</span>);
<span class="hljs-keyword">if</span> ( v7 != <span class="hljs-number">0</span> &amp;&amp; (((<span class="hljs-keyword">unsigned</span> __int8)v5 - <span class="hljs-number">64</span> + <span class="hljs-number">17</span>) &amp; <span class="hljs-number">7</span>) &gt;= v7 )
  v6 = __asan_report_store1(v5 - <span class="hljs-number">47</span>);
*(v5 - <span class="hljs-number">47</span>) = <span class="hljs-string">&apos;i&apos;</span>;</code></pre>
<p>Although the operations may look complex, it ultimately becomes clear that the access targets the <code>+32</code> offset where the array is located. </p>
<p>(The <code>__asan_report_storeX()</code> functions will be examined in the next section.)</p>
<p><strong>Cleanup Before Function Return</strong></p>
<p>If <code>v9</code> and <code>v3</code> point to the same address, this indicates that the frame resides on the real stack, and the corresponding region is unpoisoned to allow subsequent function calls.</p>
<p>Otherwise, the frame was allocated on ASan&#x2019;s fake stack. In this case, the magic number is changed to <code>0x45E0360E</code>, which corresponds to <code>kRetiredStackFrameMagic</code>, and the region is poisoned with <code>0xf5</code>, representing <em>stack after return</em>. </p>
<p>With the underlying concepts in mind, the code becomes much easier to understand.</p>
<pre><code class="hljs c">  <span class="hljs-keyword">if</span> ( v9 == (_BYTE *)v3 )
  {
    *(_QWORD *)(v6 + <span class="hljs-number">0x7FFF8000</span>) = <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">else</span>
  {
    *(_QWORD *)v3 = <span class="hljs-number">0x45E0360E</span>;
    *(_QWORD *)(v6 + <span class="hljs-number">0x7FFF8000</span>) = <span class="hljs-number">0xF5F5F5F5F5F5F5F5</span>LL;
    **(_BYTE **)(v3 + <span class="hljs-number">0x38</span>) = <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<h2 id="3-Error-Reporting"><a href="#3-Error-Reporting" class="headerlink" title="3. Error Reporting"></a>3. Error Reporting</h2><h3 id="3-1-Error-Reporting-Functions"><a href="#3-1-Error-Reporting-Functions" class="headerlink" title="3.1 Error Reporting Functions"></a>3.1 Error Reporting Functions</h3><p>When a check in the instrumentation logic fails, the following reporting functions are invoked.</p>
<blockquote>
<p><strong>llvm-project/compiler-rt/lib/asan_abi_asan_abi_shim.cpp</strong></p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-comment">// Functions concerning memory load and store reporting</span>
<span class="hljs-keyword">void</span> __asan_report_load1(uptr addr) {
  __asan_abi_report_load_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_load2(uptr addr) {
  __asan_abi_report_load_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_load4(uptr addr) {
  __asan_abi_report_load_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_load8(uptr addr) {
  __asan_abi_report_load_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">8</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_load16(uptr addr) {
  __asan_abi_report_load_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">16</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_load_n(uptr addr, uptr size) {
  __asan_abi_report_load_n((<span class="hljs-keyword">void</span> *)addr, size, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_store1(uptr addr) {
  __asan_abi_report_store_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_store2(uptr addr) {
  __asan_abi_report_store_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_store4(uptr addr) {
  __asan_abi_report_store_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_store8(uptr addr) {
  __asan_abi_report_store_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">8</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_store16(uptr addr) {
  __asan_abi_report_store_n((<span class="hljs-keyword">void</span> *)addr, <span class="hljs-number">16</span>, <span class="hljs-literal">true</span>);
}
<span class="hljs-keyword">void</span> __asan_report_store_n(uptr addr, uptr size) {
  __asan_abi_report_store_n((<span class="hljs-keyword">void</span> *)addr, size, <span class="hljs-literal">true</span>);
}</code></pre>
<p>As the names suggest, reads are labeled as <code>load</code>, writes as <code>store</code>, and the suffix indicates the number of bytes accessed.</p>
<p>The wrapped functions <code>__asan_abi_report_XXX_n</code> ultimately invoke the <code>ReportGenericError()</code> function.</p>
<blockquote>
<p><strong>llvm-project/compiler-rt/lib/asan/asan_report.cpp</strong></p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-keyword">void</span> __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, <span class="hljs-keyword">int</span> is_write,
                         uptr access_size, u32 <span class="hljs-built_in">exp</span>) {
  ENABLE_FRAME_POINTER;
  <span class="hljs-keyword">bool</span> fatal = flags()-&gt;halt_on_error;
  ReportGenericError(pc, bp, sp, addr, is_write, access_size, <span class="hljs-built_in">exp</span>, fatal);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReportGenericError</span><span class="hljs-params">(uptr pc, uptr bp, uptr sp, uptr addr, <span class="hljs-keyword">bool</span> is_write,</span></span>
<span class="hljs-function"><span class="hljs-params">                        uptr access_size, u32 <span class="hljs-built_in">exp</span>, <span class="hljs-keyword">bool</span> fatal)</span> </span>{
  <span class="hljs-keyword">if</span> (__asan_test_only_reported_buggy_pointer) {
    *__asan_test_only_reported_buggy_pointer = addr;
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (!fatal &amp;&amp; SuppressErrorReport(pc)) <span class="hljs-keyword">return</span>;
  ENABLE_FRAME_POINTER;

  <span class="hljs-comment">// Optimization experiments.</span>
  <span class="hljs-comment">// The experiments can be used to evaluate potential optimizations that remove</span>
  <span class="hljs-comment">// instrumentation (assess false negatives). Instead of completely removing</span>
  <span class="hljs-comment">// some instrumentation, compiler can emit special calls into runtime</span>
  <span class="hljs-comment">// (e.g. __asan_report_exp_load1 instead of __asan_report_load1) and pass</span>
  <span class="hljs-comment">// mask of experiments (exp).</span>
  <span class="hljs-comment">// The reaction to a non-zero value of exp is to be defined.</span>
  (<span class="hljs-keyword">void</span>)<span class="hljs-built_in">exp</span>;

  <span class="hljs-function">ScopedInErrorReport <span class="hljs-title">in_report</span><span class="hljs-params">(fatal)</span></span>;
  <span class="hljs-function">ErrorGeneric <span class="hljs-title">error</span><span class="hljs-params">(GetCurrentTidOrInvalid(), pc, bp, sp, addr, is_write,</span></span>
<span class="hljs-function"><span class="hljs-params">                     access_size)</span></span>;
  in_report.ReportError(error);
}</code></pre>
<p>The <code>fatal</code> value determines whether the program terminates after reporting an error. </p>
<p>This behavior is also controlled by compile-time options and runtime flags.</p>
<pre><code class="hljs bash"><span class="hljs-comment"># Activate ASAN Recovery Mode</span>
-fsanitize-recover=address
<span class="hljs-comment"># Runtime Flag</span>
ASAN_OPTIONS=halt_on_error=0</code></pre>
<p>If we add a <code>getchar()</code> call to the example code used in the redzone section and run it again, we can observe that the program does not terminate even after the error occurs.</p>
<pre><code class="hljs bash">$ g++ redzone.cpp -o redzone -fsanitize=address -fsanitize-recover=address &amp;&amp; ASAN_OPTIONS=halt_on_error=0 ./redzone
=================================================================
==1481048==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff00408791 at pc 0x5593d35b02fa bp 0x7fff00408750 sp 0x7fff00408740
WRITE of size 1 at 0x7fff00408791 thread T0
...

$ <span class="hljs-built_in">echo</span> $? 
0</code></pre>
<h3 id="3-2-Interpreting-Erros"><a href="#3-2-Interpreting-Erros" class="headerlink" title="3.2 Interpreting Erros"></a>3.2 Interpreting Erros</h3><p>An ASan error report is generally composed of a summary, a call stack, memory information, and the state of the shadow bytes.</p>
<p>Using the error message produced by running the previous example, let us examine each of these components in detail.</p>
<pre><code class="hljs bash">$ ./redzone      
=================================================================
==1670382==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffaec08e11 at pc 0x5591367762fa bp 0x7fffaec08dd0 sp 0x7fffaec08dc0
WRITE of size 1 at 0x7fffaec08e11 thread T0
    <span class="hljs-comment">#0 0x5591367762f9 in main (/root/asan/redzone+0x12f9)</span>
    <span class="hljs-comment">#1 0x7fe1e1807d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span>
    <span class="hljs-comment">#2 0x7fe1e1807e3f in __libc_start_main_impl ../csu/libc-start.c:392</span>
    <span class="hljs-comment">#3 0x559136776144 in _start (/root/asan/redzone+0x1144)</span>

Address 0x7fffaec08e11 is located <span class="hljs-keyword">in</span> stack of thread T0 at offset 49 <span class="hljs-keyword">in</span> frame
    <span class="hljs-comment">#0 0x559136776218 in main (/root/asan/redzone+0x1218)</span>

  This frame has 1 object(s):
    [32, 48) <span class="hljs-string">&apos;sp&apos;</span> (line 6) &lt;== Memory access at offset 49 overflows this variable
HINT: this may be a <span class="hljs-literal">false</span> positive <span class="hljs-keyword">if</span> your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow (/root/asan/redzone+0x12f9) <span class="hljs-keyword">in</span> main
Shadow bytes around the buggy address:
  0x100075d79170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791b0: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
=&gt;0x100075d791c0: 00 00[f3]f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79210: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after <span class="hljs-built_in">return</span>:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      <span class="hljs-built_in">fc</span>
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==1670382==ABORTING</code></pre>
<p><strong>Error Overview</strong></p>
<p>The type of error is a <em>stack-buffer-overflow</em>, and it occurred on thread T0 during a 1-byte write operation.</p>
<p>Below this, the call stack is displayed, allowing us to trace the function call path that led to the error.</p>
<ul>
<li>Faulting location: <code>0x5591367762fa</code></li>
</ul>
<pre><code class="hljs bash">==1670382==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffaec08e11 at pc 0x5591367762fa bp 0x7fffaec08dd0 sp 0x7fffaec08dc0
WRITE of size 1 at 0x7fffaec08e11 thread T0
    <span class="hljs-comment">#0 0x5591367762f9 in main (/root/asan/redzone+0x12f9)</span>
    <span class="hljs-comment">#1 0x7fe1e1807d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span>
    <span class="hljs-comment">#2 0x7fe1e1807e3f in __libc_start_main_impl ../csu/libc-start.c:392</span>
    <span class="hljs-comment">#3 0x559136776144 in _start (/root/asan/redzone+0x1144)</span>
    
Address 0x7fffaec08e11 is located <span class="hljs-keyword">in</span> stack of thread T0 at offset 49 <span class="hljs-keyword">in</span> frame
    <span class="hljs-comment">#0 0x559136776218 in main (/root/asan/redzone+0x1218)</span></code></pre>
<p><strong>Memory Frame Information</strong></p>
<p>The buffer named <code>sp</code> is valid only within the range <code>[32, 48)</code>&#x2014;that is, 16 bytes&#x2014;within the stack frame, but the reported access occurs at offset 49.</p>
<p>From this information, we can determine that an out-of-bounds write has occurred.</p>
<pre><code class="hljs bash">This frame has 1 object(s):
  [32, 48) <span class="hljs-string">&apos;sp&apos;</span> (line 6) &lt;== Memory access at offset 49 overflows this variable</code></pre>
<p><strong>Shadow Bytes State</strong></p>
<p>The actual accessible range is from <code>0x100075d791c0</code> to <code>0x100075d791c1</code>, but the location marked with <code>=&gt;</code> indicates an access to a poisoned region labeled <code>0xf3</code>, which represents the stack right redzone, as highlighted by the brackets <code>[ ]</code>.</p>
<p>From this, we can clearly observe the overall memory access permission state.</p>
<pre><code class="hljs bash">Shadow bytes around the buggy address:
  0x100075d79170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791b0: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
=&gt;0x100075d791c0: 00 00[f3]f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d791f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100075d79210: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</code></pre>
<p>These components clearly indicate the location, cause, and memory state of the error, making debugging significantly easier.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this article, we briefly explored Address Sanitizer. While ASan is extremely effective at detecting memory errors, it introduces significant memory and performance overhead due to shadow memory checks, redzones, and frequent runtime instrumentation. For this reason, it is typically used during development, testing, fuzzing, and vulnerability research rather than in production environments.</p>
<p>Although other sanitizers such as HWASan, UBSan, TSan, and LSan now exist, ASan remains a fundamental and essential tool for memory safety verification.</p>
<p>In the next article, I plan to explore additional sanitizers in more detail. Thank you for reading! &#x1FAC2;</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://learn.microsoft.com/ko-kr/cpp/sanitizers/asan?view=msvc-170">https://learn.microsoft.com/ko-kr/cpp/sanitizers/asan?view=msvc-170</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn">https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://clang.llvm.org/docs/AddressSanitizer.html">https://clang.llvm.org/docs/AddressSanitizer.html</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/llvm/llvm-project/tree/main">https://github.com/llvm/llvm-project/tree/main</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/google/sanitizers/issues/100">https://github.com/google/sanitizers/issues/100</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://research.google/pubs/addresssanitizer-a-fast-address-sanity-checker/">https://research.google/pubs/addresssanitizer-a-fast-address-sanity-checker/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://arxiv.org/pdf/2506.05022v2">https://arxiv.org/pdf/2506.05022v2</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/MemoryCorruption/">MemoryCorruption</a>
                  
                  <a class="hover-with-bg" href="/tags/millet/">millet</a>
                  
                  <a class="hover-with-bg" href="/tags/Address-Sanitizer/">Address Sanitizer</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_millet.jpg" srcset="/img/loading.gif" alt="millet">
                  </div>

                  <div class="link-text">
                    <div class="link-title">millet</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/millet">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">  <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a>  .        .</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/12/27/Libera/CVE-2025-62215/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[] CVE-2025-62215: Windows Kernel Race Condition  Double Free  LPE </span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/12/25/millet/asan-pt1-kr/">
                    <span class="hidden-mobile">[Research] Address Sanitizer: Part 1 (KR)</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/12/25/millet/asan-pt1-en/';
        this.page.identifier = '/2025/12/25/millet/asan-pt1-en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] Address Sanitizer: Part 1 (EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
