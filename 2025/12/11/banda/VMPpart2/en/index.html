

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;h1 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/main.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Hi, this is banda. :)&lt;/p&gt;
&lt;p&gt;Thank you for giving VMProtect Part 1 more attention than I expected. But I still crave even more attention, so I am back with VMProtect Part 2. In line with the theory-oriented flow of the previous write-up, I wanted Part 2 to extend into a more real-world setting. This time, together with static analysis, we will actually decode functions virtualized by VMProtect 3 into a devirtualized binary / restored code and walk through that process as a hands-on exercise.&lt;/p&gt;
&lt;p&gt;If you have not read it yet, I recommend checking out the previous post first: &lt;a href=&#34;https://hackyboiz.github.io/2025/09/11/banda/LLVM_based_VMP/ko/&#34;&gt;VMProtect Devirtualization Part 1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This unpacking article is written purely for educational and research purposes. Please follow ethical guidelines and help keep the ecosystem healthy.&lt;/p&gt;
&lt;h2 id=&#34;Devirtualization-Rules&#34;&gt;&lt;a href=&#34;#Devirtualization-Rules&#34; class=&#34;headerlink&#34; title=&#34;Devirtualization Rules&#34;&gt;&lt;/a&gt;Devirtualization Rules&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image1.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Before jumping into the challenge, let&amp;#x2019;s briefly recap the basic idea behind virtualization-based obfuscation. Normally, a program runs directly as machine code for a real CPU, such as x86 or x64. Tools like VMProtect or Themida do not leave this code as is. Instead, they:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Convert original x86 code into a &amp;#x201C;virtual bytecode&amp;#x201D;&lt;/li&gt;
&lt;li&gt;Embed a virtual machine (VM) inside the binary that can interpret this bytecode&lt;/li&gt;
&lt;li&gt;At runtime, the VM executes by fetching and interpreting each bytecode instruction one by one&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;VM State Transition&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To understand devirtualization, the key is to focus on &amp;#x201C;what state the VM maintains, and how that state changes when a handler executes.&amp;#x201D; The VM state can be defined as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs sql&#34;&gt;VIP: Virtual Instruction Pointer
VSP: Virtual Stack Pointer
VStack: &lt;span class=&#34;hljs-keyword&#34;&gt;values&lt;/span&gt; currently &lt;span class=&#34;hljs-keyword&#34;&gt;stored&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;on&lt;/span&gt; the &lt;span class=&#34;hljs-keyword&#34;&gt;virtual&lt;/span&gt; stack
Scratch: &lt;span class=&#34;hljs-keyword&#34;&gt;temporary&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;storage&lt;/span&gt;
VFlags: &lt;span class=&#34;hljs-keyword&#34;&gt;virtual&lt;/span&gt; flags (playing &lt;span class=&#34;hljs-keyword&#34;&gt;roles&lt;/span&gt; similar &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; ZF, CF, etc.)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No matter how heavy the obfuscation is, what ultimately matters is &amp;#x201C;how the bundle of state changes after each handler.&amp;#x201D; You can think of the VM not as a CPU, but as a collection of state-transition functions that take &lt;code&gt;VIP&lt;/code&gt;, &lt;code&gt;VStack&lt;/code&gt;, &lt;code&gt;Scratch&lt;/code&gt;, and &lt;code&gt;VFlags&lt;/code&gt; as input and produce new &lt;code&gt;VIP&lt;/code&gt;, &lt;code&gt;VStack&lt;/code&gt;, &lt;code&gt;Scratch&lt;/code&gt;, and &lt;code&gt;VFlags&lt;/code&gt; as output.&lt;/p&gt;
&lt;p&gt;When analyzing a handler, instead of trying to understand every single instruction in the disassembly, the important part is to be able to summarize: &amp;#x201C;this handler transforms the VM state in this way.&amp;#x201D; Once you can say that, you have essentially understood that handler&amp;#x2019;s semantics.&lt;/p&gt;
&lt;h2 id=&#34;DevirtualizeMe-Challenge-VMP32-v1&#34;&gt;&lt;a href=&#34;#DevirtualizeMe-Challenge-VMP32-v1&#34; class=&#34;headerlink&#34; title=&#34;DevirtualizeMe Challenge - VMP32 v1&#34;&gt;&lt;/a&gt;DevirtualizeMe Challenge - VMP32 v1&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image2.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The challenge we will work on here is &lt;a href=&#34;https://forum.tuts4you.com/topic/39481-devirtualizeme-vmprotect-309/#comment-190252&#34;&gt;DevirtualizeMe&lt;/a&gt; from Tuts4You.&lt;/p&gt;
&lt;p&gt;The program is structured around a C++ class named &lt;code&gt;UnpackMe&lt;/code&gt;, and it is protected with VMProtect 3.0.9 using Virtualization mode. The goal of this post is to locate the functions that VMProtect has virtualized inside the attached binary, interpret the bytecode running on top of that VM, and reconstruct the original native-level logic as far as possible. The tools used are IDA, Detect It Easy, Triton, and a custom VMPTrace-style toolchain.&lt;/p&gt;
&lt;h3 id=&#34;Challenge-Information&#34;&gt;&lt;a href=&#34;#Challenge-Information&#34; class=&#34;headerlink&#34; title=&#34;Challenge Information&#34;&gt;&lt;/a&gt;Challenge Information&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Difficulty :&lt;/strong&gt; 8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Language :&lt;/strong&gt; C++&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Platform :&lt;/strong&gt; Windows x86&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OS Version :&lt;/strong&gt; All&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Packer / Protector :&lt;/strong&gt; VMProtect 3.0.9&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unpack goal&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;From the attached binary (.exe), analyze the virtualized function(s), apply a devirtualization patch, and ensure that the patched program runs without errors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Condition:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When you press P, a virtualized function located in the VMP region runs and shows a message box.If the devirtualization has been done correctly (i.e., the original logic is preserved even after patching), running the patched program and pressing P must not produce a crash.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If we check the entropy view in DiE, we can see a typical pattern for Virtualization mode. The &lt;code&gt;.text&lt;/code&gt; section is obfuscated, and the presence of &lt;code&gt;.vmp0&lt;/code&gt; indicates that VMP&amp;#x2019;s core VM bytecode lives there. Entry stub and initialization stub are packed, and the runtime VM engine is expected to reside in &lt;code&gt;.vmp0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We will follow the flow &lt;code&gt;WinMain&lt;/code&gt; &amp;#x2192; &lt;code&gt;UnpackMe&lt;/code&gt; &amp;#x2192; &lt;code&gt;Run&lt;/code&gt; and carefully locate where the VMEntry actually is.&lt;/p&gt;
&lt;h3 id=&#34;Road-to-VMEntry&#34;&gt;&lt;a href=&#34;#Road-to-VMEntry&#34; class=&#34;headerlink&#34; title=&#34;Road to VMEntry&#34;&gt;&lt;/a&gt;Road to VMEntry&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __stdcall &lt;span class=&#34;hljs-title&#34;&gt;WinMain&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; nShowCmd)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
  &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall ***v4)(HINSTANCE); &lt;span class=&#34;hljs-comment&#34;&gt;// eax&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall ***v5)(HINSTANCE); &lt;span class=&#34;hljs-comment&#34;&gt;// ecx&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall **v6)(HINSTANCE); &lt;span class=&#34;hljs-comment&#34;&gt;// eax&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; result; &lt;span class=&#34;hljs-comment&#34;&gt;// eax&lt;/span&gt;

  SetUnhandledExceptionFilter(TopLevelExceptionFilter);
  v4 = (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall ***)(HINSTANCE))&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;u);
  v5 = v4;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v4 )
    *v4 = (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall **)(HINSTANCE))&amp;amp;UnpackMe::`vftable&lt;span class=&#34;hljs-number&#34;&gt;&amp;apos;&lt;/span&gt;;  &lt;span class=&#34;hljs-comment&#34;&gt;// vtable &amp;#xC124;&amp;#xC815;&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
    v5 = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  v6 = *v5;
  UnpackMe* &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; = v5;
  (*v6)(hInstance);   &lt;span class=&#34;hljs-comment&#34;&gt;// vtable[0] &amp;#xD638;&amp;#xCD9C;&lt;/span&gt;
  j__free(UnpackMe* &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;);
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A typical virtualization-based obfuscation VM can usually be broken down into the following components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;VM Entry&lt;/code&gt; / &lt;code&gt;VM Exit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  Entry: the region where native registers and stack state are copied into the VM state&lt;/p&gt;
&lt;p&gt;  Exit: after bytecode execution finishes, the VM state is written back to the original registers and stack&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;VM Dispatcher&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  Reads the opcode at the virtual PC (&lt;code&gt;VIP&lt;/code&gt;), decides which handler to jump to, and repeatedly runs a fetch &amp;#x2192; decode &amp;#x2192; dispatch &amp;#x2192; execute loop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Handler Table&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  A table mapping each opcode to its handler function&lt;/p&gt;
&lt;p&gt;  Each handler implements the semantics of one VM instruction such as &amp;#x201C;virtual ADD&amp;#x201D;, &amp;#x201C;virtual XOR&amp;#x201D;, or &amp;#x201C;virtual branch&amp;#x201D;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For a real-world challenge like DevirtualizeMe, the first step is to locate the VMEntry. Only after finding the VMEntry can we reason about the VM state layout; I will discuss the VM state in more detail later.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;WinMain()&lt;/code&gt; function itself is structurally simple. From a devirtualization perspective, note that VMP usually virtualizes only certain target functions and leaves the path leading up to those functions in normal C++ code. So here we just need to confirm that &lt;code&gt;vtable[0]&lt;/code&gt; is in fact &lt;code&gt;UnpackMe::Run&lt;/code&gt; and then move on.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image4.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Following the vtable, we find that the C++ class &lt;code&gt;UnpackMe&lt;/code&gt;&amp;#x2019;s vtable lives in the &lt;code&gt;.rdata&lt;/code&gt; section. When IDA successfully reconstructs RTTI, it attaches the symbol &lt;code&gt;??_7UnpackMe@@6B@&lt;/code&gt; and automatically names the first vtable entry as &lt;code&gt;UnpackMe::Run&lt;/code&gt;. Let&amp;#x2019;s now jump into &lt;code&gt;UnpackMe::Run&lt;/code&gt;, which opens the main loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __thiscall &lt;span class=&#34;hljs-title&#34;&gt;UnpackMe::Run&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;, HINSTANCE hInst)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    *((DWORD*)&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) = hInst;

    WNDCLASSEXW wc = {&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;};
    wc.cbSize       = &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(wc);
    wc.style        = &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;;
    wc.lpfnWndProc  = (WNDPROC)sub_40CC70;
    wc.hInstance    = hInst;
    wc.lpszClassName = &lt;span class=&#34;hljs-string&#34;&gt;L&amp;quot;WndClass_DevirtualizeMe&amp;quot;&lt;/span&gt;;
    RegisterClassExW(&amp;amp;wc);

    ((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__thiscall*)(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;*))(*(DWORD*)&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;))(&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt; ( GetMessageW(&amp;amp;Msg, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;) )
    {
        TranslateMessage(&amp;amp;Msg);
        DispatchMessageW(&amp;amp;Msg);   &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;#xC5EC;&amp;#xAE30;&amp;#xC11C; WndProc &amp;#xCCB4;&amp;#xC778;&amp;#xC73C;&amp;#xB85C; &amp;#xB4E4;&amp;#xC5B4;&amp;#xAC10;&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From a devirtualization point of view, &lt;code&gt;Run&lt;/code&gt; acts as a kind of gatekeeper into the VM. When the user presses the P key, the program flows through this loop and eventually reaches the VMProtect entry point.&lt;/p&gt;
&lt;p&gt;This function registers a window class, sets &lt;code&gt;lpfnWndProc = sub_40CC70&lt;/code&gt; as the global WndProc, and then repeatedly calls &lt;code&gt;DispatchMessageW&lt;/code&gt; inside the message loop. All key input (including P) goes through this message loop and eventually arrives at &lt;code&gt;WndProc&lt;/code&gt;, which then routes messages into &lt;code&gt;UnpackMe&lt;/code&gt;&amp;#x2019;s member functions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;LRESULT __stdcall &lt;span class=&#34;hljs-title&#34;&gt;WndProc&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( dword_415F08 )
        &lt;span class=&#34;hljs-comment&#34;&gt;// vtable[1] = UnpackMe::WndProc(sub_40CB60)&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; ((&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; (__thiscall*)(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;*, HWND, UINT, WPARAM, LPARAM))
                (*(DWORD*)UnpackMe* &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;))(
                    dword_415F08, hWnd, Msg, wParam, lParam);
    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; DefWindowProcW(hWnd, Msg, wParam, lParam);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important point here is that the OS has no idea that a C++ class named &lt;code&gt;UnpackMe&lt;/code&gt; even exists, nor how many instances there are. The OS only knows that for windows of class &lt;code&gt;WndClass_DevirtualizeMe&lt;/code&gt;, the WndProc is &lt;code&gt;sub_40CC70&lt;/code&gt;, and that function internally forwards messages into &lt;code&gt;UnpackMe::WndProc&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In other words, from a devirtualization perspective, all keyboard messages eventually end up in &lt;code&gt;UnpackMe::WndProc&lt;/code&gt;. Therefore we only need to see how this &lt;code&gt;WndProc()&lt;/code&gt; handles &lt;code&gt;WM_KEYDOWN&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __thiscall &lt;span class=&#34;hljs-title&#34;&gt;UnpackMe::WndProc&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                 HWND hWnd,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                 UINT Msg,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                 WPARAM wParam,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                 LPARAM lParam)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( Msg &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;0x14&lt;/span&gt; )
    {
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( Msg &amp;lt;= &lt;span class=&#34;hljs-number&#34;&gt;0x111&lt;/span&gt; )
        {
            &lt;span class=&#34;hljs-keyword&#34;&gt;switch&lt;/span&gt; ( Msg )
            {
            &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x100&lt;/span&gt;:  &lt;span class=&#34;hljs-comment&#34;&gt;// WM_KEYDOWN&lt;/span&gt;
                &lt;span class=&#34;hljs-comment&#34;&gt;// vtable[6] = OnKeyDown&lt;/span&gt;
                &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; ((&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; (__thiscall*)(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;*, HWND, WPARAM, LPARAM))
                        (*(DWORD*)&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;24&lt;/span&gt;))(
                            &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;, hWnd, wParam, lParam);

            &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x111&lt;/span&gt;:  &lt;span class=&#34;hljs-comment&#34;&gt;// WM_COMMAND&lt;/span&gt;
                ...
            }
        }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When &lt;code&gt;WM_KEYDOWN&lt;/code&gt; arrives, this function forwards control to &lt;code&gt;OnKeyDown&lt;/code&gt;, which is mapped to &lt;code&gt;vtable[6]&lt;/code&gt;. Up to this point we are still just in the message routing layer, and no VMProtect virtualized code has appeared yet. But we do not have to be disappointed&amp;#x2014;things are about to get more interesting.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __thiscall &lt;span class=&#34;hljs-title&#34;&gt;UnpackMe::OnKeyDown&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                   HWND hWnd,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                   WPARAM wParam,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                   LPARAM lParam)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( wParam == &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;P&amp;apos;&lt;/span&gt; )
        proc();
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;OnKeyDown&lt;/code&gt; is where the key input is actually checked. When &lt;code&gt;wParam&lt;/code&gt; equals the character &lt;code&gt;&amp;apos;P&amp;apos;&lt;/code&gt; (0x50), it calls &lt;code&gt;proc()&lt;/code&gt;. All other key presses are ignored.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image5.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If you run the program and press P, a message box appears with some address information. That entry point is effectively what we call &lt;code&gt;vir_Entry()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image6.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;From this point onward IDA shows &lt;code&gt;call analysis failed&lt;/code&gt; and cannot decompile the function. This means that inside this function, there are abnormal control flows, indirect branches, and sequences that scramble the stack/registers, making it hard to lift back to normal C code. In other words, from the perspective of building or using a devirtualizer, this &lt;code&gt;vir_Entry()&lt;/code&gt; becomes our starting point.&lt;/p&gt;
&lt;p&gt;By static analysis we traced the full path to the virtualized code as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;WinMain &amp;#x2192; UnpackMe::Run &amp;#x2192; DispatchMessage &amp;#x2192; UnpackMe::WndProc &amp;#x2192; OnKeyDown &amp;#x2192; proc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we confirmed that &lt;code&gt;proc()&lt;/code&gt; (and &lt;code&gt;vir_Entry&lt;/code&gt; inside it) is where VMEntry and the body of the VMProtect-virtualized function live.&lt;/p&gt;
&lt;p&gt;Now that we have the VMEntry address, let&amp;#x2019;s attach a debugger and follow the execution. Starting at &lt;code&gt;0x004869BB&lt;/code&gt;, you can see VMProtect&amp;#x2019;s characteristic VM engine code: repeated patterns of &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, and so on, together with instructions like &lt;code&gt;mov eax, [esi]&lt;/code&gt; / &lt;code&gt;add esi, 4&lt;/code&gt; that repeatedly load from the bytecode stream. This shows clearly that VMProtect is updating virtual registers and the bytecode pointer (&lt;code&gt;ESI&lt;/code&gt;) while stepping through handlers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image7.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Trying to analyze the entire VM engine as one big CFG is practically impossible for a human. VMProtect fills the code with thousands of junk instructions and aggressive control-flow flattening, making the actual VM dispatcher and handler paths extremely tangled.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image8.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;At first, I tried walking through the handlers and dispatcher in the debugger, chasing &lt;code&gt;jmp&lt;/code&gt; instructions to the end in the hope that something meaningful would appear. Instead, I repeatedly landed on trivial &amp;#x201C;trampoline&amp;#x201D; handlers that only redirected control elsewhere without doing any semantically interesting work. This pattern repeated over and over.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image9.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;I wanted to catch a &lt;code&gt;VMExit&lt;/code&gt;, but no matter how long I followed the flow, it was just handler &amp;#x2192; dispatcher &amp;#x2192; handler &amp;#x2192; &amp;#x2026; like an endless staircase to heaven. From the debugger&amp;#x2019;s point of view, it felt impossible to ever escape this loop. On top of that, the VM does not use physical registers like a normal CPU. It hides values in virtual registers such as &lt;code&gt;VIP&lt;/code&gt; and &lt;code&gt;VSP&lt;/code&gt; and in encrypted stack regions. Staring at &lt;code&gt;EAX&lt;/code&gt; all day yields nothing meaningful.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image10.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;&amp;#x2026; At this point I felt that my lifetime was too short to finish this using only live debugging. Time to look for another approach.&lt;/p&gt;
&lt;h3 id=&#34;Patch&#34;&gt;&lt;a href=&#34;#Patch&#34; class=&#34;headerlink&#34; title=&#34;Patch&#34;&gt;&lt;/a&gt;Patch&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D153 FF10           call dword ptr [eax]
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D155 FF35 &lt;span class=&#34;hljs-number&#34;&gt;085F&lt;/span&gt;4100  push dword ptr [&lt;span class=&#34;hljs-number&#34;&gt;415F&lt;/span&gt;08]
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D15B E8 &lt;span class=&#34;hljs-number&#34;&gt;623F&lt;/span&gt;FFFF    call &lt;span class=&#34;hljs-number&#34;&gt;4010&lt;/span&gt;C2
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D160 &lt;span class=&#34;hljs-number&#34;&gt;83&lt;/span&gt;C4 &lt;span class=&#34;hljs-number&#34;&gt;04&lt;/span&gt;        add esp, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D163 &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;D             pop ebp
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D164 C2 &lt;span class=&#34;hljs-number&#34;&gt;1000&lt;/span&gt;        ret &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image11.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;To trace the program more effectively, I first applied a small patch to the original binary. For reasons I am not certain about (whether intentional or accidental), when run under Intel Pin, this challenge binary stayed in the background and did not respond to my key presses. So I modified the binary so that right after startup it immediately jumps into VM Entry, without waiting for me to press P.&lt;/p&gt;
&lt;h3 id=&#34;Collecting-Trace-with-Pin&#34;&gt;&lt;a href=&#34;#Collecting-Trace-with-Pin&#34; class=&#34;headerlink&#34; title=&#34;Collecting Trace with Pin&#34;&gt;&lt;/a&gt;Collecting Trace with Pin&lt;/h3&gt;&lt;p&gt;Intel Pin is a dynamic binary instrumentation tool that lets you inject analysis code into a running program. Regardless of what kind of obfuscation is applied, Pin can intercept and log every single instruction that actually executes. It will not miss even one instruction.&lt;/p&gt;
&lt;p&gt;To collect traces, I first identified several key addresses through static analysis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;gDispEntry (&lt;code&gt;0x004869BB&lt;/code&gt;):&lt;/strong&gt; VM Entry (dispatcher entry point)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image12.png&#34; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;gHandler82 (&lt;code&gt;0x004181BB&lt;/code&gt;):&lt;/strong&gt; entry point of a specific handler (ID 82) found through analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;24566&lt;/span&gt; vmtrace.out
i:&lt;span class=&#34;hljs-number&#34;&gt;0x004869bb&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;68&lt;/span&gt;EACF8694
r:&lt;span class=&#34;hljs-number&#34;&gt;0x004869c0&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00401dcd&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x97010000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x004011fc&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff28&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff20&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000202&lt;/span&gt;
i:&lt;span class=&#34;hljs-number&#34;&gt;0x004869c0&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;:E883A9FFFF
r:&lt;span class=&#34;hljs-number&#34;&gt;0x00481348&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00401dcd&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x97010000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x004011fc&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff28&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff1c&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000202&lt;/span&gt;
i:&lt;span class=&#34;hljs-number&#34;&gt;0x00481348&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;51&lt;/span&gt;
r:&lt;span class=&#34;hljs-number&#34;&gt;0x00481349&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00401dcd&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x97010000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x004011fc&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff28&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff18&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000202&lt;/span&gt;
i:&lt;span class=&#34;hljs-number&#34;&gt;0x00481349&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;:E9CA50FBFF
r:&lt;span class=&#34;hljs-number&#34;&gt;0x00436418&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00401dcd&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x97010000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x004011fc&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff28&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff18&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000202&lt;/span&gt;
i:&lt;span class=&#34;hljs-number&#34;&gt;0x00436418&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;55&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I first extracted from the trace a region corresponding to one full cycle of the VMProtect VM, and that alone already produced on the order of &lt;code&gt;n0,000&lt;/code&gt; lines of log. At this scale it becomes essential to split the trace at handler boundaries and automatically identify repeating patterns.&lt;/p&gt;
&lt;p&gt;Lines starting with &lt;code&gt;i:&lt;/code&gt; record the executed instructions,&lt;/p&gt;
&lt;p&gt;and lines starting with &lt;code&gt;r:&lt;/code&gt; record the register and stack state at that point.&lt;/p&gt;
&lt;p&gt;Jonathan Salwan&amp;#x2019;s &lt;a href=&#34;https://github.com/JonathanSalwan/VMProtect-devirtualization&#34;&gt;VMProtect-devirtualization&lt;/a&gt; project was extremely helpful here.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Identifying VM main loop and handler candidates with &lt;code&gt;uniq -c&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0047f287&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0044a8ae&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0044a8ac&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0044a8ab&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0044a8a7&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;107&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x004181bb&lt;/span&gt;
 &lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x00464679&lt;/span&gt;
 &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0049acd6&lt;/span&gt;
 &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0049acd4&lt;/span&gt;
 &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0049acd2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I computed the execution count per address from the trace, using a &lt;code&gt;uniq -c&lt;/code&gt; style analysis to list the most frequently executed locations. Static analysis then allowed me to categorize them as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Highest frequency, 108 times: VM dispatcher&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;VM Dispatcher&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  Addresses like &lt;code&gt;0x0047f287&lt;/code&gt; and &lt;code&gt;0x0044a8a7&lt;/code&gt; appeared exactly 108 times each. These are pieces of dispatcher code. The dispatcher implements the CPU-like cycle in software (fetch &amp;#x2192; decode &amp;#x2192; dispatch &amp;#x2192; execute). Since the dispatcher itself does not perform interesting semantics, we can skip over it for now.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Second highest frequency, 107 times: handler ID 82&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Most frequently used handler (&lt;code&gt;LCONST&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  Address &lt;code&gt;0x004181BB&lt;/code&gt; is a strong candidate for a constant-load handler once we consider VMProtect&amp;#x2019;s stack-based VM design. In a stack machine, most operations happen on the stack, so load/copy/move-style operations tend to be used heavily. Prioritizing the most frequently executed handler for analysis is usually efficient.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Running-the-Pin-Trace-Again&#34;&gt;&lt;a href=&#34;#Running-the-Pin-Trace-Again&#34; class=&#34;headerlink&#34; title=&#34;Running the Pin Trace Again&#34;&gt;&lt;/a&gt;Running the Pin Trace Again&lt;/h3&gt;&lt;p&gt;I then extended the original Pin tool (based on the template provided with Intel Pin) into a specialized Pintool that captures only the ID 82 handler. The goal is to reverse engineer what the VMProtect VM actually does for this single opcode.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image13.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;To capture the behavior of a single VM instruction dynamically, I built Pin support to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Anchor each VM instruction using two fixed IP locations&lt;/li&gt;
&lt;li&gt;Capture the 4 bytes pointed to by &lt;code&gt;ESI&lt;/code&gt; at the moment the bytecode is loaded&lt;/li&gt;
&lt;li&gt;Record &lt;code&gt;EAX&lt;/code&gt;/&lt;code&gt;EDI&lt;/code&gt; at the point where the handler finishes its computation and pushes the result onto the stack (using Pin&amp;#x2019;s CONTEXT)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image14.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Using the built &lt;code&gt;MyPinTool&lt;/code&gt;, I collected three types of information:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;code&gt;vmtrace.out&lt;/code&gt;: the complete x86 instruction trace from dispatcher entry to VM exit&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#main exe: [0x00400000, 0x00581fff)&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;004869b&lt;/span&gt;b &lt;span class=&#34;hljs-number&#34;&gt;68&lt;/span&gt; EA CF &lt;span class=&#34;hljs-number&#34;&gt;86&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;94&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;004869&lt;/span&gt;c0 E8 &lt;span class=&#34;hljs-number&#34;&gt;83&lt;/span&gt; A9 FF FF
&lt;span class=&#34;hljs-number&#34;&gt;00481348&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;51&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;00481349&lt;/span&gt; E9 CA &lt;span class=&#34;hljs-number&#34;&gt;50&lt;/span&gt; FB FF
&lt;span class=&#34;hljs-number&#34;&gt;00436418&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;55&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;00436419&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;50&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0043641&lt;/span&gt;a &lt;span class=&#34;hljs-number&#34;&gt;66&lt;/span&gt; F7 D5
&lt;span class=&#34;hljs-number&#34;&gt;0043641&lt;/span&gt;d E9 &lt;span class=&#34;hljs-number&#34;&gt;15&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;92&lt;/span&gt; FE FF
&lt;span class=&#34;hljs-number&#34;&gt;0041f&lt;/span&gt;637 &lt;span class=&#34;hljs-number&#34;&gt;57&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0041f&lt;/span&gt;638 &lt;span class=&#34;hljs-number&#34;&gt;0F&lt;/span&gt; BF FF
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file contains every x86 instruction executed from &lt;code&gt;0x004869BB&lt;/code&gt; (VM dispatcher entry) until the VM finishes. Each line records the instruction address and machine bytes. The script that walks the trace also dumps a plain text file side by side.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. &lt;code&gt;bytecode_values.txt&lt;/code&gt;: the &lt;code&gt;[ESI]&lt;/code&gt; value when entering handler ID 82 (i.e., the VM instruction operand)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x0047fa5f&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x1ecbf564&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x000271c9&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x004892af&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x0045cb33&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x1ec6b25f&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0xfffcff9f&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x00432085&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x0046ef95&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x1ec5393d&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0xfffdab5b&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x0043cc41&lt;/span&gt;
# Total ID82 calls: &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we open the extracted &lt;code&gt;bytecode_values.txt&lt;/code&gt;, we can see which constants/operands were fed into handler ID 82. By comparing the operand patterns across multiple calls, we can infer whether this handler is pushing constants onto the stack, applying certain transforms to the operand, or using it as an index, and so on. Later, we will feed these concrete values into Triton when performing symbolic execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. &lt;code&gt;id82_registers.txt&lt;/code&gt;: register snapshots at handler entry&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;=== VM Entry (&lt;span class=&#34;hljs-number&#34;&gt;0x004869bb&lt;/span&gt;) ===
INIT_ESI=&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;
INIT_EBP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff74&lt;/span&gt;
INIT_ESP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff04&lt;/span&gt;
===========================

ID82_001: IP=&lt;span class=&#34;hljs-number&#34;&gt;0x004323ff&lt;/span&gt; EAX=&lt;span class=&#34;hljs-number&#34;&gt;0x000271c9&lt;/span&gt; EBX=&lt;span class=&#34;hljs-number&#34;&gt;0x00458b96&lt;/span&gt; ECX=&lt;span class=&#34;hljs-number&#34;&gt;0x00000020&lt;/span&gt; EDX=&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt; ESI=&lt;span class=&#34;hljs-number&#34;&gt;0x0047fa63&lt;/span&gt; EDI=&lt;span class=&#34;hljs-number&#34;&gt;0x004892af&lt;/span&gt; EBP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fed8&lt;/span&gt; ESP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fe18&lt;/span&gt; BYTECODE=&lt;span class=&#34;hljs-number&#34;&gt;0x1ecbf564&lt;/span&gt;
ID82_002: IP=&lt;span class=&#34;hljs-number&#34;&gt;0x004323ff&lt;/span&gt; EAX=&lt;span class=&#34;hljs-number&#34;&gt;0xfffcff9f&lt;/span&gt; EBX=&lt;span class=&#34;hljs-number&#34;&gt;0xffb934ac&lt;/span&gt; ECX=&lt;span class=&#34;hljs-number&#34;&gt;0x00000020&lt;/span&gt; EDX=&lt;span class=&#34;hljs-number&#34;&gt;0x0000422a&lt;/span&gt; ESI=&lt;span class=&#34;hljs-number&#34;&gt;0x0045cb37&lt;/span&gt; EDI=&lt;span class=&#34;hljs-number&#34;&gt;0x00432085&lt;/span&gt; EBP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fcd0&lt;/span&gt; ESP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fc10&lt;/span&gt; BYTECODE=&lt;span class=&#34;hljs-number&#34;&gt;0x1ec6b25f&lt;/span&gt;
ID82_003: IP=&lt;span class=&#34;hljs-number&#34;&gt;0x004323ff&lt;/span&gt; EAX=&lt;span class=&#34;hljs-number&#34;&gt;0xfffdab5b&lt;/span&gt; EBX=&lt;span class=&#34;hljs-number&#34;&gt;0xffbb44ce&lt;/span&gt; ECX=&lt;span class=&#34;hljs-number&#34;&gt;0xdcedb11a&lt;/span&gt; EDX=&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt; ESI=&lt;span class=&#34;hljs-number&#34;&gt;0x0046ef99&lt;/span&gt; EDI=&lt;span class=&#34;hljs-number&#34;&gt;0x0043cc41&lt;/span&gt; EBP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fcc0&lt;/span&gt; ESP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fc00&lt;/span&gt; BYTECODE=&lt;span class=&#34;hljs-number&#34;&gt;0x1ec5393d&lt;/span&gt;

# Total ID82 calls: &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file logs the VM entry state and, for each ID 82 call, the exact register values right before executing the handler, along with the bytecode operand (&lt;code&gt;BYTECODE&lt;/code&gt;). In other words, for handler ID 82 we now have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The handler&amp;#x2019;s code&lt;/li&gt;
&lt;li&gt;Its input (bytecode and register state)&lt;/li&gt;
&lt;li&gt;The initial VM state at entry&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This matches our goal of fully reconstructing the semantics of a single VM opcode.&lt;/p&gt;
&lt;h3 id=&#34;Splitting-the-VM-only-trace-by-ID-82-execution-segments&#34;&gt;&lt;a href=&#34;#Splitting-the-VM-only-trace-by-ID-82-execution-segments&#34; class=&#34;headerlink&#34; title=&#34;Splitting the VM-only trace by ID 82 execution segments&#34;&gt;&lt;/a&gt;Splitting the VM-only trace by ID 82 execution segments&lt;/h3&gt;&lt;p&gt;With these logs in hand, we can now start restoring the meaning of individual VM handlers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;total ins: &lt;span class=&#34;hljs-number&#34;&gt;58414&lt;/span&gt;
ID82 entries: &lt;span class=&#34;hljs-number&#34;&gt;107&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;ID82 &lt;span class=&#34;hljs-title&#34;&gt;segments&lt;/span&gt; &lt;span class=&#34;hljs-params&#34;&gt;(with glue)&lt;/span&gt;: 106&lt;/span&gt;
written id82_segments.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To do that, I wrote a script that takes &lt;code&gt;vmtrace.out&lt;/code&gt;, locates each occurrence of ID 82, and slices the trace into segments corresponding to &amp;#x201C;one execution of ID 82, including its glue code.&amp;#x201D; Each such segment is then written into a JSON file. Earlier we counted 107 entries for ID 82; the script extracted 106 segments into the JSON.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;{
  &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;idx&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,
  &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;start_ip&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;4293051&lt;/span&gt;,
  &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;end_ip&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;4715143&lt;/span&gt;,
  &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;ins&amp;quot;&lt;/span&gt;: [
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004181bb FF E7&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00468429 8B C5&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046842b 66 85 F2&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046842e 81 ED 04 00 00 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00468434 66 3B FE&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00468437 89 44 25 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046843b 9F&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046843c 13 C6&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046843e E9 C1 EC FE FF&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00457104 8B 06&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00457106 3B E6&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00457108 81 C6 04 00 00 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0045710e 33 C3&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00457110 E9 BB 7D FE FF&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed0 D1 C8&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed2 35 B9 3D CB 4A&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed7 F5&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed8 F9&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed9 66 85 C4&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eedc 2D 40 01 8C 45&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eee1 E9 FC 23 FF FF&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004312e2 D1 C0&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004312e4 33 D8&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004312e6 03 F8&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004312e8 E9 B3 DE 02 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0045f1a0 E9 02 B7 FE FF&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0044a8a7 8D 44 24 60&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0044a8ab F5&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0044a8ac 3B E8&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0044a8ae E9 D4 49 03 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0047f287 0F 87 2E 8F F9 FF&amp;quot;&lt;/span&gt;
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each segment contains the flow from entry into ID 82 &amp;#x2192; various glue/shared code &amp;#x2192; return to the dispatcher. However, there is still a lot of VMProtect-inserted noise mixed in, so this alone does not yet isolate the pure handler body. We need to keep going.&lt;/p&gt;
&lt;h3 id=&#34;Clustering-ID-82-patterns&#34;&gt;&lt;a href=&#34;#Clustering-ID-82-patterns&#34; class=&#34;headerlink&#34; title=&#34;Clustering ID 82 patterns&#34;&gt;&lt;/a&gt;Clustering ID 82 patterns&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;total segments: &lt;span class=&#34;hljs-number&#34;&gt;106&lt;/span&gt;
unique patterns: &lt;span class=&#34;hljs-number&#34;&gt;70&lt;/span&gt;
==== pattern &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; size &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;
indices: [&lt;span class=&#34;hljs-number&#34;&gt;20&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;40&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;60&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;78&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;94&lt;/span&gt;]
==== pattern &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; size &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;
indices: [&lt;span class=&#34;hljs-number&#34;&gt;21&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;62&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;82&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;99&lt;/span&gt;]
==== pattern &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt; size &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
indices: [&lt;span class=&#34;hljs-number&#34;&gt;19&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;39&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;59&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;93&lt;/span&gt;]
==== pattern &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt; size &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
indices: [&lt;span class=&#34;hljs-number&#34;&gt;22&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;65&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;84&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;103&lt;/span&gt;]
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, I loaded the JSON, compared each segment&amp;#x2019;s byte sequence, and grouped those with identical sequences into clusters. When we do this per handler, segments with exactly the same instruction pattern end up in the same cluster. For example, in pattern 1, segments 20, 40, 60, 78, and 94 all share the same sequence of bytes and thus form one cluster.&lt;/p&gt;
&lt;p&gt;The purpose of this clustering is to pick one representative pattern per handler. For ID 82, we can choose, say, index 20 from pattern 1 as the canonical example and use it as a reference to understand the handler&amp;#x2019;s semantics.&lt;/p&gt;
&lt;h3 id=&#34;Simulating-Handler-ID-82-with-Triton&#34;&gt;&lt;a href=&#34;#Simulating-Handler-ID-82-with-Triton&#34; class=&#34;headerlink&#34; title=&#34;Simulating Handler ID 82 with Triton&#34;&gt;&lt;/a&gt;Simulating Handler ID 82 with Triton&lt;/h3&gt;&lt;p&gt;Using the clustering result, I dumped the bytes for the segment at index 20 (pattern 1) as a contiguous block of x86 code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;written id82_handler.&lt;span class=&#34;hljs-keyword&#34;&gt;asm&lt;/span&gt; from idx &lt;span class=&#34;hljs-number&#34;&gt;20&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;004181b&lt;/span&gt;b FF E7
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a7a &lt;span class=&#34;hljs-number&#34;&gt;0F&lt;/span&gt; B6 &lt;span class=&#34;hljs-number&#34;&gt;06&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a7d &lt;span class=&#34;hljs-number&#34;&gt;81&lt;/span&gt; C6 &lt;span class=&#34;hljs-number&#34;&gt;01&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;00&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;00&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;00&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a83 &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt; C3
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a85 &lt;span class=&#34;hljs-number&#34;&gt;66&lt;/span&gt; F7 C2 DE &lt;span class=&#34;hljs-number&#34;&gt;7B&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a8a F9
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a8b &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;C &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;A
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a8d D0 C8
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a8f F6 D8
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a91 E9 &lt;span class=&#34;hljs-number&#34;&gt;48&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;9B&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;02&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;00&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comparing this with the corresponding IDA disassembly, we can see the structure more clearly:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image15.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x004181BB: FF E7 &amp;#x2192; 0x004181BB jmp edi&lt;/code&gt; is the &amp;#x201C;glue&amp;#x201D; entry point where the dispatcher has already loaded the handler&amp;#x2019;s address into &lt;code&gt;EDI&lt;/code&gt; and now jumps there.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image16.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;From &lt;code&gt;0x0044FA7A&lt;/code&gt; onward is the essential body of ID 82&amp;#x2019;s front half.&lt;/p&gt;
&lt;p&gt;This code performs &lt;code&gt;movzx eax, byte ptr [esi]&lt;/code&gt; / &lt;code&gt;add esi, 1&lt;/code&gt; to consume the first byte of bytecode (the opcode), then scrambles &lt;code&gt;AL&lt;/code&gt; using &lt;code&gt;XOR&lt;/code&gt;, &lt;code&gt;SUB&lt;/code&gt;, &lt;code&gt;ROR&lt;/code&gt;, &lt;code&gt;NEG&lt;/code&gt;, etc., and finally jumps onward. Later, it executes &lt;code&gt;mov eax, [esi]&lt;/code&gt; / &lt;code&gt;lea esi, [esi+4]&lt;/code&gt; to read 4 bytes, presumably the operand. That 4-byte value is decrypted via a series of operations and used to update &lt;code&gt;EBX&lt;/code&gt;. Control then returns to the dispatcher loop at &lt;code&gt;0x4323ff&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, by combining Pin&amp;#x2019;s trace with IDA disassembly, we have reconstructed the complete native code for handler ID 82 as seen in &lt;code&gt;vmtrace.out&lt;/code&gt;. We are almost there.&lt;/p&gt;
&lt;p&gt;But this is still not yet the end. To fully understand the mathematical transformation encoded by this handler, we need to load this code into Triton, feed it the initial register state and bytecode values we collected earlier, and perform symbolic execution.&lt;/p&gt;
&lt;h3 id=&#34;Tracking-state-changes&#34;&gt;&lt;a href=&#34;#Tracking-state-changes&#34; class=&#34;headerlink&#34; title=&#34;Tracking state changes&#34;&gt;&lt;/a&gt;Tracking state changes&lt;/h3&gt;&lt;p&gt;Using Triton to execute the ID 82 path and compare the registers before and after, we obtain a trace like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;0x4442f2&lt;/span&gt;: shr dh, cl
&lt;span class=&#34;hljs-number&#34;&gt;0x43641a&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;not&lt;/span&gt; bp

--- [ Logic Start (0x41F637) ] ---
&lt;span class=&#34;hljs-number&#34;&gt;0x41f638&lt;/span&gt;: movsx edi, di
&lt;span class=&#34;hljs-number&#34;&gt;0x41f63c&lt;/span&gt;: lahf
&lt;span class=&#34;hljs-number&#34;&gt;0x41f63d&lt;/span&gt;: bts ebp, esi
&lt;span class=&#34;hljs-number&#34;&gt;0x41f641&lt;/span&gt;: cmp bh, &lt;span class=&#34;hljs-number&#34;&gt;0xb4&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f645&lt;/span&gt;: shr bp, &lt;span class=&#34;hljs-number&#34;&gt;0xa6&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f649&lt;/span&gt;: sub ebx, edx
&lt;span class=&#34;hljs-number&#34;&gt;0x41f64b&lt;/span&gt;: test esi, ebp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f64e&lt;/span&gt;: xchg ah, bh
&lt;span class=&#34;hljs-number&#34;&gt;0x41f650&lt;/span&gt;: sub ax, bx
&lt;span class=&#34;hljs-number&#34;&gt;0x41f653&lt;/span&gt;: movsx ebx, bp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f656&lt;/span&gt;: mov eax, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f65b&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;not&lt;/span&gt; si
&lt;span class=&#34;hljs-number&#34;&gt;0x41f65e&lt;/span&gt;: xadd ebp, esi
&lt;span class=&#34;hljs-number&#34;&gt;0x41f662&lt;/span&gt;: mov esi, dword ptr [esp + &lt;span class=&#34;hljs-number&#34;&gt;0x28&lt;/span&gt;]
&lt;span class=&#34;hljs-number&#34;&gt;0x41f666&lt;/span&gt;: add esi, &lt;span class=&#34;hljs-number&#34;&gt;0x55106798&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f66c&lt;/span&gt;: neg esi
&lt;span class=&#34;hljs-number&#34;&gt;0x41f66e&lt;/span&gt;: rol edi, &lt;span class=&#34;hljs-number&#34;&gt;0x70&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f671&lt;/span&gt;: add esi, &lt;span class=&#34;hljs-number&#34;&gt;0x69733a52&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f677&lt;/span&gt;: btr ebp, &lt;span class=&#34;hljs-number&#34;&gt;0xc0&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f67b&lt;/span&gt;: rol esi, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f67d&lt;/span&gt;: sbb ebx, &lt;span class=&#34;hljs-number&#34;&gt;0x37516d2d&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f683&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;not&lt;/span&gt; esi
&lt;span class=&#34;hljs-number&#34;&gt;0x41f685&lt;/span&gt;: clc
&lt;span class=&#34;hljs-number&#34;&gt;0x41f686&lt;/span&gt;: cmp eax, esp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f688&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; ebp, esp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f68a&lt;/span&gt;: add esi, eax
&lt;span class=&#34;hljs-number&#34;&gt;0x41f68c&lt;/span&gt;: setns al
&lt;span class=&#34;hljs-number&#34;&gt;0x41f68f&lt;/span&gt;: mov ebp, esp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f691&lt;/span&gt;: sub bx, sp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f694&lt;/span&gt;: rol ax, cl
&lt;span class=&#34;hljs-number&#34;&gt;0x41f697&lt;/span&gt;: dec di
&lt;span class=&#34;hljs-number&#34;&gt;0x41f69a&lt;/span&gt;: sub esp, &lt;span class=&#34;hljs-number&#34;&gt;0xc0&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f6a0&lt;/span&gt;: jmp &lt;span class=&#34;hljs-number&#34;&gt;0x453e79&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x453e79&lt;/span&gt;: mov ebx, esi
&lt;span class=&#34;hljs-number&#34;&gt;0x453e7b&lt;/span&gt;: bt eax, esp
&lt;span class=&#34;hljs-number&#34;&gt;0x453e7e&lt;/span&gt;: btc ax, &lt;span class=&#34;hljs-number&#34;&gt;0x47&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x453e83&lt;/span&gt;: btr eax, edx
&lt;span class=&#34;hljs-number&#34;&gt;0x453e86&lt;/span&gt;: mov eax, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x453e8b&lt;/span&gt;: jmp &lt;span class=&#34;hljs-number&#34;&gt;0x4620dd&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x4620dd&lt;/span&gt;: sub ebx, eax
&lt;span class=&#34;hljs-number&#34;&gt;0x4620df&lt;/span&gt;: shld eax, eax, &lt;span class=&#34;hljs-number&#34;&gt;0xe3&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x4620e3&lt;/span&gt;: sub eax, edi
&lt;span class=&#34;hljs-number&#34;&gt;0x4620e5&lt;/span&gt;: stc
&lt;span class=&#34;hljs-number&#34;&gt;0x4620e6&lt;/span&gt;: lea edi, [&lt;span class=&#34;hljs-number&#34;&gt;0x4620e6&lt;/span&gt;]
&lt;span class=&#34;hljs-number&#34;&gt;0x4620ec&lt;/span&gt;: mov eax, dword ptr [esi]
&lt;span class=&#34;hljs-number&#34;&gt;0x4620ee&lt;/span&gt;: cmc
&lt;span class=&#34;hljs-number&#34;&gt;0x4620ef&lt;/span&gt;: test cl, &lt;span class=&#34;hljs-number&#34;&gt;0x19&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x4620f2&lt;/span&gt;: lea esi, [esi + &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;]
&lt;span class=&#34;hljs-number&#34;&gt;0x4620f8&lt;/span&gt;: cmc
&lt;span class=&#34;hljs-number&#34;&gt;0x4620f9&lt;/span&gt;: test ebx, &lt;span class=&#34;hljs-number&#34;&gt;0x76f532e4&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x4620ff&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; eax, ebx
&lt;span class=&#34;hljs-number&#34;&gt;0x462101&lt;/span&gt;: ror eax, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x462103&lt;/span&gt;: stc
&lt;span class=&#34;hljs-number&#34;&gt;0x462104&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; eax, &lt;span class=&#34;hljs-number&#34;&gt;0x4acb3db9&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x462109&lt;/span&gt;: sub eax, &lt;span class=&#34;hljs-number&#34;&gt;0x458c0140&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x46210e&lt;/span&gt;: rol eax, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x462110&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; ebx, eax
&lt;span class=&#34;hljs-number&#34;&gt;0x462112&lt;/span&gt;: cmc
&lt;span class=&#34;hljs-number&#34;&gt;0x462113&lt;/span&gt;: cmp bx, sp
&lt;span class=&#34;hljs-number&#34;&gt;0x462116&lt;/span&gt;: clc
&lt;span class=&#34;hljs-number&#34;&gt;0x462117&lt;/span&gt;: add edi, eax
&lt;span class=&#34;hljs-number&#34;&gt;0x462119&lt;/span&gt;: jmp &lt;span class=&#34;hljs-number&#34;&gt;0x4323ff&lt;/span&gt;
--- [ Logic End (0x432400) ] ---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the &lt;code&gt;asm&lt;/code&gt; trace produced by a Triton-based analysis script. It reconstructs the execution path of handler ID 82 using both &lt;code&gt;vmtrace.out&lt;/code&gt; and the bytes from the actual binary.&lt;/p&gt;
&lt;p&gt;Comparing registers before and after execution for each test case yields:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;=== &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; bc = &lt;span class=&#34;hljs-number&#34;&gt;0x1ecbf564&lt;/span&gt;
init EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x271c9&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0x458b96&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x47fa63&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0x4892af&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x19fe78&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0xafe65f2&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ECX = &lt;span class=&#34;hljs-number&#34;&gt;0x20&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDX = &lt;span class=&#34;hljs-number&#34;&gt;0x0&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x47fa68&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0xb0480ee&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fed4&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fe18&lt;/span&gt;
diff EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x1b8fb1&lt;/span&gt; EBX diff = &lt;span class=&#34;hljs-number&#34;&gt;0xabbee64&lt;/span&gt;

=== &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; bc = &lt;span class=&#34;hljs-number&#34;&gt;0x1ec6b25f&lt;/span&gt;
init EAX = &lt;span class=&#34;hljs-number&#34;&gt;0xfffcff9f&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0xffb934ac&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x45cb37&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0x432085&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x19fc70&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0x20ae78f3&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ECX = &lt;span class=&#34;hljs-number&#34;&gt;0x20&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDX = &lt;span class=&#34;hljs-number&#34;&gt;0x422a&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x45cb3c&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0xdf5a6d09&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fccc&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fc10&lt;/span&gt;
diff EAX = &lt;span class=&#34;hljs-number&#34;&gt;0xffe503ef&lt;/span&gt; EBX diff = &lt;span class=&#34;hljs-number&#34;&gt;0xdf174c5f&lt;/span&gt;

=== &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt; bc = &lt;span class=&#34;hljs-number&#34;&gt;0x1ec5393d&lt;/span&gt;
init EAX = &lt;span class=&#34;hljs-number&#34;&gt;0xfffdab5b&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0xffbb44ce&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x46ef99&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0x43cc41&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x19fc60&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0x20ae78f3&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ECX = &lt;span class=&#34;hljs-number&#34;&gt;0xdcedb11a&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDX = &lt;span class=&#34;hljs-number&#34;&gt;0x0&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x46ef9e&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0xdf590927&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fcbc&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fc00&lt;/span&gt;
diff EAX = &lt;span class=&#34;hljs-number&#34;&gt;0xffe4573b&lt;/span&gt; EBX diff = &lt;span class=&#34;hljs-number&#34;&gt;0xdf153c3d&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can extract the following key observations:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. In every case, &lt;code&gt;ESI&lt;/code&gt; increases by exactly 5.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Case 1: `0x47fa63` &amp;#x2192; `0x47fa68` (+5)
- Case 2: `0x45cb37` &amp;#x2192; `0x45cb3c` (+5)
- Case 3: `0x46ef99` &amp;#x2192; `0x46ef9e` (+5)

So handler ID 82 consumes 5 bytes from the bytecode stream. This matches the earlier code: `movzx eax, byte ptr [esi]` / `add esi, 1` consumes the 1-byte opcode, and later `mov eax, [esi]` / `lea esi, [esi + 4]` consumes 4 more bytes. Together, that is `1 + 4 = 5` bytes.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2. &lt;code&gt;EBX&lt;/code&gt; is updated to a completely new value.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The final `EBX` has no obvious direct relation to its initial value and is clearly the result of some transform. The `bc` (bytecode) values like `0x1ecbf564` go through the decryption routine (involving operations like `NOR`, `ADD`, `ROL`, etc.) to produce the final `EBX` values such as `0x0afe65f2`. Notice that in cases 2 and 3 the final `EBX` is the same: `0x20ae78f3`. Two different encrypted bytecode values (`0x1ec6b25f`, `0x1ec5393d`) converge to the same result, strongly suggesting a decryption function.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Putting this together:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handler ID 82 reads from the bytecode stream:&lt;ul&gt;
&lt;li&gt;1 byte for the opcode&lt;/li&gt;
&lt;li&gt;4 bytes for an encrypted immediate value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It then runs a complex transform (XOR, SUB, ROL, etc.) on that 4-byte value and writes the result into &lt;code&gt;EBX&lt;/code&gt;, effectively placing a constant on the virtual stack.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This behavior matches what we would expect from an &lt;code&gt;LCONST&lt;/code&gt; / &lt;code&gt;PUSH constant&lt;/code&gt;-style handler.&lt;/p&gt;
&lt;h3 id=&#34;So-what-is-the-actual-arithmetic&#34;&gt;&lt;a href=&#34;#So-what-is-the-actual-arithmetic&#34; class=&#34;headerlink&#34; title=&#34;So what is the actual arithmetic?&#34;&gt;&lt;/a&gt;So what is the actual arithmetic?&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;TARGET_HANDLERS = [
    &lt;span class=&#34;hljs-number&#34;&gt;0x44A8A7&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x47F287&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x4181BB&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x40356C&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x404F43&lt;/span&gt;,
    &lt;span class=&#34;hljs-number&#34;&gt;0x405B60&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x405CB6&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x405CE2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x404F5E&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x404419&lt;/span&gt;,
    &lt;span class=&#34;hljs-number&#34;&gt;0x404E83&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x4046BF&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x4046DC&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x4892AF&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x41A261&lt;/span&gt;,
    &lt;span class=&#34;hljs-number&#34;&gt;0x45F79C&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x496B0F&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x474C45&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x437E65&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x493FB7&lt;/span&gt;,
    &lt;span class=&#34;hljs-number&#34;&gt;0x43CB8A&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x46688C&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x45B9AD&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x432085&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x484226&lt;/span&gt;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The analysis above shows that we cannot reconstruct the full program logic from ID 82 alone. So I extended the same pipeline used for ID 82 to other handlers. Because there are many handlers, I first used static analysis plus trace-based hotspot analysis to pick only those handlers that are frequently called or appear semantically important.&lt;/p&gt;
&lt;h3 id=&#34;All-the-handlers-reveal-themselves&#34;&gt;&lt;a href=&#34;#All-the-handlers-reveal-themselves&#34; class=&#34;headerlink&#34; title=&#34;All the handlers reveal themselves&#34;&gt;&lt;/a&gt;All the handlers reveal themselves&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&amp;gt;&amp;gt;&amp;gt; Handler &lt;span class=&#34;hljs-number&#34;&gt;0x432085&lt;/span&gt; (Length: &lt;span class=&#34;hljs-number&#34;&gt;39&lt;/span&gt;)
----------------------------------------
  [M] &lt;span class=&#34;hljs-number&#34;&gt;0x432085&lt;/span&gt;: movzx eax, byte ptr [esi]
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x432088&lt;/span&gt;: rol cx, &lt;span class=&#34;hljs-number&#34;&gt;0xc&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x43208c&lt;/span&gt;: add esi, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x432096&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; al, bl
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x43209a&lt;/span&gt;: ror cx, &lt;span class=&#34;hljs-number&#34;&gt;0xf6&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x43209e&lt;/span&gt;: sub al, &lt;span class=&#34;hljs-number&#34;&gt;0x3a&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320a0&lt;/span&gt;: ror al, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320a2&lt;/span&gt;: neg al
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320aa&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;not&lt;/span&gt; al
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320b1&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;and&lt;/span&gt; cx, si
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320b4&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; bl, al
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320b6&lt;/span&gt;: mov ecx, dword ptr [ebp]
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320bf&lt;/span&gt;: add ebp, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320c5&lt;/span&gt;: mov dword ptr [esp + eax], ecx
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320c8&lt;/span&gt;: ror eax, &lt;span class=&#34;hljs-number&#34;&gt;0xd2&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320cb&lt;/span&gt;: mov eax, dword ptr [esi]
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320cd&lt;/span&gt;: add esi, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320de&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; eax, ebx
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320e1&lt;/span&gt;: ror eax, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320e3&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; eax, &lt;span class=&#34;hljs-number&#34;&gt;0x4acb3db9&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320ee&lt;/span&gt;: sub eax, &lt;span class=&#34;hljs-number&#34;&gt;0x458c0140&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320f3&lt;/span&gt;: rol eax, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320f5&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; ebx, eax
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320fd&lt;/span&gt;: add edi, eax
----------------------------------------
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each of the addresses is the entry point of a VM handler. For each such entry, I repeated the same process used for ID 82:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Segment splitting&lt;/li&gt;
&lt;li&gt;Pattern clustering&lt;/li&gt;
&lt;li&gt;Triton-based semantic extraction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The sample above shows the extracted semantics for handler &lt;code&gt;0x00432085&lt;/code&gt;. From this we can deduce:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It advances &lt;code&gt;ESI&lt;/code&gt; and consumes bytes from the bytecode stream&lt;/li&gt;
&lt;li&gt;It updates &lt;code&gt;EBX&lt;/code&gt;, &lt;code&gt;EDI&lt;/code&gt;, and stack locations like &lt;code&gt;[esp + eax]&lt;/code&gt; following a consistent pattern&lt;/li&gt;
&lt;li&gt;It reads and writes virtual registers located on the stack, combining constants and memory values to construct new values&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By iterating this process, we can summarize each handler as a higher-level VM instruction: load, store, add, logical operations, branches, and so on. That is, we start to see each handler as one instruction in the VM&amp;#x2019;s instruction set.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image17.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Once this is in place, the next step is to map each opcode value to its handler address. For this, I instrumented the VM dispatcher in Pin at the FETCH site and logged the opcode values being read.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image18.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Parsing that opcode log together with &lt;code&gt;vmtrace.out&lt;/code&gt; allowed me to reverse-map each opcode to a handler entry address. For example, the opcode corresponding to ID 82 turned out to be &lt;code&gt;0x02&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;Building-the-Devirtualizer&#34;&gt;&lt;a href=&#34;#Building-the-Devirtualizer&#34; class=&#34;headerlink&#34; title=&#34;Building the Devirtualizer&#34;&gt;&lt;/a&gt;Building the Devirtualizer&lt;/h3&gt;&lt;p&gt;At this stage we now have a one-to-one mapping between VM bytecodes and the actual handler addresses. The final step is to build a dedicated devirtualizer that reconstructs the entire virtualized function as native x86 and patches it back into the binary.&lt;/p&gt;
&lt;p&gt;The overall design is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Read a mapping file that contains opcode (e.g. &lt;code&gt;0x02&lt;/code&gt;, &lt;code&gt;0x40&lt;/code&gt;, &lt;code&gt;0x88&lt;/code&gt; &amp;#x2026;), the handler entry address, and a summary of its semantics. This becomes the opcode &amp;#x2192; [handler address, meaning, pseudocode] table.&lt;/li&gt;
&lt;li&gt;Parse the VM bytecode stream from start to finish.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For each opcode, emit a corresponding native x86 code snippet which we prepared in advance, for example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LCONST&lt;/code&gt; &amp;#x2192; &lt;code&gt;MOV EBX, imm32&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ADD&lt;/code&gt; &amp;#x2192; &lt;code&gt;ADD [ESP+4], EAX&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  and so on.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Concatenate all these snippets into a single region, forming a new native function body.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Finally, patch the original binary so that &lt;code&gt;vir_Entry&lt;/code&gt; jumps directly into this new native function, bypassing the VM engine.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image19.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Here is part of my devirtualizer code. The loop iterates over each VM instruction and computes the offset into the &lt;code&gt;.vmp0&lt;/code&gt; dump via &lt;code&gt;real_vip - VMP_BASE_ADDR&lt;/code&gt;. It then skips the 1-byte opcode, looks up the handler name from &lt;code&gt;VM_HANDLERS&lt;/code&gt;, and proceeds with reconstruction.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image20.png&#34; alt&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;val = (encrypted + &lt;span class=&#34;hljs-number&#34;&gt;0x55106798&lt;/span&gt;) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
val = (&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; - val) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
val = (val + &lt;span class=&#34;hljs-number&#34;&gt;0x69733a52&lt;/span&gt;) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
val = ((val &amp;lt;&amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) | (val &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;31&lt;/span&gt;)) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
decrypted = ~val &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the comments for each handler, I re-implemented the arithmetic sequence obtained by symbolically executing the handler with Triton, writing it out as 32-bit modular arithmetic in Python, as in the example above.&lt;/p&gt;
&lt;p&gt;For instance, suppose the handler takes a 32-bit encrypted constant as input, then applies exactly these steps as observed in the VM:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add a constant&lt;/li&gt;
&lt;li&gt;Compute &lt;code&gt;0 - val&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add another constant&lt;/li&gt;
&lt;li&gt;Rotate left by 1 bit&lt;/li&gt;
&lt;li&gt;Apply a bitwise &lt;code&gt;NOT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can encode that logic exactly as shown, yielding a &lt;code&gt;decrypted&lt;/code&gt; value that matches what the VM computes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image21.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;For key handlers like &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;NOR&lt;/code&gt;, &lt;code&gt;COPY&lt;/code&gt;, &lt;code&gt;SHL&lt;/code&gt;, &lt;code&gt;SHR&lt;/code&gt;, I distilled their stack-top operations plus flag reconstruction into clean native code fragments, and then used the Keystone assembler to convert them into machine code. Those bytes were pushed into a &lt;code&gt;patch_buffer&lt;/code&gt; in order, and the devirtualizer overwrote a pre-allocated region in a duplicated binary named &lt;code&gt;devirtualizeme_unpacked.exe&lt;/code&gt; with this buffer.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image22.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;At the end of this long journey, we finally get to see the restored native x86 code: the devirtualized function. This code is entirely generated from the data we collected and analyzed and represents the original logic in a straightforward x86 form. If you open this region in IDA on the patched binary, you will now see clean assembly in place of VMP&amp;#x2019;s obfuscated engine code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image23.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;To compare before and after, I looked at the beginning of the &lt;code&gt;.vmp0&lt;/code&gt; region. Before patching, the section is filled with VMP-specific obfuscated code: meaningless operations and tangled jumps.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image24.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;After patching, the same location now contains a normal native x86 function that pops values from the stack and performs simple operations such as &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;SHR&lt;/code&gt;, and &lt;code&gt;SHL&lt;/code&gt;. When you run the patched binary, it no longer goes through the VMProtect engine; instead, it executes the restored native function directly. Pressing P still triggers the same virtualized logic and shows the original message box&amp;#x2014;just without the VM.&lt;/p&gt;
&lt;h2 id=&#34;Wrapping-Up-Devirtualization-Success&#34;&gt;&lt;a href=&#34;#Wrapping-Up-Devirtualization-Success&#34; class=&#34;headerlink&#34; title=&#34;Wrapping Up: Devirtualization Success&#34;&gt;&lt;/a&gt;Wrapping Up: Devirtualization Success&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image25.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;I will conclude with a screenshot showing the successful devirtualization. For the virtualized target function, I patched &lt;code&gt;vir_Entry&lt;/code&gt; so that it jumps directly into the native code block I generated instead of the VMP dispatcher.&lt;/p&gt;
&lt;p&gt;Originally I planned to stop at Part 2, but now I feel like trying even harder virtualization challenges and unpacking them as well. While writing Part 2, I also thought a lot about how far one could push devirtualization by combining this approach with LLVM, and if I ever write a follow-up in this series, that will very likely be the topic.&lt;/p&gt;
&lt;p&gt;Thank you for joining me on this journey through deobfuscation. &amp;#x1F601;&lt;/p&gt;
&lt;h1 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://forum.tuts4you.com/topic/39481-devirtualizeme-vmprotect-309/#comment-190252&#34;&gt;https://forum.tuts4you.com/topic/39481-devirtualizeme-vmprotect-309/#comment-190252&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hackyboiz.github.io/2025/09/11/banda/LLVM_based_VMP/ko/&#34;&gt;https://hackyboiz.github.io/2025/09/11/banda/LLVM_based_VMP/ko/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://whereisr0da.github.io/blog/posts/2021-01-05-vmp-1/&#34;&gt;https://whereisr0da.github.io/blog/posts/2021-01-05-vmp-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://secret.club/2021/09/08/vmprotect-llvm-lifting-1.html&#34;&gt;https://secret.club/2021/09/08/vmprotect-llvm-lifting-1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] VMProtect Devirtualization: Part 2 (EN) - hackyboiz">
  <meta property="og:description" content="&lt;h1 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/main.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Hi, this is banda. :)&lt;/p&gt;
&lt;p&gt;Thank you for giving VMProtect Part 1 more attention than I expected. But I still crave even more attention, so I am back with VMProtect Part 2. In line with the theory-oriented flow of the previous write-up, I wanted Part 2 to extend into a more real-world setting. This time, together with static analysis, we will actually decode functions virtualized by VMProtect 3 into a devirtualized binary / restored code and walk through that process as a hands-on exercise.&lt;/p&gt;
&lt;p&gt;If you have not read it yet, I recommend checking out the previous post first: &lt;a href=&#34;https://hackyboiz.github.io/2025/09/11/banda/LLVM_based_VMP/ko/&#34;&gt;VMProtect Devirtualization Part 1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This unpacking article is written purely for educational and research purposes. Please follow ethical guidelines and help keep the ecosystem healthy.&lt;/p&gt;
&lt;h2 id=&#34;Devirtualization-Rules&#34;&gt;&lt;a href=&#34;#Devirtualization-Rules&#34; class=&#34;headerlink&#34; title=&#34;Devirtualization Rules&#34;&gt;&lt;/a&gt;Devirtualization Rules&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image1.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Before jumping into the challenge, let&amp;#x2019;s briefly recap the basic idea behind virtualization-based obfuscation. Normally, a program runs directly as machine code for a real CPU, such as x86 or x64. Tools like VMProtect or Themida do not leave this code as is. Instead, they:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Convert original x86 code into a &amp;#x201C;virtual bytecode&amp;#x201D;&lt;/li&gt;
&lt;li&gt;Embed a virtual machine (VM) inside the binary that can interpret this bytecode&lt;/li&gt;
&lt;li&gt;At runtime, the VM executes by fetching and interpreting each bytecode instruction one by one&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;VM State Transition&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To understand devirtualization, the key is to focus on &amp;#x201C;what state the VM maintains, and how that state changes when a handler executes.&amp;#x201D; The VM state can be defined as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs sql&#34;&gt;VIP: Virtual Instruction Pointer
VSP: Virtual Stack Pointer
VStack: &lt;span class=&#34;hljs-keyword&#34;&gt;values&lt;/span&gt; currently &lt;span class=&#34;hljs-keyword&#34;&gt;stored&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;on&lt;/span&gt; the &lt;span class=&#34;hljs-keyword&#34;&gt;virtual&lt;/span&gt; stack
Scratch: &lt;span class=&#34;hljs-keyword&#34;&gt;temporary&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;storage&lt;/span&gt;
VFlags: &lt;span class=&#34;hljs-keyword&#34;&gt;virtual&lt;/span&gt; flags (playing &lt;span class=&#34;hljs-keyword&#34;&gt;roles&lt;/span&gt; similar &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; ZF, CF, etc.)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No matter how heavy the obfuscation is, what ultimately matters is &amp;#x201C;how the bundle of state changes after each handler.&amp;#x201D; You can think of the VM not as a CPU, but as a collection of state-transition functions that take &lt;code&gt;VIP&lt;/code&gt;, &lt;code&gt;VStack&lt;/code&gt;, &lt;code&gt;Scratch&lt;/code&gt;, and &lt;code&gt;VFlags&lt;/code&gt; as input and produce new &lt;code&gt;VIP&lt;/code&gt;, &lt;code&gt;VStack&lt;/code&gt;, &lt;code&gt;Scratch&lt;/code&gt;, and &lt;code&gt;VFlags&lt;/code&gt; as output.&lt;/p&gt;
&lt;p&gt;When analyzing a handler, instead of trying to understand every single instruction in the disassembly, the important part is to be able to summarize: &amp;#x201C;this handler transforms the VM state in this way.&amp;#x201D; Once you can say that, you have essentially understood that handler&amp;#x2019;s semantics.&lt;/p&gt;
&lt;h2 id=&#34;DevirtualizeMe-Challenge-VMP32-v1&#34;&gt;&lt;a href=&#34;#DevirtualizeMe-Challenge-VMP32-v1&#34; class=&#34;headerlink&#34; title=&#34;DevirtualizeMe Challenge - VMP32 v1&#34;&gt;&lt;/a&gt;DevirtualizeMe Challenge - VMP32 v1&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image2.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The challenge we will work on here is &lt;a href=&#34;https://forum.tuts4you.com/topic/39481-devirtualizeme-vmprotect-309/#comment-190252&#34;&gt;DevirtualizeMe&lt;/a&gt; from Tuts4You.&lt;/p&gt;
&lt;p&gt;The program is structured around a C++ class named &lt;code&gt;UnpackMe&lt;/code&gt;, and it is protected with VMProtect 3.0.9 using Virtualization mode. The goal of this post is to locate the functions that VMProtect has virtualized inside the attached binary, interpret the bytecode running on top of that VM, and reconstruct the original native-level logic as far as possible. The tools used are IDA, Detect It Easy, Triton, and a custom VMPTrace-style toolchain.&lt;/p&gt;
&lt;h3 id=&#34;Challenge-Information&#34;&gt;&lt;a href=&#34;#Challenge-Information&#34; class=&#34;headerlink&#34; title=&#34;Challenge Information&#34;&gt;&lt;/a&gt;Challenge Information&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Difficulty :&lt;/strong&gt; 8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Language :&lt;/strong&gt; C++&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Platform :&lt;/strong&gt; Windows x86&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OS Version :&lt;/strong&gt; All&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Packer / Protector :&lt;/strong&gt; VMProtect 3.0.9&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unpack goal&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;From the attached binary (.exe), analyze the virtualized function(s), apply a devirtualization patch, and ensure that the patched program runs without errors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Condition:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When you press P, a virtualized function located in the VMP region runs and shows a message box.If the devirtualization has been done correctly (i.e., the original logic is preserved even after patching), running the patched program and pressing P must not produce a crash.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If we check the entropy view in DiE, we can see a typical pattern for Virtualization mode. The &lt;code&gt;.text&lt;/code&gt; section is obfuscated, and the presence of &lt;code&gt;.vmp0&lt;/code&gt; indicates that VMP&amp;#x2019;s core VM bytecode lives there. Entry stub and initialization stub are packed, and the runtime VM engine is expected to reside in &lt;code&gt;.vmp0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We will follow the flow &lt;code&gt;WinMain&lt;/code&gt; &amp;#x2192; &lt;code&gt;UnpackMe&lt;/code&gt; &amp;#x2192; &lt;code&gt;Run&lt;/code&gt; and carefully locate where the VMEntry actually is.&lt;/p&gt;
&lt;h3 id=&#34;Road-to-VMEntry&#34;&gt;&lt;a href=&#34;#Road-to-VMEntry&#34; class=&#34;headerlink&#34; title=&#34;Road to VMEntry&#34;&gt;&lt;/a&gt;Road to VMEntry&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __stdcall &lt;span class=&#34;hljs-title&#34;&gt;WinMain&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; nShowCmd)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
  &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall ***v4)(HINSTANCE); &lt;span class=&#34;hljs-comment&#34;&gt;// eax&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall ***v5)(HINSTANCE); &lt;span class=&#34;hljs-comment&#34;&gt;// ecx&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall **v6)(HINSTANCE); &lt;span class=&#34;hljs-comment&#34;&gt;// eax&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; result; &lt;span class=&#34;hljs-comment&#34;&gt;// eax&lt;/span&gt;

  SetUnhandledExceptionFilter(TopLevelExceptionFilter);
  v4 = (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall ***)(HINSTANCE))&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;u);
  v5 = v4;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v4 )
    *v4 = (&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__stdcall **)(HINSTANCE))&amp;amp;UnpackMe::`vftable&lt;span class=&#34;hljs-number&#34;&gt;&amp;apos;&lt;/span&gt;;  &lt;span class=&#34;hljs-comment&#34;&gt;// vtable &amp;#xC124;&amp;#xC815;&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
    v5 = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
  v6 = *v5;
  UnpackMe* &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; = v5;
  (*v6)(hInstance);   &lt;span class=&#34;hljs-comment&#34;&gt;// vtable[0] &amp;#xD638;&amp;#xCD9C;&lt;/span&gt;
  j__free(UnpackMe* &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;);
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A typical virtualization-based obfuscation VM can usually be broken down into the following components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;VM Entry&lt;/code&gt; / &lt;code&gt;VM Exit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  Entry: the region where native registers and stack state are copied into the VM state&lt;/p&gt;
&lt;p&gt;  Exit: after bytecode execution finishes, the VM state is written back to the original registers and stack&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;VM Dispatcher&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  Reads the opcode at the virtual PC (&lt;code&gt;VIP&lt;/code&gt;), decides which handler to jump to, and repeatedly runs a fetch &amp;#x2192; decode &amp;#x2192; dispatch &amp;#x2192; execute loop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Handler Table&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  A table mapping each opcode to its handler function&lt;/p&gt;
&lt;p&gt;  Each handler implements the semantics of one VM instruction such as &amp;#x201C;virtual ADD&amp;#x201D;, &amp;#x201C;virtual XOR&amp;#x201D;, or &amp;#x201C;virtual branch&amp;#x201D;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For a real-world challenge like DevirtualizeMe, the first step is to locate the VMEntry. Only after finding the VMEntry can we reason about the VM state layout; I will discuss the VM state in more detail later.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;WinMain()&lt;/code&gt; function itself is structurally simple. From a devirtualization perspective, note that VMP usually virtualizes only certain target functions and leaves the path leading up to those functions in normal C++ code. So here we just need to confirm that &lt;code&gt;vtable[0]&lt;/code&gt; is in fact &lt;code&gt;UnpackMe::Run&lt;/code&gt; and then move on.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image4.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Following the vtable, we find that the C++ class &lt;code&gt;UnpackMe&lt;/code&gt;&amp;#x2019;s vtable lives in the &lt;code&gt;.rdata&lt;/code&gt; section. When IDA successfully reconstructs RTTI, it attaches the symbol &lt;code&gt;??_7UnpackMe@@6B@&lt;/code&gt; and automatically names the first vtable entry as &lt;code&gt;UnpackMe::Run&lt;/code&gt;. Let&amp;#x2019;s now jump into &lt;code&gt;UnpackMe::Run&lt;/code&gt;, which opens the main loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __thiscall &lt;span class=&#34;hljs-title&#34;&gt;UnpackMe::Run&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;, HINSTANCE hInst)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    *((DWORD*)&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) = hInst;

    WNDCLASSEXW wc = {&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;};
    wc.cbSize       = &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(wc);
    wc.style        = &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;;
    wc.lpfnWndProc  = (WNDPROC)sub_40CC70;
    wc.hInstance    = hInst;
    wc.lpszClassName = &lt;span class=&#34;hljs-string&#34;&gt;L&amp;quot;WndClass_DevirtualizeMe&amp;quot;&lt;/span&gt;;
    RegisterClassExW(&amp;amp;wc);

    ((&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; (__thiscall*)(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;*))(*(DWORD*)&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;))(&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt; ( GetMessageW(&amp;amp;Msg, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;) )
    {
        TranslateMessage(&amp;amp;Msg);
        DispatchMessageW(&amp;amp;Msg);   &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;#xC5EC;&amp;#xAE30;&amp;#xC11C; WndProc &amp;#xCCB4;&amp;#xC778;&amp;#xC73C;&amp;#xB85C; &amp;#xB4E4;&amp;#xC5B4;&amp;#xAC10;&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From a devirtualization point of view, &lt;code&gt;Run&lt;/code&gt; acts as a kind of gatekeeper into the VM. When the user presses the P key, the program flows through this loop and eventually reaches the VMProtect entry point.&lt;/p&gt;
&lt;p&gt;This function registers a window class, sets &lt;code&gt;lpfnWndProc = sub_40CC70&lt;/code&gt; as the global WndProc, and then repeatedly calls &lt;code&gt;DispatchMessageW&lt;/code&gt; inside the message loop. All key input (including P) goes through this message loop and eventually arrives at &lt;code&gt;WndProc&lt;/code&gt;, which then routes messages into &lt;code&gt;UnpackMe&lt;/code&gt;&amp;#x2019;s member functions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;LRESULT __stdcall &lt;span class=&#34;hljs-title&#34;&gt;WndProc&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( dword_415F08 )
        &lt;span class=&#34;hljs-comment&#34;&gt;// vtable[1] = UnpackMe::WndProc(sub_40CB60)&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; ((&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; (__thiscall*)(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;*, HWND, UINT, WPARAM, LPARAM))
                (*(DWORD*)UnpackMe* &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;))(
                    dword_415F08, hWnd, Msg, wParam, lParam);
    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; DefWindowProcW(hWnd, Msg, wParam, lParam);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important point here is that the OS has no idea that a C++ class named &lt;code&gt;UnpackMe&lt;/code&gt; even exists, nor how many instances there are. The OS only knows that for windows of class &lt;code&gt;WndClass_DevirtualizeMe&lt;/code&gt;, the WndProc is &lt;code&gt;sub_40CC70&lt;/code&gt;, and that function internally forwards messages into &lt;code&gt;UnpackMe::WndProc&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In other words, from a devirtualization perspective, all keyboard messages eventually end up in &lt;code&gt;UnpackMe::WndProc&lt;/code&gt;. Therefore we only need to see how this &lt;code&gt;WndProc()&lt;/code&gt; handles &lt;code&gt;WM_KEYDOWN&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __thiscall &lt;span class=&#34;hljs-title&#34;&gt;UnpackMe::WndProc&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; *&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                 HWND hWnd,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                 UINT Msg,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                 WPARAM wParam,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                 LPARAM lParam)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( Msg &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;0x14&lt;/span&gt; )
    {
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( Msg &amp;lt;= &lt;span class=&#34;hljs-number&#34;&gt;0x111&lt;/span&gt; )
        {
            &lt;span class=&#34;hljs-keyword&#34;&gt;switch&lt;/span&gt; ( Msg )
            {
            &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x100&lt;/span&gt;:  &lt;span class=&#34;hljs-comment&#34;&gt;// WM_KEYDOWN&lt;/span&gt;
                &lt;span class=&#34;hljs-comment&#34;&gt;// vtable[6] = OnKeyDown&lt;/span&gt;
                &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; ((&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; (__thiscall*)(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;*, HWND, WPARAM, LPARAM))
                        (*(DWORD*)&lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt; + &lt;span class=&#34;hljs-number&#34;&gt;24&lt;/span&gt;))(
                            &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;, hWnd, wParam, lParam);

            &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x111&lt;/span&gt;:  &lt;span class=&#34;hljs-comment&#34;&gt;// WM_COMMAND&lt;/span&gt;
                ...
            }
        }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When &lt;code&gt;WM_KEYDOWN&lt;/code&gt; arrives, this function forwards control to &lt;code&gt;OnKeyDown&lt;/code&gt;, which is mapped to &lt;code&gt;vtable[6]&lt;/code&gt;. Up to this point we are still just in the message routing layer, and no VMProtect virtualized code has appeared yet. But we do not have to be disappointed&amp;#x2014;things are about to get more interesting.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; __thiscall &lt;span class=&#34;hljs-title&#34;&gt;UnpackMe::OnKeyDown&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                   HWND hWnd,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                   WPARAM wParam,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;                                   LPARAM lParam)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( wParam == &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;P&amp;apos;&lt;/span&gt; )
        proc();
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;OnKeyDown&lt;/code&gt; is where the key input is actually checked. When &lt;code&gt;wParam&lt;/code&gt; equals the character &lt;code&gt;&amp;apos;P&amp;apos;&lt;/code&gt; (0x50), it calls &lt;code&gt;proc()&lt;/code&gt;. All other key presses are ignored.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image5.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If you run the program and press P, a message box appears with some address information. That entry point is effectively what we call &lt;code&gt;vir_Entry()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image6.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;From this point onward IDA shows &lt;code&gt;call analysis failed&lt;/code&gt; and cannot decompile the function. This means that inside this function, there are abnormal control flows, indirect branches, and sequences that scramble the stack/registers, making it hard to lift back to normal C code. In other words, from the perspective of building or using a devirtualizer, this &lt;code&gt;vir_Entry()&lt;/code&gt; becomes our starting point.&lt;/p&gt;
&lt;p&gt;By static analysis we traced the full path to the virtualized code as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;WinMain &amp;#x2192; UnpackMe::Run &amp;#x2192; DispatchMessage &amp;#x2192; UnpackMe::WndProc &amp;#x2192; OnKeyDown &amp;#x2192; proc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we confirmed that &lt;code&gt;proc()&lt;/code&gt; (and &lt;code&gt;vir_Entry&lt;/code&gt; inside it) is where VMEntry and the body of the VMProtect-virtualized function live.&lt;/p&gt;
&lt;p&gt;Now that we have the VMEntry address, let&amp;#x2019;s attach a debugger and follow the execution. Starting at &lt;code&gt;0x004869BB&lt;/code&gt;, you can see VMProtect&amp;#x2019;s characteristic VM engine code: repeated patterns of &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, and so on, together with instructions like &lt;code&gt;mov eax, [esi]&lt;/code&gt; / &lt;code&gt;add esi, 4&lt;/code&gt; that repeatedly load from the bytecode stream. This shows clearly that VMProtect is updating virtual registers and the bytecode pointer (&lt;code&gt;ESI&lt;/code&gt;) while stepping through handlers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image7.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Trying to analyze the entire VM engine as one big CFG is practically impossible for a human. VMProtect fills the code with thousands of junk instructions and aggressive control-flow flattening, making the actual VM dispatcher and handler paths extremely tangled.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image8.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;At first, I tried walking through the handlers and dispatcher in the debugger, chasing &lt;code&gt;jmp&lt;/code&gt; instructions to the end in the hope that something meaningful would appear. Instead, I repeatedly landed on trivial &amp;#x201C;trampoline&amp;#x201D; handlers that only redirected control elsewhere without doing any semantically interesting work. This pattern repeated over and over.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image9.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;I wanted to catch a &lt;code&gt;VMExit&lt;/code&gt;, but no matter how long I followed the flow, it was just handler &amp;#x2192; dispatcher &amp;#x2192; handler &amp;#x2192; &amp;#x2026; like an endless staircase to heaven. From the debugger&amp;#x2019;s point of view, it felt impossible to ever escape this loop. On top of that, the VM does not use physical registers like a normal CPU. It hides values in virtual registers such as &lt;code&gt;VIP&lt;/code&gt; and &lt;code&gt;VSP&lt;/code&gt; and in encrypted stack regions. Staring at &lt;code&gt;EAX&lt;/code&gt; all day yields nothing meaningful.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image10.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;&amp;#x2026; At this point I felt that my lifetime was too short to finish this using only live debugging. Time to look for another approach.&lt;/p&gt;
&lt;h3 id=&#34;Patch&#34;&gt;&lt;a href=&#34;#Patch&#34; class=&#34;headerlink&#34; title=&#34;Patch&#34;&gt;&lt;/a&gt;Patch&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D153 FF10           call dword ptr [eax]
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D155 FF35 &lt;span class=&#34;hljs-number&#34;&gt;085F&lt;/span&gt;4100  push dword ptr [&lt;span class=&#34;hljs-number&#34;&gt;415F&lt;/span&gt;08]
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D15B E8 &lt;span class=&#34;hljs-number&#34;&gt;623F&lt;/span&gt;FFFF    call &lt;span class=&#34;hljs-number&#34;&gt;4010&lt;/span&gt;C2
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D160 &lt;span class=&#34;hljs-number&#34;&gt;83&lt;/span&gt;C4 &lt;span class=&#34;hljs-number&#34;&gt;04&lt;/span&gt;        add esp, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D163 &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;D             pop ebp
&lt;span class=&#34;hljs-number&#34;&gt;0040&lt;/span&gt;D164 C2 &lt;span class=&#34;hljs-number&#34;&gt;1000&lt;/span&gt;        ret &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image11.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;To trace the program more effectively, I first applied a small patch to the original binary. For reasons I am not certain about (whether intentional or accidental), when run under Intel Pin, this challenge binary stayed in the background and did not respond to my key presses. So I modified the binary so that right after startup it immediately jumps into VM Entry, without waiting for me to press P.&lt;/p&gt;
&lt;h3 id=&#34;Collecting-Trace-with-Pin&#34;&gt;&lt;a href=&#34;#Collecting-Trace-with-Pin&#34; class=&#34;headerlink&#34; title=&#34;Collecting Trace with Pin&#34;&gt;&lt;/a&gt;Collecting Trace with Pin&lt;/h3&gt;&lt;p&gt;Intel Pin is a dynamic binary instrumentation tool that lets you inject analysis code into a running program. Regardless of what kind of obfuscation is applied, Pin can intercept and log every single instruction that actually executes. It will not miss even one instruction.&lt;/p&gt;
&lt;p&gt;To collect traces, I first identified several key addresses through static analysis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;gDispEntry (&lt;code&gt;0x004869BB&lt;/code&gt;):&lt;/strong&gt; VM Entry (dispatcher entry point)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image12.png&#34; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;gHandler82 (&lt;code&gt;0x004181BB&lt;/code&gt;):&lt;/strong&gt; entry point of a specific handler (ID 82) found through analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;24566&lt;/span&gt; vmtrace.out
i:&lt;span class=&#34;hljs-number&#34;&gt;0x004869bb&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;68&lt;/span&gt;EACF8694
r:&lt;span class=&#34;hljs-number&#34;&gt;0x004869c0&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00401dcd&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x97010000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x004011fc&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff28&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff20&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000202&lt;/span&gt;
i:&lt;span class=&#34;hljs-number&#34;&gt;0x004869c0&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;:E883A9FFFF
r:&lt;span class=&#34;hljs-number&#34;&gt;0x00481348&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00401dcd&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x97010000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x004011fc&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff28&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff1c&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000202&lt;/span&gt;
i:&lt;span class=&#34;hljs-number&#34;&gt;0x00481348&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;51&lt;/span&gt;
r:&lt;span class=&#34;hljs-number&#34;&gt;0x00481349&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00401dcd&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x97010000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x004011fc&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff28&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff18&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000202&lt;/span&gt;
i:&lt;span class=&#34;hljs-number&#34;&gt;0x00481349&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;:E9CA50FBFF
r:&lt;span class=&#34;hljs-number&#34;&gt;0x00436418&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00401dcd&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x97010000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x004011fc&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff28&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff18&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;0x00000202&lt;/span&gt;
i:&lt;span class=&#34;hljs-number&#34;&gt;0x00436418&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;55&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I first extracted from the trace a region corresponding to one full cycle of the VMProtect VM, and that alone already produced on the order of &lt;code&gt;n0,000&lt;/code&gt; lines of log. At this scale it becomes essential to split the trace at handler boundaries and automatically identify repeating patterns.&lt;/p&gt;
&lt;p&gt;Lines starting with &lt;code&gt;i:&lt;/code&gt; record the executed instructions,&lt;/p&gt;
&lt;p&gt;and lines starting with &lt;code&gt;r:&lt;/code&gt; record the register and stack state at that point.&lt;/p&gt;
&lt;p&gt;Jonathan Salwan&amp;#x2019;s &lt;a href=&#34;https://github.com/JonathanSalwan/VMProtect-devirtualization&#34;&gt;VMProtect-devirtualization&lt;/a&gt; project was extremely helpful here.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Identifying VM main loop and handler candidates with &lt;code&gt;uniq -c&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0047f287&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0044a8ae&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0044a8ac&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0044a8ab&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;108&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0044a8a7&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;107&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x004181bb&lt;/span&gt;
 &lt;span class=&#34;hljs-number&#34;&gt;64&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x00464679&lt;/span&gt;
 &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0049acd6&lt;/span&gt;
 &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0049acd4&lt;/span&gt;
 &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0x0049acd2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I computed the execution count per address from the trace, using a &lt;code&gt;uniq -c&lt;/code&gt; style analysis to list the most frequently executed locations. Static analysis then allowed me to categorize them as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Highest frequency, 108 times: VM dispatcher&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;VM Dispatcher&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  Addresses like &lt;code&gt;0x0047f287&lt;/code&gt; and &lt;code&gt;0x0044a8a7&lt;/code&gt; appeared exactly 108 times each. These are pieces of dispatcher code. The dispatcher implements the CPU-like cycle in software (fetch &amp;#x2192; decode &amp;#x2192; dispatch &amp;#x2192; execute). Since the dispatcher itself does not perform interesting semantics, we can skip over it for now.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Second highest frequency, 107 times: handler ID 82&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Most frequently used handler (&lt;code&gt;LCONST&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  Address &lt;code&gt;0x004181BB&lt;/code&gt; is a strong candidate for a constant-load handler once we consider VMProtect&amp;#x2019;s stack-based VM design. In a stack machine, most operations happen on the stack, so load/copy/move-style operations tend to be used heavily. Prioritizing the most frequently executed handler for analysis is usually efficient.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Running-the-Pin-Trace-Again&#34;&gt;&lt;a href=&#34;#Running-the-Pin-Trace-Again&#34; class=&#34;headerlink&#34; title=&#34;Running the Pin Trace Again&#34;&gt;&lt;/a&gt;Running the Pin Trace Again&lt;/h3&gt;&lt;p&gt;I then extended the original Pin tool (based on the template provided with Intel Pin) into a specialized Pintool that captures only the ID 82 handler. The goal is to reverse engineer what the VMProtect VM actually does for this single opcode.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image13.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;To capture the behavior of a single VM instruction dynamically, I built Pin support to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Anchor each VM instruction using two fixed IP locations&lt;/li&gt;
&lt;li&gt;Capture the 4 bytes pointed to by &lt;code&gt;ESI&lt;/code&gt; at the moment the bytecode is loaded&lt;/li&gt;
&lt;li&gt;Record &lt;code&gt;EAX&lt;/code&gt;/&lt;code&gt;EDI&lt;/code&gt; at the point where the handler finishes its computation and pushes the result onto the stack (using Pin&amp;#x2019;s CONTEXT)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image14.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Using the built &lt;code&gt;MyPinTool&lt;/code&gt;, I collected three types of information:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;code&gt;vmtrace.out&lt;/code&gt;: the complete x86 instruction trace from dispatcher entry to VM exit&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#main exe: [0x00400000, 0x00581fff)&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;004869b&lt;/span&gt;b &lt;span class=&#34;hljs-number&#34;&gt;68&lt;/span&gt; EA CF &lt;span class=&#34;hljs-number&#34;&gt;86&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;94&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;004869&lt;/span&gt;c0 E8 &lt;span class=&#34;hljs-number&#34;&gt;83&lt;/span&gt; A9 FF FF
&lt;span class=&#34;hljs-number&#34;&gt;00481348&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;51&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;00481349&lt;/span&gt; E9 CA &lt;span class=&#34;hljs-number&#34;&gt;50&lt;/span&gt; FB FF
&lt;span class=&#34;hljs-number&#34;&gt;00436418&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;55&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;00436419&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;50&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0043641&lt;/span&gt;a &lt;span class=&#34;hljs-number&#34;&gt;66&lt;/span&gt; F7 D5
&lt;span class=&#34;hljs-number&#34;&gt;0043641&lt;/span&gt;d E9 &lt;span class=&#34;hljs-number&#34;&gt;15&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;92&lt;/span&gt; FE FF
&lt;span class=&#34;hljs-number&#34;&gt;0041f&lt;/span&gt;637 &lt;span class=&#34;hljs-number&#34;&gt;57&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0041f&lt;/span&gt;638 &lt;span class=&#34;hljs-number&#34;&gt;0F&lt;/span&gt; BF FF
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file contains every x86 instruction executed from &lt;code&gt;0x004869BB&lt;/code&gt; (VM dispatcher entry) until the VM finishes. Each line records the instruction address and machine bytes. The script that walks the trace also dumps a plain text file side by side.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. &lt;code&gt;bytecode_values.txt&lt;/code&gt;: the &lt;code&gt;[ESI]&lt;/code&gt; value when entering handler ID 82 (i.e., the VM instruction operand)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x0047fa5f&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x1ecbf564&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x000271c9&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x004892af&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x0045cb33&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x1ec6b25f&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0xfffcff9f&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x00432085&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x0046ef95&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x1ec5393d&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0xfffdab5b&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0x0043cc41&lt;/span&gt;
# Total ID82 calls: &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we open the extracted &lt;code&gt;bytecode_values.txt&lt;/code&gt;, we can see which constants/operands were fed into handler ID 82. By comparing the operand patterns across multiple calls, we can infer whether this handler is pushing constants onto the stack, applying certain transforms to the operand, or using it as an index, and so on. Later, we will feed these concrete values into Triton when performing symbolic execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. &lt;code&gt;id82_registers.txt&lt;/code&gt;: register snapshots at handler entry&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;=== VM Entry (&lt;span class=&#34;hljs-number&#34;&gt;0x004869bb&lt;/span&gt;) ===
INIT_ESI=&lt;span class=&#34;hljs-number&#34;&gt;0x0000000a&lt;/span&gt;
INIT_EBP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff74&lt;/span&gt;
INIT_ESP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019ff04&lt;/span&gt;
===========================

ID82_001: IP=&lt;span class=&#34;hljs-number&#34;&gt;0x004323ff&lt;/span&gt; EAX=&lt;span class=&#34;hljs-number&#34;&gt;0x000271c9&lt;/span&gt; EBX=&lt;span class=&#34;hljs-number&#34;&gt;0x00458b96&lt;/span&gt; ECX=&lt;span class=&#34;hljs-number&#34;&gt;0x00000020&lt;/span&gt; EDX=&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt; ESI=&lt;span class=&#34;hljs-number&#34;&gt;0x0047fa63&lt;/span&gt; EDI=&lt;span class=&#34;hljs-number&#34;&gt;0x004892af&lt;/span&gt; EBP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fed8&lt;/span&gt; ESP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fe18&lt;/span&gt; BYTECODE=&lt;span class=&#34;hljs-number&#34;&gt;0x1ecbf564&lt;/span&gt;
ID82_002: IP=&lt;span class=&#34;hljs-number&#34;&gt;0x004323ff&lt;/span&gt; EAX=&lt;span class=&#34;hljs-number&#34;&gt;0xfffcff9f&lt;/span&gt; EBX=&lt;span class=&#34;hljs-number&#34;&gt;0xffb934ac&lt;/span&gt; ECX=&lt;span class=&#34;hljs-number&#34;&gt;0x00000020&lt;/span&gt; EDX=&lt;span class=&#34;hljs-number&#34;&gt;0x0000422a&lt;/span&gt; ESI=&lt;span class=&#34;hljs-number&#34;&gt;0x0045cb37&lt;/span&gt; EDI=&lt;span class=&#34;hljs-number&#34;&gt;0x00432085&lt;/span&gt; EBP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fcd0&lt;/span&gt; ESP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fc10&lt;/span&gt; BYTECODE=&lt;span class=&#34;hljs-number&#34;&gt;0x1ec6b25f&lt;/span&gt;
ID82_003: IP=&lt;span class=&#34;hljs-number&#34;&gt;0x004323ff&lt;/span&gt; EAX=&lt;span class=&#34;hljs-number&#34;&gt;0xfffdab5b&lt;/span&gt; EBX=&lt;span class=&#34;hljs-number&#34;&gt;0xffbb44ce&lt;/span&gt; ECX=&lt;span class=&#34;hljs-number&#34;&gt;0xdcedb11a&lt;/span&gt; EDX=&lt;span class=&#34;hljs-number&#34;&gt;0x00000000&lt;/span&gt; ESI=&lt;span class=&#34;hljs-number&#34;&gt;0x0046ef99&lt;/span&gt; EDI=&lt;span class=&#34;hljs-number&#34;&gt;0x0043cc41&lt;/span&gt; EBP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fcc0&lt;/span&gt; ESP=&lt;span class=&#34;hljs-number&#34;&gt;0x0019fc00&lt;/span&gt; BYTECODE=&lt;span class=&#34;hljs-number&#34;&gt;0x1ec5393d&lt;/span&gt;

# Total ID82 calls: &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file logs the VM entry state and, for each ID 82 call, the exact register values right before executing the handler, along with the bytecode operand (&lt;code&gt;BYTECODE&lt;/code&gt;). In other words, for handler ID 82 we now have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The handler&amp;#x2019;s code&lt;/li&gt;
&lt;li&gt;Its input (bytecode and register state)&lt;/li&gt;
&lt;li&gt;The initial VM state at entry&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This matches our goal of fully reconstructing the semantics of a single VM opcode.&lt;/p&gt;
&lt;h3 id=&#34;Splitting-the-VM-only-trace-by-ID-82-execution-segments&#34;&gt;&lt;a href=&#34;#Splitting-the-VM-only-trace-by-ID-82-execution-segments&#34; class=&#34;headerlink&#34; title=&#34;Splitting the VM-only trace by ID 82 execution segments&#34;&gt;&lt;/a&gt;Splitting the VM-only trace by ID 82 execution segments&lt;/h3&gt;&lt;p&gt;With these logs in hand, we can now start restoring the meaning of individual VM handlers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;total ins: &lt;span class=&#34;hljs-number&#34;&gt;58414&lt;/span&gt;
ID82 entries: &lt;span class=&#34;hljs-number&#34;&gt;107&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;ID82 &lt;span class=&#34;hljs-title&#34;&gt;segments&lt;/span&gt; &lt;span class=&#34;hljs-params&#34;&gt;(with glue)&lt;/span&gt;: 106&lt;/span&gt;
written id82_segments.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To do that, I wrote a script that takes &lt;code&gt;vmtrace.out&lt;/code&gt;, locates each occurrence of ID 82, and slices the trace into segments corresponding to &amp;#x201C;one execution of ID 82, including its glue code.&amp;#x201D; Each such segment is then written into a JSON file. Earlier we counted 107 entries for ID 82; the script extracted 106 segments into the JSON.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;{
  &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;idx&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,
  &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;start_ip&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;4293051&lt;/span&gt;,
  &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;end_ip&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;4715143&lt;/span&gt;,
  &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;ins&amp;quot;&lt;/span&gt;: [
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004181bb FF E7&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00468429 8B C5&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046842b 66 85 F2&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046842e 81 ED 04 00 00 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00468434 66 3B FE&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00468437 89 44 25 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046843b 9F&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046843c 13 C6&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0046843e E9 C1 EC FE FF&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00457104 8B 06&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00457106 3B E6&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00457108 81 C6 04 00 00 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0045710e 33 C3&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;00457110 E9 BB 7D FE FF&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed0 D1 C8&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed2 35 B9 3D CB 4A&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed7 F5&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed8 F9&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eed9 66 85 C4&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eedc 2D 40 01 8C 45&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0043eee1 E9 FC 23 FF FF&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004312e2 D1 C0&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004312e4 33 D8&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004312e6 03 F8&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;004312e8 E9 B3 DE 02 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0045f1a0 E9 02 B7 FE FF&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0044a8a7 8D 44 24 60&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0044a8ab F5&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0044a8ac 3B E8&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0044a8ae E9 D4 49 03 00&amp;quot;&lt;/span&gt;,
    &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0047f287 0F 87 2E 8F F9 FF&amp;quot;&lt;/span&gt;
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each segment contains the flow from entry into ID 82 &amp;#x2192; various glue/shared code &amp;#x2192; return to the dispatcher. However, there is still a lot of VMProtect-inserted noise mixed in, so this alone does not yet isolate the pure handler body. We need to keep going.&lt;/p&gt;
&lt;h3 id=&#34;Clustering-ID-82-patterns&#34;&gt;&lt;a href=&#34;#Clustering-ID-82-patterns&#34; class=&#34;headerlink&#34; title=&#34;Clustering ID 82 patterns&#34;&gt;&lt;/a&gt;Clustering ID 82 patterns&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;total segments: &lt;span class=&#34;hljs-number&#34;&gt;106&lt;/span&gt;
unique patterns: &lt;span class=&#34;hljs-number&#34;&gt;70&lt;/span&gt;
==== pattern &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; size &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;
indices: [&lt;span class=&#34;hljs-number&#34;&gt;20&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;40&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;60&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;78&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;94&lt;/span&gt;]
==== pattern &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; size &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;
indices: [&lt;span class=&#34;hljs-number&#34;&gt;21&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;62&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;82&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;99&lt;/span&gt;]
==== pattern &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt; size &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
indices: [&lt;span class=&#34;hljs-number&#34;&gt;19&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;39&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;59&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;93&lt;/span&gt;]
==== pattern &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt; size &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
indices: [&lt;span class=&#34;hljs-number&#34;&gt;22&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;65&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;84&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;103&lt;/span&gt;]
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, I loaded the JSON, compared each segment&amp;#x2019;s byte sequence, and grouped those with identical sequences into clusters. When we do this per handler, segments with exactly the same instruction pattern end up in the same cluster. For example, in pattern 1, segments 20, 40, 60, 78, and 94 all share the same sequence of bytes and thus form one cluster.&lt;/p&gt;
&lt;p&gt;The purpose of this clustering is to pick one representative pattern per handler. For ID 82, we can choose, say, index 20 from pattern 1 as the canonical example and use it as a reference to understand the handler&amp;#x2019;s semantics.&lt;/p&gt;
&lt;h3 id=&#34;Simulating-Handler-ID-82-with-Triton&#34;&gt;&lt;a href=&#34;#Simulating-Handler-ID-82-with-Triton&#34; class=&#34;headerlink&#34; title=&#34;Simulating Handler ID 82 with Triton&#34;&gt;&lt;/a&gt;Simulating Handler ID 82 with Triton&lt;/h3&gt;&lt;p&gt;Using the clustering result, I dumped the bytes for the segment at index 20 (pattern 1) as a contiguous block of x86 code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;written id82_handler.&lt;span class=&#34;hljs-keyword&#34;&gt;asm&lt;/span&gt; from idx &lt;span class=&#34;hljs-number&#34;&gt;20&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;004181b&lt;/span&gt;b FF E7
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a7a &lt;span class=&#34;hljs-number&#34;&gt;0F&lt;/span&gt; B6 &lt;span class=&#34;hljs-number&#34;&gt;06&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a7d &lt;span class=&#34;hljs-number&#34;&gt;81&lt;/span&gt; C6 &lt;span class=&#34;hljs-number&#34;&gt;01&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;00&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;00&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;00&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a83 &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt; C3
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a85 &lt;span class=&#34;hljs-number&#34;&gt;66&lt;/span&gt; F7 C2 DE &lt;span class=&#34;hljs-number&#34;&gt;7B&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a8a F9
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a8b &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;C &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;A
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a8d D0 C8
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a8f F6 D8
&lt;span class=&#34;hljs-number&#34;&gt;0044f&lt;/span&gt;a91 E9 &lt;span class=&#34;hljs-number&#34;&gt;48&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;9B&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;02&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;00&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comparing this with the corresponding IDA disassembly, we can see the structure more clearly:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image15.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x004181BB: FF E7 &amp;#x2192; 0x004181BB jmp edi&lt;/code&gt; is the &amp;#x201C;glue&amp;#x201D; entry point where the dispatcher has already loaded the handler&amp;#x2019;s address into &lt;code&gt;EDI&lt;/code&gt; and now jumps there.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image16.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;From &lt;code&gt;0x0044FA7A&lt;/code&gt; onward is the essential body of ID 82&amp;#x2019;s front half.&lt;/p&gt;
&lt;p&gt;This code performs &lt;code&gt;movzx eax, byte ptr [esi]&lt;/code&gt; / &lt;code&gt;add esi, 1&lt;/code&gt; to consume the first byte of bytecode (the opcode), then scrambles &lt;code&gt;AL&lt;/code&gt; using &lt;code&gt;XOR&lt;/code&gt;, &lt;code&gt;SUB&lt;/code&gt;, &lt;code&gt;ROR&lt;/code&gt;, &lt;code&gt;NEG&lt;/code&gt;, etc., and finally jumps onward. Later, it executes &lt;code&gt;mov eax, [esi]&lt;/code&gt; / &lt;code&gt;lea esi, [esi+4]&lt;/code&gt; to read 4 bytes, presumably the operand. That 4-byte value is decrypted via a series of operations and used to update &lt;code&gt;EBX&lt;/code&gt;. Control then returns to the dispatcher loop at &lt;code&gt;0x4323ff&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, by combining Pin&amp;#x2019;s trace with IDA disassembly, we have reconstructed the complete native code for handler ID 82 as seen in &lt;code&gt;vmtrace.out&lt;/code&gt;. We are almost there.&lt;/p&gt;
&lt;p&gt;But this is still not yet the end. To fully understand the mathematical transformation encoded by this handler, we need to load this code into Triton, feed it the initial register state and bytecode values we collected earlier, and perform symbolic execution.&lt;/p&gt;
&lt;h3 id=&#34;Tracking-state-changes&#34;&gt;&lt;a href=&#34;#Tracking-state-changes&#34; class=&#34;headerlink&#34; title=&#34;Tracking state changes&#34;&gt;&lt;/a&gt;Tracking state changes&lt;/h3&gt;&lt;p&gt;Using Triton to execute the ID 82 path and compare the registers before and after, we obtain a trace like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;0x4442f2&lt;/span&gt;: shr dh, cl
&lt;span class=&#34;hljs-number&#34;&gt;0x43641a&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;not&lt;/span&gt; bp

--- [ Logic Start (0x41F637) ] ---
&lt;span class=&#34;hljs-number&#34;&gt;0x41f638&lt;/span&gt;: movsx edi, di
&lt;span class=&#34;hljs-number&#34;&gt;0x41f63c&lt;/span&gt;: lahf
&lt;span class=&#34;hljs-number&#34;&gt;0x41f63d&lt;/span&gt;: bts ebp, esi
&lt;span class=&#34;hljs-number&#34;&gt;0x41f641&lt;/span&gt;: cmp bh, &lt;span class=&#34;hljs-number&#34;&gt;0xb4&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f645&lt;/span&gt;: shr bp, &lt;span class=&#34;hljs-number&#34;&gt;0xa6&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f649&lt;/span&gt;: sub ebx, edx
&lt;span class=&#34;hljs-number&#34;&gt;0x41f64b&lt;/span&gt;: test esi, ebp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f64e&lt;/span&gt;: xchg ah, bh
&lt;span class=&#34;hljs-number&#34;&gt;0x41f650&lt;/span&gt;: sub ax, bx
&lt;span class=&#34;hljs-number&#34;&gt;0x41f653&lt;/span&gt;: movsx ebx, bp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f656&lt;/span&gt;: mov eax, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f65b&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;not&lt;/span&gt; si
&lt;span class=&#34;hljs-number&#34;&gt;0x41f65e&lt;/span&gt;: xadd ebp, esi
&lt;span class=&#34;hljs-number&#34;&gt;0x41f662&lt;/span&gt;: mov esi, dword ptr [esp + &lt;span class=&#34;hljs-number&#34;&gt;0x28&lt;/span&gt;]
&lt;span class=&#34;hljs-number&#34;&gt;0x41f666&lt;/span&gt;: add esi, &lt;span class=&#34;hljs-number&#34;&gt;0x55106798&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f66c&lt;/span&gt;: neg esi
&lt;span class=&#34;hljs-number&#34;&gt;0x41f66e&lt;/span&gt;: rol edi, &lt;span class=&#34;hljs-number&#34;&gt;0x70&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f671&lt;/span&gt;: add esi, &lt;span class=&#34;hljs-number&#34;&gt;0x69733a52&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f677&lt;/span&gt;: btr ebp, &lt;span class=&#34;hljs-number&#34;&gt;0xc0&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f67b&lt;/span&gt;: rol esi, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f67d&lt;/span&gt;: sbb ebx, &lt;span class=&#34;hljs-number&#34;&gt;0x37516d2d&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f683&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;not&lt;/span&gt; esi
&lt;span class=&#34;hljs-number&#34;&gt;0x41f685&lt;/span&gt;: clc
&lt;span class=&#34;hljs-number&#34;&gt;0x41f686&lt;/span&gt;: cmp eax, esp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f688&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; ebp, esp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f68a&lt;/span&gt;: add esi, eax
&lt;span class=&#34;hljs-number&#34;&gt;0x41f68c&lt;/span&gt;: setns al
&lt;span class=&#34;hljs-number&#34;&gt;0x41f68f&lt;/span&gt;: mov ebp, esp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f691&lt;/span&gt;: sub bx, sp
&lt;span class=&#34;hljs-number&#34;&gt;0x41f694&lt;/span&gt;: rol ax, cl
&lt;span class=&#34;hljs-number&#34;&gt;0x41f697&lt;/span&gt;: dec di
&lt;span class=&#34;hljs-number&#34;&gt;0x41f69a&lt;/span&gt;: sub esp, &lt;span class=&#34;hljs-number&#34;&gt;0xc0&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x41f6a0&lt;/span&gt;: jmp &lt;span class=&#34;hljs-number&#34;&gt;0x453e79&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x453e79&lt;/span&gt;: mov ebx, esi
&lt;span class=&#34;hljs-number&#34;&gt;0x453e7b&lt;/span&gt;: bt eax, esp
&lt;span class=&#34;hljs-number&#34;&gt;0x453e7e&lt;/span&gt;: btc ax, &lt;span class=&#34;hljs-number&#34;&gt;0x47&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x453e83&lt;/span&gt;: btr eax, edx
&lt;span class=&#34;hljs-number&#34;&gt;0x453e86&lt;/span&gt;: mov eax, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x453e8b&lt;/span&gt;: jmp &lt;span class=&#34;hljs-number&#34;&gt;0x4620dd&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x4620dd&lt;/span&gt;: sub ebx, eax
&lt;span class=&#34;hljs-number&#34;&gt;0x4620df&lt;/span&gt;: shld eax, eax, &lt;span class=&#34;hljs-number&#34;&gt;0xe3&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x4620e3&lt;/span&gt;: sub eax, edi
&lt;span class=&#34;hljs-number&#34;&gt;0x4620e5&lt;/span&gt;: stc
&lt;span class=&#34;hljs-number&#34;&gt;0x4620e6&lt;/span&gt;: lea edi, [&lt;span class=&#34;hljs-number&#34;&gt;0x4620e6&lt;/span&gt;]
&lt;span class=&#34;hljs-number&#34;&gt;0x4620ec&lt;/span&gt;: mov eax, dword ptr [esi]
&lt;span class=&#34;hljs-number&#34;&gt;0x4620ee&lt;/span&gt;: cmc
&lt;span class=&#34;hljs-number&#34;&gt;0x4620ef&lt;/span&gt;: test cl, &lt;span class=&#34;hljs-number&#34;&gt;0x19&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x4620f2&lt;/span&gt;: lea esi, [esi + &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;]
&lt;span class=&#34;hljs-number&#34;&gt;0x4620f8&lt;/span&gt;: cmc
&lt;span class=&#34;hljs-number&#34;&gt;0x4620f9&lt;/span&gt;: test ebx, &lt;span class=&#34;hljs-number&#34;&gt;0x76f532e4&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x4620ff&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; eax, ebx
&lt;span class=&#34;hljs-number&#34;&gt;0x462101&lt;/span&gt;: ror eax, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x462103&lt;/span&gt;: stc
&lt;span class=&#34;hljs-number&#34;&gt;0x462104&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; eax, &lt;span class=&#34;hljs-number&#34;&gt;0x4acb3db9&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x462109&lt;/span&gt;: sub eax, &lt;span class=&#34;hljs-number&#34;&gt;0x458c0140&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x46210e&lt;/span&gt;: rol eax, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;hljs-number&#34;&gt;0x462110&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; ebx, eax
&lt;span class=&#34;hljs-number&#34;&gt;0x462112&lt;/span&gt;: cmc
&lt;span class=&#34;hljs-number&#34;&gt;0x462113&lt;/span&gt;: cmp bx, sp
&lt;span class=&#34;hljs-number&#34;&gt;0x462116&lt;/span&gt;: clc
&lt;span class=&#34;hljs-number&#34;&gt;0x462117&lt;/span&gt;: add edi, eax
&lt;span class=&#34;hljs-number&#34;&gt;0x462119&lt;/span&gt;: jmp &lt;span class=&#34;hljs-number&#34;&gt;0x4323ff&lt;/span&gt;
--- [ Logic End (0x432400) ] ---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the &lt;code&gt;asm&lt;/code&gt; trace produced by a Triton-based analysis script. It reconstructs the execution path of handler ID 82 using both &lt;code&gt;vmtrace.out&lt;/code&gt; and the bytes from the actual binary.&lt;/p&gt;
&lt;p&gt;Comparing registers before and after execution for each test case yields:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;=== &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; bc = &lt;span class=&#34;hljs-number&#34;&gt;0x1ecbf564&lt;/span&gt;
init EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x271c9&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0x458b96&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x47fa63&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0x4892af&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x19fe78&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0xafe65f2&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ECX = &lt;span class=&#34;hljs-number&#34;&gt;0x20&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDX = &lt;span class=&#34;hljs-number&#34;&gt;0x0&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x47fa68&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0xb0480ee&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fed4&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fe18&lt;/span&gt;
diff EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x1b8fb1&lt;/span&gt; EBX diff = &lt;span class=&#34;hljs-number&#34;&gt;0xabbee64&lt;/span&gt;

=== &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; bc = &lt;span class=&#34;hljs-number&#34;&gt;0x1ec6b25f&lt;/span&gt;
init EAX = &lt;span class=&#34;hljs-number&#34;&gt;0xfffcff9f&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0xffb934ac&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x45cb37&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0x432085&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x19fc70&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0x20ae78f3&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ECX = &lt;span class=&#34;hljs-number&#34;&gt;0x20&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDX = &lt;span class=&#34;hljs-number&#34;&gt;0x422a&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x45cb3c&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0xdf5a6d09&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fccc&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fc10&lt;/span&gt;
diff EAX = &lt;span class=&#34;hljs-number&#34;&gt;0xffe503ef&lt;/span&gt; EBX diff = &lt;span class=&#34;hljs-number&#34;&gt;0xdf174c5f&lt;/span&gt;

=== &lt;span class=&#34;hljs-keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt; bc = &lt;span class=&#34;hljs-number&#34;&gt;0x1ec5393d&lt;/span&gt;
init EAX = &lt;span class=&#34;hljs-number&#34;&gt;0xfffdab5b&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0xffbb44ce&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x46ef99&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0x43cc41&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EAX = &lt;span class=&#34;hljs-number&#34;&gt;0x19fc60&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBX = &lt;span class=&#34;hljs-number&#34;&gt;0x20ae78f3&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ECX = &lt;span class=&#34;hljs-number&#34;&gt;0xdcedb11a&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDX = &lt;span class=&#34;hljs-number&#34;&gt;0x0&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESI = &lt;span class=&#34;hljs-number&#34;&gt;0x46ef9e&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EDI = &lt;span class=&#34;hljs-number&#34;&gt;0xdf590927&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; EBP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fcbc&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;final&lt;/span&gt; ESP = &lt;span class=&#34;hljs-number&#34;&gt;0x19fc00&lt;/span&gt;
diff EAX = &lt;span class=&#34;hljs-number&#34;&gt;0xffe4573b&lt;/span&gt; EBX diff = &lt;span class=&#34;hljs-number&#34;&gt;0xdf153c3d&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can extract the following key observations:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. In every case, &lt;code&gt;ESI&lt;/code&gt; increases by exactly 5.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Case 1: `0x47fa63` &amp;#x2192; `0x47fa68` (+5)
- Case 2: `0x45cb37` &amp;#x2192; `0x45cb3c` (+5)
- Case 3: `0x46ef99` &amp;#x2192; `0x46ef9e` (+5)

So handler ID 82 consumes 5 bytes from the bytecode stream. This matches the earlier code: `movzx eax, byte ptr [esi]` / `add esi, 1` consumes the 1-byte opcode, and later `mov eax, [esi]` / `lea esi, [esi + 4]` consumes 4 more bytes. Together, that is `1 + 4 = 5` bytes.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2. &lt;code&gt;EBX&lt;/code&gt; is updated to a completely new value.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The final `EBX` has no obvious direct relation to its initial value and is clearly the result of some transform. The `bc` (bytecode) values like `0x1ecbf564` go through the decryption routine (involving operations like `NOR`, `ADD`, `ROL`, etc.) to produce the final `EBX` values such as `0x0afe65f2`. Notice that in cases 2 and 3 the final `EBX` is the same: `0x20ae78f3`. Two different encrypted bytecode values (`0x1ec6b25f`, `0x1ec5393d`) converge to the same result, strongly suggesting a decryption function.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Putting this together:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handler ID 82 reads from the bytecode stream:&lt;ul&gt;
&lt;li&gt;1 byte for the opcode&lt;/li&gt;
&lt;li&gt;4 bytes for an encrypted immediate value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It then runs a complex transform (XOR, SUB, ROL, etc.) on that 4-byte value and writes the result into &lt;code&gt;EBX&lt;/code&gt;, effectively placing a constant on the virtual stack.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This behavior matches what we would expect from an &lt;code&gt;LCONST&lt;/code&gt; / &lt;code&gt;PUSH constant&lt;/code&gt;-style handler.&lt;/p&gt;
&lt;h3 id=&#34;So-what-is-the-actual-arithmetic&#34;&gt;&lt;a href=&#34;#So-what-is-the-actual-arithmetic&#34; class=&#34;headerlink&#34; title=&#34;So what is the actual arithmetic?&#34;&gt;&lt;/a&gt;So what is the actual arithmetic?&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;TARGET_HANDLERS = [
    &lt;span class=&#34;hljs-number&#34;&gt;0x44A8A7&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x47F287&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x4181BB&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x40356C&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x404F43&lt;/span&gt;,
    &lt;span class=&#34;hljs-number&#34;&gt;0x405B60&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x405CB6&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x405CE2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x404F5E&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x404419&lt;/span&gt;,
    &lt;span class=&#34;hljs-number&#34;&gt;0x404E83&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x4046BF&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x4046DC&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x4892AF&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x41A261&lt;/span&gt;,
    &lt;span class=&#34;hljs-number&#34;&gt;0x45F79C&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x496B0F&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x474C45&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x437E65&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x493FB7&lt;/span&gt;,
    &lt;span class=&#34;hljs-number&#34;&gt;0x43CB8A&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x46688C&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x45B9AD&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x432085&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x484226&lt;/span&gt;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The analysis above shows that we cannot reconstruct the full program logic from ID 82 alone. So I extended the same pipeline used for ID 82 to other handlers. Because there are many handlers, I first used static analysis plus trace-based hotspot analysis to pick only those handlers that are frequently called or appear semantically important.&lt;/p&gt;
&lt;h3 id=&#34;All-the-handlers-reveal-themselves&#34;&gt;&lt;a href=&#34;#All-the-handlers-reveal-themselves&#34; class=&#34;headerlink&#34; title=&#34;All the handlers reveal themselves&#34;&gt;&lt;/a&gt;All the handlers reveal themselves&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&amp;gt;&amp;gt;&amp;gt; Handler &lt;span class=&#34;hljs-number&#34;&gt;0x432085&lt;/span&gt; (Length: &lt;span class=&#34;hljs-number&#34;&gt;39&lt;/span&gt;)
----------------------------------------
  [M] &lt;span class=&#34;hljs-number&#34;&gt;0x432085&lt;/span&gt;: movzx eax, byte ptr [esi]
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x432088&lt;/span&gt;: rol cx, &lt;span class=&#34;hljs-number&#34;&gt;0xc&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x43208c&lt;/span&gt;: add esi, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x432096&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; al, bl
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x43209a&lt;/span&gt;: ror cx, &lt;span class=&#34;hljs-number&#34;&gt;0xf6&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x43209e&lt;/span&gt;: sub al, &lt;span class=&#34;hljs-number&#34;&gt;0x3a&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320a0&lt;/span&gt;: ror al, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320a2&lt;/span&gt;: neg al
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320aa&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;not&lt;/span&gt; al
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320b1&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;and&lt;/span&gt; cx, si
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320b4&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; bl, al
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320b6&lt;/span&gt;: mov ecx, dword ptr [ebp]
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320bf&lt;/span&gt;: add ebp, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320c5&lt;/span&gt;: mov dword ptr [esp + eax], ecx
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320c8&lt;/span&gt;: ror eax, &lt;span class=&#34;hljs-number&#34;&gt;0xd2&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320cb&lt;/span&gt;: mov eax, dword ptr [esi]
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320cd&lt;/span&gt;: add esi, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320de&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; eax, ebx
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320e1&lt;/span&gt;: ror eax, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320e3&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; eax, &lt;span class=&#34;hljs-number&#34;&gt;0x4acb3db9&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320ee&lt;/span&gt;: sub eax, &lt;span class=&#34;hljs-number&#34;&gt;0x458c0140&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320f3&lt;/span&gt;: rol eax, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320f5&lt;/span&gt;: &lt;span class=&#34;hljs-keyword&#34;&gt;xor&lt;/span&gt; ebx, eax
  [!] &lt;span class=&#34;hljs-number&#34;&gt;0x4320fd&lt;/span&gt;: add edi, eax
----------------------------------------
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each of the addresses is the entry point of a VM handler. For each such entry, I repeated the same process used for ID 82:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Segment splitting&lt;/li&gt;
&lt;li&gt;Pattern clustering&lt;/li&gt;
&lt;li&gt;Triton-based semantic extraction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The sample above shows the extracted semantics for handler &lt;code&gt;0x00432085&lt;/code&gt;. From this we can deduce:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It advances &lt;code&gt;ESI&lt;/code&gt; and consumes bytes from the bytecode stream&lt;/li&gt;
&lt;li&gt;It updates &lt;code&gt;EBX&lt;/code&gt;, &lt;code&gt;EDI&lt;/code&gt;, and stack locations like &lt;code&gt;[esp + eax]&lt;/code&gt; following a consistent pattern&lt;/li&gt;
&lt;li&gt;It reads and writes virtual registers located on the stack, combining constants and memory values to construct new values&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By iterating this process, we can summarize each handler as a higher-level VM instruction: load, store, add, logical operations, branches, and so on. That is, we start to see each handler as one instruction in the VM&amp;#x2019;s instruction set.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image17.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Once this is in place, the next step is to map each opcode value to its handler address. For this, I instrumented the VM dispatcher in Pin at the FETCH site and logged the opcode values being read.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image18.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Parsing that opcode log together with &lt;code&gt;vmtrace.out&lt;/code&gt; allowed me to reverse-map each opcode to a handler entry address. For example, the opcode corresponding to ID 82 turned out to be &lt;code&gt;0x02&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;Building-the-Devirtualizer&#34;&gt;&lt;a href=&#34;#Building-the-Devirtualizer&#34; class=&#34;headerlink&#34; title=&#34;Building the Devirtualizer&#34;&gt;&lt;/a&gt;Building the Devirtualizer&lt;/h3&gt;&lt;p&gt;At this stage we now have a one-to-one mapping between VM bytecodes and the actual handler addresses. The final step is to build a dedicated devirtualizer that reconstructs the entire virtualized function as native x86 and patches it back into the binary.&lt;/p&gt;
&lt;p&gt;The overall design is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Read a mapping file that contains opcode (e.g. &lt;code&gt;0x02&lt;/code&gt;, &lt;code&gt;0x40&lt;/code&gt;, &lt;code&gt;0x88&lt;/code&gt; &amp;#x2026;), the handler entry address, and a summary of its semantics. This becomes the opcode &amp;#x2192; [handler address, meaning, pseudocode] table.&lt;/li&gt;
&lt;li&gt;Parse the VM bytecode stream from start to finish.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For each opcode, emit a corresponding native x86 code snippet which we prepared in advance, for example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LCONST&lt;/code&gt; &amp;#x2192; &lt;code&gt;MOV EBX, imm32&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ADD&lt;/code&gt; &amp;#x2192; &lt;code&gt;ADD [ESP+4], EAX&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  and so on.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Concatenate all these snippets into a single region, forming a new native function body.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Finally, patch the original binary so that &lt;code&gt;vir_Entry&lt;/code&gt; jumps directly into this new native function, bypassing the VM engine.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image19.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Here is part of my devirtualizer code. The loop iterates over each VM instruction and computes the offset into the &lt;code&gt;.vmp0&lt;/code&gt; dump via &lt;code&gt;real_vip - VMP_BASE_ADDR&lt;/code&gt;. It then skips the 1-byte opcode, looks up the handler name from &lt;code&gt;VM_HANDLERS&lt;/code&gt;, and proceeds with reconstruction.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image20.png&#34; alt&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;val = (encrypted + &lt;span class=&#34;hljs-number&#34;&gt;0x55106798&lt;/span&gt;) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
val = (&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; - val) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
val = (val + &lt;span class=&#34;hljs-number&#34;&gt;0x69733a52&lt;/span&gt;) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
val = ((val &amp;lt;&amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) | (val &amp;gt;&amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;31&lt;/span&gt;)) &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
decrypted = ~val &amp;amp; &lt;span class=&#34;hljs-number&#34;&gt;0xFFFFFFFF&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the comments for each handler, I re-implemented the arithmetic sequence obtained by symbolically executing the handler with Triton, writing it out as 32-bit modular arithmetic in Python, as in the example above.&lt;/p&gt;
&lt;p&gt;For instance, suppose the handler takes a 32-bit encrypted constant as input, then applies exactly these steps as observed in the VM:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add a constant&lt;/li&gt;
&lt;li&gt;Compute &lt;code&gt;0 - val&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add another constant&lt;/li&gt;
&lt;li&gt;Rotate left by 1 bit&lt;/li&gt;
&lt;li&gt;Apply a bitwise &lt;code&gt;NOT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can encode that logic exactly as shown, yielding a &lt;code&gt;decrypted&lt;/code&gt; value that matches what the VM computes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image21.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;For key handlers like &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;NOR&lt;/code&gt;, &lt;code&gt;COPY&lt;/code&gt;, &lt;code&gt;SHL&lt;/code&gt;, &lt;code&gt;SHR&lt;/code&gt;, I distilled their stack-top operations plus flag reconstruction into clean native code fragments, and then used the Keystone assembler to convert them into machine code. Those bytes were pushed into a &lt;code&gt;patch_buffer&lt;/code&gt; in order, and the devirtualizer overwrote a pre-allocated region in a duplicated binary named &lt;code&gt;devirtualizeme_unpacked.exe&lt;/code&gt; with this buffer.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image22.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;At the end of this long journey, we finally get to see the restored native x86 code: the devirtualized function. This code is entirely generated from the data we collected and analyzed and represents the original logic in a straightforward x86 form. If you open this region in IDA on the patched binary, you will now see clean assembly in place of VMP&amp;#x2019;s obfuscated engine code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image23.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;To compare before and after, I looked at the beginning of the &lt;code&gt;.vmp0&lt;/code&gt; region. Before patching, the section is filled with VMP-specific obfuscated code: meaningless operations and tangled jumps.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image24.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;After patching, the same location now contains a normal native x86 function that pops values from the stack and performs simple operations such as &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;SHR&lt;/code&gt;, and &lt;code&gt;SHL&lt;/code&gt;. When you run the patched binary, it no longer goes through the VMProtect engine; instead, it executes the restored native function directly. Pressing P still triggers the same virtualized logic and shows the original message box&amp;#x2014;just without the VM.&lt;/p&gt;
&lt;h2 id=&#34;Wrapping-Up-Devirtualization-Success&#34;&gt;&lt;a href=&#34;#Wrapping-Up-Devirtualization-Success&#34; class=&#34;headerlink&#34; title=&#34;Wrapping Up: Devirtualization Success&#34;&gt;&lt;/a&gt;Wrapping Up: Devirtualization Success&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/12/11/banda/VMPpart2/en/image25.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;I will conclude with a screenshot showing the successful devirtualization. For the virtualized target function, I patched &lt;code&gt;vir_Entry&lt;/code&gt; so that it jumps directly into the native code block I generated instead of the VMP dispatcher.&lt;/p&gt;
&lt;p&gt;Originally I planned to stop at Part 2, but now I feel like trying even harder virtualization challenges and unpacking them as well. While writing Part 2, I also thought a lot about how far one could push devirtualization by combining this approach with LLVM, and if I ever write a follow-up in this series, that will very likely be the topic.&lt;/p&gt;
&lt;p&gt;Thank you for joining me on this journey through deobfuscation. &amp;#x1F601;&lt;/p&gt;
&lt;h1 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://forum.tuts4you.com/topic/39481-devirtualizeme-vmprotect-309/#comment-190252&#34;&gt;https://forum.tuts4you.com/topic/39481-devirtualizeme-vmprotect-309/#comment-190252&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hackyboiz.github.io/2025/09/11/banda/LLVM_based_VMP/ko/&#34;&gt;https://hackyboiz.github.io/2025/09/11/banda/LLVM_based_VMP/ko/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://whereisr0da.github.io/blog/posts/2021-01-05-vmp-1/&#34;&gt;https://whereisr0da.github.io/blog/posts/2021-01-05-vmp-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://secret.club/2021/09/08/vmprotect-llvm-lifting-1.html&#34;&gt;https://secret.club/2021/09/08/vmprotect-llvm-lifting-1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/12/11/banda/VMPpart2/en/main.png">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/12/11/banda/vmppart2/en/">

  <title>[Research] VMProtect Devirtualization: Part 2 (EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!--  -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!--  -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-12-11 17:00" pubdate>
      2025 12 11 
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.4k 
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      107
       
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] VMProtect Devirtualization: Part 2 (EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><img src="/2025/12/11/banda/VMPpart2/en/main.png" srcset="/img/loading.gif" alt></p>
<p>Hi, this is banda. :)</p>
<p>Thank you for giving VMProtect Part 1 more attention than I expected. But I still crave even more attention, so I am back with VMProtect Part 2. In line with the theory-oriented flow of the previous write-up, I wanted Part 2 to extend into a more real-world setting. This time, together with static analysis, we will actually decode functions virtualized by VMProtect 3 into a devirtualized binary / restored code and walk through that process as a hands-on exercise.</p>
<p>If you have not read it yet, I recommend checking out the previous post first: <a href="https://hackyboiz.github.io/2025/09/11/banda/LLVM_based_VMP/ko/">VMProtect Devirtualization Part 1</a>.</p>
<p>This unpacking article is written purely for educational and research purposes. Please follow ethical guidelines and help keep the ecosystem healthy.</p>
<h2 id="Devirtualization-Rules"><a href="#Devirtualization-Rules" class="headerlink" title="Devirtualization Rules"></a>Devirtualization Rules</h2><p><img src="/2025/12/11/banda/VMPpart2/en/image1.png" srcset="/img/loading.gif" alt></p>
<p>Before jumping into the challenge, let&#x2019;s briefly recap the basic idea behind virtualization-based obfuscation. Normally, a program runs directly as machine code for a real CPU, such as x86 or x64. Tools like VMProtect or Themida do not leave this code as is. Instead, they:</p>
<ol>
<li>Convert original x86 code into a &#x201C;virtual bytecode&#x201D;</li>
<li>Embed a virtual machine (VM) inside the binary that can interpret this bytecode</li>
<li>At runtime, the VM executes by fetching and interpreting each bytecode instruction one by one</li>
</ol>
<p><strong>VM State Transition</strong></p>
<p>To understand devirtualization, the key is to focus on &#x201C;what state the VM maintains, and how that state changes when a handler executes.&#x201D; The VM state can be defined as follows:</p>
<pre><code class="hljs sql">VIP: Virtual Instruction Pointer
VSP: Virtual Stack Pointer
VStack: <span class="hljs-keyword">values</span> currently <span class="hljs-keyword">stored</span> <span class="hljs-keyword">on</span> the <span class="hljs-keyword">virtual</span> stack
Scratch: <span class="hljs-keyword">temporary</span> <span class="hljs-keyword">storage</span>
VFlags: <span class="hljs-keyword">virtual</span> flags (playing <span class="hljs-keyword">roles</span> similar <span class="hljs-keyword">to</span> ZF, CF, etc.)
</code></pre>
<p>No matter how heavy the obfuscation is, what ultimately matters is &#x201C;how the bundle of state changes after each handler.&#x201D; You can think of the VM not as a CPU, but as a collection of state-transition functions that take <code>VIP</code>, <code>VStack</code>, <code>Scratch</code>, and <code>VFlags</code> as input and produce new <code>VIP</code>, <code>VStack</code>, <code>Scratch</code>, and <code>VFlags</code> as output.</p>
<p>When analyzing a handler, instead of trying to understand every single instruction in the disassembly, the important part is to be able to summarize: &#x201C;this handler transforms the VM state in this way.&#x201D; Once you can say that, you have essentially understood that handler&#x2019;s semantics.</p>
<h2 id="DevirtualizeMe-Challenge-VMP32-v1"><a href="#DevirtualizeMe-Challenge-VMP32-v1" class="headerlink" title="DevirtualizeMe Challenge - VMP32 v1"></a>DevirtualizeMe Challenge - VMP32 v1</h2><p><img src="/2025/12/11/banda/VMPpart2/en/image2.png" srcset="/img/loading.gif" alt></p>
<p>The challenge we will work on here is <a target="_blank" rel="external nofollow noopener noreferrer" href="https://forum.tuts4you.com/topic/39481-devirtualizeme-vmprotect-309/#comment-190252">DevirtualizeMe</a> from Tuts4You.</p>
<p>The program is structured around a C++ class named <code>UnpackMe</code>, and it is protected with VMProtect 3.0.9 using Virtualization mode. The goal of this post is to locate the functions that VMProtect has virtualized inside the attached binary, interpret the bytecode running on top of that VM, and reconstruct the original native-level logic as far as possible. The tools used are IDA, Detect It Easy, Triton, and a custom VMPTrace-style toolchain.</p>
<h3 id="Challenge-Information"><a href="#Challenge-Information" class="headerlink" title="Challenge Information"></a>Challenge Information</h3><p><strong>Difficulty :</strong> 8</p>
<p><strong>Language :</strong> C++</p>
<p><strong>Platform :</strong> Windows x86</p>
<p><strong>OS Version :</strong> All</p>
<p><strong>Packer / Protector :</strong> VMProtect 3.0.9</p>
<p><strong>Unpack goal</strong></p>
<blockquote>
<p>From the attached binary (.exe), analyze the virtualized function(s), apply a devirtualization patch, and ensure that the patched program runs without errors.</p>
</blockquote>
<p><strong><em>Condition:</em></strong></p>
<blockquote>
<p>When you press P, a virtualized function located in the VMP region runs and shows a message box.If the devirtualization has been done correctly (i.e., the original logic is preserved even after patching), running the patched program and pressing P must not produce a crash.</p>
</blockquote>
<p><img src="/2025/12/11/banda/VMPpart2/en/image3.png" srcset="/img/loading.gif" alt></p>
<p>If we check the entropy view in DiE, we can see a typical pattern for Virtualization mode. The <code>.text</code> section is obfuscated, and the presence of <code>.vmp0</code> indicates that VMP&#x2019;s core VM bytecode lives there. Entry stub and initialization stub are packed, and the runtime VM engine is expected to reside in <code>.vmp0</code>.</p>
<p>We will follow the flow <code>WinMain</code> &#x2192; <code>UnpackMe</code> &#x2192; <code>Run</code> and carefully locate where the VMEntry actually is.</p>
<h3 id="Road-to-VMEntry"><a href="#Road-to-VMEntry" class="headerlink" title="Road to VMEntry"></a>Road to VMEntry</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __stdcall <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nShowCmd)</span></span>
<span class="hljs-function"></span>{
  <span class="hljs-keyword">void</span> (__stdcall ***v4)(HINSTANCE); <span class="hljs-comment">// eax</span>
  <span class="hljs-keyword">void</span> (__stdcall ***v5)(HINSTANCE); <span class="hljs-comment">// ecx</span>
  <span class="hljs-keyword">void</span> (__stdcall **v6)(HINSTANCE); <span class="hljs-comment">// eax</span>
  <span class="hljs-keyword">int</span> result; <span class="hljs-comment">// eax</span>

  SetUnhandledExceptionFilter(TopLevelExceptionFilter);
  v4 = (<span class="hljs-keyword">void</span> (__stdcall ***)(HINSTANCE))<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-number">0x48</span>u);
  v5 = v4;
  <span class="hljs-keyword">if</span> ( v4 )
    *v4 = (<span class="hljs-keyword">void</span> (__stdcall **)(HINSTANCE))&amp;UnpackMe::`vftable<span class="hljs-number">&apos;</span>;  <span class="hljs-comment">// vtable &#xC124;&#xC815;</span>
  <span class="hljs-keyword">else</span>
    v5 = <span class="hljs-number">0</span>;
  v6 = *v5;
  UnpackMe* <span class="hljs-keyword">this</span> = v5;
  (*v6)(hInstance);   <span class="hljs-comment">// vtable[0] &#xD638;&#xCD9C;</span>
  j__free(UnpackMe* <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>A typical virtualization-based obfuscation VM can usually be broken down into the following components:</p>
<ul>
<li><p><code>VM Entry</code> / <code>VM Exit</code></p>
<p>  Entry: the region where native registers and stack state are copied into the VM state</p>
<p>  Exit: after bytecode execution finishes, the VM state is written back to the original registers and stack</p>
</li>
<li><p><code>VM Dispatcher</code></p>
<p>  Reads the opcode at the virtual PC (<code>VIP</code>), decides which handler to jump to, and repeatedly runs a fetch &#x2192; decode &#x2192; dispatch &#x2192; execute loop</p>
</li>
<li><p><code>Handler Table</code></p>
<p>  A table mapping each opcode to its handler function</p>
<p>  Each handler implements the semantics of one VM instruction such as &#x201C;virtual ADD&#x201D;, &#x201C;virtual XOR&#x201D;, or &#x201C;virtual branch&#x201D;</p>
</li>
</ul>
<p>For a real-world challenge like DevirtualizeMe, the first step is to locate the VMEntry. Only after finding the VMEntry can we reason about the VM state layout; I will discuss the VM state in more detail later.</p>
<p>The <code>WinMain()</code> function itself is structurally simple. From a devirtualization perspective, note that VMP usually virtualizes only certain target functions and leaves the path leading up to those functions in normal C++ code. So here we just need to confirm that <code>vtable[0]</code> is in fact <code>UnpackMe::Run</code> and then move on.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image4.png" srcset="/img/loading.gif" alt></p>
<p>Following the vtable, we find that the C++ class <code>UnpackMe</code>&#x2019;s vtable lives in the <code>.rdata</code> section. When IDA successfully reconstructs RTTI, it attaches the symbol <code>??_7UnpackMe@@6B@</code> and automatically names the first vtable entry as <code>UnpackMe::Run</code>. Let&#x2019;s now jump into <code>UnpackMe::Run</code>, which opens the main loop.</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __thiscall <span class="hljs-title">UnpackMe::Run</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *<span class="hljs-keyword">this</span>, HINSTANCE hInst)</span></span>
<span class="hljs-function"></span>{
    *((DWORD*)<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>) = hInst;

    WNDCLASSEXW wc = {<span class="hljs-number">0</span>};
    wc.cbSize       = <span class="hljs-keyword">sizeof</span>(wc);
    wc.style        = <span class="hljs-number">3</span>;
    wc.lpfnWndProc  = (WNDPROC)sub_40CC70;
    wc.hInstance    = hInst;
    wc.lpszClassName = <span class="hljs-string">L&quot;WndClass_DevirtualizeMe&quot;</span>;
    RegisterClassExW(&amp;wc);

    ((<span class="hljs-keyword">void</span> (__thiscall*)(<span class="hljs-keyword">void</span>*))(*(DWORD*)<span class="hljs-keyword">this</span> + <span class="hljs-number">8</span>))(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">while</span> ( GetMessageW(&amp;Msg, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) )
    {
        TranslateMessage(&amp;Msg);
        DispatchMessageW(&amp;Msg);   <span class="hljs-comment">// &#xC5EC;&#xAE30;&#xC11C; WndProc &#xCCB4;&#xC778;&#xC73C;&#xB85C; &#xB4E4;&#xC5B4;&#xAC10;</span>
    }
}
</code></pre>
<p>From a devirtualization point of view, <code>Run</code> acts as a kind of gatekeeper into the VM. When the user presses the P key, the program flows through this loop and eventually reaches the VMProtect entry point.</p>
<p>This function registers a window class, sets <code>lpfnWndProc = sub_40CC70</code> as the global WndProc, and then repeatedly calls <code>DispatchMessageW</code> inside the message loop. All key input (including P) goes through this message loop and eventually arrives at <code>WndProc</code>, which then routes messages into <code>UnpackMe</code>&#x2019;s member functions.</p>
<pre><code class="hljs c"><span class="hljs-function">LRESULT __stdcall <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">if</span> ( dword_415F08 )
        <span class="hljs-comment">// vtable[1] = UnpackMe::WndProc(sub_40CB60)</span>
        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">int</span> (__thiscall*)(<span class="hljs-keyword">void</span>*, HWND, UINT, WPARAM, LPARAM))
                (*(DWORD*)UnpackMe* <span class="hljs-keyword">this</span> + <span class="hljs-number">4</span>))(
                    dword_415F08, hWnd, Msg, wParam, lParam);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> DefWindowProcW(hWnd, Msg, wParam, lParam);
}
</code></pre>
<p>The important point here is that the OS has no idea that a C++ class named <code>UnpackMe</code> even exists, nor how many instances there are. The OS only knows that for windows of class <code>WndClass_DevirtualizeMe</code>, the WndProc is <code>sub_40CC70</code>, and that function internally forwards messages into <code>UnpackMe::WndProc</code>.</p>
<p>In other words, from a devirtualization perspective, all keyboard messages eventually end up in <code>UnpackMe::WndProc</code>. Therefore we only need to see how this <code>WndProc()</code> handles <code>WM_KEYDOWN</code>.</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __thiscall <span class="hljs-title">UnpackMe::WndProc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *<span class="hljs-keyword">this</span>,</span></span>
<span class="hljs-function"><span class="hljs-params">                                 HWND hWnd,</span></span>
<span class="hljs-function"><span class="hljs-params">                                 UINT Msg,</span></span>
<span class="hljs-function"><span class="hljs-params">                                 WPARAM wParam,</span></span>
<span class="hljs-function"><span class="hljs-params">                                 LPARAM lParam)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">if</span> ( Msg &gt; <span class="hljs-number">0x14</span> )
    {
        <span class="hljs-keyword">if</span> ( Msg &lt;= <span class="hljs-number">0x111</span> )
        {
            <span class="hljs-keyword">switch</span> ( Msg )
            {
            <span class="hljs-keyword">case</span> <span class="hljs-number">0x100</span>:  <span class="hljs-comment">// WM_KEYDOWN</span>
                <span class="hljs-comment">// vtable[6] = OnKeyDown</span>
                <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">int</span> (__thiscall*)(<span class="hljs-keyword">void</span>*, HWND, WPARAM, LPARAM))
                        (*(DWORD*)<span class="hljs-keyword">this</span> + <span class="hljs-number">24</span>))(
                            <span class="hljs-keyword">this</span>, hWnd, wParam, lParam);

            <span class="hljs-keyword">case</span> <span class="hljs-number">0x111</span>:  <span class="hljs-comment">// WM_COMMAND</span>
                ...
            }
        }
    }
    ...
}
</code></pre>
<p>When <code>WM_KEYDOWN</code> arrives, this function forwards control to <code>OnKeyDown</code>, which is mapped to <code>vtable[6]</code>. Up to this point we are still just in the message routing layer, and no VMProtect virtualized code has appeared yet. But we do not have to be disappointed&#x2014;things are about to get more interesting.</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __thiscall <span class="hljs-title">UnpackMe::OnKeyDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-keyword">this</span>,</span></span>
<span class="hljs-function"><span class="hljs-params">                                   HWND hWnd,</span></span>
<span class="hljs-function"><span class="hljs-params">                                   WPARAM wParam,</span></span>
<span class="hljs-function"><span class="hljs-params">                                   LPARAM lParam)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">if</span> ( wParam == <span class="hljs-string">&apos;P&apos;</span> )
        proc();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><code>OnKeyDown</code> is where the key input is actually checked. When <code>wParam</code> equals the character <code>&apos;P&apos;</code> (0x50), it calls <code>proc()</code>. All other key presses are ignored.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image5.png" srcset="/img/loading.gif" alt></p>
<p>If you run the program and press P, a message box appears with some address information. That entry point is effectively what we call <code>vir_Entry()</code>.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image6.png" srcset="/img/loading.gif" alt></p>
<p>From this point onward IDA shows <code>call analysis failed</code> and cannot decompile the function. This means that inside this function, there are abnormal control flows, indirect branches, and sequences that scramble the stack/registers, making it hard to lift back to normal C code. In other words, from the perspective of building or using a devirtualizer, this <code>vir_Entry()</code> becomes our starting point.</p>
<p>By static analysis we traced the full path to the virtualized code as:</p>
<pre><code class="hljs c">WinMain &#x2192; UnpackMe::Run &#x2192; DispatchMessage &#x2192; UnpackMe::WndProc &#x2192; OnKeyDown &#x2192; proc()
</code></pre>
<p>and we confirmed that <code>proc()</code> (and <code>vir_Entry</code> inside it) is where VMEntry and the body of the VMProtect-virtualized function live.</p>
<p>Now that we have the VMEntry address, let&#x2019;s attach a debugger and follow the execution. Starting at <code>0x004869BB</code>, you can see VMProtect&#x2019;s characteristic VM engine code: repeated patterns of <code>push</code>, <code>call</code>, <code>xor</code>, <code>add</code>, and so on, together with instructions like <code>mov eax, [esi]</code> / <code>add esi, 4</code> that repeatedly load from the bytecode stream. This shows clearly that VMProtect is updating virtual registers and the bytecode pointer (<code>ESI</code>) while stepping through handlers.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image7.png" srcset="/img/loading.gif" alt></p>
<p>Trying to analyze the entire VM engine as one big CFG is practically impossible for a human. VMProtect fills the code with thousands of junk instructions and aggressive control-flow flattening, making the actual VM dispatcher and handler paths extremely tangled.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image8.png" srcset="/img/loading.gif" alt></p>
<p>At first, I tried walking through the handlers and dispatcher in the debugger, chasing <code>jmp</code> instructions to the end in the hope that something meaningful would appear. Instead, I repeatedly landed on trivial &#x201C;trampoline&#x201D; handlers that only redirected control elsewhere without doing any semantically interesting work. This pattern repeated over and over.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image9.png" srcset="/img/loading.gif" alt></p>
<p>I wanted to catch a <code>VMExit</code>, but no matter how long I followed the flow, it was just handler &#x2192; dispatcher &#x2192; handler &#x2192; &#x2026; like an endless staircase to heaven. From the debugger&#x2019;s point of view, it felt impossible to ever escape this loop. On top of that, the VM does not use physical registers like a normal CPU. It hides values in virtual registers such as <code>VIP</code> and <code>VSP</code> and in encrypted stack regions. Staring at <code>EAX</code> all day yields nothing meaningful.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image10.png" srcset="/img/loading.gif" alt></p>
<p>&#x2026; At this point I felt that my lifetime was too short to finish this using only live debugging. Time to look for another approach.</p>
<h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><pre><code class="hljs c"><span class="hljs-number">0040</span>D153 FF10           call dword ptr [eax]
<span class="hljs-number">0040</span>D155 FF35 <span class="hljs-number">085F</span>4100  push dword ptr [<span class="hljs-number">415F</span>08]
<span class="hljs-number">0040</span>D15B E8 <span class="hljs-number">623F</span>FFFF    call <span class="hljs-number">4010</span>C2
<span class="hljs-number">0040</span>D160 <span class="hljs-number">83</span>C4 <span class="hljs-number">04</span>        add esp, <span class="hljs-number">4</span>
<span class="hljs-number">0040</span>D163 <span class="hljs-number">5</span>D             pop ebp
<span class="hljs-number">0040</span>D164 C2 <span class="hljs-number">1000</span>        ret <span class="hljs-number">10</span>
</code></pre>
<p><img src="/2025/12/11/banda/VMPpart2/en/image11.png" srcset="/img/loading.gif" alt></p>
<p>To trace the program more effectively, I first applied a small patch to the original binary. For reasons I am not certain about (whether intentional or accidental), when run under Intel Pin, this challenge binary stayed in the background and did not respond to my key presses. So I modified the binary so that right after startup it immediately jumps into VM Entry, without waiting for me to press P.</p>
<h3 id="Collecting-Trace-with-Pin"><a href="#Collecting-Trace-with-Pin" class="headerlink" title="Collecting Trace with Pin"></a>Collecting Trace with Pin</h3><p>Intel Pin is a dynamic binary instrumentation tool that lets you inject analysis code into a running program. Regardless of what kind of obfuscation is applied, Pin can intercept and log every single instruction that actually executes. It will not miss even one instruction.</p>
<p>To collect traces, I first identified several key addresses through static analysis:</p>
<ul>
<li><strong>gDispEntry (<code>0x004869BB</code>):</strong> VM Entry (dispatcher entry point)</li>
</ul>
<p><img src="/2025/12/11/banda/VMPpart2/en/image12.png" srcset="/img/loading.gif" alt></p>
<ul>
<li><strong>gHandler82 (<code>0x004181BB</code>):</strong> entry point of a specific handler (ID 82) found through analysis</li>
</ul>
<pre><code class="hljs c"><span class="hljs-number">24566</span> vmtrace.out
i:<span class="hljs-number">0x004869bb</span>:<span class="hljs-number">5</span>:<span class="hljs-number">68</span>EACF8694
r:<span class="hljs-number">0x004869c0</span>:<span class="hljs-number">0x00401dcd</span>:<span class="hljs-number">0x00000000</span>:<span class="hljs-number">0x97010000</span>:<span class="hljs-number">0x00000000</span>:<span class="hljs-number">0x0000000a</span>:<span class="hljs-number">0x004011fc</span>:<span class="hljs-number">0x0019ff28</span>:<span class="hljs-number">0x0019ff20</span>:<span class="hljs-number">0x00000202</span>
i:<span class="hljs-number">0x004869c0</span>:<span class="hljs-number">5</span>:E883A9FFFF
r:<span class="hljs-number">0x00481348</span>:<span class="hljs-number">0x00401dcd</span>:<span class="hljs-number">0x00000000</span>:<span class="hljs-number">0x97010000</span>:<span class="hljs-number">0x00000000</span>:<span class="hljs-number">0x0000000a</span>:<span class="hljs-number">0x004011fc</span>:<span class="hljs-number">0x0019ff28</span>:<span class="hljs-number">0x0019ff1c</span>:<span class="hljs-number">0x00000202</span>
i:<span class="hljs-number">0x00481348</span>:<span class="hljs-number">1</span>:<span class="hljs-number">51</span>
r:<span class="hljs-number">0x00481349</span>:<span class="hljs-number">0x00401dcd</span>:<span class="hljs-number">0x00000000</span>:<span class="hljs-number">0x97010000</span>:<span class="hljs-number">0x00000000</span>:<span class="hljs-number">0x0000000a</span>:<span class="hljs-number">0x004011fc</span>:<span class="hljs-number">0x0019ff28</span>:<span class="hljs-number">0x0019ff18</span>:<span class="hljs-number">0x00000202</span>
i:<span class="hljs-number">0x00481349</span>:<span class="hljs-number">5</span>:E9CA50FBFF
r:<span class="hljs-number">0x00436418</span>:<span class="hljs-number">0x00401dcd</span>:<span class="hljs-number">0x00000000</span>:<span class="hljs-number">0x97010000</span>:<span class="hljs-number">0x00000000</span>:<span class="hljs-number">0x0000000a</span>:<span class="hljs-number">0x004011fc</span>:<span class="hljs-number">0x0019ff28</span>:<span class="hljs-number">0x0019ff18</span>:<span class="hljs-number">0x00000202</span>
i:<span class="hljs-number">0x00436418</span>:<span class="hljs-number">1</span>:<span class="hljs-number">55</span>
</code></pre>
<p>I first extracted from the trace a region corresponding to one full cycle of the VMProtect VM, and that alone already produced on the order of <code>n0,000</code> lines of log. At this scale it becomes essential to split the trace at handler boundaries and automatically identify repeating patterns.</p>
<p>Lines starting with <code>i:</code> record the executed instructions,</p>
<p>and lines starting with <code>r:</code> record the register and stack state at that point.</p>
<p>Jonathan Salwan&#x2019;s <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/JonathanSalwan/VMProtect-devirtualization">VMProtect-devirtualization</a> project was extremely helpful here.</p>
<p><strong>Identifying VM main loop and handler candidates with <code>uniq -c</code></strong></p>
<pre><code class="hljs c"><span class="hljs-number">108</span> <span class="hljs-number">0x0047f287</span>
<span class="hljs-number">108</span> <span class="hljs-number">0x0044a8ae</span>
<span class="hljs-number">108</span> <span class="hljs-number">0x0044a8ac</span>
<span class="hljs-number">108</span> <span class="hljs-number">0x0044a8ab</span>
<span class="hljs-number">108</span> <span class="hljs-number">0x0044a8a7</span>
<span class="hljs-number">107</span> <span class="hljs-number">0x004181bb</span>
 <span class="hljs-number">64</span> <span class="hljs-number">0x00464679</span>
 <span class="hljs-number">10</span> <span class="hljs-number">0x0049acd6</span>
 <span class="hljs-number">10</span> <span class="hljs-number">0x0049acd4</span>
 <span class="hljs-number">10</span> <span class="hljs-number">0x0049acd2</span>
</code></pre>
<p>I computed the execution count per address from the trace, using a <code>uniq -c</code> style analysis to list the most frequently executed locations. Static analysis then allowed me to categorize them as follows:</p>
<ul>
<li><p>Highest frequency, 108 times: VM dispatcher</p>
<ul>
<li><p><strong>VM Dispatcher</strong></p>
<p>  Addresses like <code>0x0047f287</code> and <code>0x0044a8a7</code> appeared exactly 108 times each. These are pieces of dispatcher code. The dispatcher implements the CPU-like cycle in software (fetch &#x2192; decode &#x2192; dispatch &#x2192; execute). Since the dispatcher itself does not perform interesting semantics, we can skip over it for now.</p>
</li>
</ul>
</li>
<li><p>Second highest frequency, 107 times: handler ID 82</p>
<ul>
<li><p><strong>Most frequently used handler (<code>LCONST</code>)</strong></p>
<p>  Address <code>0x004181BB</code> is a strong candidate for a constant-load handler once we consider VMProtect&#x2019;s stack-based VM design. In a stack machine, most operations happen on the stack, so load/copy/move-style operations tend to be used heavily. Prioritizing the most frequently executed handler for analysis is usually efficient.</p>
</li>
</ul>
</li>
</ul>
<h3 id="Running-the-Pin-Trace-Again"><a href="#Running-the-Pin-Trace-Again" class="headerlink" title="Running the Pin Trace Again"></a>Running the Pin Trace Again</h3><p>I then extended the original Pin tool (based on the template provided with Intel Pin) into a specialized Pintool that captures only the ID 82 handler. The goal is to reverse engineer what the VMProtect VM actually does for this single opcode.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image13.png" srcset="/img/loading.gif" alt></p>
<p>To capture the behavior of a single VM instruction dynamically, I built Pin support to:</p>
<ul>
<li>Anchor each VM instruction using two fixed IP locations</li>
<li>Capture the 4 bytes pointed to by <code>ESI</code> at the moment the bytecode is loaded</li>
<li>Record <code>EAX</code>/<code>EDI</code> at the point where the handler finishes its computation and pushes the result onto the stack (using Pin&#x2019;s CONTEXT)</li>
</ul>
<p><img src="/2025/12/11/banda/VMPpart2/en/image14.png" srcset="/img/loading.gif" alt></p>
<p>Using the built <code>MyPinTool</code>, I collected three types of information:</p>
<p><strong>1. <code>vmtrace.out</code>: the complete x86 instruction trace from dispatcher entry to VM exit</strong></p>
<pre><code class="hljs c"><span class="hljs-meta">#main exe: [0x00400000, 0x00581fff)</span>
<span class="hljs-number">004869b</span>b <span class="hljs-number">68</span> EA CF <span class="hljs-number">86</span> <span class="hljs-number">94</span>
<span class="hljs-number">004869</span>c0 E8 <span class="hljs-number">83</span> A9 FF FF
<span class="hljs-number">00481348</span> <span class="hljs-number">51</span>
<span class="hljs-number">00481349</span> E9 CA <span class="hljs-number">50</span> FB FF
<span class="hljs-number">00436418</span> <span class="hljs-number">55</span>
<span class="hljs-number">00436419</span> <span class="hljs-number">50</span>
<span class="hljs-number">0043641</span>a <span class="hljs-number">66</span> F7 D5
<span class="hljs-number">0043641</span>d E9 <span class="hljs-number">15</span> <span class="hljs-number">92</span> FE FF
<span class="hljs-number">0041f</span>637 <span class="hljs-number">57</span>
<span class="hljs-number">0041f</span>638 <span class="hljs-number">0F</span> BF FF
...
</code></pre>
<p>This file contains every x86 instruction executed from <code>0x004869BB</code> (VM dispatcher entry) until the VM finishes. Each line records the instruction address and machine bytes. The script that walks the trace also dumps a plain text file side by side.</p>
<p><strong>2. <code>bytecode_values.txt</code>: the <code>[ESI]</code> value when entering handler ID 82 (i.e., the VM instruction operand)</strong></p>
<pre><code class="hljs c"><span class="hljs-number">1</span>,<span class="hljs-number">0x0047fa5f</span>,<span class="hljs-number">0x1ecbf564</span>,<span class="hljs-number">0x000271c9</span>,<span class="hljs-number">0x004892af</span>
<span class="hljs-number">2</span>,<span class="hljs-number">0x0045cb33</span>,<span class="hljs-number">0x1ec6b25f</span>,<span class="hljs-number">0xfffcff9f</span>,<span class="hljs-number">0x00432085</span>
<span class="hljs-number">3</span>,<span class="hljs-number">0x0046ef95</span>,<span class="hljs-number">0x1ec5393d</span>,<span class="hljs-number">0xfffdab5b</span>,<span class="hljs-number">0x0043cc41</span>
# Total ID82 calls: <span class="hljs-number">3</span>
</code></pre>
<p>If we open the extracted <code>bytecode_values.txt</code>, we can see which constants/operands were fed into handler ID 82. By comparing the operand patterns across multiple calls, we can infer whether this handler is pushing constants onto the stack, applying certain transforms to the operand, or using it as an index, and so on. Later, we will feed these concrete values into Triton when performing symbolic execution.</p>
<p><strong>3. <code>id82_registers.txt</code>: register snapshots at handler entry</strong></p>
<pre><code class="hljs c">=== VM Entry (<span class="hljs-number">0x004869bb</span>) ===
INIT_ESI=<span class="hljs-number">0x0000000a</span>
INIT_EBP=<span class="hljs-number">0x0019ff74</span>
INIT_ESP=<span class="hljs-number">0x0019ff04</span>
===========================

ID82_001: IP=<span class="hljs-number">0x004323ff</span> EAX=<span class="hljs-number">0x000271c9</span> EBX=<span class="hljs-number">0x00458b96</span> ECX=<span class="hljs-number">0x00000020</span> EDX=<span class="hljs-number">0x00000000</span> ESI=<span class="hljs-number">0x0047fa63</span> EDI=<span class="hljs-number">0x004892af</span> EBP=<span class="hljs-number">0x0019fed8</span> ESP=<span class="hljs-number">0x0019fe18</span> BYTECODE=<span class="hljs-number">0x1ecbf564</span>
ID82_002: IP=<span class="hljs-number">0x004323ff</span> EAX=<span class="hljs-number">0xfffcff9f</span> EBX=<span class="hljs-number">0xffb934ac</span> ECX=<span class="hljs-number">0x00000020</span> EDX=<span class="hljs-number">0x0000422a</span> ESI=<span class="hljs-number">0x0045cb37</span> EDI=<span class="hljs-number">0x00432085</span> EBP=<span class="hljs-number">0x0019fcd0</span> ESP=<span class="hljs-number">0x0019fc10</span> BYTECODE=<span class="hljs-number">0x1ec6b25f</span>
ID82_003: IP=<span class="hljs-number">0x004323ff</span> EAX=<span class="hljs-number">0xfffdab5b</span> EBX=<span class="hljs-number">0xffbb44ce</span> ECX=<span class="hljs-number">0xdcedb11a</span> EDX=<span class="hljs-number">0x00000000</span> ESI=<span class="hljs-number">0x0046ef99</span> EDI=<span class="hljs-number">0x0043cc41</span> EBP=<span class="hljs-number">0x0019fcc0</span> ESP=<span class="hljs-number">0x0019fc00</span> BYTECODE=<span class="hljs-number">0x1ec5393d</span>

# Total ID82 calls: <span class="hljs-number">3</span>
</code></pre>
<p>This file logs the VM entry state and, for each ID 82 call, the exact register values right before executing the handler, along with the bytecode operand (<code>BYTECODE</code>). In other words, for handler ID 82 we now have:</p>
<ul>
<li>The handler&#x2019;s code</li>
<li>Its input (bytecode and register state)</li>
<li>The initial VM state at entry</li>
</ul>
<p>This matches our goal of fully reconstructing the semantics of a single VM opcode.</p>
<h3 id="Splitting-the-VM-only-trace-by-ID-82-execution-segments"><a href="#Splitting-the-VM-only-trace-by-ID-82-execution-segments" class="headerlink" title="Splitting the VM-only trace by ID 82 execution segments"></a>Splitting the VM-only trace by ID 82 execution segments</h3><p>With these logs in hand, we can now start restoring the meaning of individual VM handlers.</p>
<pre><code class="hljs c">total ins: <span class="hljs-number">58414</span>
ID82 entries: <span class="hljs-number">107</span>
<span class="hljs-function">ID82 <span class="hljs-title">segments</span> <span class="hljs-params">(with glue)</span>: 106</span>
written id82_segments.json
</code></pre>
<p>To do that, I wrote a script that takes <code>vmtrace.out</code>, locates each occurrence of ID 82, and slices the trace into segments corresponding to &#x201C;one execution of ID 82, including its glue code.&#x201D; Each such segment is then written into a JSON file. Earlier we counted 107 entries for ID 82; the script extracted 106 segments into the JSON.</p>
<pre><code class="hljs c">{
  <span class="hljs-string">&quot;idx&quot;</span>: <span class="hljs-number">1</span>,
  <span class="hljs-string">&quot;start_ip&quot;</span>: <span class="hljs-number">4293051</span>,
  <span class="hljs-string">&quot;end_ip&quot;</span>: <span class="hljs-number">4715143</span>,
  <span class="hljs-string">&quot;ins&quot;</span>: [
    <span class="hljs-string">&quot;004181bb FF E7&quot;</span>,
    <span class="hljs-string">&quot;00468429 8B C5&quot;</span>,
    <span class="hljs-string">&quot;0046842b 66 85 F2&quot;</span>,
    <span class="hljs-string">&quot;0046842e 81 ED 04 00 00 00&quot;</span>,
    <span class="hljs-string">&quot;00468434 66 3B FE&quot;</span>,
    <span class="hljs-string">&quot;00468437 89 44 25 00&quot;</span>,
    <span class="hljs-string">&quot;0046843b 9F&quot;</span>,
    <span class="hljs-string">&quot;0046843c 13 C6&quot;</span>,
    <span class="hljs-string">&quot;0046843e E9 C1 EC FE FF&quot;</span>,
    <span class="hljs-string">&quot;00457104 8B 06&quot;</span>,
    <span class="hljs-string">&quot;00457106 3B E6&quot;</span>,
    <span class="hljs-string">&quot;00457108 81 C6 04 00 00 00&quot;</span>,
    <span class="hljs-string">&quot;0045710e 33 C3&quot;</span>,
    <span class="hljs-string">&quot;00457110 E9 BB 7D FE FF&quot;</span>,
    <span class="hljs-string">&quot;0043eed0 D1 C8&quot;</span>,
    <span class="hljs-string">&quot;0043eed2 35 B9 3D CB 4A&quot;</span>,
    <span class="hljs-string">&quot;0043eed7 F5&quot;</span>,
    <span class="hljs-string">&quot;0043eed8 F9&quot;</span>,
    <span class="hljs-string">&quot;0043eed9 66 85 C4&quot;</span>,
    <span class="hljs-string">&quot;0043eedc 2D 40 01 8C 45&quot;</span>,
    <span class="hljs-string">&quot;0043eee1 E9 FC 23 FF FF&quot;</span>,
    <span class="hljs-string">&quot;004312e2 D1 C0&quot;</span>,
    <span class="hljs-string">&quot;004312e4 33 D8&quot;</span>,
    <span class="hljs-string">&quot;004312e6 03 F8&quot;</span>,
    <span class="hljs-string">&quot;004312e8 E9 B3 DE 02 00&quot;</span>,
    <span class="hljs-string">&quot;0045f1a0 E9 02 B7 FE FF&quot;</span>,
    <span class="hljs-string">&quot;0044a8a7 8D 44 24 60&quot;</span>,
    <span class="hljs-string">&quot;0044a8ab F5&quot;</span>,
    <span class="hljs-string">&quot;0044a8ac 3B E8&quot;</span>,
    <span class="hljs-string">&quot;0044a8ae E9 D4 49 03 00&quot;</span>,
    <span class="hljs-string">&quot;0047f287 0F 87 2E 8F F9 FF&quot;</span>
  ]
}
</code></pre>
<p>Each segment contains the flow from entry into ID 82 &#x2192; various glue/shared code &#x2192; return to the dispatcher. However, there is still a lot of VMProtect-inserted noise mixed in, so this alone does not yet isolate the pure handler body. We need to keep going.</p>
<h3 id="Clustering-ID-82-patterns"><a href="#Clustering-ID-82-patterns" class="headerlink" title="Clustering ID 82 patterns"></a>Clustering ID 82 patterns</h3><pre><code class="hljs c">total segments: <span class="hljs-number">106</span>
unique patterns: <span class="hljs-number">70</span>
==== pattern <span class="hljs-number">1</span> size <span class="hljs-number">5</span>
indices: [<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>, <span class="hljs-number">78</span>, <span class="hljs-number">94</span>]
==== pattern <span class="hljs-number">2</span> size <span class="hljs-number">5</span>
indices: [<span class="hljs-number">21</span>, <span class="hljs-number">43</span>, <span class="hljs-number">62</span>, <span class="hljs-number">82</span>, <span class="hljs-number">99</span>]
==== pattern <span class="hljs-number">3</span> size <span class="hljs-number">4</span>
indices: [<span class="hljs-number">19</span>, <span class="hljs-number">39</span>, <span class="hljs-number">59</span>, <span class="hljs-number">93</span>]
==== pattern <span class="hljs-number">4</span> size <span class="hljs-number">4</span>
indices: [<span class="hljs-number">22</span>, <span class="hljs-number">65</span>, <span class="hljs-number">84</span>, <span class="hljs-number">103</span>]
...
</code></pre>
<p>Next, I loaded the JSON, compared each segment&#x2019;s byte sequence, and grouped those with identical sequences into clusters. When we do this per handler, segments with exactly the same instruction pattern end up in the same cluster. For example, in pattern 1, segments 20, 40, 60, 78, and 94 all share the same sequence of bytes and thus form one cluster.</p>
<p>The purpose of this clustering is to pick one representative pattern per handler. For ID 82, we can choose, say, index 20 from pattern 1 as the canonical example and use it as a reference to understand the handler&#x2019;s semantics.</p>
<h3 id="Simulating-Handler-ID-82-with-Triton"><a href="#Simulating-Handler-ID-82-with-Triton" class="headerlink" title="Simulating Handler ID 82 with Triton"></a>Simulating Handler ID 82 with Triton</h3><p>Using the clustering result, I dumped the bytes for the segment at index 20 (pattern 1) as a contiguous block of x86 code:</p>
<pre><code class="hljs c">written id82_handler.<span class="hljs-keyword">asm</span> from idx <span class="hljs-number">20</span>
<span class="hljs-number">004181b</span>b FF E7
<span class="hljs-number">0044f</span>a7a <span class="hljs-number">0F</span> B6 <span class="hljs-number">06</span>
<span class="hljs-number">0044f</span>a7d <span class="hljs-number">81</span> C6 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">0044f</span>a83 <span class="hljs-number">32</span> C3
<span class="hljs-number">0044f</span>a85 <span class="hljs-number">66</span> F7 C2 DE <span class="hljs-number">7B</span>
<span class="hljs-number">0044f</span>a8a F9
<span class="hljs-number">0044f</span>a8b <span class="hljs-number">2</span>C <span class="hljs-number">3</span>A
<span class="hljs-number">0044f</span>a8d D0 C8
<span class="hljs-number">0044f</span>a8f F6 D8
<span class="hljs-number">0044f</span>a91 E9 <span class="hljs-number">48</span> <span class="hljs-number">9B</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span>
</code></pre>
<p>Comparing this with the corresponding IDA disassembly, we can see the structure more clearly:</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image15.png" srcset="/img/loading.gif" alt></p>
<p><code>0x004181BB: FF E7 &#x2192; 0x004181BB jmp edi</code> is the &#x201C;glue&#x201D; entry point where the dispatcher has already loaded the handler&#x2019;s address into <code>EDI</code> and now jumps there.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image16.png" srcset="/img/loading.gif" alt></p>
<p>From <code>0x0044FA7A</code> onward is the essential body of ID 82&#x2019;s front half.</p>
<p>This code performs <code>movzx eax, byte ptr [esi]</code> / <code>add esi, 1</code> to consume the first byte of bytecode (the opcode), then scrambles <code>AL</code> using <code>XOR</code>, <code>SUB</code>, <code>ROR</code>, <code>NEG</code>, etc., and finally jumps onward. Later, it executes <code>mov eax, [esi]</code> / <code>lea esi, [esi+4]</code> to read 4 bytes, presumably the operand. That 4-byte value is decrypted via a series of operations and used to update <code>EBX</code>. Control then returns to the dispatcher loop at <code>0x4323ff</code>.</p>
<p>So, by combining Pin&#x2019;s trace with IDA disassembly, we have reconstructed the complete native code for handler ID 82 as seen in <code>vmtrace.out</code>. We are almost there.</p>
<p>But this is still not yet the end. To fully understand the mathematical transformation encoded by this handler, we need to load this code into Triton, feed it the initial register state and bytecode values we collected earlier, and perform symbolic execution.</p>
<h3 id="Tracking-state-changes"><a href="#Tracking-state-changes" class="headerlink" title="Tracking state changes"></a>Tracking state changes</h3><p>Using Triton to execute the ID 82 path and compare the registers before and after, we obtain a trace like the following:</p>
<pre><code class="hljs c"><span class="hljs-number">0x4442f2</span>: shr dh, cl
<span class="hljs-number">0x43641a</span>: <span class="hljs-keyword">not</span> bp

--- [ Logic Start (0x41F637) ] ---
<span class="hljs-number">0x41f638</span>: movsx edi, di
<span class="hljs-number">0x41f63c</span>: lahf
<span class="hljs-number">0x41f63d</span>: bts ebp, esi
<span class="hljs-number">0x41f641</span>: cmp bh, <span class="hljs-number">0xb4</span>
<span class="hljs-number">0x41f645</span>: shr bp, <span class="hljs-number">0xa6</span>
<span class="hljs-number">0x41f649</span>: sub ebx, edx
<span class="hljs-number">0x41f64b</span>: test esi, ebp
<span class="hljs-number">0x41f64e</span>: xchg ah, bh
<span class="hljs-number">0x41f650</span>: sub ax, bx
<span class="hljs-number">0x41f653</span>: movsx ebx, bp
<span class="hljs-number">0x41f656</span>: mov eax, <span class="hljs-number">0</span>
<span class="hljs-number">0x41f65b</span>: <span class="hljs-keyword">not</span> si
<span class="hljs-number">0x41f65e</span>: xadd ebp, esi
<span class="hljs-number">0x41f662</span>: mov esi, dword ptr [esp + <span class="hljs-number">0x28</span>]
<span class="hljs-number">0x41f666</span>: add esi, <span class="hljs-number">0x55106798</span>
<span class="hljs-number">0x41f66c</span>: neg esi
<span class="hljs-number">0x41f66e</span>: rol edi, <span class="hljs-number">0x70</span>
<span class="hljs-number">0x41f671</span>: add esi, <span class="hljs-number">0x69733a52</span>
<span class="hljs-number">0x41f677</span>: btr ebp, <span class="hljs-number">0xc0</span>
<span class="hljs-number">0x41f67b</span>: rol esi, <span class="hljs-number">1</span>
<span class="hljs-number">0x41f67d</span>: sbb ebx, <span class="hljs-number">0x37516d2d</span>
<span class="hljs-number">0x41f683</span>: <span class="hljs-keyword">not</span> esi
<span class="hljs-number">0x41f685</span>: clc
<span class="hljs-number">0x41f686</span>: cmp eax, esp
<span class="hljs-number">0x41f688</span>: <span class="hljs-keyword">xor</span> ebp, esp
<span class="hljs-number">0x41f68a</span>: add esi, eax
<span class="hljs-number">0x41f68c</span>: setns al
<span class="hljs-number">0x41f68f</span>: mov ebp, esp
<span class="hljs-number">0x41f691</span>: sub bx, sp
<span class="hljs-number">0x41f694</span>: rol ax, cl
<span class="hljs-number">0x41f697</span>: dec di
<span class="hljs-number">0x41f69a</span>: sub esp, <span class="hljs-number">0xc0</span>
<span class="hljs-number">0x41f6a0</span>: jmp <span class="hljs-number">0x453e79</span>
<span class="hljs-number">0x453e79</span>: mov ebx, esi
<span class="hljs-number">0x453e7b</span>: bt eax, esp
<span class="hljs-number">0x453e7e</span>: btc ax, <span class="hljs-number">0x47</span>
<span class="hljs-number">0x453e83</span>: btr eax, edx
<span class="hljs-number">0x453e86</span>: mov eax, <span class="hljs-number">0</span>
<span class="hljs-number">0x453e8b</span>: jmp <span class="hljs-number">0x4620dd</span>
<span class="hljs-number">0x4620dd</span>: sub ebx, eax
<span class="hljs-number">0x4620df</span>: shld eax, eax, <span class="hljs-number">0xe3</span>
<span class="hljs-number">0x4620e3</span>: sub eax, edi
<span class="hljs-number">0x4620e5</span>: stc
<span class="hljs-number">0x4620e6</span>: lea edi, [<span class="hljs-number">0x4620e6</span>]
<span class="hljs-number">0x4620ec</span>: mov eax, dword ptr [esi]
<span class="hljs-number">0x4620ee</span>: cmc
<span class="hljs-number">0x4620ef</span>: test cl, <span class="hljs-number">0x19</span>
<span class="hljs-number">0x4620f2</span>: lea esi, [esi + <span class="hljs-number">4</span>]
<span class="hljs-number">0x4620f8</span>: cmc
<span class="hljs-number">0x4620f9</span>: test ebx, <span class="hljs-number">0x76f532e4</span>
<span class="hljs-number">0x4620ff</span>: <span class="hljs-keyword">xor</span> eax, ebx
<span class="hljs-number">0x462101</span>: ror eax, <span class="hljs-number">1</span>
<span class="hljs-number">0x462103</span>: stc
<span class="hljs-number">0x462104</span>: <span class="hljs-keyword">xor</span> eax, <span class="hljs-number">0x4acb3db9</span>
<span class="hljs-number">0x462109</span>: sub eax, <span class="hljs-number">0x458c0140</span>
<span class="hljs-number">0x46210e</span>: rol eax, <span class="hljs-number">1</span>
<span class="hljs-number">0x462110</span>: <span class="hljs-keyword">xor</span> ebx, eax
<span class="hljs-number">0x462112</span>: cmc
<span class="hljs-number">0x462113</span>: cmp bx, sp
<span class="hljs-number">0x462116</span>: clc
<span class="hljs-number">0x462117</span>: add edi, eax
<span class="hljs-number">0x462119</span>: jmp <span class="hljs-number">0x4323ff</span>
--- [ Logic End (0x432400) ] ---
</code></pre>
<p>This is the <code>asm</code> trace produced by a Triton-based analysis script. It reconstructs the execution path of handler ID 82 using both <code>vmtrace.out</code> and the bytes from the actual binary.</p>
<p>Comparing registers before and after execution for each test case yields:</p>
<pre><code class="hljs c">=== <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> bc = <span class="hljs-number">0x1ecbf564</span>
init EAX = <span class="hljs-number">0x271c9</span> EBX = <span class="hljs-number">0x458b96</span> ESI = <span class="hljs-number">0x47fa63</span> EDI = <span class="hljs-number">0x4892af</span>
<span class="hljs-keyword">final</span> EAX = <span class="hljs-number">0x19fe78</span>
<span class="hljs-keyword">final</span> EBX = <span class="hljs-number">0xafe65f2</span>
<span class="hljs-keyword">final</span> ECX = <span class="hljs-number">0x20</span>
<span class="hljs-keyword">final</span> EDX = <span class="hljs-number">0x0</span>
<span class="hljs-keyword">final</span> ESI = <span class="hljs-number">0x47fa68</span>
<span class="hljs-keyword">final</span> EDI = <span class="hljs-number">0xb0480ee</span>
<span class="hljs-keyword">final</span> EBP = <span class="hljs-number">0x19fed4</span>
<span class="hljs-keyword">final</span> ESP = <span class="hljs-number">0x19fe18</span>
diff EAX = <span class="hljs-number">0x1b8fb1</span> EBX diff = <span class="hljs-number">0xabbee64</span>

=== <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> bc = <span class="hljs-number">0x1ec6b25f</span>
init EAX = <span class="hljs-number">0xfffcff9f</span> EBX = <span class="hljs-number">0xffb934ac</span> ESI = <span class="hljs-number">0x45cb37</span> EDI = <span class="hljs-number">0x432085</span>
<span class="hljs-keyword">final</span> EAX = <span class="hljs-number">0x19fc70</span>
<span class="hljs-keyword">final</span> EBX = <span class="hljs-number">0x20ae78f3</span>
<span class="hljs-keyword">final</span> ECX = <span class="hljs-number">0x20</span>
<span class="hljs-keyword">final</span> EDX = <span class="hljs-number">0x422a</span>
<span class="hljs-keyword">final</span> ESI = <span class="hljs-number">0x45cb3c</span>
<span class="hljs-keyword">final</span> EDI = <span class="hljs-number">0xdf5a6d09</span>
<span class="hljs-keyword">final</span> EBP = <span class="hljs-number">0x19fccc</span>
<span class="hljs-keyword">final</span> ESP = <span class="hljs-number">0x19fc10</span>
diff EAX = <span class="hljs-number">0xffe503ef</span> EBX diff = <span class="hljs-number">0xdf174c5f</span>

=== <span class="hljs-keyword">case</span> <span class="hljs-number">3</span> bc = <span class="hljs-number">0x1ec5393d</span>
init EAX = <span class="hljs-number">0xfffdab5b</span> EBX = <span class="hljs-number">0xffbb44ce</span> ESI = <span class="hljs-number">0x46ef99</span> EDI = <span class="hljs-number">0x43cc41</span>
<span class="hljs-keyword">final</span> EAX = <span class="hljs-number">0x19fc60</span>
<span class="hljs-keyword">final</span> EBX = <span class="hljs-number">0x20ae78f3</span>
<span class="hljs-keyword">final</span> ECX = <span class="hljs-number">0xdcedb11a</span>
<span class="hljs-keyword">final</span> EDX = <span class="hljs-number">0x0</span>
<span class="hljs-keyword">final</span> ESI = <span class="hljs-number">0x46ef9e</span>
<span class="hljs-keyword">final</span> EDI = <span class="hljs-number">0xdf590927</span>
<span class="hljs-keyword">final</span> EBP = <span class="hljs-number">0x19fcbc</span>
<span class="hljs-keyword">final</span> ESP = <span class="hljs-number">0x19fc00</span>
diff EAX = <span class="hljs-number">0xffe4573b</span> EBX diff = <span class="hljs-number">0xdf153c3d</span>
</code></pre>
<p>We can extract the following key observations:</p>
<p><strong>1. In every case, <code>ESI</code> increases by exactly 5.</strong></p>
<pre><code>- Case 1: `0x47fa63` &#x2192; `0x47fa68` (+5)
- Case 2: `0x45cb37` &#x2192; `0x45cb3c` (+5)
- Case 3: `0x46ef99` &#x2192; `0x46ef9e` (+5)

So handler ID 82 consumes 5 bytes from the bytecode stream. This matches the earlier code: `movzx eax, byte ptr [esi]` / `add esi, 1` consumes the 1-byte opcode, and later `mov eax, [esi]` / `lea esi, [esi + 4]` consumes 4 more bytes. Together, that is `1 + 4 = 5` bytes.
</code></pre><p><strong>2. <code>EBX</code> is updated to a completely new value.</strong></p>
<pre><code>The final `EBX` has no obvious direct relation to its initial value and is clearly the result of some transform. The `bc` (bytecode) values like `0x1ecbf564` go through the decryption routine (involving operations like `NOR`, `ADD`, `ROL`, etc.) to produce the final `EBX` values such as `0x0afe65f2`. Notice that in cases 2 and 3 the final `EBX` is the same: `0x20ae78f3`. Two different encrypted bytecode values (`0x1ec6b25f`, `0x1ec5393d`) converge to the same result, strongly suggesting a decryption function.
</code></pre><p>Putting this together:</p>
<ul>
<li>Handler ID 82 reads from the bytecode stream:<ul>
<li>1 byte for the opcode</li>
<li>4 bytes for an encrypted immediate value</li>
</ul>
</li>
<li>It then runs a complex transform (XOR, SUB, ROL, etc.) on that 4-byte value and writes the result into <code>EBX</code>, effectively placing a constant on the virtual stack.</li>
</ul>
<p>This behavior matches what we would expect from an <code>LCONST</code> / <code>PUSH constant</code>-style handler.</p>
<h3 id="So-what-is-the-actual-arithmetic"><a href="#So-what-is-the-actual-arithmetic" class="headerlink" title="So what is the actual arithmetic?"></a>So what is the actual arithmetic?</h3><pre><code class="hljs c">TARGET_HANDLERS = [
    <span class="hljs-number">0x44A8A7</span>, <span class="hljs-number">0x47F287</span>, <span class="hljs-number">0x4181BB</span>, <span class="hljs-number">0x40356C</span>, <span class="hljs-number">0x404F43</span>,
    <span class="hljs-number">0x405B60</span>, <span class="hljs-number">0x405CB6</span>, <span class="hljs-number">0x405CE2</span>, <span class="hljs-number">0x404F5E</span>, <span class="hljs-number">0x404419</span>,
    <span class="hljs-number">0x404E83</span>, <span class="hljs-number">0x4046BF</span>, <span class="hljs-number">0x4046DC</span>, <span class="hljs-number">0x4892AF</span>, <span class="hljs-number">0x41A261</span>,
    <span class="hljs-number">0x45F79C</span>, <span class="hljs-number">0x496B0F</span>, <span class="hljs-number">0x474C45</span>, <span class="hljs-number">0x437E65</span>, <span class="hljs-number">0x493FB7</span>,
    <span class="hljs-number">0x43CB8A</span>, <span class="hljs-number">0x46688C</span>, <span class="hljs-number">0x45B9AD</span>, <span class="hljs-number">0x432085</span>, <span class="hljs-number">0x484226</span>
]
</code></pre>
<p>The analysis above shows that we cannot reconstruct the full program logic from ID 82 alone. So I extended the same pipeline used for ID 82 to other handlers. Because there are many handlers, I first used static analysis plus trace-based hotspot analysis to pick only those handlers that are frequently called or appear semantically important.</p>
<h3 id="All-the-handlers-reveal-themselves"><a href="#All-the-handlers-reveal-themselves" class="headerlink" title="All the handlers reveal themselves"></a>All the handlers reveal themselves</h3><pre><code class="hljs c">&gt;&gt;&gt; Handler <span class="hljs-number">0x432085</span> (Length: <span class="hljs-number">39</span>)
----------------------------------------
  [M] <span class="hljs-number">0x432085</span>: movzx eax, byte ptr [esi]
  [!] <span class="hljs-number">0x432088</span>: rol cx, <span class="hljs-number">0xc</span>
  [!] <span class="hljs-number">0x43208c</span>: add esi, <span class="hljs-number">1</span>
  [!] <span class="hljs-number">0x432096</span>: <span class="hljs-keyword">xor</span> al, bl
  [!] <span class="hljs-number">0x43209a</span>: ror cx, <span class="hljs-number">0xf6</span>
  [!] <span class="hljs-number">0x43209e</span>: sub al, <span class="hljs-number">0x3a</span>
  [!] <span class="hljs-number">0x4320a0</span>: ror al, <span class="hljs-number">1</span>
  [!] <span class="hljs-number">0x4320a2</span>: neg al
  [!] <span class="hljs-number">0x4320aa</span>: <span class="hljs-keyword">not</span> al
  [!] <span class="hljs-number">0x4320b1</span>: <span class="hljs-keyword">and</span> cx, si
  [!] <span class="hljs-number">0x4320b4</span>: <span class="hljs-keyword">xor</span> bl, al
  [!] <span class="hljs-number">0x4320b6</span>: mov ecx, dword ptr [ebp]
  [!] <span class="hljs-number">0x4320bf</span>: add ebp, <span class="hljs-number">4</span>
  [!] <span class="hljs-number">0x4320c5</span>: mov dword ptr [esp + eax], ecx
  [!] <span class="hljs-number">0x4320c8</span>: ror eax, <span class="hljs-number">0xd2</span>
  [!] <span class="hljs-number">0x4320cb</span>: mov eax, dword ptr [esi]
  [!] <span class="hljs-number">0x4320cd</span>: add esi, <span class="hljs-number">4</span>
  [!] <span class="hljs-number">0x4320de</span>: <span class="hljs-keyword">xor</span> eax, ebx
  [!] <span class="hljs-number">0x4320e1</span>: ror eax, <span class="hljs-number">1</span>
  [!] <span class="hljs-number">0x4320e3</span>: <span class="hljs-keyword">xor</span> eax, <span class="hljs-number">0x4acb3db9</span>
  [!] <span class="hljs-number">0x4320ee</span>: sub eax, <span class="hljs-number">0x458c0140</span>
  [!] <span class="hljs-number">0x4320f3</span>: rol eax, <span class="hljs-number">1</span>
  [!] <span class="hljs-number">0x4320f5</span>: <span class="hljs-keyword">xor</span> ebx, eax
  [!] <span class="hljs-number">0x4320fd</span>: add edi, eax
----------------------------------------
...
</code></pre>
<p>Each of the addresses is the entry point of a VM handler. For each such entry, I repeated the same process used for ID 82:</p>
<ul>
<li>Segment splitting</li>
<li>Pattern clustering</li>
<li>Triton-based semantic extraction</li>
</ul>
<p>The sample above shows the extracted semantics for handler <code>0x00432085</code>. From this we can deduce:</p>
<ul>
<li>It advances <code>ESI</code> and consumes bytes from the bytecode stream</li>
<li>It updates <code>EBX</code>, <code>EDI</code>, and stack locations like <code>[esp + eax]</code> following a consistent pattern</li>
<li>It reads and writes virtual registers located on the stack, combining constants and memory values to construct new values</li>
</ul>
<p>By iterating this process, we can summarize each handler as a higher-level VM instruction: load, store, add, logical operations, branches, and so on. That is, we start to see each handler as one instruction in the VM&#x2019;s instruction set.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image17.png" srcset="/img/loading.gif" alt></p>
<p>Once this is in place, the next step is to map each opcode value to its handler address. For this, I instrumented the VM dispatcher in Pin at the FETCH site and logged the opcode values being read.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image18.png" srcset="/img/loading.gif" alt></p>
<p>Parsing that opcode log together with <code>vmtrace.out</code> allowed me to reverse-map each opcode to a handler entry address. For example, the opcode corresponding to ID 82 turned out to be <code>0x02</code>.</p>
<h3 id="Building-the-Devirtualizer"><a href="#Building-the-Devirtualizer" class="headerlink" title="Building the Devirtualizer"></a>Building the Devirtualizer</h3><p>At this stage we now have a one-to-one mapping between VM bytecodes and the actual handler addresses. The final step is to build a dedicated devirtualizer that reconstructs the entire virtualized function as native x86 and patches it back into the binary.</p>
<p>The overall design is:</p>
<ol>
<li>Read a mapping file that contains opcode (e.g. <code>0x02</code>, <code>0x40</code>, <code>0x88</code> &#x2026;), the handler entry address, and a summary of its semantics. This becomes the opcode &#x2192; [handler address, meaning, pseudocode] table.</li>
<li>Parse the VM bytecode stream from start to finish.</li>
<li><p>For each opcode, emit a corresponding native x86 code snippet which we prepared in advance, for example:</p>
<ul>
<li><code>LCONST</code> &#x2192; <code>MOV EBX, imm32</code></li>
<li><p><code>ADD</code> &#x2192; <code>ADD [ESP+4], EAX</code></p>
<p>  and so on.</p>
</li>
</ul>
</li>
<li><p>Concatenate all these snippets into a single region, forming a new native function body.</p>
</li>
<li>Finally, patch the original binary so that <code>vir_Entry</code> jumps directly into this new native function, bypassing the VM engine.</li>
</ol>
<p><img src="/2025/12/11/banda/VMPpart2/en/image19.png" srcset="/img/loading.gif" alt></p>
<p>Here is part of my devirtualizer code. The loop iterates over each VM instruction and computes the offset into the <code>.vmp0</code> dump via <code>real_vip - VMP_BASE_ADDR</code>. It then skips the 1-byte opcode, looks up the handler name from <code>VM_HANDLERS</code>, and proceeds with reconstruction.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image20.png" srcset="/img/loading.gif" alt></p>
<pre><code class="hljs c">val = (encrypted + <span class="hljs-number">0x55106798</span>) &amp; <span class="hljs-number">0xFFFFFFFF</span>
val = (<span class="hljs-number">0</span> - val) &amp; <span class="hljs-number">0xFFFFFFFF</span>
val = (val + <span class="hljs-number">0x69733a52</span>) &amp; <span class="hljs-number">0xFFFFFFFF</span>
val = ((val &lt;&lt; <span class="hljs-number">1</span>) | (val &gt;&gt; <span class="hljs-number">31</span>)) &amp; <span class="hljs-number">0xFFFFFFFF</span>
decrypted = ~val &amp; <span class="hljs-number">0xFFFFFFFF</span>
</code></pre>
<p>In the comments for each handler, I re-implemented the arithmetic sequence obtained by symbolically executing the handler with Triton, writing it out as 32-bit modular arithmetic in Python, as in the example above.</p>
<p>For instance, suppose the handler takes a 32-bit encrypted constant as input, then applies exactly these steps as observed in the VM:</p>
<ul>
<li>Add a constant</li>
<li>Compute <code>0 - val</code></li>
<li>Add another constant</li>
<li>Rotate left by 1 bit</li>
<li>Apply a bitwise <code>NOT</code></li>
</ul>
<p>We can encode that logic exactly as shown, yielding a <code>decrypted</code> value that matches what the VM computes.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image21.png" srcset="/img/loading.gif" alt></p>
<p>For key handlers like <code>ADD</code>, <code>NOR</code>, <code>COPY</code>, <code>SHL</code>, <code>SHR</code>, I distilled their stack-top operations plus flag reconstruction into clean native code fragments, and then used the Keystone assembler to convert them into machine code. Those bytes were pushed into a <code>patch_buffer</code> in order, and the devirtualizer overwrote a pre-allocated region in a duplicated binary named <code>devirtualizeme_unpacked.exe</code> with this buffer.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image22.png" srcset="/img/loading.gif" alt></p>
<p>At the end of this long journey, we finally get to see the restored native x86 code: the devirtualized function. This code is entirely generated from the data we collected and analyzed and represents the original logic in a straightforward x86 form. If you open this region in IDA on the patched binary, you will now see clean assembly in place of VMP&#x2019;s obfuscated engine code.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image23.png" srcset="/img/loading.gif" alt></p>
<p>To compare before and after, I looked at the beginning of the <code>.vmp0</code> region. Before patching, the section is filled with VMP-specific obfuscated code: meaningless operations and tangled jumps.</p>
<p><img src="/2025/12/11/banda/VMPpart2/en/image24.png" srcset="/img/loading.gif" alt></p>
<p>After patching, the same location now contains a normal native x86 function that pops values from the stack and performs simple operations such as <code>AND</code>, <code>SHR</code>, and <code>SHL</code>. When you run the patched binary, it no longer goes through the VMProtect engine; instead, it executes the restored native function directly. Pressing P still triggers the same virtualized logic and shows the original message box&#x2014;just without the VM.</p>
<h2 id="Wrapping-Up-Devirtualization-Success"><a href="#Wrapping-Up-Devirtualization-Success" class="headerlink" title="Wrapping Up: Devirtualization Success"></a>Wrapping Up: Devirtualization Success</h2><p><img src="/2025/12/11/banda/VMPpart2/en/image25.png" srcset="/img/loading.gif" alt></p>
<p>I will conclude with a screenshot showing the successful devirtualization. For the virtualized target function, I patched <code>vir_Entry</code> so that it jumps directly into the native code block I generated instead of the VMP dispatcher.</p>
<p>Originally I planned to stop at Part 2, but now I feel like trying even harder virtualization challenges and unpacking them as well. While writing Part 2, I also thought a lot about how far one could push devirtualization by combining this approach with LLVM, and if I ever write a follow-up in this series, that will very likely be the topic.</p>
<p>Thank you for joining me on this journey through deobfuscation. &#x1F601;</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://forum.tuts4you.com/topic/39481-devirtualizeme-vmprotect-309/#comment-190252">https://forum.tuts4you.com/topic/39481-devirtualizeme-vmprotect-309/#comment-190252</a></li>
<li><a href="https://hackyboiz.github.io/2025/09/11/banda/LLVM_based_VMP/ko/">https://hackyboiz.github.io/2025/09/11/banda/LLVM_based_VMP/ko/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://whereisr0da.github.io/blog/posts/2021-01-05-vmp-1/">https://whereisr0da.github.io/blog/posts/2021-01-05-vmp-1/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://secret.club/2021/09/08/vmprotect-llvm-lifting-1.html">https://secret.club/2021/09/08/vmprotect-llvm-lifting-1.html</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/banda/">banda</a>
                  
                  <a class="hover-with-bg" href="/tags/VMProtect/">VMProtect</a>
                  
                  <a class="hover-with-bg" href="/tags/Pin/">Pin</a>
                  
                  <a class="hover-with-bg" href="/tags/Triton/">Triton</a>
                  
                  <a class="hover-with-bg" href="/tags/devirtualize/">devirtualize</a>
                  
                  <a class="hover-with-bg" href="/tags/unpack/">unpack</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_banda.jpg" srcset="/img/loading.gif" alt="banda">
                  </div>

                  <div class="link-text">
                    <div class="link-title">banda</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/banda">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">  <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a>  .        .</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/12/13/bekim/2025-12-13/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[] CVE-2025-65108: md-to-pdf Front matter   RCE</span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/12/11/banda/VMPpart2/ko/">
                    <span class="hidden-mobile">[Research] VMProtect Devirtualization: Part 2 (KR)</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/12/11/banda/VMPpart2/en/';
        this.page.identifier = '/2025/12/11/banda/VMPpart2/en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] VMProtect Devirtualization: Part 2 (EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
