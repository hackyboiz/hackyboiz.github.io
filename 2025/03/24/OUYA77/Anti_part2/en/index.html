

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;p&gt;Hello, this is OUYA77. &amp;#x1F642;&lt;/p&gt;
&lt;p&gt;Last time, we explored:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Debugging&lt;/strong&gt;: The process of identifying problematic areas in code, narrowing down the scope, analyzing the cause, and resolving issues.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti-debugging&lt;/strong&gt;: Techniques used to detect or disrupt debuggers to protect software from reverse engineering and analysis.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you haven&amp;#x2019;t checked it out yet, here&amp;#x2019;s the link! &amp;#x1F447; &amp;#x1F606;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hackyboiz.github.io/2024/12/29/OUYA77/Anti_part1/en/&#34;&gt;&lt;em&gt;Previous Part: Anti-Debugging Part 1 (EN)&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In our discussion on anti-debugging techniques, we covered two main categories: &lt;strong&gt;Static&lt;/strong&gt; and &lt;strong&gt;Dynamic&lt;/strong&gt; methods. &lt;strong&gt;Static&lt;/strong&gt; anti-debugging techniques rely on system information or APIs to check if a debugger is attached. For example, in Windows, the &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; function can be used to detect a debugger. &lt;strong&gt;Dynamic&lt;/strong&gt; techniques, on the other hand, detect debugging through behavioral patterns during program execution, such as timing-based anti-debugging.&lt;/p&gt;
&lt;h2 id=&#34;Bypassing-Anti-Debugging-Techniques&#34;&gt;&lt;a href=&#34;#Bypassing-Anti-Debugging-Techniques&#34; class=&#34;headerlink&#34; title=&#34;Bypassing Anti-Debugging Techniques&#34;&gt;&lt;/a&gt;Bypassing Anti-Debugging Techniques&lt;/h2&gt;&lt;h3 id=&#34;Bypassing-Static-Anti-Debugging&#34;&gt;&lt;a href=&#34;#Bypassing-Static-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;Bypassing Static Anti-Debugging&#34;&gt;&lt;/a&gt;Bypassing Static Anti-Debugging&lt;/h3&gt;&lt;p&gt;Static techniques are relatively simple to implement but can also be bypassed with ease. Here are some common methods to circumvent them:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;API Hooking&lt;/strong&gt;: By hooking API functions used for debugger detection, we can intercept and modify their behavior. For instance, in Windows, hooking &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; to always return false can effectively hide the debugger.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Manipulating the PEB Structure&lt;/strong&gt;: The &lt;code&gt;BeingDebugged&lt;/code&gt; flag in the Process Environment Block (PEB) can be directly modified to conceal the presence of a debugger.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;Bypassing-Dynamic-Anti-Debugging&#34;&gt;&lt;a href=&#34;#Bypassing-Dynamic-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;Bypassing Dynamic Anti-Debugging&#34;&gt;&lt;/a&gt;Bypassing Dynamic Anti-Debugging&lt;/h3&gt;&lt;p&gt;Dynamic techniques rely on runtime environmental changes and conditions, so bypassing them requires a deep understanding of the program&amp;#x2019;s execution flow. Here are some common bypassing methods:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Timing-based Evasion&lt;/strong&gt;: Timing-based anti-debugging detects debuggers by measuring execution speed. To bypass this, tools like IDA can be used to patch the code and modify timing checks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exception Handling Manipulation&lt;/strong&gt;: Some dynamic techniques detect debuggers by triggering and monitoring exceptions. To evade this, exception-handling routines can be altered to prevent debugger detection.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Hands-on-Practice&#34;&gt;&lt;a href=&#34;#Hands-on-Practice&#34; class=&#34;headerlink&#34; title=&#34;Hands-on Practice&#34;&gt;&lt;/a&gt;Hands-on Practice&lt;/h1&gt;&lt;p&gt;Now, let&amp;#x2019;s dive into a hands-on exercise.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Environment Setup&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS: Windows 11&lt;/li&gt;
&lt;li&gt;Binary Architecture: 32-bit&lt;/li&gt;
&lt;li&gt;Debugging Tool: IDA Freeware 8.4&lt;/li&gt;
&lt;li&gt;IDE: Visual Studio 2022&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this setup, we will build a 32-bit binary and use IDA Freeware to debug a binary with anti-debugging techniques applied.&lt;/p&gt;
&lt;h2 id=&#34;Static-Anti-Debugging-Bypass-Practice&#34;&gt;&lt;a href=&#34;#Static-Anti-Debugging-Bypass-Practice&#34; class=&#34;headerlink&#34; title=&#34;Static Anti-Debugging Bypass Practice&#34;&gt;&lt;/a&gt;Static Anti-Debugging Bypass Practice&lt;/h2&gt;&lt;h3 id=&#34;1-Basic-Program&#34;&gt;&lt;a href=&#34;#1-Basic-Program&#34; class=&#34;headerlink&#34; title=&#34;1. Basic Program&#34;&gt;&lt;/a&gt;1. Basic Program&lt;/h3&gt;&lt;p&gt;As demonstrated in &amp;#x201C;Part 1,&amp;#x201D; let&amp;#x2019;s create a simple program with anti-debugging measures.&lt;/p&gt;
&lt;p&gt;Open Visual Studio 2022, create an empty project, add a &lt;code&gt;main.cpp&lt;/code&gt; file, and build it as an x86 binary.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// main.cpp&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (IsDebuggerPresent()) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected!\n&amp;quot;&lt;/span&gt;);
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;No debugger found.\n&amp;quot;&lt;/span&gt;);
    }

    system(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;pause&amp;quot;&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After building the executable, navigate to the &lt;code&gt;./Debug&lt;/code&gt; folder and run the compiled binary. You should see the message: &lt;code&gt;No debugger found.&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now, let&amp;#x2019;s try debugging this program using IDA Freeware. Load the binary into IDA, press &lt;strong&gt;F9&lt;/strong&gt; to start debugging, and&amp;#x2026;!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;As seen above, the program detects the debugger using the &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; function and displays a detection message.&lt;/p&gt;
&lt;p&gt;This binary employs &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; to check for a debugger. But what if this function is disabled or modified? Let&amp;#x2019;s bypass &lt;strong&gt;Static Anti-Debugging&lt;/strong&gt; using &lt;strong&gt;API Hooking&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;2-API-Hooking-Practice-Bypassing-Static-Anti-Debugging&#34;&gt;&lt;a href=&#34;#2-API-Hooking-Practice-Bypassing-Static-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;2. API Hooking Practice (Bypassing Static Anti-Debugging)&#34;&gt;&lt;/a&gt;&lt;strong&gt;2. API Hooking Practice (Bypassing Static Anti-Debugging)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;We will use the &lt;strong&gt;Microsoft Detours&lt;/strong&gt; library to perform API Hooking. This library allows us to intercept API calls and modify their behavior to prevent debugger detection.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download the compressed file from &lt;a href=&#34;https://github.com/microsoft/detours&#34;&gt;Microsoft Detours git&lt;/a&gt;, extract it to a preferred folder.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Open &lt;strong&gt;Visual Studio 2022&lt;/strong&gt; and launch the terminal.&lt;/p&gt;
&lt;p&gt; &lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run &lt;code&gt;nmake&lt;/code&gt; to build the source code. This will generate the &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;lib&lt;/code&gt; directories.&lt;/p&gt;
&lt;p&gt; &lt;img src=&#34;image%205.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In &lt;strong&gt;Visual Studio&lt;/strong&gt;, go to &lt;strong&gt;Project &amp;gt; Properties&lt;/strong&gt;, set &lt;strong&gt;Configuration&lt;/strong&gt; to &lt;strong&gt;All Configurations&lt;/strong&gt;, and &lt;strong&gt;Platform&lt;/strong&gt; to &lt;strong&gt;Win32&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt; &lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the &lt;strong&gt;Detours&lt;/strong&gt; library to Visual Studio.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;C/C++ Properties: Adding Include Directory&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open &lt;strong&gt;Project Properties&lt;/strong&gt; and select &lt;strong&gt;C/C++&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Navigate to &lt;strong&gt;General &amp;gt; Additional Include Directories&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the installation path for Detours:&lt;/p&gt;
&lt;p&gt; &lt;code&gt;C:\Users\OUYA77\Desktop\Detours-main\include&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click &lt;strong&gt;OK&lt;/strong&gt; to save changes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Linker Properties: Adding Library Directory&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;In &lt;strong&gt;Project Properties&lt;/strong&gt;, go to &lt;strong&gt;Linker&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Navigate to &lt;strong&gt;General &amp;gt; Additional Library Directories&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the installation path for Detours:&lt;/p&gt;
&lt;p&gt; &lt;code&gt;C:\Users\OUYA77\Desktop\Detours-main\lib&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click &lt;strong&gt;OK&lt;/strong&gt; to save changes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If your environment is ready, create &lt;strong&gt;dllmain.cpp&lt;/strong&gt; to begin API Hooking! &amp;#x1F680;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// dllmain.cpp&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; comment(lib, &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;detours.lib&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, actually bypass Static Anti-Debugging by hooking the &lt;strong&gt;&lt;code&gt;IsDebuggerPresent()&lt;/code&gt;&lt;/strong&gt; function using Detours.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// main.cpp&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;detours.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-comment&#34;&gt;// Function to hook IsDebuggerPresent()&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;BOOL WINAPI &lt;span class=&#34;hljs-title&#34;&gt;HookedIsDebuggerPresent&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; FALSE; &lt;span class=&#34;hljs-comment&#34;&gt;// Always return that no debugger is present&lt;/span&gt;
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Hook IsDebuggerPresent()&lt;/span&gt;
    HMODULE hKernel32 = GetModuleHandleA(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;kernel32.dll&amp;quot;&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (hKernel32) {
        FARPROC pIsDebuggerPresent = GetProcAddress(hKernel32, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;IsDebuggerPresent&amp;quot;&lt;/span&gt;);
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (pIsDebuggerPresent) {
            &lt;span class=&#34;hljs-comment&#34;&gt;// Hooking using the Detours library&lt;/span&gt;
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());
            DetourAttach(&amp;amp;(PVOID&amp;amp;)pIsDebuggerPresent, HookedIsDebuggerPresent);
            DetourTransactionCommit();
        }
    }
    &lt;span class=&#34;hljs-comment&#34;&gt;// Test&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (IsDebuggerPresent()) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected!\n&amp;quot;&lt;/span&gt;);
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;No debugger found.\n&amp;quot;&lt;/span&gt;);
    }
    system(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;pause&amp;quot;&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build the above source code and conduct the same test as before.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Naturally, when executed locally without a debugger attached, it prints &lt;code&gt;No debugger found.&lt;/code&gt; Now, what happens if we attach a debugger to the binary using IDA?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;OUYA&amp;#x2026;(It is interjection, means Oh wow&amp;#x2026;, Oh my God..) Even while debugging in IDA, it still executes as if no debugger is present.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1b18ed6b-05c4-4b20-a412-522bd1c12bb3.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;This demonstrates how easily Static Anti-Debugging can be bypassed through API hooking.&lt;/p&gt;
&lt;p&gt;Since Static Anti-Debugging techniques rely on various system information, they can be bypassed by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hooking functions&lt;/strong&gt; commonly used for anti-debugging, such as &lt;code&gt;NtQueryInformationProcess()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Directly modifying&lt;/strong&gt; anti-debugging-related information in memory, such as the PEB&amp;#x2019;s &lt;code&gt;BeingDebugged&lt;/code&gt; flag&lt;ul&gt;
&lt;li&gt;These friends are typically manipulated by anti-debugging functions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, how can we bypass &lt;strong&gt;Dynamic Anti-Debugging&lt;/strong&gt;, which exploits the debugger&amp;#x2019;s mechanics? Unlike Static Anti-Debugging, which only needs to be bypassed once, Dynamic Anti-Debugging is applied continuously during execution, requiring either repeated bypassing or a more fundamental approach.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s explore bypassing &lt;strong&gt;Dynamic Anti-Debugging&lt;/strong&gt; techniques and observe the differences!&lt;/p&gt;
&lt;h2 id=&#34;Dynamic-Anti-Debugging-Bypass-Practice&#34;&gt;&lt;a href=&#34;#Dynamic-Anti-Debugging-Bypass-Practice&#34; class=&#34;headerlink&#34; title=&#34;Dynamic Anti-Debugging Bypass Practice&#34;&gt;&lt;/a&gt;Dynamic Anti-Debugging Bypass Practice&lt;/h2&gt;&lt;h3 id=&#34;1-Regular-Program&#34;&gt;&lt;a href=&#34;#1-Regular-Program&#34; class=&#34;headerlink&#34; title=&#34;1. Regular Program&#34;&gt;&lt;/a&gt;1. Regular Program&lt;/h3&gt;&lt;p&gt;For the Dynamic Anti-Debugging practice, we&amp;#x2019;ll use &lt;strong&gt;timing-based anti-debugging&lt;/strong&gt; techniques introduced in &amp;#x201C;Part 1.&amp;#x201D; Please build the following code as an x86 binary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// main.cpp&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-comment&#34;&gt;// Key decryption function&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;decryptKey&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt;* key)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-built_in&#34;&gt;strlen&lt;/span&gt;(key); i++) {
        key[i] = key[i] - &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// Simple Caesar cipher&lt;/span&gt;
    }
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Function to process important data&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;processImportantData&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt;* key)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Processing important data with key: %s\n&amp;quot;&lt;/span&gt;, key);
    &lt;span class=&#34;hljs-comment&#34;&gt;// Print a simple message&lt;/span&gt;
    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Important data processed successfully!\n&amp;quot;&lt;/span&gt;);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; key[] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;nztfdsfulfz&amp;quot;&lt;/span&gt;;

    &lt;span class=&#34;hljs-comment&#34;&gt;// [1] Timing-based anti-debugging: Measure execution time and detect if an abnormal delay occurs, indicating a debugger is attached.&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; start_time = GetTickCount64();
    decryptKey(key);
    &lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; end_time = GetTickCount64();

    &lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; elapsed_time = end_time - start_time;

    &lt;span class=&#34;hljs-comment&#34;&gt;// [2] If execution takes longer than 1 second, assume a debugger is attached.&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (elapsed_time &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;1000&lt;/span&gt;) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected!\n&amp;quot;&lt;/span&gt;);
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// Exit the program&lt;/span&gt;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// [3] Execute critical logic using the decrypted key: Compare with the correct key to determine valid execution.&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;hljs-built_in&#34;&gt;strcmp&lt;/span&gt;(key, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;mysecretkey&amp;quot;&lt;/span&gt;) == &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;) {
        processImportantData(key);
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Invalid key!\n&amp;quot;&lt;/span&gt;);
    }

    system(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;pause&amp;quot;&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code implements timing-based anti-debugging to protect the critical decryption logic ([1]). If an attacker attempts to analyze the key decryption process, the execution time difference will trigger ([2]), causing the program to terminate. Conversely, under normal execution conditions ([3]), the logic proceeds without issue.&lt;/p&gt;
&lt;p&gt;Now, let&amp;#x2019;s build and run the program!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;It runs correctly. In this simple example, it just prints &lt;code&gt;Important data processed successfully!&lt;/code&gt;, but you can imagine a scenario where a critical operation using the key takes place.&lt;/p&gt;
&lt;p&gt;Since we have verified normal execution, let&amp;#x2019;s attempt debugging this program using IDA.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2011.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Given that we are particularly interested in the key decryption logic, set a breakpoint (shortcut: F2) on the decryption function and start debugging (F9). By stepping into (F7) the function and analyzing how the key is decrypted, we can then continue execution. However, as shown below, the program detects debugging activity and terminates.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;2f9db531-4021-4c69-9805-b40c8cb60ee0.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Even though this is a simple example, if the key changed on every execution, even if extracted via debugging, the anti-debugging mechanism would cause the program to terminate, making it impossible to use the extracted key. The effectiveness of anti-debugging depends on the skill level of the attacker; by applying more advanced techniques, the difficulty of analysis can be significantly increased.&lt;/p&gt;
&lt;h3 id=&#34;2-Binary-Patching-Bypassing-Dynamic-Anti-Debugging&#34;&gt;&lt;a href=&#34;#2-Binary-Patching-Bypassing-Dynamic-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;2. Binary Patching (Bypassing Dynamic Anti-Debugging)&#34;&gt;&lt;/a&gt;2. Binary Patching (Bypassing Dynamic Anti-Debugging)&lt;/h3&gt;&lt;p&gt;How can we modify the program&amp;#x2019;s flow to bypass the anti-debugging check?&lt;/p&gt;
&lt;p&gt;We can consider two main approaches:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;#x2460; Neutralizing the timing check&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Locate the &lt;code&gt;GetTickCount64()&lt;/code&gt; function calls and modify them.&lt;ul&gt;
&lt;li&gt;Patch them with NOP instructions or replace them with a function that always returns a constant value.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Modify &lt;code&gt;if (elapsed_time &amp;gt; 1000)&lt;/code&gt; to an impossible condition, like &lt;code&gt;if (elapsed_time &amp;lt; 0)&lt;/code&gt;.&lt;ul&gt;
&lt;li&gt;Alternatively, modify a &lt;code&gt;jmp&lt;/code&gt; instruction to always proceed normally.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2461; Preventing program termination&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Locate &lt;code&gt;printf(&amp;quot;Debugger detected!\n&amp;quot;); return 1;&lt;/code&gt; and patch &lt;code&gt;return 1;&lt;/code&gt; with &lt;strong&gt;NOP (0x90)&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since compiler optimizations may alter the actual implementation, let&amp;#x2019;s examine the binary in IDA.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2012.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;I will patch the instruction at line 16. Normally, CF and ZF flags must be 0 for &lt;code&gt;elapsed_time&lt;/code&gt; to be less than 1 second, but I will modify &lt;code&gt;jbe&lt;/code&gt; to &lt;code&gt;ja&lt;/code&gt; so that the key validation logic only executes when execution takes more than 1 second. By selecting line 16 and examining the assembly, we can see two jump instructions. I will patch the first one with NOP and modify the second one at runtime.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2013.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now, let&amp;#x2019;s set a breakpoint on the key decryption function and ensure debugging lasts longer than 1 second before proceeding.&lt;/p&gt;
&lt;p&gt;When we press F9 to start debugging:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2014.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;We hit the first breakpoint, allowing us to analyze &lt;code&gt;decryptKey&lt;/code&gt;. After analyzing, we continue execution until the second breakpoint.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2015.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;At the second breakpoint, we modify &lt;code&gt;jbe&lt;/code&gt; to &lt;code&gt;ja&lt;/code&gt; using &amp;#x201C;Edit &amp;gt; Patch Program &amp;gt; Assemble,&amp;#x201D; successfully bypassing the anti-debugging check. LOL&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2016.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;In similar situations, other bypass techniques include modifying &lt;code&gt;CF&lt;/code&gt; and &lt;code&gt;ZF&lt;/code&gt; flags at runtime or hooking &lt;code&gt;GetTickCount()&lt;/code&gt; to return a constant value, effectively neutralizing the anti-debugging logic.&lt;/p&gt;
&lt;h1 id=&#34;Conclusion&#34;&gt;&lt;a href=&#34;#Conclusion&#34; class=&#34;headerlink&#34; title=&#34;Conclusion&#34;&gt;&lt;/a&gt;Conclusion&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;Debug_part2.jpg&#34; alt=&#34;Debug_part2.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;The techniques we practiced today are classic examples of bypassing anti-debugging. These techniques are used as &amp;#x201C;trap card&amp;#x201D; to bypass security solutions when they try to block specific actions.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blocking debuggers with Anti-Debugging techniques, bypassing those with Anti-Debugging bypass, &lt;del&gt;countering that with Anti-Anti-Anti-Debugging, and stopping that with Anti-Anti-Anti-Anti tititi Fragile Fragile!&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Anti-Fragile.gif&#34; alt=&#34;K-POP Group LE SSERAFIM&#34;&gt;&lt;/p&gt;
&lt;p&gt;K-POP Group LE SSERAFIM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;Limitations-of-Anti-Debugging&#34;&gt;&lt;a href=&#34;#Limitations-of-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;Limitations of Anti-Debugging&#34;&gt;&lt;/a&gt;Limitations of Anti-Debugging&lt;/h2&gt;&lt;p&gt;Anti-debugging is a core technique that makes code analysis difficult and hinders reverse engineering and vulnerability analysis. It can prevent unauthorized copying, cracking, and misuse of software, especially in areas handling sensitive data like finance, gaming, and security products. (Often featured in CTF challenges!) With its flexibility to be adapted to various environments, it has high effectiveness in detecting and responding when an attacker tries to debug.&lt;/p&gt;
&lt;p&gt;However, as we saw in the practice session today, it is vulnerable to code patching and API hooking. This is because once you know the area, it becomes patchable.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2017.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;???: So why not just hide it? / 000: How!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;9o6emu.gif&#34; alt=&#34;9o6emu.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;By obfuscating the anti-debugging logic, it becomes impossible to understand the technique used. If you cannot identify the anti-debugging method, it becomes much harder to figure out how to bypass it. This combination of static obfuscation techniques and dynamic anti-debugging creates a program that is extremely difficult and complex to analyze. (Maybe I&amp;#x2019;ll cover obfuscation in a future blog post!)&lt;/p&gt;
&lt;h2 id=&#34;Significance&#34;&gt;&lt;a href=&#34;#Significance&#34; class=&#34;headerlink&#34; title=&#34;Significance&#34;&gt;&lt;/a&gt;Significance&lt;/h2&gt;&lt;p&gt;From a malware analysis perspective, reversing and anti-reversing are like an eternal battle between sword and shield. Malware analysts use reversing techniques to uncover how malicious code operates, while malware developers employ anti-reversing techniques to obstruct analysis and keep their code&amp;#x2019;s secrets hidden.&lt;/p&gt;
&lt;p&gt;Even from the standpoint of ethical software developers, reversing and anti-reversing hold significant meaning. Reversing can be used to identify software vulnerabilities and strengthen security, whereas anti-reversing helps protect intellectual property and prevent unauthorized copying.&lt;/p&gt;
&lt;p&gt;Ultimately, reversing and anti-reversing, debugging and anti-debugging, continuously evolve in response to each other, fueling an ongoing battle. In this sense, it feels much like the never-ending struggle between heroes and villains in movies&amp;#x2014;an endless tug-of-war between malware developers and analysts, software developers and attackers. However, the real issue is not the technology itself, but the ethical responsibility of those who wield it. Perhaps our true mission is to use these technologies wisely to build a safer and more trustworthy digital world. How do you think?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2018.jpg&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Thank you for reading the long post. I&amp;#x2019;ll return with better research articles &amp;#x1F642;&lt;/p&gt;
&lt;h3 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;p&gt;&amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xD575;&amp;#xC2EC; &amp;#xC6D0;&amp;#xB9AC;: &amp;#xC545;&amp;#xC131; &amp;#xCF54;&amp;#xB4DC; &amp;#xBD84;&amp;#xC11D;&amp;#xAC00;&amp;#xC758; &amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xC774;&amp;#xC57C;&amp;#xAE30;(&amp;#xC800;&amp;#xC790; &amp;#xC774;&amp;#xC2B9;&amp;#xC6D0;)&lt;/p&gt;
&lt;p&gt;Detoures - &lt;a href=&#34;https://secmem.tistory.com/480&#34;&gt;https://secmem.tistory.com/480&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software&#34;&gt;https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bitdefender.com/en-us/blog/businessinsights/the-differences-between-static-malware-analysis-and-dynamic-malware-analysis&#34;&gt;https://www.bitdefender.com/en-us/blog/businessinsights/the-differences-between-static-malware-analysis-and-dynamic-malware-analysis&lt;/a&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] Anti-Debugging Part 2(EN) - hackyboiz">
  <meta property="og:description" content="&lt;p&gt;Hello, this is OUYA77. &amp;#x1F642;&lt;/p&gt;
&lt;p&gt;Last time, we explored:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Debugging&lt;/strong&gt;: The process of identifying problematic areas in code, narrowing down the scope, analyzing the cause, and resolving issues.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti-debugging&lt;/strong&gt;: Techniques used to detect or disrupt debuggers to protect software from reverse engineering and analysis.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you haven&amp;#x2019;t checked it out yet, here&amp;#x2019;s the link! &amp;#x1F447; &amp;#x1F606;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hackyboiz.github.io/2024/12/29/OUYA77/Anti_part1/en/&#34;&gt;&lt;em&gt;Previous Part: Anti-Debugging Part 1 (EN)&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In our discussion on anti-debugging techniques, we covered two main categories: &lt;strong&gt;Static&lt;/strong&gt; and &lt;strong&gt;Dynamic&lt;/strong&gt; methods. &lt;strong&gt;Static&lt;/strong&gt; anti-debugging techniques rely on system information or APIs to check if a debugger is attached. For example, in Windows, the &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; function can be used to detect a debugger. &lt;strong&gt;Dynamic&lt;/strong&gt; techniques, on the other hand, detect debugging through behavioral patterns during program execution, such as timing-based anti-debugging.&lt;/p&gt;
&lt;h2 id=&#34;Bypassing-Anti-Debugging-Techniques&#34;&gt;&lt;a href=&#34;#Bypassing-Anti-Debugging-Techniques&#34; class=&#34;headerlink&#34; title=&#34;Bypassing Anti-Debugging Techniques&#34;&gt;&lt;/a&gt;Bypassing Anti-Debugging Techniques&lt;/h2&gt;&lt;h3 id=&#34;Bypassing-Static-Anti-Debugging&#34;&gt;&lt;a href=&#34;#Bypassing-Static-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;Bypassing Static Anti-Debugging&#34;&gt;&lt;/a&gt;Bypassing Static Anti-Debugging&lt;/h3&gt;&lt;p&gt;Static techniques are relatively simple to implement but can also be bypassed with ease. Here are some common methods to circumvent them:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;API Hooking&lt;/strong&gt;: By hooking API functions used for debugger detection, we can intercept and modify their behavior. For instance, in Windows, hooking &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; to always return false can effectively hide the debugger.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Manipulating the PEB Structure&lt;/strong&gt;: The &lt;code&gt;BeingDebugged&lt;/code&gt; flag in the Process Environment Block (PEB) can be directly modified to conceal the presence of a debugger.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;Bypassing-Dynamic-Anti-Debugging&#34;&gt;&lt;a href=&#34;#Bypassing-Dynamic-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;Bypassing Dynamic Anti-Debugging&#34;&gt;&lt;/a&gt;Bypassing Dynamic Anti-Debugging&lt;/h3&gt;&lt;p&gt;Dynamic techniques rely on runtime environmental changes and conditions, so bypassing them requires a deep understanding of the program&amp;#x2019;s execution flow. Here are some common bypassing methods:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Timing-based Evasion&lt;/strong&gt;: Timing-based anti-debugging detects debuggers by measuring execution speed. To bypass this, tools like IDA can be used to patch the code and modify timing checks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exception Handling Manipulation&lt;/strong&gt;: Some dynamic techniques detect debuggers by triggering and monitoring exceptions. To evade this, exception-handling routines can be altered to prevent debugger detection.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Hands-on-Practice&#34;&gt;&lt;a href=&#34;#Hands-on-Practice&#34; class=&#34;headerlink&#34; title=&#34;Hands-on Practice&#34;&gt;&lt;/a&gt;Hands-on Practice&lt;/h1&gt;&lt;p&gt;Now, let&amp;#x2019;s dive into a hands-on exercise.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Environment Setup&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS: Windows 11&lt;/li&gt;
&lt;li&gt;Binary Architecture: 32-bit&lt;/li&gt;
&lt;li&gt;Debugging Tool: IDA Freeware 8.4&lt;/li&gt;
&lt;li&gt;IDE: Visual Studio 2022&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this setup, we will build a 32-bit binary and use IDA Freeware to debug a binary with anti-debugging techniques applied.&lt;/p&gt;
&lt;h2 id=&#34;Static-Anti-Debugging-Bypass-Practice&#34;&gt;&lt;a href=&#34;#Static-Anti-Debugging-Bypass-Practice&#34; class=&#34;headerlink&#34; title=&#34;Static Anti-Debugging Bypass Practice&#34;&gt;&lt;/a&gt;Static Anti-Debugging Bypass Practice&lt;/h2&gt;&lt;h3 id=&#34;1-Basic-Program&#34;&gt;&lt;a href=&#34;#1-Basic-Program&#34; class=&#34;headerlink&#34; title=&#34;1. Basic Program&#34;&gt;&lt;/a&gt;1. Basic Program&lt;/h3&gt;&lt;p&gt;As demonstrated in &amp;#x201C;Part 1,&amp;#x201D; let&amp;#x2019;s create a simple program with anti-debugging measures.&lt;/p&gt;
&lt;p&gt;Open Visual Studio 2022, create an empty project, add a &lt;code&gt;main.cpp&lt;/code&gt; file, and build it as an x86 binary.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// main.cpp&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (IsDebuggerPresent()) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected!\n&amp;quot;&lt;/span&gt;);
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;No debugger found.\n&amp;quot;&lt;/span&gt;);
    }

    system(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;pause&amp;quot;&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After building the executable, navigate to the &lt;code&gt;./Debug&lt;/code&gt; folder and run the compiled binary. You should see the message: &lt;code&gt;No debugger found.&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now, let&amp;#x2019;s try debugging this program using IDA Freeware. Load the binary into IDA, press &lt;strong&gt;F9&lt;/strong&gt; to start debugging, and&amp;#x2026;!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;As seen above, the program detects the debugger using the &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; function and displays a detection message.&lt;/p&gt;
&lt;p&gt;This binary employs &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; to check for a debugger. But what if this function is disabled or modified? Let&amp;#x2019;s bypass &lt;strong&gt;Static Anti-Debugging&lt;/strong&gt; using &lt;strong&gt;API Hooking&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;2-API-Hooking-Practice-Bypassing-Static-Anti-Debugging&#34;&gt;&lt;a href=&#34;#2-API-Hooking-Practice-Bypassing-Static-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;2. API Hooking Practice (Bypassing Static Anti-Debugging)&#34;&gt;&lt;/a&gt;&lt;strong&gt;2. API Hooking Practice (Bypassing Static Anti-Debugging)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;We will use the &lt;strong&gt;Microsoft Detours&lt;/strong&gt; library to perform API Hooking. This library allows us to intercept API calls and modify their behavior to prevent debugger detection.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download the compressed file from &lt;a href=&#34;https://github.com/microsoft/detours&#34;&gt;Microsoft Detours git&lt;/a&gt;, extract it to a preferred folder.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Open &lt;strong&gt;Visual Studio 2022&lt;/strong&gt; and launch the terminal.&lt;/p&gt;
&lt;p&gt; &lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run &lt;code&gt;nmake&lt;/code&gt; to build the source code. This will generate the &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;lib&lt;/code&gt; directories.&lt;/p&gt;
&lt;p&gt; &lt;img src=&#34;image%205.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In &lt;strong&gt;Visual Studio&lt;/strong&gt;, go to &lt;strong&gt;Project &amp;gt; Properties&lt;/strong&gt;, set &lt;strong&gt;Configuration&lt;/strong&gt; to &lt;strong&gt;All Configurations&lt;/strong&gt;, and &lt;strong&gt;Platform&lt;/strong&gt; to &lt;strong&gt;Win32&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt; &lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the &lt;strong&gt;Detours&lt;/strong&gt; library to Visual Studio.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;C/C++ Properties: Adding Include Directory&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open &lt;strong&gt;Project Properties&lt;/strong&gt; and select &lt;strong&gt;C/C++&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Navigate to &lt;strong&gt;General &amp;gt; Additional Include Directories&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the installation path for Detours:&lt;/p&gt;
&lt;p&gt; &lt;code&gt;C:\Users\OUYA77\Desktop\Detours-main\include&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click &lt;strong&gt;OK&lt;/strong&gt; to save changes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Linker Properties: Adding Library Directory&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;In &lt;strong&gt;Project Properties&lt;/strong&gt;, go to &lt;strong&gt;Linker&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Navigate to &lt;strong&gt;General &amp;gt; Additional Library Directories&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the installation path for Detours:&lt;/p&gt;
&lt;p&gt; &lt;code&gt;C:\Users\OUYA77\Desktop\Detours-main\lib&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click &lt;strong&gt;OK&lt;/strong&gt; to save changes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If your environment is ready, create &lt;strong&gt;dllmain.cpp&lt;/strong&gt; to begin API Hooking! &amp;#x1F680;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// dllmain.cpp&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; comment(lib, &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;detours.lib&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, actually bypass Static Anti-Debugging by hooking the &lt;strong&gt;&lt;code&gt;IsDebuggerPresent()&lt;/code&gt;&lt;/strong&gt; function using Detours.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// main.cpp&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;detours.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-comment&#34;&gt;// Function to hook IsDebuggerPresent()&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;BOOL WINAPI &lt;span class=&#34;hljs-title&#34;&gt;HookedIsDebuggerPresent&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; FALSE; &lt;span class=&#34;hljs-comment&#34;&gt;// Always return that no debugger is present&lt;/span&gt;
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Hook IsDebuggerPresent()&lt;/span&gt;
    HMODULE hKernel32 = GetModuleHandleA(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;kernel32.dll&amp;quot;&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (hKernel32) {
        FARPROC pIsDebuggerPresent = GetProcAddress(hKernel32, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;IsDebuggerPresent&amp;quot;&lt;/span&gt;);
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (pIsDebuggerPresent) {
            &lt;span class=&#34;hljs-comment&#34;&gt;// Hooking using the Detours library&lt;/span&gt;
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());
            DetourAttach(&amp;amp;(PVOID&amp;amp;)pIsDebuggerPresent, HookedIsDebuggerPresent);
            DetourTransactionCommit();
        }
    }
    &lt;span class=&#34;hljs-comment&#34;&gt;// Test&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (IsDebuggerPresent()) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected!\n&amp;quot;&lt;/span&gt;);
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;No debugger found.\n&amp;quot;&lt;/span&gt;);
    }
    system(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;pause&amp;quot;&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build the above source code and conduct the same test as before.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Naturally, when executed locally without a debugger attached, it prints &lt;code&gt;No debugger found.&lt;/code&gt; Now, what happens if we attach a debugger to the binary using IDA?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;OUYA&amp;#x2026;(It is interjection, means Oh wow&amp;#x2026;, Oh my God..) Even while debugging in IDA, it still executes as if no debugger is present.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1b18ed6b-05c4-4b20-a412-522bd1c12bb3.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;This demonstrates how easily Static Anti-Debugging can be bypassed through API hooking.&lt;/p&gt;
&lt;p&gt;Since Static Anti-Debugging techniques rely on various system information, they can be bypassed by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hooking functions&lt;/strong&gt; commonly used for anti-debugging, such as &lt;code&gt;NtQueryInformationProcess()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Directly modifying&lt;/strong&gt; anti-debugging-related information in memory, such as the PEB&amp;#x2019;s &lt;code&gt;BeingDebugged&lt;/code&gt; flag&lt;ul&gt;
&lt;li&gt;These friends are typically manipulated by anti-debugging functions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, how can we bypass &lt;strong&gt;Dynamic Anti-Debugging&lt;/strong&gt;, which exploits the debugger&amp;#x2019;s mechanics? Unlike Static Anti-Debugging, which only needs to be bypassed once, Dynamic Anti-Debugging is applied continuously during execution, requiring either repeated bypassing or a more fundamental approach.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s explore bypassing &lt;strong&gt;Dynamic Anti-Debugging&lt;/strong&gt; techniques and observe the differences!&lt;/p&gt;
&lt;h2 id=&#34;Dynamic-Anti-Debugging-Bypass-Practice&#34;&gt;&lt;a href=&#34;#Dynamic-Anti-Debugging-Bypass-Practice&#34; class=&#34;headerlink&#34; title=&#34;Dynamic Anti-Debugging Bypass Practice&#34;&gt;&lt;/a&gt;Dynamic Anti-Debugging Bypass Practice&lt;/h2&gt;&lt;h3 id=&#34;1-Regular-Program&#34;&gt;&lt;a href=&#34;#1-Regular-Program&#34; class=&#34;headerlink&#34; title=&#34;1. Regular Program&#34;&gt;&lt;/a&gt;1. Regular Program&lt;/h3&gt;&lt;p&gt;For the Dynamic Anti-Debugging practice, we&amp;#x2019;ll use &lt;strong&gt;timing-based anti-debugging&lt;/strong&gt; techniques introduced in &amp;#x201C;Part 1.&amp;#x201D; Please build the following code as an x86 binary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// main.cpp&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-comment&#34;&gt;// Key decryption function&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;decryptKey&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt;* key)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-built_in&#34;&gt;strlen&lt;/span&gt;(key); i++) {
        key[i] = key[i] - &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// Simple Caesar cipher&lt;/span&gt;
    }
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Function to process important data&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;processImportantData&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt;* key)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Processing important data with key: %s\n&amp;quot;&lt;/span&gt;, key);
    &lt;span class=&#34;hljs-comment&#34;&gt;// Print a simple message&lt;/span&gt;
    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Important data processed successfully!\n&amp;quot;&lt;/span&gt;);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; key[] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;nztfdsfulfz&amp;quot;&lt;/span&gt;;

    &lt;span class=&#34;hljs-comment&#34;&gt;// [1] Timing-based anti-debugging: Measure execution time and detect if an abnormal delay occurs, indicating a debugger is attached.&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; start_time = GetTickCount64();
    decryptKey(key);
    &lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; end_time = GetTickCount64();

    &lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; elapsed_time = end_time - start_time;

    &lt;span class=&#34;hljs-comment&#34;&gt;// [2] If execution takes longer than 1 second, assume a debugger is attached.&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (elapsed_time &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;1000&lt;/span&gt;) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected!\n&amp;quot;&lt;/span&gt;);
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// Exit the program&lt;/span&gt;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// [3] Execute critical logic using the decrypted key: Compare with the correct key to determine valid execution.&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;hljs-built_in&#34;&gt;strcmp&lt;/span&gt;(key, &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;mysecretkey&amp;quot;&lt;/span&gt;) == &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;) {
        processImportantData(key);
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Invalid key!\n&amp;quot;&lt;/span&gt;);
    }

    system(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;pause&amp;quot;&lt;/span&gt;);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code implements timing-based anti-debugging to protect the critical decryption logic ([1]). If an attacker attempts to analyze the key decryption process, the execution time difference will trigger ([2]), causing the program to terminate. Conversely, under normal execution conditions ([3]), the logic proceeds without issue.&lt;/p&gt;
&lt;p&gt;Now, let&amp;#x2019;s build and run the program!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;It runs correctly. In this simple example, it just prints &lt;code&gt;Important data processed successfully!&lt;/code&gt;, but you can imagine a scenario where a critical operation using the key takes place.&lt;/p&gt;
&lt;p&gt;Since we have verified normal execution, let&amp;#x2019;s attempt debugging this program using IDA.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2011.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Given that we are particularly interested in the key decryption logic, set a breakpoint (shortcut: F2) on the decryption function and start debugging (F9). By stepping into (F7) the function and analyzing how the key is decrypted, we can then continue execution. However, as shown below, the program detects debugging activity and terminates.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;2f9db531-4021-4c69-9805-b40c8cb60ee0.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Even though this is a simple example, if the key changed on every execution, even if extracted via debugging, the anti-debugging mechanism would cause the program to terminate, making it impossible to use the extracted key. The effectiveness of anti-debugging depends on the skill level of the attacker; by applying more advanced techniques, the difficulty of analysis can be significantly increased.&lt;/p&gt;
&lt;h3 id=&#34;2-Binary-Patching-Bypassing-Dynamic-Anti-Debugging&#34;&gt;&lt;a href=&#34;#2-Binary-Patching-Bypassing-Dynamic-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;2. Binary Patching (Bypassing Dynamic Anti-Debugging)&#34;&gt;&lt;/a&gt;2. Binary Patching (Bypassing Dynamic Anti-Debugging)&lt;/h3&gt;&lt;p&gt;How can we modify the program&amp;#x2019;s flow to bypass the anti-debugging check?&lt;/p&gt;
&lt;p&gt;We can consider two main approaches:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;#x2460; Neutralizing the timing check&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Locate the &lt;code&gt;GetTickCount64()&lt;/code&gt; function calls and modify them.&lt;ul&gt;
&lt;li&gt;Patch them with NOP instructions or replace them with a function that always returns a constant value.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Modify &lt;code&gt;if (elapsed_time &amp;gt; 1000)&lt;/code&gt; to an impossible condition, like &lt;code&gt;if (elapsed_time &amp;lt; 0)&lt;/code&gt;.&lt;ul&gt;
&lt;li&gt;Alternatively, modify a &lt;code&gt;jmp&lt;/code&gt; instruction to always proceed normally.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2461; Preventing program termination&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Locate &lt;code&gt;printf(&amp;quot;Debugger detected!\n&amp;quot;); return 1;&lt;/code&gt; and patch &lt;code&gt;return 1;&lt;/code&gt; with &lt;strong&gt;NOP (0x90)&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since compiler optimizations may alter the actual implementation, let&amp;#x2019;s examine the binary in IDA.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2012.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;I will patch the instruction at line 16. Normally, CF and ZF flags must be 0 for &lt;code&gt;elapsed_time&lt;/code&gt; to be less than 1 second, but I will modify &lt;code&gt;jbe&lt;/code&gt; to &lt;code&gt;ja&lt;/code&gt; so that the key validation logic only executes when execution takes more than 1 second. By selecting line 16 and examining the assembly, we can see two jump instructions. I will patch the first one with NOP and modify the second one at runtime.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2013.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now, let&amp;#x2019;s set a breakpoint on the key decryption function and ensure debugging lasts longer than 1 second before proceeding.&lt;/p&gt;
&lt;p&gt;When we press F9 to start debugging:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2014.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;We hit the first breakpoint, allowing us to analyze &lt;code&gt;decryptKey&lt;/code&gt;. After analyzing, we continue execution until the second breakpoint.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2015.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;At the second breakpoint, we modify &lt;code&gt;jbe&lt;/code&gt; to &lt;code&gt;ja&lt;/code&gt; using &amp;#x201C;Edit &amp;gt; Patch Program &amp;gt; Assemble,&amp;#x201D; successfully bypassing the anti-debugging check. LOL&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2016.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;In similar situations, other bypass techniques include modifying &lt;code&gt;CF&lt;/code&gt; and &lt;code&gt;ZF&lt;/code&gt; flags at runtime or hooking &lt;code&gt;GetTickCount()&lt;/code&gt; to return a constant value, effectively neutralizing the anti-debugging logic.&lt;/p&gt;
&lt;h1 id=&#34;Conclusion&#34;&gt;&lt;a href=&#34;#Conclusion&#34; class=&#34;headerlink&#34; title=&#34;Conclusion&#34;&gt;&lt;/a&gt;Conclusion&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;Debug_part2.jpg&#34; alt=&#34;Debug_part2.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;The techniques we practiced today are classic examples of bypassing anti-debugging. These techniques are used as &amp;#x201C;trap card&amp;#x201D; to bypass security solutions when they try to block specific actions.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blocking debuggers with Anti-Debugging techniques, bypassing those with Anti-Debugging bypass, &lt;del&gt;countering that with Anti-Anti-Anti-Debugging, and stopping that with Anti-Anti-Anti-Anti tititi Fragile Fragile!&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Anti-Fragile.gif&#34; alt=&#34;K-POP Group LE SSERAFIM&#34;&gt;&lt;/p&gt;
&lt;p&gt;K-POP Group LE SSERAFIM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;Limitations-of-Anti-Debugging&#34;&gt;&lt;a href=&#34;#Limitations-of-Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;Limitations of Anti-Debugging&#34;&gt;&lt;/a&gt;Limitations of Anti-Debugging&lt;/h2&gt;&lt;p&gt;Anti-debugging is a core technique that makes code analysis difficult and hinders reverse engineering and vulnerability analysis. It can prevent unauthorized copying, cracking, and misuse of software, especially in areas handling sensitive data like finance, gaming, and security products. (Often featured in CTF challenges!) With its flexibility to be adapted to various environments, it has high effectiveness in detecting and responding when an attacker tries to debug.&lt;/p&gt;
&lt;p&gt;However, as we saw in the practice session today, it is vulnerable to code patching and API hooking. This is because once you know the area, it becomes patchable.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2017.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;???: So why not just hide it? / 000: How!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;9o6emu.gif&#34; alt=&#34;9o6emu.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;By obfuscating the anti-debugging logic, it becomes impossible to understand the technique used. If you cannot identify the anti-debugging method, it becomes much harder to figure out how to bypass it. This combination of static obfuscation techniques and dynamic anti-debugging creates a program that is extremely difficult and complex to analyze. (Maybe I&amp;#x2019;ll cover obfuscation in a future blog post!)&lt;/p&gt;
&lt;h2 id=&#34;Significance&#34;&gt;&lt;a href=&#34;#Significance&#34; class=&#34;headerlink&#34; title=&#34;Significance&#34;&gt;&lt;/a&gt;Significance&lt;/h2&gt;&lt;p&gt;From a malware analysis perspective, reversing and anti-reversing are like an eternal battle between sword and shield. Malware analysts use reversing techniques to uncover how malicious code operates, while malware developers employ anti-reversing techniques to obstruct analysis and keep their code&amp;#x2019;s secrets hidden.&lt;/p&gt;
&lt;p&gt;Even from the standpoint of ethical software developers, reversing and anti-reversing hold significant meaning. Reversing can be used to identify software vulnerabilities and strengthen security, whereas anti-reversing helps protect intellectual property and prevent unauthorized copying.&lt;/p&gt;
&lt;p&gt;Ultimately, reversing and anti-reversing, debugging and anti-debugging, continuously evolve in response to each other, fueling an ongoing battle. In this sense, it feels much like the never-ending struggle between heroes and villains in movies&amp;#x2014;an endless tug-of-war between malware developers and analysts, software developers and attackers. However, the real issue is not the technology itself, but the ethical responsibility of those who wield it. Perhaps our true mission is to use these technologies wisely to build a safer and more trustworthy digital world. How do you think?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2018.jpg&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Thank you for reading the long post. I&amp;#x2019;ll return with better research articles &amp;#x1F642;&lt;/p&gt;
&lt;h3 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;p&gt;&amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xD575;&amp;#xC2EC; &amp;#xC6D0;&amp;#xB9AC;: &amp;#xC545;&amp;#xC131; &amp;#xCF54;&amp;#xB4DC; &amp;#xBD84;&amp;#xC11D;&amp;#xAC00;&amp;#xC758; &amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xC774;&amp;#xC57C;&amp;#xAE30;(&amp;#xC800;&amp;#xC790; &amp;#xC774;&amp;#xC2B9;&amp;#xC6D0;)&lt;/p&gt;
&lt;p&gt;Detoures - &lt;a href=&#34;https://secmem.tistory.com/480&#34;&gt;https://secmem.tistory.com/480&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software&#34;&gt;https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bitdefender.com/en-us/blog/businessinsights/the-differences-between-static-malware-analysis-and-dynamic-malware-analysis&#34;&gt;https://www.bitdefender.com/en-us/blog/businessinsights/the-differences-between-static-malware-analysis-and-dynamic-malware-analysis&lt;/a&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/03/24/OUYA77/Anti_part2/kr/Debug_part2.jpg">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/03/24/ouya77/anti_part2/en/">

  <title>[Research] Anti-Debugging Part 2(EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-03-24 00:45" pubdate>
      2025년 3월 24일 오전
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.3k 자
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      45
       분
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Anti-Debugging Part 2(EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <p>Hello, this is OUYA77. &#x1F642;</p>
<p>Last time, we explored:</p>
<ul>
<li><strong>Debugging</strong>: The process of identifying problematic areas in code, narrowing down the scope, analyzing the cause, and resolving issues.</li>
<li><strong>Anti-debugging</strong>: Techniques used to detect or disrupt debuggers to protect software from reverse engineering and analysis.</li>
</ul>
<p>If you haven&#x2019;t checked it out yet, here&#x2019;s the link! &#x1F447; &#x1F606;</p>
<p><a href="https://hackyboiz.github.io/2024/12/29/OUYA77/Anti_part1/en/"><em>Previous Part: Anti-Debugging Part 1 (EN)</em></a></p>
<p>In our discussion on anti-debugging techniques, we covered two main categories: <strong>Static</strong> and <strong>Dynamic</strong> methods. <strong>Static</strong> anti-debugging techniques rely on system information or APIs to check if a debugger is attached. For example, in Windows, the <code>IsDebuggerPresent()</code> function can be used to detect a debugger. <strong>Dynamic</strong> techniques, on the other hand, detect debugging through behavioral patterns during program execution, such as timing-based anti-debugging.</p>
<h2 id="Bypassing-Anti-Debugging-Techniques"><a href="#Bypassing-Anti-Debugging-Techniques" class="headerlink" title="Bypassing Anti-Debugging Techniques"></a>Bypassing Anti-Debugging Techniques</h2><h3 id="Bypassing-Static-Anti-Debugging"><a href="#Bypassing-Static-Anti-Debugging" class="headerlink" title="Bypassing Static Anti-Debugging"></a>Bypassing Static Anti-Debugging</h3><p>Static techniques are relatively simple to implement but can also be bypassed with ease. Here are some common methods to circumvent them:</p>
<ol>
<li><strong>API Hooking</strong>: By hooking API functions used for debugger detection, we can intercept and modify their behavior. For instance, in Windows, hooking <code>IsDebuggerPresent()</code> to always return false can effectively hide the debugger.</li>
<li><strong>Manipulating the PEB Structure</strong>: The <code>BeingDebugged</code> flag in the Process Environment Block (PEB) can be directly modified to conceal the presence of a debugger.</li>
</ol>
<h3 id="Bypassing-Dynamic-Anti-Debugging"><a href="#Bypassing-Dynamic-Anti-Debugging" class="headerlink" title="Bypassing Dynamic Anti-Debugging"></a>Bypassing Dynamic Anti-Debugging</h3><p>Dynamic techniques rely on runtime environmental changes and conditions, so bypassing them requires a deep understanding of the program&#x2019;s execution flow. Here are some common bypassing methods:</p>
<ol>
<li><strong>Timing-based Evasion</strong>: Timing-based anti-debugging detects debuggers by measuring execution speed. To bypass this, tools like IDA can be used to patch the code and modify timing checks.</li>
<li><strong>Exception Handling Manipulation</strong>: Some dynamic techniques detect debuggers by triggering and monitoring exceptions. To evade this, exception-handling routines can be altered to prevent debugger detection.</li>
</ol>
<h1 id="Hands-on-Practice"><a href="#Hands-on-Practice" class="headerlink" title="Hands-on Practice"></a>Hands-on Practice</h1><p>Now, let&#x2019;s dive into a hands-on exercise.</p>
<p><strong>Environment Setup</strong></p>
<ul>
<li>OS: Windows 11</li>
<li>Binary Architecture: 32-bit</li>
<li>Debugging Tool: IDA Freeware 8.4</li>
<li>IDE: Visual Studio 2022</li>
</ul>
<p>In this setup, we will build a 32-bit binary and use IDA Freeware to debug a binary with anti-debugging techniques applied.</p>
<h2 id="Static-Anti-Debugging-Bypass-Practice"><a href="#Static-Anti-Debugging-Bypass-Practice" class="headerlink" title="Static Anti-Debugging Bypass Practice"></a>Static Anti-Debugging Bypass Practice</h2><h3 id="1-Basic-Program"><a href="#1-Basic-Program" class="headerlink" title="1. Basic Program"></a>1. Basic Program</h3><p>As demonstrated in &#x201C;Part 1,&#x201D; let&#x2019;s create a simple program with anti-debugging measures.</p>
<p>Open Visual Studio 2022, create an empty project, add a <code>main.cpp</code> file, and build it as an x86 binary.</p>
<p><img src="image.png" srcset="/img/loading.gif" alt="image.png"></p>
<pre><code class="hljs c"><span class="hljs-comment">// main.cpp</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (IsDebuggerPresent()) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugger detected!\n&quot;</span>);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No debugger found.\n&quot;</span>);
    }

    system(<span class="hljs-string">&quot;pause&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>After building the executable, navigate to the <code>./Debug</code> folder and run the compiled binary. You should see the message: <code>No debugger found.</code> </p>
<p><img src="image%201.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Now, let&#x2019;s try debugging this program using IDA Freeware. Load the binary into IDA, press <strong>F9</strong> to start debugging, and&#x2026;!!</p>
<p><img src="image%202.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>As seen above, the program detects the debugger using the <code>IsDebuggerPresent()</code> function and displays a detection message.</p>
<p>This binary employs <code>IsDebuggerPresent()</code> to check for a debugger. But what if this function is disabled or modified? Let&#x2019;s bypass <strong>Static Anti-Debugging</strong> using <strong>API Hooking</strong>.</p>
<h3 id="2-API-Hooking-Practice-Bypassing-Static-Anti-Debugging"><a href="#2-API-Hooking-Practice-Bypassing-Static-Anti-Debugging" class="headerlink" title="2. API Hooking Practice (Bypassing Static Anti-Debugging)"></a><strong>2. API Hooking Practice (Bypassing Static Anti-Debugging)</strong></h3><p>We will use the <strong>Microsoft Detours</strong> library to perform API Hooking. This library allows us to intercept API calls and modify their behavior to prevent debugger detection.</p>
<ol>
<li>Download the compressed file from <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/microsoft/detours">Microsoft Detours git</a>, extract it to a preferred folder.</li>
</ol>
<p><img src="image%203.png" srcset="/img/loading.gif" alt="image.png"></p>
<ol>
<li><p>Open <strong>Visual Studio 2022</strong> and launch the terminal.</p>
<p> <img src="image%204.png" srcset="/img/loading.gif" alt="image.png"></p>
</li>
<li><p>Run <code>nmake</code> to build the source code. This will generate the <code>bin</code>, <code>include</code>, and <code>lib</code> directories.</p>
<p> <img src="image%205.png" srcset="/img/loading.gif" alt="image.png"></p>
<p> <img src="image%206.png" srcset="/img/loading.gif" alt="image.png"></p>
</li>
<li><p>In <strong>Visual Studio</strong>, go to <strong>Project &gt; Properties</strong>, set <strong>Configuration</strong> to <strong>All Configurations</strong>, and <strong>Platform</strong> to <strong>Win32</strong>.</p>
<p> <img src="image%207.png" srcset="/img/loading.gif" alt="image.png"></p>
</li>
<li><p>Add the <strong>Detours</strong> library to Visual Studio.</p>
<ul>
<li><p><strong>C/C++ Properties: Adding Include Directory</strong></p>
<ol>
<li>Open <strong>Project Properties</strong> and select <strong>C/C++</strong>.</li>
<li>Navigate to <strong>General &gt; Additional Include Directories</strong>.</li>
<li><p>Add the installation path for Detours:</p>
<p> <code>C:\Users\OUYA77\Desktop\Detours-main\include</code></p>
</li>
<li><p>Click <strong>OK</strong> to save changes.</p>
</li>
</ol>
</li>
<li><p><strong>Linker Properties: Adding Library Directory</strong></p>
<ol>
<li>In <strong>Project Properties</strong>, go to <strong>Linker</strong>.</li>
<li>Navigate to <strong>General &gt; Additional Library Directories</strong>.</li>
<li><p>Add the installation path for Detours:</p>
<p> <code>C:\Users\OUYA77\Desktop\Detours-main\lib</code></p>
</li>
<li><p>Click <strong>OK</strong> to save changes.</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>If your environment is ready, create <strong>dllmain.cpp</strong> to begin API Hooking! &#x1F680;</p>
<pre><code class="hljs c"><span class="hljs-comment">// dllmain.cpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;detours.lib&quot;</span>)</span></code></pre>
<p>Now, actually bypass Static Anti-Debugging by hooking the <strong><code>IsDebuggerPresent()</code></strong> function using Detours.</p>
<pre><code class="hljs c"><span class="hljs-comment">// main.cpp</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;detours.h&gt;</span></span>

<span class="hljs-comment">// Function to hook IsDebuggerPresent()</span>
<span class="hljs-function">BOOL WINAPI <span class="hljs-title">HookedIsDebuggerPresent</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> FALSE; <span class="hljs-comment">// Always return that no debugger is present</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">// Hook IsDebuggerPresent()</span>
    HMODULE hKernel32 = GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>);
    <span class="hljs-keyword">if</span> (hKernel32) {
        FARPROC pIsDebuggerPresent = GetProcAddress(hKernel32, <span class="hljs-string">&quot;IsDebuggerPresent&quot;</span>);
        <span class="hljs-keyword">if</span> (pIsDebuggerPresent) {
            <span class="hljs-comment">// Hooking using the Detours library</span>
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());
            DetourAttach(&amp;(PVOID&amp;)pIsDebuggerPresent, HookedIsDebuggerPresent);
            DetourTransactionCommit();
        }
    }
    <span class="hljs-comment">// Test</span>
    <span class="hljs-keyword">if</span> (IsDebuggerPresent()) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugger detected!\n&quot;</span>);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No debugger found.\n&quot;</span>);
    }
    system(<span class="hljs-string">&quot;pause&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Build the above source code and conduct the same test as before.</p>
<p><img src="image%208.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Naturally, when executed locally without a debugger attached, it prints <code>No debugger found.</code> Now, what happens if we attach a debugger to the binary using IDA?</p>
<p><img src="image%209.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>OUYA&#x2026;(It is interjection, means Oh wow&#x2026;, Oh my God..) Even while debugging in IDA, it still executes as if no debugger is present.</p>
<p><img src="1b18ed6b-05c4-4b20-a412-522bd1c12bb3.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>This demonstrates how easily Static Anti-Debugging can be bypassed through API hooking.</p>
<p>Since Static Anti-Debugging techniques rely on various system information, they can be bypassed by:</p>
<ul>
<li><strong>Hooking functions</strong> commonly used for anti-debugging, such as <code>NtQueryInformationProcess()</code></li>
<li><strong>Directly modifying</strong> anti-debugging-related information in memory, such as the PEB&#x2019;s <code>BeingDebugged</code> flag<ul>
<li>These friends are typically manipulated by anti-debugging functions.</li>
</ul>
</li>
</ul>
<p>So, how can we bypass <strong>Dynamic Anti-Debugging</strong>, which exploits the debugger&#x2019;s mechanics? Unlike Static Anti-Debugging, which only needs to be bypassed once, Dynamic Anti-Debugging is applied continuously during execution, requiring either repeated bypassing or a more fundamental approach.</p>
<p>Let&#x2019;s explore bypassing <strong>Dynamic Anti-Debugging</strong> techniques and observe the differences!</p>
<h2 id="Dynamic-Anti-Debugging-Bypass-Practice"><a href="#Dynamic-Anti-Debugging-Bypass-Practice" class="headerlink" title="Dynamic Anti-Debugging Bypass Practice"></a>Dynamic Anti-Debugging Bypass Practice</h2><h3 id="1-Regular-Program"><a href="#1-Regular-Program" class="headerlink" title="1. Regular Program"></a>1. Regular Program</h3><p>For the Dynamic Anti-Debugging practice, we&#x2019;ll use <strong>timing-based anti-debugging</strong> techniques introduced in &#x201C;Part 1.&#x201D; Please build the following code as an x86 binary.</p>
<pre><code class="hljs c"><span class="hljs-comment">// main.cpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span>

<span class="hljs-comment">// Key decryption function</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decryptKey</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* key)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(key); i++) {
        key[i] = key[i] - <span class="hljs-number">1</span>; <span class="hljs-comment">// Simple Caesar cipher</span>
    }
}

<span class="hljs-comment">// Function to process important data</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processImportantData</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* key)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Processing important data with key: %s\n&quot;</span>, key);
    <span class="hljs-comment">// Print a simple message</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Important data processed successfully!\n&quot;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">char</span> key[] = <span class="hljs-string">&quot;nztfdsfulfz&quot;</span>;

    <span class="hljs-comment">// [1] Timing-based anti-debugging: Measure execution time and detect if an abnormal delay occurs, indicating a debugger is attached.</span>
    <span class="hljs-keyword">uint64_t</span> start_time = GetTickCount64();
    decryptKey(key);
    <span class="hljs-keyword">uint64_t</span> end_time = GetTickCount64();

    <span class="hljs-keyword">uint64_t</span> elapsed_time = end_time - start_time;

    <span class="hljs-comment">// [2] If execution takes longer than 1 second, assume a debugger is attached.</span>
    <span class="hljs-keyword">if</span> (elapsed_time &gt; <span class="hljs-number">1000</span>) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugger detected!\n&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// Exit the program</span>
    }

    <span class="hljs-comment">// [3] Execute critical logic using the decrypted key: Compare with the correct key to determine valid execution.</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(key, <span class="hljs-string">&quot;mysecretkey&quot;</span>) == <span class="hljs-number">0</span>) {
        processImportantData(key);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid key!\n&quot;</span>);
    }

    system(<span class="hljs-string">&quot;pause&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>This code implements timing-based anti-debugging to protect the critical decryption logic ([1]). If an attacker attempts to analyze the key decryption process, the execution time difference will trigger ([2]), causing the program to terminate. Conversely, under normal execution conditions ([3]), the logic proceeds without issue.</p>
<p>Now, let&#x2019;s build and run the program!</p>
<p><img src="image%2010.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>It runs correctly. In this simple example, it just prints <code>Important data processed successfully!</code>, but you can imagine a scenario where a critical operation using the key takes place.</p>
<p>Since we have verified normal execution, let&#x2019;s attempt debugging this program using IDA.</p>
<p><img src="image%2011.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Given that we are particularly interested in the key decryption logic, set a breakpoint (shortcut: F2) on the decryption function and start debugging (F9). By stepping into (F7) the function and analyzing how the key is decrypted, we can then continue execution. However, as shown below, the program detects debugging activity and terminates.</p>
<p><img src="2f9db531-4021-4c69-9805-b40c8cb60ee0.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Even though this is a simple example, if the key changed on every execution, even if extracted via debugging, the anti-debugging mechanism would cause the program to terminate, making it impossible to use the extracted key. The effectiveness of anti-debugging depends on the skill level of the attacker; by applying more advanced techniques, the difficulty of analysis can be significantly increased.</p>
<h3 id="2-Binary-Patching-Bypassing-Dynamic-Anti-Debugging"><a href="#2-Binary-Patching-Bypassing-Dynamic-Anti-Debugging" class="headerlink" title="2. Binary Patching (Bypassing Dynamic Anti-Debugging)"></a>2. Binary Patching (Bypassing Dynamic Anti-Debugging)</h3><p>How can we modify the program&#x2019;s flow to bypass the anti-debugging check?</p>
<p>We can consider two main approaches:</p>
<blockquote>
<p>&#x2460; Neutralizing the timing check</p>
<ol>
<li>Locate the <code>GetTickCount64()</code> function calls and modify them.<ul>
<li>Patch them with NOP instructions or replace them with a function that always returns a constant value.</li>
</ul>
</li>
<li>Modify <code>if (elapsed_time &gt; 1000)</code> to an impossible condition, like <code>if (elapsed_time &lt; 0)</code>.<ul>
<li>Alternatively, modify a <code>jmp</code> instruction to always proceed normally.</li>
</ul>
</li>
</ol>
<p><strong>&#x2461; Preventing program termination</strong></p>
<ul>
<li>Locate <code>printf(&quot;Debugger detected!\n&quot;); return 1;</code> and patch <code>return 1;</code> with <strong>NOP (0x90)</strong>.</li>
</ul>
</blockquote>
<p>Since compiler optimizations may alter the actual implementation, let&#x2019;s examine the binary in IDA.</p>
<p><img src="image%2012.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>I will patch the instruction at line 16. Normally, CF and ZF flags must be 0 for <code>elapsed_time</code> to be less than 1 second, but I will modify <code>jbe</code> to <code>ja</code> so that the key validation logic only executes when execution takes more than 1 second. By selecting line 16 and examining the assembly, we can see two jump instructions. I will patch the first one with NOP and modify the second one at runtime.</p>
<p><img src="image%2013.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Now, let&#x2019;s set a breakpoint on the key decryption function and ensure debugging lasts longer than 1 second before proceeding.</p>
<p>When we press F9 to start debugging:</p>
<p><img src="image%2014.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>We hit the first breakpoint, allowing us to analyze <code>decryptKey</code>. After analyzing, we continue execution until the second breakpoint.</p>
<p><img src="image%2015.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>At the second breakpoint, we modify <code>jbe</code> to <code>ja</code> using &#x201C;Edit &gt; Patch Program &gt; Assemble,&#x201D; successfully bypassing the anti-debugging check. LOL</p>
<p><img src="image%2016.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>In similar situations, other bypass techniques include modifying <code>CF</code> and <code>ZF</code> flags at runtime or hooking <code>GetTickCount()</code> to return a constant value, effectively neutralizing the anti-debugging logic.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><img src="Debug_part2.jpg" srcset="/img/loading.gif" alt="Debug_part2.jpg"></p>
<p>The techniques we practiced today are classic examples of bypassing anti-debugging. These techniques are used as &#x201C;trap card&#x201D; to bypass security solutions when they try to block specific actions.</p>
<blockquote>
<p>Blocking debuggers with Anti-Debugging techniques, bypassing those with Anti-Debugging bypass, <del>countering that with Anti-Anti-Anti-Debugging, and stopping that with Anti-Anti-Anti-Anti tititi Fragile Fragile!</del></p>
<p><img src="Anti-Fragile.gif" srcset="/img/loading.gif" alt="K-POP Group LE SSERAFIM"></p>
<p>K-POP Group LE SSERAFIM</p>
</blockquote>
<h2 id="Limitations-of-Anti-Debugging"><a href="#Limitations-of-Anti-Debugging" class="headerlink" title="Limitations of Anti-Debugging"></a>Limitations of Anti-Debugging</h2><p>Anti-debugging is a core technique that makes code analysis difficult and hinders reverse engineering and vulnerability analysis. It can prevent unauthorized copying, cracking, and misuse of software, especially in areas handling sensitive data like finance, gaming, and security products. (Often featured in CTF challenges!) With its flexibility to be adapted to various environments, it has high effectiveness in detecting and responding when an attacker tries to debug.</p>
<p>However, as we saw in the practice session today, it is vulnerable to code patching and API hooking. This is because once you know the area, it becomes patchable.</p>
<p><img src="image%2017.png" srcset="/img/loading.gif" alt="image.png"></p>
<blockquote>
<p>???: So why not just hide it? / 000: How!!</p>
</blockquote>
<p><img src="9o6emu.gif" srcset="/img/loading.gif" alt="9o6emu.gif"></p>
<p>By obfuscating the anti-debugging logic, it becomes impossible to understand the technique used. If you cannot identify the anti-debugging method, it becomes much harder to figure out how to bypass it. This combination of static obfuscation techniques and dynamic anti-debugging creates a program that is extremely difficult and complex to analyze. (Maybe I&#x2019;ll cover obfuscation in a future blog post!)</p>
<h2 id="Significance"><a href="#Significance" class="headerlink" title="Significance"></a>Significance</h2><p>From a malware analysis perspective, reversing and anti-reversing are like an eternal battle between sword and shield. Malware analysts use reversing techniques to uncover how malicious code operates, while malware developers employ anti-reversing techniques to obstruct analysis and keep their code&#x2019;s secrets hidden.</p>
<p>Even from the standpoint of ethical software developers, reversing and anti-reversing hold significant meaning. Reversing can be used to identify software vulnerabilities and strengthen security, whereas anti-reversing helps protect intellectual property and prevent unauthorized copying.</p>
<p>Ultimately, reversing and anti-reversing, debugging and anti-debugging, continuously evolve in response to each other, fueling an ongoing battle. In this sense, it feels much like the never-ending struggle between heroes and villains in movies&#x2014;an endless tug-of-war between malware developers and analysts, software developers and attackers. However, the real issue is not the technology itself, but the ethical responsibility of those who wield it. Perhaps our true mission is to use these technologies wisely to build a safer and more trustworthy digital world. How do you think?</p>
<p><img src="image%2018.jpg" srcset="/img/loading.gif" alt="image.png"></p>
<p>Thank you for reading the long post. I&#x2019;ll return with better research articles &#x1F642;</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>&#xB9AC;&#xBC84;&#xC2F1; &#xD575;&#xC2EC; &#xC6D0;&#xB9AC;: &#xC545;&#xC131; &#xCF54;&#xB4DC; &#xBD84;&#xC11D;&#xAC00;&#xC758; &#xB9AC;&#xBC84;&#xC2F1; &#xC774;&#xC57C;&#xAE30;(&#xC800;&#xC790; &#xC774;&#xC2B9;&#xC6D0;)</p>
<p>Detoures - <a target="_blank" rel="external nofollow noopener noreferrer" href="https://secmem.tistory.com/480">https://secmem.tistory.com/480</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software">https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.bitdefender.com/en-us/blog/businessinsights/the-differences-between-static-malware-analysis-and-dynamic-malware-analysis">https://www.bitdefender.com/en-us/blog/businessinsights/the-differences-between-static-malware-analysis-and-dynamic-malware-analysis</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/OUYA77/">OUYA77</a>
                  
                  <a class="hover-with-bg" href="/tags/Debugging/">Debugging</a>
                  
                  <a class="hover-with-bg" href="/tags/Anti-Debugging/">Anti-Debugging</a>
                  
                  <a class="hover-with-bg" href="/tags/Malware/">Malware</a>
                  
                  <a class="hover-with-bg" href="/tags/Reverse-Engineering/">Reverse Engineering</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_OUYA77.jpg" srcset="/img/loading.gif" alt="OUYA77">
                  </div>

                  <div class="link-text">
                    <div class="link-title">OUYA77</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/OUYA77">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">본 글은 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a> 라이선스로 배포됩니다. 공유 또는 변경 시 반드시 출처를 남겨주시기 바랍니다.</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/03/26/newp1ayer48/CVE-2025-25742/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[하루한줄] CVE-2025-25742: D-Link DIR-853에서 발생하는 Stack-based Buffer Overflow로 인한 RCE 취약점</span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/03/24/OUYA77/Anti_part2/kr/">
                    <span class="hidden-mobile">[Research] Anti-Debugging Part 2(KR)</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/03/24/OUYA77/Anti_part2/en/';
        this.page.identifier = '/2025/03/24/OUYA77/Anti_part2/en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] Anti-Debugging Part 2(EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
