

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;p&gt;Hello! I&amp;#x2019;m &lt;code&gt;newp1ayer48&lt;/code&gt;, and it&amp;#x2019;s a pleasure to introduce myself! &amp;#x1F647;&amp;#x1F3FB;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image1.jpeg&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The start of IoT / Embedded hacking and its most crucial part is obtaining the firmware.&lt;/p&gt;
&lt;p&gt;Firmware is essential because, with it, you can understand how the device operates, analyze the vectors where vulnerabilities may arise, and analyze the code.&lt;/p&gt;
&lt;p&gt;There are several ways to obtain firmware, but here are some representative methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Downloading firmware from official websites&lt;/li&gt;
&lt;li&gt;Sniffing firmware update packets&lt;/li&gt;
&lt;li&gt;Dumping firmware through debugging ports (UART, JTAG, etc.)&lt;/li&gt;
&lt;li&gt;Directly connecting to Flash Memory dumping the firmware&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Flash memory is a chip typically used for storage purposes and is commonly found in IoT devices in an 8-pin form.&lt;/p&gt;
&lt;p&gt;Since the firmware is ultimately stored in this Flash Memory chip, directly extracting the firmware from Flash Memory has the advantage of being a more reliable method.&lt;/p&gt;
&lt;p&gt;Using the flashrom program, you can easily extract the firmware from Flash Memory.&lt;/p&gt;
&lt;p&gt;However, this method can potentially damage the equipment and board, so you should proceed with caution. &amp;#x26A0;&amp;#xFE0F;&lt;/p&gt;
&lt;p&gt;Because heat is applied directly to the board using tools like soldering irons or heat guns, there is a risk of damaging the chip or the board, and improper connections may lead to short circuits.&lt;/p&gt;
&lt;p&gt;Due to these risks, you may end up damaging IoT/embedded equipment that was purchased for bug bounty purposes.&lt;/p&gt;
&lt;p&gt;It&amp;#x2019;s somewhat like trying to extract a golden egg by cutting open a goose&amp;#x2019;s belly, only to kill the goose in the process&amp;#x2026; &amp;#x1FAA6;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image2.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If you need to extract firmware, it&amp;#x2019;s best to try the other methods mentioned above before opting for a Flash memory dump.&lt;/p&gt;
&lt;p&gt;The flow for performing a Flash memory dump using flashrom is as follows: &amp;#x1F4DD;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Install flashrom on Raspberry Pi&lt;/li&gt;
&lt;li&gt;Flash Memory Chip Off&lt;/li&gt;
&lt;li&gt;Connect Flash Memory chip to Raspberry Pi&lt;/li&gt;
&lt;li&gt;Flash memory dump&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&amp;#x2019;s a list of the required equipment and tools: &amp;#x1F4B8;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Raspberry Pi (64 Bit)&lt;/li&gt;
&lt;li&gt;IC Test Hook Clip (SDK08)&lt;/li&gt;
&lt;li&gt;Heat Gun&lt;/li&gt;
&lt;li&gt;Jumper cables and breadboard&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-Installing-flashrom&#34;&gt;&lt;a href=&#34;#1-Installing-flashrom&#34; class=&#34;headerlink&#34; title=&#34;1. Installing flashrom&#34;&gt;&lt;/a&gt;1. Installing flashrom&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.flashrom.org/&#34;&gt;https://www.flashrom.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Flashrom is a development tool that allows you to flash data and images to flash chips.&lt;/p&gt;
&lt;p&gt;It offers functions like detecting, reading, writing, verifying, and erasing, which makes it useful for embedded hacking to extract firmware from flash memory.&lt;/p&gt;
&lt;p&gt;You need to install the necessary dependencies and use meson to install it on Raspberry Pi. &amp;#x1F352;&lt;/p&gt;
&lt;p&gt;Prepare your Raspberry Pi in 64-bit mode for installation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;sudo apt-get install -y gcc meson ninja-build pkg-config python3-sphinx libcmocka-dev libpci-dev libusb-1.0-0-dev libftdi1-dev libjaylink-dev libssl-dev
git &lt;span class=&#34;hljs-built_in&#34;&gt;clone&lt;/span&gt; https://github.com/flashrom/flashrom
meson setup builddir
meson compile -C builddir
meson &lt;span class=&#34;hljs-built_in&#34;&gt;test&lt;/span&gt; -C builddir
meson install -C builddir&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-Flash-Memory-Chip-Off&#34;&gt;&lt;a href=&#34;#2-Flash-Memory-Chip-Off&#34; class=&#34;headerlink&#34; title=&#34;2. Flash Memory Chip Off&#34;&gt;&lt;/a&gt;2. Flash Memory Chip Off&lt;/h2&gt;&lt;p&gt;When extracting the chip with flashrom, performing the dump while the chip is still attached to the board may result in unsuccessful extraction. &amp;#x1F47B;&lt;/p&gt;
&lt;p&gt;The reason varies depending on the equipment and board, but usually, the Raspberry Pi provides power to the entire board, which may introduce noise signals that could interfere with the extraction process.&lt;/p&gt;
&lt;p&gt;The following image shows the Raspberry Pi&amp;#x2019;s VCC and GND pins touching the corresponding pins on the Flash Memory chip, confirming that power is supplied to the board.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;For this reason, it&amp;#x2019;s better to remove the chip from the board and connect only the chip.&lt;/p&gt;
&lt;p&gt;Use a heat gun to melt the solder and remove the chip from the board.&lt;/p&gt;
&lt;p&gt;Be cautious during this process as the risk of damaging the board is quite high.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image4.png&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-Connecting-the-Flash-Memory-Chip-to-the-Raspberry-Pi&#34;&gt;&lt;a href=&#34;#3-Connecting-the-Flash-Memory-Chip-to-the-Raspberry-Pi&#34; class=&#34;headerlink&#34; title=&#34;3. Connecting the Flash Memory Chip to the Raspberry Pi&#34;&gt;&lt;/a&gt;3. Connecting the Flash Memory Chip to the Raspberry Pi&lt;/h2&gt;&lt;p&gt;Typically, Flash memory used in low-power IoT and embedded devices is an 8-pin chip that uses SPI communication.&lt;/p&gt;
&lt;p&gt;While the pin assignments may vary depending on the chip model and vendor, the function of the 8 pins is usually the same, so refer to the datasheet for the pinout.&lt;/p&gt;
&lt;p&gt;The datasheet provides all the information for using and describing the chip, so make sure to consult it!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image5.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The roles of each of the 8 pins of Flash Memory are as follows: &amp;#x1F4CC;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;VCC&lt;/strong&gt;: Supplies power&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GND&lt;/strong&gt;: Ground, provides reference voltage&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SCLK (SCK, CLK)&lt;/strong&gt;: Serial Clock, synchronization signal&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CS (SS)&lt;/strong&gt;: Chip Select, selects the device and chip&lt;ul&gt;
&lt;li&gt;This pin is used to select a specific chip from multiple chips on the main MCU.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DI (SI)&lt;/strong&gt;: Data Input&lt;ul&gt;
&lt;li&gt;Used to input data to Flash Memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DO (SO)&lt;/strong&gt;: Data Output&lt;ul&gt;
&lt;li&gt;Used to output data from Flash Memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WP&lt;/strong&gt;: Write Protect&lt;ul&gt;
&lt;li&gt;When this pin signal is activated, writing to the Flash Memory is disabled.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hold&lt;/strong&gt;: Chip Pause&lt;ul&gt;
&lt;li&gt;When this pin signal is activated, it pauses the operation of the Flash Memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Connect the Raspberry Pi&amp;#x2019;s GPIO pins to the Flash Memory&amp;#x2019;s pins.&lt;/p&gt;
&lt;p&gt;The VCC, Hold, and WP pins on the Flash Memory use the VCC power signal. Since Raspberry Pi&amp;#x2019;s GPIO pins lack enough VCC pins, it&amp;#x2019;s more convenient to supply the VCC signal using a breadboard or similar method.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image6.jpg&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Use the IC Test Hook Clip to connect the pins and begin the extraction process.&lt;/p&gt;
&lt;p&gt;The thinner the clip, the easier the connection, so it&amp;#x2019;s recommended to use a thin test clip.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image7.png&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-Flash-Memory-Dump&#34;&gt;&lt;a href=&#34;#4-Flash-Memory-Dump&#34; class=&#34;headerlink&#34; title=&#34;4. Flash Memory Dump&#34;&gt;&lt;/a&gt;4. Flash Memory Dump&lt;/h2&gt;&lt;p&gt;Once everything is connected, execute the following command in the Raspberry Pi terminal to start the extraction process. &amp;#x1F489;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;# Check connection and check chip name&lt;/span&gt;
sudo flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=2000 -V

&lt;span class=&#34;hljs-comment&#34;&gt;# extraction&lt;/span&gt;
sudo flashrom -p linux_spi:dev=/dev/spidev0.0 -r [filename]
sudo flashrom -p linux_spi:dev=/dev/spidev0.0 -c [Chipname] -r [filename]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image8.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If the chip is supported, flashrom will begin the extraction process immediately.&lt;/p&gt;
&lt;p&gt;However, if the chip is not supported, you can check &lt;code&gt;flashchips.h&lt;/code&gt; and &lt;code&gt;flashchips.c&lt;/code&gt;. If the chip is not listed, you can add the chip manually and then build it for extraction.&lt;/p&gt;
&lt;p&gt;Refer to the datasheet to add the chip information to the flashchips.c file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;flashchip&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;flashchips&lt;/span&gt;[] = {&lt;/span&gt;

	&lt;span class=&#34;hljs-comment&#34;&gt;/*&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .vendor		= Vendor name&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .name		= Chip name&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .bustype		= Supported flash bus types (Parallel, LPC...)&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .manufacture_id	= Manufacturer chip ID&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .model_id		= Model chip ID&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .total_size		= Total size in (binary) kbytes&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .page_size		= Page or eraseblock(?) size in bytes&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .tested		= Test status&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .probe		= Probe function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .probe_timing	= Probe function delay&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .block_erasers[]	= Array of erase layouts and erase functions&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * {&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 *	.eraseblocks[]	= Array of { blocksize, blockcount }&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 *	.block_erase	= Block erase function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * }&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .printlock		= Chip lock status function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .unlock		= Chip unlock function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .write		= Chip write function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .read		= Chip read function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .voltage		= Voltage range in millivolt&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this process, you can successfully dump the firmware stored in the chip!&lt;/p&gt;
&lt;p&gt;After removing the Flash Memory chip, the device won&amp;#x2019;t work until it&amp;#x2019;s reassembled&amp;#x2026;&lt;/p&gt;
&lt;p&gt;But! Reassembly is simply the reverse of disassembly!&lt;/p&gt;
&lt;p&gt;Once the Flash Memory chip is properly (!) re-soldered, the device will be usable again!&lt;/p&gt;
&lt;p&gt;By extracting the firmware and restoring the device, you can have the best of both worlds! &amp;#x1F925;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image9.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Next, we will cover the commonly attempted UART/JTAG debugging port connections in embedded hacking!Thank you! &amp;#x1F64F;&amp;#x1F3FB;&lt;/p&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] Flash Memory Dump with Flashrom - hackyboiz">
  <meta property="og:description" content="&lt;p&gt;Hello! I&amp;#x2019;m &lt;code&gt;newp1ayer48&lt;/code&gt;, and it&amp;#x2019;s a pleasure to introduce myself! &amp;#x1F647;&amp;#x1F3FB;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image1.jpeg&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The start of IoT / Embedded hacking and its most crucial part is obtaining the firmware.&lt;/p&gt;
&lt;p&gt;Firmware is essential because, with it, you can understand how the device operates, analyze the vectors where vulnerabilities may arise, and analyze the code.&lt;/p&gt;
&lt;p&gt;There are several ways to obtain firmware, but here are some representative methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Downloading firmware from official websites&lt;/li&gt;
&lt;li&gt;Sniffing firmware update packets&lt;/li&gt;
&lt;li&gt;Dumping firmware through debugging ports (UART, JTAG, etc.)&lt;/li&gt;
&lt;li&gt;Directly connecting to Flash Memory dumping the firmware&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Flash memory is a chip typically used for storage purposes and is commonly found in IoT devices in an 8-pin form.&lt;/p&gt;
&lt;p&gt;Since the firmware is ultimately stored in this Flash Memory chip, directly extracting the firmware from Flash Memory has the advantage of being a more reliable method.&lt;/p&gt;
&lt;p&gt;Using the flashrom program, you can easily extract the firmware from Flash Memory.&lt;/p&gt;
&lt;p&gt;However, this method can potentially damage the equipment and board, so you should proceed with caution. &amp;#x26A0;&amp;#xFE0F;&lt;/p&gt;
&lt;p&gt;Because heat is applied directly to the board using tools like soldering irons or heat guns, there is a risk of damaging the chip or the board, and improper connections may lead to short circuits.&lt;/p&gt;
&lt;p&gt;Due to these risks, you may end up damaging IoT/embedded equipment that was purchased for bug bounty purposes.&lt;/p&gt;
&lt;p&gt;It&amp;#x2019;s somewhat like trying to extract a golden egg by cutting open a goose&amp;#x2019;s belly, only to kill the goose in the process&amp;#x2026; &amp;#x1FAA6;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image2.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If you need to extract firmware, it&amp;#x2019;s best to try the other methods mentioned above before opting for a Flash memory dump.&lt;/p&gt;
&lt;p&gt;The flow for performing a Flash memory dump using flashrom is as follows: &amp;#x1F4DD;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Install flashrom on Raspberry Pi&lt;/li&gt;
&lt;li&gt;Flash Memory Chip Off&lt;/li&gt;
&lt;li&gt;Connect Flash Memory chip to Raspberry Pi&lt;/li&gt;
&lt;li&gt;Flash memory dump&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&amp;#x2019;s a list of the required equipment and tools: &amp;#x1F4B8;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Raspberry Pi (64 Bit)&lt;/li&gt;
&lt;li&gt;IC Test Hook Clip (SDK08)&lt;/li&gt;
&lt;li&gt;Heat Gun&lt;/li&gt;
&lt;li&gt;Jumper cables and breadboard&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-Installing-flashrom&#34;&gt;&lt;a href=&#34;#1-Installing-flashrom&#34; class=&#34;headerlink&#34; title=&#34;1. Installing flashrom&#34;&gt;&lt;/a&gt;1. Installing flashrom&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.flashrom.org/&#34;&gt;https://www.flashrom.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Flashrom is a development tool that allows you to flash data and images to flash chips.&lt;/p&gt;
&lt;p&gt;It offers functions like detecting, reading, writing, verifying, and erasing, which makes it useful for embedded hacking to extract firmware from flash memory.&lt;/p&gt;
&lt;p&gt;You need to install the necessary dependencies and use meson to install it on Raspberry Pi. &amp;#x1F352;&lt;/p&gt;
&lt;p&gt;Prepare your Raspberry Pi in 64-bit mode for installation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;sudo apt-get install -y gcc meson ninja-build pkg-config python3-sphinx libcmocka-dev libpci-dev libusb-1.0-0-dev libftdi1-dev libjaylink-dev libssl-dev
git &lt;span class=&#34;hljs-built_in&#34;&gt;clone&lt;/span&gt; https://github.com/flashrom/flashrom
meson setup builddir
meson compile -C builddir
meson &lt;span class=&#34;hljs-built_in&#34;&gt;test&lt;/span&gt; -C builddir
meson install -C builddir&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-Flash-Memory-Chip-Off&#34;&gt;&lt;a href=&#34;#2-Flash-Memory-Chip-Off&#34; class=&#34;headerlink&#34; title=&#34;2. Flash Memory Chip Off&#34;&gt;&lt;/a&gt;2. Flash Memory Chip Off&lt;/h2&gt;&lt;p&gt;When extracting the chip with flashrom, performing the dump while the chip is still attached to the board may result in unsuccessful extraction. &amp;#x1F47B;&lt;/p&gt;
&lt;p&gt;The reason varies depending on the equipment and board, but usually, the Raspberry Pi provides power to the entire board, which may introduce noise signals that could interfere with the extraction process.&lt;/p&gt;
&lt;p&gt;The following image shows the Raspberry Pi&amp;#x2019;s VCC and GND pins touching the corresponding pins on the Flash Memory chip, confirming that power is supplied to the board.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;For this reason, it&amp;#x2019;s better to remove the chip from the board and connect only the chip.&lt;/p&gt;
&lt;p&gt;Use a heat gun to melt the solder and remove the chip from the board.&lt;/p&gt;
&lt;p&gt;Be cautious during this process as the risk of damaging the board is quite high.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image4.png&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-Connecting-the-Flash-Memory-Chip-to-the-Raspberry-Pi&#34;&gt;&lt;a href=&#34;#3-Connecting-the-Flash-Memory-Chip-to-the-Raspberry-Pi&#34; class=&#34;headerlink&#34; title=&#34;3. Connecting the Flash Memory Chip to the Raspberry Pi&#34;&gt;&lt;/a&gt;3. Connecting the Flash Memory Chip to the Raspberry Pi&lt;/h2&gt;&lt;p&gt;Typically, Flash memory used in low-power IoT and embedded devices is an 8-pin chip that uses SPI communication.&lt;/p&gt;
&lt;p&gt;While the pin assignments may vary depending on the chip model and vendor, the function of the 8 pins is usually the same, so refer to the datasheet for the pinout.&lt;/p&gt;
&lt;p&gt;The datasheet provides all the information for using and describing the chip, so make sure to consult it!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image5.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The roles of each of the 8 pins of Flash Memory are as follows: &amp;#x1F4CC;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;VCC&lt;/strong&gt;: Supplies power&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GND&lt;/strong&gt;: Ground, provides reference voltage&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SCLK (SCK, CLK)&lt;/strong&gt;: Serial Clock, synchronization signal&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CS (SS)&lt;/strong&gt;: Chip Select, selects the device and chip&lt;ul&gt;
&lt;li&gt;This pin is used to select a specific chip from multiple chips on the main MCU.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DI (SI)&lt;/strong&gt;: Data Input&lt;ul&gt;
&lt;li&gt;Used to input data to Flash Memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DO (SO)&lt;/strong&gt;: Data Output&lt;ul&gt;
&lt;li&gt;Used to output data from Flash Memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WP&lt;/strong&gt;: Write Protect&lt;ul&gt;
&lt;li&gt;When this pin signal is activated, writing to the Flash Memory is disabled.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hold&lt;/strong&gt;: Chip Pause&lt;ul&gt;
&lt;li&gt;When this pin signal is activated, it pauses the operation of the Flash Memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Connect the Raspberry Pi&amp;#x2019;s GPIO pins to the Flash Memory&amp;#x2019;s pins.&lt;/p&gt;
&lt;p&gt;The VCC, Hold, and WP pins on the Flash Memory use the VCC power signal. Since Raspberry Pi&amp;#x2019;s GPIO pins lack enough VCC pins, it&amp;#x2019;s more convenient to supply the VCC signal using a breadboard or similar method.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image6.jpg&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Use the IC Test Hook Clip to connect the pins and begin the extraction process.&lt;/p&gt;
&lt;p&gt;The thinner the clip, the easier the connection, so it&amp;#x2019;s recommended to use a thin test clip.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image7.png&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-Flash-Memory-Dump&#34;&gt;&lt;a href=&#34;#4-Flash-Memory-Dump&#34; class=&#34;headerlink&#34; title=&#34;4. Flash Memory Dump&#34;&gt;&lt;/a&gt;4. Flash Memory Dump&lt;/h2&gt;&lt;p&gt;Once everything is connected, execute the following command in the Raspberry Pi terminal to start the extraction process. &amp;#x1F489;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs bash&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;# Check connection and check chip name&lt;/span&gt;
sudo flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=2000 -V

&lt;span class=&#34;hljs-comment&#34;&gt;# extraction&lt;/span&gt;
sudo flashrom -p linux_spi:dev=/dev/spidev0.0 -r [filename]
sudo flashrom -p linux_spi:dev=/dev/spidev0.0 -c [Chipname] -r [filename]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image8.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If the chip is supported, flashrom will begin the extraction process immediately.&lt;/p&gt;
&lt;p&gt;However, if the chip is not supported, you can check &lt;code&gt;flashchips.h&lt;/code&gt; and &lt;code&gt;flashchips.c&lt;/code&gt;. If the chip is not listed, you can add the chip manually and then build it for extraction.&lt;/p&gt;
&lt;p&gt;Refer to the datasheet to add the chip information to the flashchips.c file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;flashchip&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;flashchips&lt;/span&gt;[] = {&lt;/span&gt;

	&lt;span class=&#34;hljs-comment&#34;&gt;/*&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .vendor		= Vendor name&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .name		= Chip name&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .bustype		= Supported flash bus types (Parallel, LPC...)&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .manufacture_id	= Manufacturer chip ID&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .model_id		= Model chip ID&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .total_size		= Total size in (binary) kbytes&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .page_size		= Page or eraseblock(?) size in bytes&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .tested		= Test status&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .probe		= Probe function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .probe_timing	= Probe function delay&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .block_erasers[]	= Array of erase layouts and erase functions&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * {&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 *	.eraseblocks[]	= Array of { blocksize, blockcount }&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 *	.block_erase	= Block erase function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * }&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .printlock		= Chip lock status function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .unlock		= Chip unlock function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .write		= Chip write function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .read		= Chip read function&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 * .voltage		= Voltage range in millivolt&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;	 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this process, you can successfully dump the firmware stored in the chip!&lt;/p&gt;
&lt;p&gt;After removing the Flash Memory chip, the device won&amp;#x2019;t work until it&amp;#x2019;s reassembled&amp;#x2026;&lt;/p&gt;
&lt;p&gt;But! Reassembly is simply the reverse of disassembly!&lt;/p&gt;
&lt;p&gt;Once the Flash Memory chip is properly (!) re-soldered, the device will be usable again!&lt;/p&gt;
&lt;p&gt;By extracting the firmware and restoring the device, you can have the best of both worlds! &amp;#x1F925;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/03/09/newp1ayer48/flashrom/en/image9.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Next, we will cover the commonly attempted UART/JTAG debugging port connections in embedded hacking!Thank you! &amp;#x1F64F;&amp;#x1F3FB;&lt;/p&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/03/09/newp1ayer48/flashrom/en/image2.png">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/03/09/newp1ayer48/flashrom/en/">

  <title>[Research] Flash Memory Dump with Flashrom - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-03-09 12:00" pubdate>
      2025년 3월 9일 오후
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      1.2k 자
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      23
       분
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Flash Memory Dump with Flashrom</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <p>Hello! I&#x2019;m <code>newp1ayer48</code>, and it&#x2019;s a pleasure to introduce myself! &#x1F647;&#x1F3FB;</p>
<p><img src="/2025/03/09/newp1ayer48/flashrom/en/image1.jpeg" srcset="/img/loading.gif" alt></p>
<p>The start of IoT / Embedded hacking and its most crucial part is obtaining the firmware.</p>
<p>Firmware is essential because, with it, you can understand how the device operates, analyze the vectors where vulnerabilities may arise, and analyze the code.</p>
<p>There are several ways to obtain firmware, but here are some representative methods:</p>
<ul>
<li>Downloading firmware from official websites</li>
<li>Sniffing firmware update packets</li>
<li>Dumping firmware through debugging ports (UART, JTAG, etc.)</li>
<li>Directly connecting to Flash Memory dumping the firmware</li>
</ul>
<p>Flash memory is a chip typically used for storage purposes and is commonly found in IoT devices in an 8-pin form.</p>
<p>Since the firmware is ultimately stored in this Flash Memory chip, directly extracting the firmware from Flash Memory has the advantage of being a more reliable method.</p>
<p>Using the flashrom program, you can easily extract the firmware from Flash Memory.</p>
<p>However, this method can potentially damage the equipment and board, so you should proceed with caution. &#x26A0;&#xFE0F;</p>
<p>Because heat is applied directly to the board using tools like soldering irons or heat guns, there is a risk of damaging the chip or the board, and improper connections may lead to short circuits.</p>
<p>Due to these risks, you may end up damaging IoT/embedded equipment that was purchased for bug bounty purposes.</p>
<p>It&#x2019;s somewhat like trying to extract a golden egg by cutting open a goose&#x2019;s belly, only to kill the goose in the process&#x2026; &#x1FAA6;</p>
<p><img src="/2025/03/09/newp1ayer48/flashrom/en/image2.png" srcset="/img/loading.gif" alt></p>
<p>If you need to extract firmware, it&#x2019;s best to try the other methods mentioned above before opting for a Flash memory dump.</p>
<p>The flow for performing a Flash memory dump using flashrom is as follows: &#x1F4DD;</p>
<ol>
<li>Install flashrom on Raspberry Pi</li>
<li>Flash Memory Chip Off</li>
<li>Connect Flash Memory chip to Raspberry Pi</li>
<li>Flash memory dump</li>
</ol>
<p>Here&#x2019;s a list of the required equipment and tools: &#x1F4B8;</p>
<ul>
<li>Raspberry Pi (64 Bit)</li>
<li>IC Test Hook Clip (SDK08)</li>
<li>Heat Gun</li>
<li>Jumper cables and breadboard</li>
</ul>
<h2 id="1-Installing-flashrom"><a href="#1-Installing-flashrom" class="headerlink" title="1. Installing flashrom"></a>1. Installing flashrom</h2><blockquote>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.flashrom.org/">https://www.flashrom.org/</a></p>
</blockquote>
<p>Flashrom is a development tool that allows you to flash data and images to flash chips.</p>
<p>It offers functions like detecting, reading, writing, verifying, and erasing, which makes it useful for embedded hacking to extract firmware from flash memory.</p>
<p>You need to install the necessary dependencies and use meson to install it on Raspberry Pi. &#x1F352;</p>
<p>Prepare your Raspberry Pi in 64-bit mode for installation.</p>
<pre><code class="hljs bash">sudo apt-get install -y gcc meson ninja-build pkg-config python3-sphinx libcmocka-dev libpci-dev libusb-1.0-0-dev libftdi1-dev libjaylink-dev libssl-dev
git <span class="hljs-built_in">clone</span> https://github.com/flashrom/flashrom
meson setup builddir
meson compile -C builddir
meson <span class="hljs-built_in">test</span> -C builddir
meson install -C builddir</code></pre>
<h2 id="2-Flash-Memory-Chip-Off"><a href="#2-Flash-Memory-Chip-Off" class="headerlink" title="2. Flash Memory Chip Off"></a>2. Flash Memory Chip Off</h2><p>When extracting the chip with flashrom, performing the dump while the chip is still attached to the board may result in unsuccessful extraction. &#x1F47B;</p>
<p>The reason varies depending on the equipment and board, but usually, the Raspberry Pi provides power to the entire board, which may introduce noise signals that could interfere with the extraction process.</p>
<p>The following image shows the Raspberry Pi&#x2019;s VCC and GND pins touching the corresponding pins on the Flash Memory chip, confirming that power is supplied to the board.</p>
<p><img src="/2025/03/09/newp1ayer48/flashrom/en/image3.png" srcset="/img/loading.gif" alt></p>
<p>For this reason, it&#x2019;s better to remove the chip from the board and connect only the chip.</p>
<p>Use a heat gun to melt the solder and remove the chip from the board.</p>
<p>Be cautious during this process as the risk of damaging the board is quite high.</p>
<p><img src="/2025/03/09/newp1ayer48/flashrom/en/image4.png" srcset="/img/loading.gif" alt></p>
<h2 id="3-Connecting-the-Flash-Memory-Chip-to-the-Raspberry-Pi"><a href="#3-Connecting-the-Flash-Memory-Chip-to-the-Raspberry-Pi" class="headerlink" title="3. Connecting the Flash Memory Chip to the Raspberry Pi"></a>3. Connecting the Flash Memory Chip to the Raspberry Pi</h2><p>Typically, Flash memory used in low-power IoT and embedded devices is an 8-pin chip that uses SPI communication.</p>
<p>While the pin assignments may vary depending on the chip model and vendor, the function of the 8 pins is usually the same, so refer to the datasheet for the pinout.</p>
<p>The datasheet provides all the information for using and describing the chip, so make sure to consult it!</p>
<p><img src="/2025/03/09/newp1ayer48/flashrom/en/image5.png" srcset="/img/loading.gif" alt></p>
<p>The roles of each of the 8 pins of Flash Memory are as follows: &#x1F4CC;</p>
<ul>
<li><strong>VCC</strong>: Supplies power</li>
<li><strong>GND</strong>: Ground, provides reference voltage</li>
<li><strong>SCLK (SCK, CLK)</strong>: Serial Clock, synchronization signal</li>
<li><strong>CS (SS)</strong>: Chip Select, selects the device and chip<ul>
<li>This pin is used to select a specific chip from multiple chips on the main MCU.</li>
</ul>
</li>
<li><strong>DI (SI)</strong>: Data Input<ul>
<li>Used to input data to Flash Memory.</li>
</ul>
</li>
<li><strong>DO (SO)</strong>: Data Output<ul>
<li>Used to output data from Flash Memory.</li>
</ul>
</li>
<li><strong>WP</strong>: Write Protect<ul>
<li>When this pin signal is activated, writing to the Flash Memory is disabled.</li>
</ul>
</li>
<li><strong>Hold</strong>: Chip Pause<ul>
<li>When this pin signal is activated, it pauses the operation of the Flash Memory.</li>
</ul>
</li>
</ul>
<p>Connect the Raspberry Pi&#x2019;s GPIO pins to the Flash Memory&#x2019;s pins.</p>
<p>The VCC, Hold, and WP pins on the Flash Memory use the VCC power signal. Since Raspberry Pi&#x2019;s GPIO pins lack enough VCC pins, it&#x2019;s more convenient to supply the VCC signal using a breadboard or similar method.</p>
<p><img src="/2025/03/09/newp1ayer48/flashrom/en/image6.jpg" srcset="/img/loading.gif" alt></p>
<p>Use the IC Test Hook Clip to connect the pins and begin the extraction process.</p>
<p>The thinner the clip, the easier the connection, so it&#x2019;s recommended to use a thin test clip.</p>
<p><img src="/2025/03/09/newp1ayer48/flashrom/en/image7.png" srcset="/img/loading.gif" alt></p>
<h2 id="4-Flash-Memory-Dump"><a href="#4-Flash-Memory-Dump" class="headerlink" title="4. Flash Memory Dump"></a>4. Flash Memory Dump</h2><p>Once everything is connected, execute the following command in the Raspberry Pi terminal to start the extraction process. &#x1F489;</p>
<pre><code class="hljs bash"><span class="hljs-comment"># Check connection and check chip name</span>
sudo flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=2000 -V

<span class="hljs-comment"># extraction</span>
sudo flashrom -p linux_spi:dev=/dev/spidev0.0 -r [filename]
sudo flashrom -p linux_spi:dev=/dev/spidev0.0 -c [Chipname] -r [filename]</code></pre>
<p><img src="/2025/03/09/newp1ayer48/flashrom/en/image8.png" srcset="/img/loading.gif" alt></p>
<p>If the chip is supported, flashrom will begin the extraction process immediately.</p>
<p>However, if the chip is not supported, you can check <code>flashchips.h</code> and <code>flashchips.c</code>. If the chip is not listed, you can add the chip manually and then build it for extraction.</p>
<p>Refer to the datasheet to add the chip information to the flashchips.c file.</p>
<pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flashchip</span> <span class="hljs-title">flashchips</span>[] = {</span>

	<span class="hljs-comment">/*</span>
<span class="hljs-comment">	 * .vendor		= Vendor name</span>
<span class="hljs-comment">	 * .name		= Chip name</span>
<span class="hljs-comment">	 * .bustype		= Supported flash bus types (Parallel, LPC...)</span>
<span class="hljs-comment">	 * .manufacture_id	= Manufacturer chip ID</span>
<span class="hljs-comment">	 * .model_id		= Model chip ID</span>
<span class="hljs-comment">	 * .total_size		= Total size in (binary) kbytes</span>
<span class="hljs-comment">	 * .page_size		= Page or eraseblock(?) size in bytes</span>
<span class="hljs-comment">	 * .tested		= Test status</span>
<span class="hljs-comment">	 * .probe		= Probe function</span>
<span class="hljs-comment">	 * .probe_timing	= Probe function delay</span>
<span class="hljs-comment">	 * .block_erasers[]	= Array of erase layouts and erase functions</span>
<span class="hljs-comment">	 * {</span>
<span class="hljs-comment">	 *	.eraseblocks[]	= Array of { blocksize, blockcount }</span>
<span class="hljs-comment">	 *	.block_erase	= Block erase function</span>
<span class="hljs-comment">	 * }</span>
<span class="hljs-comment">	 * .printlock		= Chip lock status function</span>
<span class="hljs-comment">	 * .unlock		= Chip unlock function</span>
<span class="hljs-comment">	 * .write		= Chip write function</span>
<span class="hljs-comment">	 * .read		= Chip read function</span>
<span class="hljs-comment">	 * .voltage		= Voltage range in millivolt</span>
<span class="hljs-comment">	 */</span>
</code></pre>
<p>With this process, you can successfully dump the firmware stored in the chip!</p>
<p>After removing the Flash Memory chip, the device won&#x2019;t work until it&#x2019;s reassembled&#x2026;</p>
<p>But! Reassembly is simply the reverse of disassembly!</p>
<p>Once the Flash Memory chip is properly (!) re-soldered, the device will be usable again!</p>
<p>By extracting the firmware and restoring the device, you can have the best of both worlds! &#x1F925;</p>
<p><img src="/2025/03/09/newp1ayer48/flashrom/en/image9.png" srcset="/img/loading.gif" alt></p>
<p>Next, we will cover the commonly attempted UART/JTAG debugging port connections in embedded hacking!Thank you! &#x1F64F;&#x1F3FB;</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/firmware/">firmware</a>
                  
                  <a class="hover-with-bg" href="/tags/newp1ayer48/">newp1ayer48</a>
                  
                  <a class="hover-with-bg" href="/tags/IoT/">IoT</a>
                  
                  <a class="hover-with-bg" href="/tags/Embedded/">Embedded</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_newp1ayer48.jpg" srcset="/img/loading.gif" alt="newp1ayer48">
                  </div>

                  <div class="link-text">
                    <div class="link-title">newp1ayer48</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/newp1ayer48">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">본 글은 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a> 라이선스로 배포됩니다. 공유 또는 변경 시 반드시 출처를 남겨주시기 바랍니다.</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/03/09/newp1ayer48/flashrom/ko/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[Research] Flashrom으로 Flash Memory Dump하기</span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/03/08/j0ker/2025-03-08/">
                    <span class="hidden-mobile">[하루한줄] CVE-2024-53104: Linux Kernel의 Out-Of-Bounds(OOB) Write 취약점</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/03/09/newp1ayer48/flashrom/en/';
        this.page.identifier = '/2025/03/09/newp1ayer48/flashrom/en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] Flash Memory Dump with Flashrom&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
