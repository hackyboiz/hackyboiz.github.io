

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;h2 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Hello! I&amp;#x2019;m &lt;code&gt;gongjae&lt;/code&gt;, a new member who recently joined HackyBoiz! &amp;#x1F47B;&lt;/p&gt;
&lt;p&gt;During my time as a trainee at HackyBoiz, I had a question related to the Kernel Driver and Named Pipe bug hunting project I had previously worked on.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;Nope&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Actually, I already knew that ALPC is one of the IPC communication methods, but I decided to take this opportunity to study it properly. &lt;/p&gt;
&lt;p&gt;So today, we&amp;#x2019;ll explore the concept of ALPC, its communication flow, and how messages are transmitted &amp;#x2014; all while debugging it directly! :)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-About-ALPC&#34;&gt;&lt;a href=&#34;#1-About-ALPC&#34; class=&#34;headerlink&#34; title=&#34;1. About ALPC&#34;&gt;&lt;/a&gt;1. About ALPC&lt;/h2&gt;&lt;p&gt;In the Windows environment, IPC mechanisms that can be used both remotely and locally include Named Pipes and RPC. However, ALPC is unique in that it can only be used locally.&lt;/p&gt;
&lt;p&gt;While RPC stands for Remote Procedure Call, ALPC stands for Advanced Local Procedure Call and is sometimes also referred to as Asynchronous Local Call.&lt;/p&gt;
&lt;p&gt;The term &amp;#x201C;asynchronous&amp;#x201D; reflects the Windows Vista era, during which ALPC was introduced to replace the existing LPC mechanism.&lt;/p&gt;
&lt;p&gt;ALPC enables high-speed message communication and is used for data transmission between processes.&lt;/p&gt;
&lt;h3 id=&#34;1-1-LPC-to-ALPC&#34;&gt;&lt;a href=&#34;#1-1-LPC-to-ALPC&#34; class=&#34;headerlink&#34; title=&#34;1.1. LPC to ALPC&#34;&gt;&lt;/a&gt;1.1. LPC to ALPC&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Before Windows Vista, LPC was an undocumented internal IPC mechanism provided by the Microsoft Windows NT kernel, used for lightweight communication between processes on the same machine.&lt;/p&gt;
&lt;p&gt;Due to LPC&amp;#x2019;s synchronous nature, both the client and server had to wait until a message was processed, which resulted in continuous blocking and performance issues.&lt;/p&gt;
&lt;p&gt;As a result, from Windows Vista onward, the existing LPC mechanism was effectively reimplemented on top of ALPC, and later versions of Windows internally rely on ALPC as the core IPC mechanism. However, LPC APIs themselves did not completely disappear; rather, their internal implementation was redirected to ALPC.&lt;/p&gt;
&lt;p&gt;&amp;#x1F4A1;As seen in the image below, existing functions for creating LPC ports remain, but internally they are redirected to create ALPC ports instead. @.@&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-2-ALPC-Internal-Structure&#34;&gt;&lt;a href=&#34;#1-2-ALPC-Internal-Structure&#34; class=&#34;headerlink&#34; title=&#34;1.2. ALPC Internal Structure&#34;&gt;&lt;/a&gt;1.2. ALPC Internal Structure&lt;/h3&gt;&lt;p&gt;The main component of ALPC communication is the ALPC port object, and its usage is similar to a network socket.&lt;/p&gt;
&lt;p&gt;&amp;#x2192; The server opens a socket that clients can connect to in order to exchange messages.&lt;/p&gt;
&lt;p&gt;Using Sysinternals Suite&amp;#x2019;s WinObj.exe, we can inspect ALPC ports.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Although some ALPC ports exist in the root path, most of them are located under the \RPC Control path.&lt;/p&gt;
&lt;p&gt;In ALPC communication, three ALPC ports are involved (2 on the server side, 1 on the client side). The ALPC ports shown in WinObj are ALPC Communication Ports that clients can connect to.&lt;/p&gt;
&lt;p&gt;Before explaining the communication process, let&amp;#x2019;s briefly go over some important functions we will repeatedly encounter.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NtAlpcCreatePort()&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS NTAPI &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcCreatePort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    OUT PHANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN POBJECT_ATTRIBUTES ObjectAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN OUT PALPC_INFO PortInformation OPTIONAL&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This function is used to create an ALPC port. Unlike LPC, instead of listing options individually, ALPC bundles them into an ALPC_INFO structure and passes it as the final parameter.&lt;/li&gt;
&lt;li&gt;This structure is copied into the ALPC object when the port is created and later referenced internally.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_INFO&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-class&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_LPCMODE               0x001000 &lt;span class=&#34;hljs-comment&#34;&gt;// Operate like an LPC port&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_CANIMPERSONATE        0x010000 &lt;span class=&#34;hljs-comment&#34;&gt;// Allow impersonation&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_REQUEST_ALLOWED       0x020000 &lt;span class=&#34;hljs-comment&#34;&gt;// Allow message requests&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_SEMAPHORE             0x040000 &lt;span class=&#34;hljs-comment&#34;&gt;// Enable synchronization mechanism&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_HANDLE_EXPOSE         0x080000 &lt;span class=&#34;hljs-comment&#34;&gt;// Allow handle exposure&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_PARENT_SYSTEM_PRACESS 0x100000 &lt;span class=&#34;hljs-comment&#34;&gt;// Kernel ALPC interface (system process parent)&lt;/span&gt;&lt;/span&gt;

    ULONG Flags;
    SECURITY_QUALITY_OF_SERVICE PortQos;
    ULONG MaxMessageSize;
    ULONG unknown1;
    CHAR  cReserved1[&lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;];
    ULONG MaxViewSize;
    CHAR  cReserved2[&lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;];
} ALPC_INFO, *PALPC_INFO;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NtAlpcConnectPort()&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS NTAPI &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcConnectPort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    OUT PHANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PUNICODE_STRING PortName,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN POBJECT_ATTRIBUTES ObjectAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PALPC_INFO PortInformation OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN DWORD ConnectionFlags,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PSID pSid OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PLPC_MESSAGE ConnectionMessage OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN OUT PULONG ConnectMessageSize OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PVOID InMessageBuffer OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PVOID OutMessageBuffer OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PLARGE_INTEGER Timeout OPTIONAL&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The PortName parameter specifies the name of the port to connect to, along with various optional settings. The kernel searches for the ALPC Connection Port object with the given name and then proceeds to request a connection.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Important ConnectionFlags values&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ALPC_SYNC_CONNECTION   0x020000 &lt;span class=&#34;hljs-comment&#34;&gt;// Synchronous connection&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ALPC_USER_WAIT_MODE    0x100000 &lt;span class=&#34;hljs-comment&#34;&gt;// Wait in user mode&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ALPC_WAIT_IS_ALERTABLE 0x200000 &lt;span class=&#34;hljs-comment&#34;&gt;// Alertable wait&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;By default, the connection is asynchronous.&lt;ul&gt;
&lt;li&gt;This means the client can obtain a handle &lt;strong&gt;before&lt;/strong&gt; the server has actually processed and accepted the connection request.&lt;/li&gt;
&lt;li&gt;So if the client sends a message while the server hasn&amp;#x2019;t handled the connection yet, it can result in an error.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NtAlpcSendWaitReceivePort()&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcSendWaitReceivePort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    HANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    DWORD Flags,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PPORT_MESSAGE SendMessage,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PPORT_MESSAGE ReceiveMessage,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PSIZE_T BufferLength,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PLARGE_INTEGER Timeout&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This is the most important function: with this single function, you can send and receive messages at the same time!!&lt;/li&gt;
&lt;li&gt;SendMessage, ReceiveMessage are literally the send/receive message buffers.&lt;/li&gt;
&lt;li&gt;SendMessageAttributes, ReceiveMessageAttributes are used to request or receive extra actions along with the message (section mapping, passing handles, etc.).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-ALPC-Communication-Flow&#34;&gt;&lt;a href=&#34;#2-ALPC-Communication-Flow&#34; class=&#34;headerlink&#34; title=&#34;2. ALPC Communication Flow&#34;&gt;&lt;/a&gt;2. ALPC Communication Flow&lt;/h2&gt;&lt;p&gt;Alright, now that we roughly know what each function does, let&amp;#x2019;s look at the actual communication flow. Earlier, I mentioned that an ALPC communication scenario involves &lt;strong&gt;three&lt;/strong&gt; ALPC ports:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The ALPC connection port created by the server process&lt;/li&gt;
&lt;li&gt;The ALPC server communication port newly created by the kernel when a client connects&lt;/li&gt;
&lt;li&gt;The ALPC client communication port&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We use these three, but just listing them like this doesn&amp;#x2019;t make it very intuitive&amp;#x2026;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;At least it didn&amp;#x2019;t for me&amp;#x3160;&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;In reality, it &lt;em&gt;looks&lt;/em&gt; like three logical ports exist during ALPC communication, but under the hood it&amp;#x2019;s more like multiple endpoints being created on top of a single ALPC port object.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s walk through the communication flow step by step!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%205.png&#34; alt=&#34;[&amp;#xBAA8;&amp;#xB4E0; &amp;#xAC83;&amp;#xC744; &amp;#xD0C0;&amp;#xD611;&amp;#xD558;&amp;#xAE30; &amp;#xC704;&amp;#xD574; N&amp;#xC77C; &amp;#xCCB4;&amp;#xC778;: 2&amp;#xBD80; &amp;#x2014; Windows &amp;#xCEE4;&amp;#xB110; LPE (&amp;#xC77C;&amp;#xBA85; &amp;#xD06C;&amp;#xB86C; &amp;#xC0CC;&amp;#xB4DC;&amp;#xBC15;&amp;#xC2A4; Escape) - Theori BLOG](https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape)&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape&#34;&gt;&amp;#xBAA8;&amp;#xB4E0; &amp;#xAC83;&amp;#xC744; &amp;#xD0C0;&amp;#xD611;&amp;#xD558;&amp;#xAE30; &amp;#xC704;&amp;#xD574; N&amp;#xC77C; &amp;#xCCB4;&amp;#xC778;: 2&amp;#xBD80; &amp;#x2014; Windows &amp;#xCEE4;&amp;#xB110; LPE (&amp;#xC77C;&amp;#xBA85; &amp;#xD06C;&amp;#xB86C; &amp;#xC0CC;&amp;#xB4DC;&amp;#xBC15;&amp;#xC2A4; Escape) - Theori BLOG&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The function we should pay the most attention to is, again, &lt;code&gt;NtAlpcSendWaitReceivePort()&lt;/code&gt;. This guy is basically responsible for all the request/response message exchange. In order, the flow looks like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The server process calls &lt;code&gt;NtAlpcCreatePort()&lt;/code&gt; to create an ALPC port.&lt;ul&gt;
&lt;li&gt;Example name: &lt;code&gt;\RPC Control\HackyBoiz&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The kernel creates the ALPC port object and returns a handle to the server.&lt;/p&gt;
&lt;p&gt; &amp;#x2192; This is the &lt;strong&gt;ALPC Connection Port!&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The server calls &lt;code&gt;NtAlpcSendWaitReceivePort()&lt;/code&gt; and waits for a client connection.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;The client calls &lt;code&gt;NtAlpcConnectPort()&lt;/code&gt;.&lt;ul&gt;
&lt;li&gt;Name of the server port to connect to: &lt;code&gt;\RPC Control\HackyBoiz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;(Optional) Initial message to send to the server&lt;/li&gt;
&lt;li&gt;(Optional) Server SID to verify it&amp;#x2019;s talking to the correct server&lt;/li&gt;
&lt;li&gt;(Optional) Additional message attributes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This connection request is delivered to the server, and the server calls &lt;code&gt;NtAlpcAcceptConnectPort()&lt;/code&gt; to either accept or reject the connection.&lt;ul&gt;
&lt;li&gt;The last argument is a boolean: &lt;code&gt;TRUE&lt;/code&gt; means accept, &lt;code&gt;FALSE&lt;/code&gt; means reject.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If the connection is accepted, the kernel creates a new ALPC Communication Port and returns handles to both the server and the client.&lt;/li&gt;
&lt;li&gt;From this point on, messages are no longer sent through the Connection Port, but through this new Communication Port.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now it&amp;#x2019;s starting to make a bit more sense, right?&lt;/p&gt;
&lt;p&gt;Good. Then let&amp;#x2019;s actually debug it and see it in action.&lt;/p&gt;
&lt;p&gt;You can grab an example ALPC implementation here:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/DownWithUp/ALPC-Example&#34;&gt;https://github.com/DownWithUp/ALPC-Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We&amp;#x2019;ll run this code and walk through the communication process ourselves! XD&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Server.c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;winternl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;ntalpcapi.h&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; comment(lib, &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;ntdll.lib&amp;quot;&lt;/span&gt;)&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; MAX_MSG_LEN 0x500&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;LPVOID &lt;span class=&#34;hljs-title&#34;&gt;AllocMsgMem&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(SIZE_T Size)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE)));
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;CreatePortAndListen&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(LPCWSTR PortName)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    ALPC_PORT_ATTRIBUTES    serverPortAttr;
    OBJECT_ATTRIBUTES       objPort;
    UNICODE_STRING          usPortName;
    PORT_MESSAGE            pmRequest;
    PORT_MESSAGE            pmReceive;
    NTSTATUS                ntRet;
    BOOLEAN                 bBreak;
    HANDLE                  hConnectedPort;
    HANDLE                  hPort;
    SIZE_T                  nLen;
    LPVOID                  lpMem;
    BYTE                    bTemp;
  
    RtlInitUnicodeString(&amp;amp;usPortName, PortName);
    InitializeObjectAttributes(&amp;amp;objPort, &amp;amp;usPortName, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;);
    RtlSecureZeroMemory(&amp;amp;serverPortAttr, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(serverPortAttr));
    serverPortAttr.MaxMessageLength = MAX_MSG_LEN;

    ntRet = NtAlpcCreatePort(&amp;amp;hPort, &amp;amp;objPort, &amp;amp;serverPortAttr);
    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcCreatePort: 0x%X\n&amp;quot;&lt;/span&gt;, ntRet);
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!ntRet)
    {
        nLen = &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmReceive);
        ntRet = NtAlpcSendWaitReceivePort(hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &amp;amp;pmReceive, &amp;amp;nLen, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!ntRet)
        {
            RtlSecureZeroMemory(&amp;amp;pmRequest, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmRequest));
            pmRequest.MessageId = pmReceive.MessageId;
            pmRequest.u1.s1.DataLength = &lt;span class=&#34;hljs-number&#34;&gt;0x0&lt;/span&gt;;
            pmRequest.u1.s1.TotalLength = pmRequest.u1.s1.DataLength + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE);
            ntRet = NtAlpcAcceptConnectPort(&amp;amp;hConnectedPort, hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &amp;amp;pmRequest, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, TRUE); &lt;span class=&#34;hljs-comment&#34;&gt;// 0&lt;/span&gt;
            &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcAcceptConnectPort: 0x%X\n&amp;quot;&lt;/span&gt;, ntRet);
            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!ntRet)
            {
                bBreak = TRUE;
                &lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt; (bBreak)
                {	
                    nLen = MAX_MSG_LEN;
                    lpMem = AllocMsgMem(nLen);
                    NtAlpcSendWaitReceivePort(hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, (PPORT_MESSAGE)lpMem, &amp;amp;nLen, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);
                    pmReceive = *(PORT_MESSAGE*)lpMem;
                    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!&lt;span class=&#34;hljs-built_in&#34;&gt;strcmp&lt;/span&gt;((BYTE*)lpMem + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE), &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;exit\n&amp;quot;&lt;/span&gt;))
                    {
                        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] Received &amp;apos;exit&amp;apos; command\n&amp;quot;&lt;/span&gt;);
                        HeapFree(GetProcessHeap(), &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, lpMem);
                        ntRet = NtAlpcDisconnectPort(hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;);
                        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcDisconnectPort: %X\n&amp;quot;&lt;/span&gt;, ntRet);
                        CloseHandle(hConnectedPort);
                        CloseHandle(hPort);
                        ExitThread(&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;);
                    }
                    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
                    {
                        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] Received Data: &amp;quot;&lt;/span&gt;);
                        &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt;= pmReceive.u1.s1.DataLength; i++)
                        {
                            bTemp = *(BYTE*)((BYTE*)lpMem + i + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
                            &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x%X &amp;quot;&lt;/span&gt;, bTemp);
                        }
                        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;);
                        HeapFree(GetProcessHeap(), &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, lpMem);
                    }
                }
            }
        }
    }
    ExitThread(&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    HANDLE hThread;

    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] ALPC-Example Server\n&amp;quot;&lt;/span&gt;);
    hThread = CreateThread(&lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, (LPTHREAD_START_ROUTINE)&amp;amp;CreatePortAndListen, &lt;span class=&#34;hljs-string&#34;&gt;L&amp;quot;\\RPC Control\\HackyBoiz&amp;quot;&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);
    WaitForSingleObject(hThread, INFINITE);
    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] Shuting down server\n&amp;quot;&lt;/span&gt;);
    getchar();
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Client.c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;winternl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;ntalpcapi.h&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; comment(lib, &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;ntdll.lib&amp;quot;&lt;/span&gt;)&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; MSG_LEN 0x100&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;LPVOID &lt;span class=&#34;hljs-title&#34;&gt;CreateMsgMem&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(PPORT_MESSAGE PortMessage, SIZE_T MessageSize, LPVOID Message)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    LPVOID lpMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MessageSize + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
    memmove(lpMem, PortMessage, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
    memmove((BYTE*)lpMem + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE), Message, MessageSize);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;(lpMem);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    UNICODE_STRING  usPort;
    PORT_MESSAGE    pmSend;
    PORT_MESSAGE    pmReceive;
    NTSTATUS        ntRet;
    BOOLEAN         bBreak;
    SIZE_T          nLen;
    HANDLE          hPort;
    LPVOID          lpMem; 
    CHAR            szInput[MSG_LEN];

    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;ALPC-Example Client\n&amp;quot;&lt;/span&gt;);
    RtlInitUnicodeString(&amp;amp;usPort, &lt;span class=&#34;hljs-string&#34;&gt;L&amp;quot;\\RPC Control\\HackyBoiz&amp;quot;&lt;/span&gt;);
    RtlSecureZeroMemory(&amp;amp;pmSend, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmSend));
    pmSend.u1.s1.DataLength = MSG_LEN;
    pmSend.u1.s1.TotalLength = pmSend.u1.s1.DataLength + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmSend);
    lpMem = CreateMsgMem(&amp;amp;pmSend, MSG_LEN, &lt;span class=&#34;hljs-string&#34;&gt;L&amp;quot;Hello HackyBoiz!&amp;quot;&lt;/span&gt;);
    ntRet = NtAlpcConnectPort(&amp;amp;hPort, &amp;amp;usPort, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);

    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcConnectPort: 0x%X\n&amp;quot;&lt;/span&gt;, ntRet);
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!ntRet)
    {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] type &amp;apos;exit&amp;apos; to disconnect from the server\n&amp;quot;&lt;/span&gt;);
        bBreak = TRUE;
        &lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt; (bBreak)
        {
            RtlSecureZeroMemory(&amp;amp;pmSend, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmSend));
            RtlSecureZeroMemory(&amp;amp;szInput, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(szInput));
            &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[.] Enter Message &amp;gt; &amp;quot;&lt;/span&gt;);
            fgets(&amp;amp;szInput, MSG_LEN, &lt;span class=&#34;hljs-built_in&#34;&gt;stdin&lt;/span&gt;);
            pmSend.u1.s1.DataLength = &lt;span class=&#34;hljs-built_in&#34;&gt;strlen&lt;/span&gt;(szInput);
            pmSend.u1.s1.TotalLength = pmSend.u1.s1.DataLength + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE);
            lpMem = CreateMsgMem(&amp;amp;pmSend, pmSend.u1.s1.DataLength, &amp;amp;szInput);
            ntRet = NtAlpcSendWaitReceivePort(hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, (PPORT_MESSAGE)lpMem, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);
            &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcSendWaitReceivePort: 0x%X\n&amp;quot;&lt;/span&gt;, ntRet);
            HeapFree(GetProcessHeap(), &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, lpMem);
        }
    }
    getchar();
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you build and run Server.c, you can see that a server ALPC port is created under \RPC Control.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now let&amp;#x2019;s debug the server side with WinDbg. First, take a look at NtAlpcCreatePort:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS NTAPI &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcCreatePort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    OUT PHANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN POBJECT_ATTRIBUTES ObjectAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN OUT PALPC_INFO PortInformation OPTIONAL&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;After setting a breakpoint, you&amp;#x2019;ll see that rdx points to the ObjectAttributes. We&amp;#x2019;ll look at Attributes in more detail later, but inside this structure there is an ObjectName. The OBJECT_ATTRIBUTES structure looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;OBJECT_ATTRIBUTES&lt;/span&gt; {&lt;/span&gt;
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;   &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;#x2190; this one&lt;/span&gt;
    ULONG           Attributes;
    PVOID           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So rdx + 0x10 should be the ObjectName, right? If we inspect that:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;You can see that the port is created with the name \RPC Control\HackyBoiz!&lt;/p&gt;
&lt;p&gt;Now let&amp;#x2019;s switch to the client side and debug the communication with WinDbg.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Once we run the client, the server accepts the connection, and the client can start sending messages. Let&amp;#x2019;s look at that part in more detail.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;First, we inspect the initial connection call to &lt;code&gt;NtAlpcConnectPort&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS NTAPI &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcConnectPort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    OUT PHANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PUNICODE_STRING PortName, &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;lt;- here&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN POBJECT_ATTRIBUTES ObjectAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PALPC_INFO PortInformation OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN DWORD ConnectionFlags,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PSID pSid OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PLPC_MESSAGE ConnectionMessage OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN OUT PULONG ConnectMessageSize OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PVOID InMessageBuffer OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PVOID OutMessageBuffer OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PLARGE_INTEGER Timeout OPTIONAL&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rdx holds the PortName. If we dump that, we can confirm that it&amp;#x2019;s pointing to the HackyBoiz port we set up on the server!&lt;/p&gt;
&lt;p&gt;Once the Connect request is sent, the server decides whether to accept it or not.&lt;/p&gt;
&lt;p&gt;Looking at the NtAlpcAcceptConnectPort call in Server.c:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;ntRet = NtAlpcAcceptConnectPort(
    &amp;amp;hConnectedPort,   &lt;span class=&#34;hljs-comment&#34;&gt;// OUT PHANDLE PortHandle  &amp;#x2192; rcx&lt;/span&gt;
    hPort, 
    &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,   
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,   
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,   
    &amp;amp;pmRequest,     
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           
    TRUE              
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The arguments are set up like this.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rcx is the handle that the server will receive for the new communication port. After the syscall, you&amp;#x2019;ll see that hConnectedPort now holds the actual ALPC server communication port handle.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since the last argument AcceptConnection is TRUE, the connection is accepted, and both sides can now exchange messages over this communication port!&lt;/p&gt;
&lt;h2 id=&#34;3-ALPC-Messaging&#34;&gt;&lt;a href=&#34;#3-ALPC-Messaging&#34; class=&#34;headerlink&#34; title=&#34;3. ALPC Messaging&#34;&gt;&lt;/a&gt;3. ALPC Messaging&lt;/h2&gt;&lt;p&gt;Now that we&amp;#x2019;ve seen how ALPC connects, let&amp;#x2019;s look at the actual message format going back and forth.&lt;/p&gt;
&lt;p&gt;In ALPC, messages always have the following layout:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2011.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;[ PORT_MESSAGE ][ Payload(Data) ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The front is the fixed PORT_MESSAGE header, and after that comes the actual text/binary payload we want to send.&lt;/p&gt;
&lt;h3 id=&#34;3-1-PORT-MESSAGE-structure&#34;&gt;&lt;a href=&#34;#3-1-PORT-MESSAGE-structure&#34; class=&#34;headerlink&#34; title=&#34;3.1. PORT_MESSAGE structure&#34;&gt;&lt;/a&gt;3.1. PORT_MESSAGE structure&lt;/h3&gt;&lt;p&gt;The header structure looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;PORT_MESSAGE&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-class&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;union&lt;/span&gt; {
        &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; {&lt;/span&gt;
            USHORT DataLength;   &lt;span class=&#34;hljs-comment&#34;&gt;// Actual payload length&lt;/span&gt;
            USHORT TotalLength;  &lt;span class=&#34;hljs-comment&#34;&gt;// Total size = PORT_MESSAGE + payload&lt;/span&gt;
        } s1;
        ULONG Length;
    } u1;

    &lt;span class=&#34;hljs-keyword&#34;&gt;union&lt;/span&gt; {
        &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; {&lt;/span&gt;
            USHORT Type;             &lt;span class=&#34;hljs-comment&#34;&gt;// Message type&lt;/span&gt;
            USHORT DataInfoOffset;   &lt;span class=&#34;hljs-comment&#34;&gt;// Attribute area offset&lt;/span&gt;
        } s2;
        ULONG ZeroInit;
    } u2;

    &lt;span class=&#34;hljs-keyword&#34;&gt;union&lt;/span&gt; {
        CLIENT_ID ClientId;          &lt;span class=&#34;hljs-comment&#34;&gt;// Sender process/thread ID&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt;    DoNotUseThisField; &lt;span class=&#34;hljs-comment&#34;&gt;// (alignment)&lt;/span&gt;
    };

    ULONG MessageId;                 &lt;span class=&#34;hljs-comment&#34;&gt;// Message identifier&lt;/span&gt;

    &lt;span class=&#34;hljs-keyword&#34;&gt;union&lt;/span&gt; {
        SIZE_T ClientViewSize;       &lt;span class=&#34;hljs-comment&#34;&gt;// Section view size&lt;/span&gt;
        ULONG  CallbackId;           &lt;span class=&#34;hljs-comment&#34;&gt;// Callback ID&lt;/span&gt;
    };

} PORT_MESSAGE, *PPORT_MESSAGE;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In practice, we usually only care about around four fields:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;u1.s1.DataLength&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Length of the payload&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;u1.s1.TotalLength&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; sizeof(PORT_MESSAGE) + DataLength&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Used by the kernel to know the total size of the message&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ClientId&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Process and thread ID of the sender&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MessageId / CallbackId&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Used to match requests and responses&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the actual format is pretty straightforward.&lt;/p&gt;
&lt;p&gt;If we look again at the example client code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; MSG_LEN 0x100&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;LPVOID &lt;span class=&#34;hljs-title&#34;&gt;CreateMsgMem&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(PPORT_MESSAGE PortMessage, SIZE_T MessageSize, LPVOID Message)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;    LPVOID lpMem &lt;/span&gt;= HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MessageSize + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
    memmove(lpMem, PortMessage, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
    memmove((BYTE*)lpMem + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE), Message, MessageSize);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;(lpMem);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, lpMem is exactly:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;[ PORT_MESSAGE ][ Payload ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A fully-formed ALPC message buffer.&lt;/p&gt;
&lt;p&gt;In main() we use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;RtlSecureZeroMemory(&amp;amp;pmSend, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmSend));

&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[.] Enter Message &amp;gt; &amp;quot;&lt;/span&gt;);
fgets(&amp;amp;szInput, MSG_LEN, &lt;span class=&#34;hljs-built_in&#34;&gt;stdin&lt;/span&gt;);

pmSend.u1.s1.DataLength  = &lt;span class=&#34;hljs-built_in&#34;&gt;strlen&lt;/span&gt;(szInput);
pmSend.u1.s1.TotalLength = pmSend.u1.s1.DataLength + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE);

lpMem = CreateMsgMem(&amp;amp;pmSend, pmSend.u1.s1.DataLength, &amp;amp;szInput);

ntRet = NtAlpcSendWaitReceivePort(
    hPort,                &lt;span class=&#34;hljs-comment&#34;&gt;// HANDLE PortHandle&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,                    &lt;span class=&#34;hljs-comment&#34;&gt;// ULONG Flags&lt;/span&gt;
    (PPORT_MESSAGE)lpMem, &lt;span class=&#34;hljs-comment&#34;&gt;// SendMessage&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,                 &lt;span class=&#34;hljs-comment&#34;&gt;// SendMessageAttributes&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,                 &lt;span class=&#34;hljs-comment&#34;&gt;// ReceiveMessage&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,                 &lt;span class=&#34;hljs-comment&#34;&gt;// BufferLength&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,                 &lt;span class=&#34;hljs-comment&#34;&gt;// ReceiveMessageAttributes&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;                  &lt;span class=&#34;hljs-comment&#34;&gt;// Timeout&lt;/span&gt;
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To summarize:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We set DataLength and TotalLength inside pmSend.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CreateMsgMem() builds a single buffer lpMem with:&lt;/p&gt;
&lt;p&gt; [ pmSend | user input string ]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We pass lpMem as SendMessage to NtAlpcSendWaitReceivePort.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course, we should also look at how the message actually looks in memory during debugging.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2012.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s check what the buffer looks like when the client sends &lt;strong&gt;&amp;#x201C;Hello HackyBoiz!&amp;#x201D;&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;ntRet = NtAlpcSendWaitReceivePort(
    hPort,          &lt;span class=&#34;hljs-comment&#34;&gt;// HANDLE PortHandle&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,              &lt;span class=&#34;hljs-comment&#34;&gt;// ULONG Flags&lt;/span&gt;
    (PPORT_MESSAGE)lpMem, &lt;span class=&#34;hljs-comment&#34;&gt;// SendMessage&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           &lt;span class=&#34;hljs-comment&#34;&gt;// SendMessageAttributes&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           &lt;span class=&#34;hljs-comment&#34;&gt;// ReceiveMessage&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           &lt;span class=&#34;hljs-comment&#34;&gt;// BufferLength&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           &lt;span class=&#34;hljs-comment&#34;&gt;// ReceiveMessageAttributes&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;            &lt;span class=&#34;hljs-comment&#34;&gt;// Timeout&lt;/span&gt;
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our code, NtAlpcSendWaitReceivePort is called like this.&lt;/p&gt;
&lt;p&gt;lpMem should contain the message we&amp;#x2019;re sending. Let&amp;#x2019;s inspect it!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2013.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;r8 is the pointer to the full message buffer, and we can clearly see PORT_MESSAGE followed by &amp;#x201C;Hello HackyBoiz!&amp;#x201D;.&lt;/p&gt;
&lt;p&gt;The first DWORD is 00390011 because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lower 2 bytes = 0x0011 &amp;#x2192; DataLength = 0x11 = 17 (string length)&lt;/li&gt;
&lt;li&gt;Upper 2 bytes = 0x0039 &amp;#x2192; TotalLength = 0x39 = 57 (PORT_MESSAGE + payload)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is the buffer that gets copied from user mode to kernel mode, then from the server&amp;#x2019;s kernel-side buffer to the server&amp;#x2019;s receive buffer.&lt;/p&gt;
&lt;h2 id=&#34;4-ALPC-Message-Attribute&#34;&gt;&lt;a href=&#34;#4-ALPC-Message-Attribute&#34; class=&#34;headerlink&#34; title=&#34;4. ALPC Message Attribute&#34;&gt;&lt;/a&gt;4. ALPC Message Attribute&lt;/h2&gt;&lt;p&gt;So far we&amp;#x2019;ve looked at &lt;strong&gt;how to create ports, connect them, and send messages&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;But if ALPC were only about sending messages, there&amp;#x2019;d be no reason for it to be this complex.&lt;/p&gt;
&lt;p&gt;The real reason ALPC is complicated is that, besides the message body, it can also attach various &lt;strong&gt;attributes&lt;/strong&gt; to a message:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Security context (impersonation)&lt;/li&gt;
&lt;li&gt;Shared memory sections (views)&lt;/li&gt;
&lt;li&gt;Handles (files, processes, sections, etc.)&lt;/li&gt;
&lt;li&gt;Token information&lt;/li&gt;
&lt;li&gt;User-defined context&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ALPC is basically a framework that lets you send all of this together in a single NtAlpcSendWaitReceivePort call.&lt;/p&gt;
&lt;h3 id=&#34;4-1-ALPC-Message-Attribute&#34;&gt;&lt;a href=&#34;#4-1-ALPC-Message-Attribute&#34; class=&#34;headerlink&#34; title=&#34;4.1. ALPC Message Attribute&#34;&gt;&lt;/a&gt;4.1. ALPC Message Attribute&lt;/h3&gt;&lt;p&gt;If we look again at the &lt;code&gt;NtAlpcSendWaitReceivePort()&lt;/code&gt; signature, we see two extra parameters for attributes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcSendWaitReceivePort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    HANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    DWORD Flags,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PPORT_MESSAGE SendMessage,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,    &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;#x2190; send-side attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PPORT_MESSAGE ReceiveMessage,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PSIZE_T BufferLength,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;#x2190; receive-side attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PLARGE_INTEGER Timeout&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SendMessageAttributes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Attributes we want to attach when sending the message.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ReceiveMessageAttributes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Attributes we want to receive along with the response.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So you can think of it as a &amp;#x201C;mutual agreement&amp;#x201D; model for sending attributes.&lt;/p&gt;
&lt;p&gt;At the beginning of the attribute buffer, there is a common header:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_MESSAGE_ATTRIBUTES&lt;/span&gt; {&lt;/span&gt;
    ULONG AllocatedAttributes;  &lt;span class=&#34;hljs-comment&#34;&gt;// Which attribute types this buffer has space for&lt;/span&gt;
    ULONG ValidAttributes;      &lt;span class=&#34;hljs-comment&#34;&gt;// Which attributes are actually valid for this message&lt;/span&gt;
} ALPC_MESSAGE_ATTRIBUTES, *PALPC_MESSAGE_ATTRIBUTES;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;AllocatedAttributes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Bit flags indicating which attribute types this buffer can hold&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ValidAttributes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Which attributes are actually used for this specific message&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To paraphrase it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs ini&#34;&gt;&lt;span class=&#34;hljs-attr&#34;&gt;AllocatedAttributes&lt;/span&gt; = &amp;#x201C;This buffer can hold these attributes.&amp;#x201D;

&lt;span class=&#34;hljs-attr&#34;&gt;ValidAttributes&lt;/span&gt; =  &amp;#x201C;These are the &lt;span class=&#34;hljs-literal&#34;&gt;on&lt;/span&gt;es we&amp;#x2019;re actually using for this message.&amp;#x201D;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-2-Main-attribute-types&#34;&gt;&lt;a href=&#34;#4-2-Main-attribute-types&#34; class=&#34;headerlink&#34; title=&#34;4.2 Main attribute types&#34;&gt;&lt;/a&gt;4.2 Main attribute types&lt;/h3&gt;&lt;p&gt;There are several types of attributes, but let&amp;#x2019;s look at the most important ones.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. Security Attribute&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This includes the sender&amp;#x2019;s security context, which allows the receiver to impersonate the sender.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_SECURITY_ATTR&lt;/span&gt; {&lt;/span&gt;
    ULONG Flags;
    PSECURITY_QUALITY_OF_SERVICE pQOS;
    HANDLE ContextHandle;
} ALPC_SECURITY_ATTR, *PALPC_SECURITY_ATTR;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pQOS&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Pointer to a &lt;code&gt;SECURITY_QUALITY_OF_SERVICE&lt;/code&gt; structure&lt;/li&gt;
&lt;li&gt;Controls what level of impersonation, context tracking, etc. is allowed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContextHandle&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Handle to a kernel-managed security context&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2. View Attribute (Data View Attribute)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Used to pass a shared memory section. This is how you bypass the normal 64KB message size limit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_DATA_VIEW_ATTR&lt;/span&gt; {&lt;/span&gt;
    ULONG  Flags;
    HANDLE SectionHandle;  &lt;span class=&#34;hljs-comment&#34;&gt;// Section handle attached to the ALPC port&lt;/span&gt;
    PVOID  ViewBase;       &lt;span class=&#34;hljs-comment&#34;&gt;// Base address where the section is mapped in this process&lt;/span&gt;
    SIZE_T ViewSize;       &lt;span class=&#34;hljs-comment&#34;&gt;// Size of the mapped view&lt;/span&gt;
} ALPC_DATA_VIEW_ATTR, *PALPC_DATA_VIEW_ATTR;&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Create a shared section and configure a view using &lt;code&gt;NtAlpcCreatePortSection&lt;/code&gt; / &lt;code&gt;NtAlpcCreateSectionView&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Fill an &lt;code&gt;ALPC_DATA_VIEW_ATTR&lt;/code&gt; with that information.&lt;/li&gt;
&lt;li&gt;Attach it to the attribute buffer and send it along with the message.&lt;/li&gt;
&lt;li&gt;The receiver maps the same section view in its own address space, effectively sharing memory.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;3. Context Attribute&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Used to attach user-defined context to a particular client or message.&lt;/p&gt;
&lt;p&gt;The server can use this to track per-client state or per-message state.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_CONTEXT_ATTR&lt;/span&gt; {&lt;/span&gt;
    PVOID PortContext;     &lt;span class=&#34;hljs-comment&#34;&gt;// Context attached to this port (client)&lt;/span&gt;
    PVOID MessageContext;  &lt;span class=&#34;hljs-comment&#34;&gt;// Context attached to this specific message&lt;/span&gt;
    ULONG Sequence;        &lt;span class=&#34;hljs-comment&#34;&gt;// Sequence number&lt;/span&gt;
    ULONG MessageId;       &lt;span class=&#34;hljs-comment&#34;&gt;// Message ID&lt;/span&gt;
    ULONG CallbackId;      &lt;span class=&#34;hljs-comment&#34;&gt;// Callback ID&lt;/span&gt;
} ALPC_CONTEXT_ATTR, *PALPC_CONTEXT_ATTR;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PortContext&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;A pointer to a structure the server associates with the client port (session ID, user info, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MessageContext&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Used when you want separate context per message&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sequence&lt;/code&gt; / &lt;code&gt;MessageId&lt;/code&gt; / &lt;code&gt;CallbackId&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Values set by the kernel&lt;/li&gt;
&lt;li&gt;Help with structured message handling, similar to how TCP tracks state for requests/responses&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;4. Handle Attribute&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Used to pass object handles along with the message.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_MESSAGE_HANDLE_INFORMATION&lt;/span&gt; {&lt;/span&gt;
    ULONG Index;        &lt;span class=&#34;hljs-comment&#34;&gt;// Index in the attribute buffer&lt;/span&gt;
    ULONG Flags;
    ULONG Handle;       &lt;span class=&#34;hljs-comment&#34;&gt;// Handle value (from the sender&amp;#x2019;s perspective)&lt;/span&gt;
    ULONG ObjectType;   &lt;span class=&#34;hljs-comment&#34;&gt;// Object type&lt;/span&gt;
    ACCESS_MASK GrantedAccess; &lt;span class=&#34;hljs-comment&#34;&gt;// Access rights the receiver will get&lt;/span&gt;
} ALPC_MESSAGE_HANDLE_INFORMATION, *PALPC_MESSAGE_HANDLE_INFORMATION;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The kernel checks whether the handle is valid, whether the rights make sense, and whether cross-process duplication is allowed.&lt;/li&gt;
&lt;li&gt;The receiver then uses this information to obtain a valid handle for the corresponding object in its own process.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Wrapping-Up&#34;&gt;&lt;a href=&#34;#Wrapping-Up&#34; class=&#34;headerlink&#34; title=&#34;Wrapping Up&#34;&gt;&lt;/a&gt;Wrapping Up&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;image%2014.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;So that&amp;#x2019;s the basic flow of ALPC! On the surface it just looks like &amp;#x201C;yet another IPC mechanism,&amp;#x201D; but under the hood, a single call to &lt;code&gt;NtAlpcSendWaitReceivePort()&lt;/code&gt; takes care of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Managing port objects&lt;/li&gt;
&lt;li&gt;Handling the &lt;code&gt;PORT_MESSAGE&lt;/code&gt; header&lt;/li&gt;
&lt;li&gt;Parsing various attributes&lt;/li&gt;
&lt;li&gt;Mapping section views, validating permissions, duplicating handles, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Because of this complexity, a lot of real-world vulnerabilities tend to appear in the logic that interprets and validates these attributes.&lt;/p&gt;
&lt;p&gt;If I get the chance, I&amp;#x2019;d love to write another post just focusing on ALPC-based vulnerabilities.&lt;/p&gt;
&lt;p&gt;Thanks for reading this long post &amp;#x2014; see you next time! &amp;#x1F44B;&lt;/p&gt;
&lt;h2 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://ti.qianxin.com/blog/articles/the-tragedy-of-alpc-unknown-windows-privilege-escalation-nday-vulnerability-research-in-august-en/&#34;&gt;https://ti.qianxin.com/blog/articles/the-tragedy-of-alpc-unknown-windows-privilege-escalation-nday-vulnerability-research-in-august-en/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://csandker.io/2022/05/24/Offensive-Windows-IPC-3-ALPC.html&#34;&gt;https://csandker.io/2022/05/24/Offensive-Windows-IPC-3-ALPC.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://csandker.io/2022/05/29/Debugging-And-Reversing-ALPC.html&#34;&gt;https://csandker.io/2022/05/29/Debugging-And-Reversing-ALPC.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://recon.cx/2008/a/thomas_garnier/LPC-ALPC-paper.pdf&#34;&gt;https://recon.cx/2008/a/thomas_garnier/LPC-ALPC-paper.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape&#34;&gt;https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://infocon.org/cons/SyScan/SyScan%202014%20Singapore/SyScan%202014%20presentations/SyScan2014_AlexIonescu_AllabouttheRPCLRPCALPCandLPCinyourPC.pdf&#34;&gt;https://infocon.org/cons/SyScan/SyScan%202014%20Singapore/SyScan%202014%20presentations/SyScan2014_AlexIonescu_AllabouttheRPCLRPCALPCandLPCinyourPC.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Local_Inter-Process_Communication&#34;&gt;https://en.wikipedia.org/wiki/Local_Inter-Process_Communication&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://processhacker.sourceforge.io/doc/struct___a_l_p_c___s_e_c_u_r_i_t_y___a_t_t_r.html&#34;&gt;https://processhacker.sourceforge.io/doc/struct___a_l_p_c___s_e_c_u_r_i_t_y___a_t_t_r.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://ntdoc.m417z.com/&#34;&gt;https://ntdoc.m417z.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] Windows ALPC (EN) - hackyboiz">
  <meta property="og:description" content="&lt;h2 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Hello! I&amp;#x2019;m &lt;code&gt;gongjae&lt;/code&gt;, a new member who recently joined HackyBoiz! &amp;#x1F47B;&lt;/p&gt;
&lt;p&gt;During my time as a trainee at HackyBoiz, I had a question related to the Kernel Driver and Named Pipe bug hunting project I had previously worked on.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;Nope&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Actually, I already knew that ALPC is one of the IPC communication methods, but I decided to take this opportunity to study it properly. &lt;/p&gt;
&lt;p&gt;So today, we&amp;#x2019;ll explore the concept of ALPC, its communication flow, and how messages are transmitted &amp;#x2014; all while debugging it directly! :)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-About-ALPC&#34;&gt;&lt;a href=&#34;#1-About-ALPC&#34; class=&#34;headerlink&#34; title=&#34;1. About ALPC&#34;&gt;&lt;/a&gt;1. About ALPC&lt;/h2&gt;&lt;p&gt;In the Windows environment, IPC mechanisms that can be used both remotely and locally include Named Pipes and RPC. However, ALPC is unique in that it can only be used locally.&lt;/p&gt;
&lt;p&gt;While RPC stands for Remote Procedure Call, ALPC stands for Advanced Local Procedure Call and is sometimes also referred to as Asynchronous Local Call.&lt;/p&gt;
&lt;p&gt;The term &amp;#x201C;asynchronous&amp;#x201D; reflects the Windows Vista era, during which ALPC was introduced to replace the existing LPC mechanism.&lt;/p&gt;
&lt;p&gt;ALPC enables high-speed message communication and is used for data transmission between processes.&lt;/p&gt;
&lt;h3 id=&#34;1-1-LPC-to-ALPC&#34;&gt;&lt;a href=&#34;#1-1-LPC-to-ALPC&#34; class=&#34;headerlink&#34; title=&#34;1.1. LPC to ALPC&#34;&gt;&lt;/a&gt;1.1. LPC to ALPC&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Before Windows Vista, LPC was an undocumented internal IPC mechanism provided by the Microsoft Windows NT kernel, used for lightweight communication between processes on the same machine.&lt;/p&gt;
&lt;p&gt;Due to LPC&amp;#x2019;s synchronous nature, both the client and server had to wait until a message was processed, which resulted in continuous blocking and performance issues.&lt;/p&gt;
&lt;p&gt;As a result, from Windows Vista onward, the existing LPC mechanism was effectively reimplemented on top of ALPC, and later versions of Windows internally rely on ALPC as the core IPC mechanism. However, LPC APIs themselves did not completely disappear; rather, their internal implementation was redirected to ALPC.&lt;/p&gt;
&lt;p&gt;&amp;#x1F4A1;As seen in the image below, existing functions for creating LPC ports remain, but internally they are redirected to create ALPC ports instead. @.@&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-2-ALPC-Internal-Structure&#34;&gt;&lt;a href=&#34;#1-2-ALPC-Internal-Structure&#34; class=&#34;headerlink&#34; title=&#34;1.2. ALPC Internal Structure&#34;&gt;&lt;/a&gt;1.2. ALPC Internal Structure&lt;/h3&gt;&lt;p&gt;The main component of ALPC communication is the ALPC port object, and its usage is similar to a network socket.&lt;/p&gt;
&lt;p&gt;&amp;#x2192; The server opens a socket that clients can connect to in order to exchange messages.&lt;/p&gt;
&lt;p&gt;Using Sysinternals Suite&amp;#x2019;s WinObj.exe, we can inspect ALPC ports.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Although some ALPC ports exist in the root path, most of them are located under the \RPC Control path.&lt;/p&gt;
&lt;p&gt;In ALPC communication, three ALPC ports are involved (2 on the server side, 1 on the client side). The ALPC ports shown in WinObj are ALPC Communication Ports that clients can connect to.&lt;/p&gt;
&lt;p&gt;Before explaining the communication process, let&amp;#x2019;s briefly go over some important functions we will repeatedly encounter.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NtAlpcCreatePort()&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS NTAPI &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcCreatePort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    OUT PHANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN POBJECT_ATTRIBUTES ObjectAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN OUT PALPC_INFO PortInformation OPTIONAL&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This function is used to create an ALPC port. Unlike LPC, instead of listing options individually, ALPC bundles them into an ALPC_INFO structure and passes it as the final parameter.&lt;/li&gt;
&lt;li&gt;This structure is copied into the ALPC object when the port is created and later referenced internally.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_INFO&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-class&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_LPCMODE               0x001000 &lt;span class=&#34;hljs-comment&#34;&gt;// Operate like an LPC port&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_CANIMPERSONATE        0x010000 &lt;span class=&#34;hljs-comment&#34;&gt;// Allow impersonation&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_REQUEST_ALLOWED       0x020000 &lt;span class=&#34;hljs-comment&#34;&gt;// Allow message requests&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_SEMAPHORE             0x040000 &lt;span class=&#34;hljs-comment&#34;&gt;// Enable synchronization mechanism&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_HANDLE_EXPOSE         0x080000 &lt;span class=&#34;hljs-comment&#34;&gt;// Allow handle exposure&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; PORT_INFO_PARENT_SYSTEM_PRACESS 0x100000 &lt;span class=&#34;hljs-comment&#34;&gt;// Kernel ALPC interface (system process parent)&lt;/span&gt;&lt;/span&gt;

    ULONG Flags;
    SECURITY_QUALITY_OF_SERVICE PortQos;
    ULONG MaxMessageSize;
    ULONG unknown1;
    CHAR  cReserved1[&lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;];
    ULONG MaxViewSize;
    CHAR  cReserved2[&lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;];
} ALPC_INFO, *PALPC_INFO;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NtAlpcConnectPort()&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS NTAPI &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcConnectPort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    OUT PHANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PUNICODE_STRING PortName,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN POBJECT_ATTRIBUTES ObjectAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PALPC_INFO PortInformation OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN DWORD ConnectionFlags,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PSID pSid OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PLPC_MESSAGE ConnectionMessage OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN OUT PULONG ConnectMessageSize OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PVOID InMessageBuffer OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PVOID OutMessageBuffer OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PLARGE_INTEGER Timeout OPTIONAL&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The PortName parameter specifies the name of the port to connect to, along with various optional settings. The kernel searches for the ALPC Connection Port object with the given name and then proceeds to request a connection.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Important ConnectionFlags values&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ALPC_SYNC_CONNECTION   0x020000 &lt;span class=&#34;hljs-comment&#34;&gt;// Synchronous connection&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ALPC_USER_WAIT_MODE    0x100000 &lt;span class=&#34;hljs-comment&#34;&gt;// Wait in user mode&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; ALPC_WAIT_IS_ALERTABLE 0x200000 &lt;span class=&#34;hljs-comment&#34;&gt;// Alertable wait&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;By default, the connection is asynchronous.&lt;ul&gt;
&lt;li&gt;This means the client can obtain a handle &lt;strong&gt;before&lt;/strong&gt; the server has actually processed and accepted the connection request.&lt;/li&gt;
&lt;li&gt;So if the client sends a message while the server hasn&amp;#x2019;t handled the connection yet, it can result in an error.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NtAlpcSendWaitReceivePort()&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcSendWaitReceivePort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    HANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    DWORD Flags,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PPORT_MESSAGE SendMessage,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PPORT_MESSAGE ReceiveMessage,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PSIZE_T BufferLength,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PLARGE_INTEGER Timeout&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This is the most important function: with this single function, you can send and receive messages at the same time!!&lt;/li&gt;
&lt;li&gt;SendMessage, ReceiveMessage are literally the send/receive message buffers.&lt;/li&gt;
&lt;li&gt;SendMessageAttributes, ReceiveMessageAttributes are used to request or receive extra actions along with the message (section mapping, passing handles, etc.).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-ALPC-Communication-Flow&#34;&gt;&lt;a href=&#34;#2-ALPC-Communication-Flow&#34; class=&#34;headerlink&#34; title=&#34;2. ALPC Communication Flow&#34;&gt;&lt;/a&gt;2. ALPC Communication Flow&lt;/h2&gt;&lt;p&gt;Alright, now that we roughly know what each function does, let&amp;#x2019;s look at the actual communication flow. Earlier, I mentioned that an ALPC communication scenario involves &lt;strong&gt;three&lt;/strong&gt; ALPC ports:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The ALPC connection port created by the server process&lt;/li&gt;
&lt;li&gt;The ALPC server communication port newly created by the kernel when a client connects&lt;/li&gt;
&lt;li&gt;The ALPC client communication port&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We use these three, but just listing them like this doesn&amp;#x2019;t make it very intuitive&amp;#x2026;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;At least it didn&amp;#x2019;t for me&amp;#x3160;&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;In reality, it &lt;em&gt;looks&lt;/em&gt; like three logical ports exist during ALPC communication, but under the hood it&amp;#x2019;s more like multiple endpoints being created on top of a single ALPC port object.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s walk through the communication flow step by step!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%205.png&#34; alt=&#34;[&amp;#xBAA8;&amp;#xB4E0; &amp;#xAC83;&amp;#xC744; &amp;#xD0C0;&amp;#xD611;&amp;#xD558;&amp;#xAE30; &amp;#xC704;&amp;#xD574; N&amp;#xC77C; &amp;#xCCB4;&amp;#xC778;: 2&amp;#xBD80; &amp;#x2014; Windows &amp;#xCEE4;&amp;#xB110; LPE (&amp;#xC77C;&amp;#xBA85; &amp;#xD06C;&amp;#xB86C; &amp;#xC0CC;&amp;#xB4DC;&amp;#xBC15;&amp;#xC2A4; Escape) - Theori BLOG](https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape)&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape&#34;&gt;&amp;#xBAA8;&amp;#xB4E0; &amp;#xAC83;&amp;#xC744; &amp;#xD0C0;&amp;#xD611;&amp;#xD558;&amp;#xAE30; &amp;#xC704;&amp;#xD574; N&amp;#xC77C; &amp;#xCCB4;&amp;#xC778;: 2&amp;#xBD80; &amp;#x2014; Windows &amp;#xCEE4;&amp;#xB110; LPE (&amp;#xC77C;&amp;#xBA85; &amp;#xD06C;&amp;#xB86C; &amp;#xC0CC;&amp;#xB4DC;&amp;#xBC15;&amp;#xC2A4; Escape) - Theori BLOG&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The function we should pay the most attention to is, again, &lt;code&gt;NtAlpcSendWaitReceivePort()&lt;/code&gt;. This guy is basically responsible for all the request/response message exchange. In order, the flow looks like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The server process calls &lt;code&gt;NtAlpcCreatePort()&lt;/code&gt; to create an ALPC port.&lt;ul&gt;
&lt;li&gt;Example name: &lt;code&gt;\RPC Control\HackyBoiz&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The kernel creates the ALPC port object and returns a handle to the server.&lt;/p&gt;
&lt;p&gt; &amp;#x2192; This is the &lt;strong&gt;ALPC Connection Port!&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The server calls &lt;code&gt;NtAlpcSendWaitReceivePort()&lt;/code&gt; and waits for a client connection.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;The client calls &lt;code&gt;NtAlpcConnectPort()&lt;/code&gt;.&lt;ul&gt;
&lt;li&gt;Name of the server port to connect to: &lt;code&gt;\RPC Control\HackyBoiz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;(Optional) Initial message to send to the server&lt;/li&gt;
&lt;li&gt;(Optional) Server SID to verify it&amp;#x2019;s talking to the correct server&lt;/li&gt;
&lt;li&gt;(Optional) Additional message attributes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This connection request is delivered to the server, and the server calls &lt;code&gt;NtAlpcAcceptConnectPort()&lt;/code&gt; to either accept or reject the connection.&lt;ul&gt;
&lt;li&gt;The last argument is a boolean: &lt;code&gt;TRUE&lt;/code&gt; means accept, &lt;code&gt;FALSE&lt;/code&gt; means reject.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If the connection is accepted, the kernel creates a new ALPC Communication Port and returns handles to both the server and the client.&lt;/li&gt;
&lt;li&gt;From this point on, messages are no longer sent through the Connection Port, but through this new Communication Port.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now it&amp;#x2019;s starting to make a bit more sense, right?&lt;/p&gt;
&lt;p&gt;Good. Then let&amp;#x2019;s actually debug it and see it in action.&lt;/p&gt;
&lt;p&gt;You can grab an example ALPC implementation here:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/DownWithUp/ALPC-Example&#34;&gt;https://github.com/DownWithUp/ALPC-Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We&amp;#x2019;ll run this code and walk through the communication process ourselves! XD&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Server.c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;winternl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;ntalpcapi.h&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; comment(lib, &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;ntdll.lib&amp;quot;&lt;/span&gt;)&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; MAX_MSG_LEN 0x500&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;LPVOID &lt;span class=&#34;hljs-title&#34;&gt;AllocMsgMem&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(SIZE_T Size)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE)));
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;CreatePortAndListen&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(LPCWSTR PortName)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    ALPC_PORT_ATTRIBUTES    serverPortAttr;
    OBJECT_ATTRIBUTES       objPort;
    UNICODE_STRING          usPortName;
    PORT_MESSAGE            pmRequest;
    PORT_MESSAGE            pmReceive;
    NTSTATUS                ntRet;
    BOOLEAN                 bBreak;
    HANDLE                  hConnectedPort;
    HANDLE                  hPort;
    SIZE_T                  nLen;
    LPVOID                  lpMem;
    BYTE                    bTemp;
  
    RtlInitUnicodeString(&amp;amp;usPortName, PortName);
    InitializeObjectAttributes(&amp;amp;objPort, &amp;amp;usPortName, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;);
    RtlSecureZeroMemory(&amp;amp;serverPortAttr, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(serverPortAttr));
    serverPortAttr.MaxMessageLength = MAX_MSG_LEN;

    ntRet = NtAlpcCreatePort(&amp;amp;hPort, &amp;amp;objPort, &amp;amp;serverPortAttr);
    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcCreatePort: 0x%X\n&amp;quot;&lt;/span&gt;, ntRet);
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!ntRet)
    {
        nLen = &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmReceive);
        ntRet = NtAlpcSendWaitReceivePort(hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &amp;amp;pmReceive, &amp;amp;nLen, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!ntRet)
        {
            RtlSecureZeroMemory(&amp;amp;pmRequest, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmRequest));
            pmRequest.MessageId = pmReceive.MessageId;
            pmRequest.u1.s1.DataLength = &lt;span class=&#34;hljs-number&#34;&gt;0x0&lt;/span&gt;;
            pmRequest.u1.s1.TotalLength = pmRequest.u1.s1.DataLength + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE);
            ntRet = NtAlpcAcceptConnectPort(&amp;amp;hConnectedPort, hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &amp;amp;pmRequest, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, TRUE); &lt;span class=&#34;hljs-comment&#34;&gt;// 0&lt;/span&gt;
            &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcAcceptConnectPort: 0x%X\n&amp;quot;&lt;/span&gt;, ntRet);
            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!ntRet)
            {
                bBreak = TRUE;
                &lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt; (bBreak)
                {	
                    nLen = MAX_MSG_LEN;
                    lpMem = AllocMsgMem(nLen);
                    NtAlpcSendWaitReceivePort(hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, (PPORT_MESSAGE)lpMem, &amp;amp;nLen, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);
                    pmReceive = *(PORT_MESSAGE*)lpMem;
                    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!&lt;span class=&#34;hljs-built_in&#34;&gt;strcmp&lt;/span&gt;((BYTE*)lpMem + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE), &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;exit\n&amp;quot;&lt;/span&gt;))
                    {
                        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] Received &amp;apos;exit&amp;apos; command\n&amp;quot;&lt;/span&gt;);
                        HeapFree(GetProcessHeap(), &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, lpMem);
                        ntRet = NtAlpcDisconnectPort(hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;);
                        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcDisconnectPort: %X\n&amp;quot;&lt;/span&gt;, ntRet);
                        CloseHandle(hConnectedPort);
                        CloseHandle(hPort);
                        ExitThread(&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;);
                    }
                    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;
                    {
                        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] Received Data: &amp;quot;&lt;/span&gt;);
                        &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt;= pmReceive.u1.s1.DataLength; i++)
                        {
                            bTemp = *(BYTE*)((BYTE*)lpMem + i + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
                            &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x%X &amp;quot;&lt;/span&gt;, bTemp);
                        }
                        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;);
                        HeapFree(GetProcessHeap(), &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, lpMem);
                    }
                }
            }
        }
    }
    ExitThread(&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    HANDLE hThread;

    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] ALPC-Example Server\n&amp;quot;&lt;/span&gt;);
    hThread = CreateThread(&lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, (LPTHREAD_START_ROUTINE)&amp;amp;CreatePortAndListen, &lt;span class=&#34;hljs-string&#34;&gt;L&amp;quot;\\RPC Control\\HackyBoiz&amp;quot;&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);
    WaitForSingleObject(hThread, INFINITE);
    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] Shuting down server\n&amp;quot;&lt;/span&gt;);
    getchar();
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Client.c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;winternl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;ntalpcapi.h&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; comment(lib, &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;quot;ntdll.lib&amp;quot;&lt;/span&gt;)&lt;/span&gt;

&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; MSG_LEN 0x100&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;LPVOID &lt;span class=&#34;hljs-title&#34;&gt;CreateMsgMem&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(PPORT_MESSAGE PortMessage, SIZE_T MessageSize, LPVOID Message)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    LPVOID lpMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MessageSize + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
    memmove(lpMem, PortMessage, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
    memmove((BYTE*)lpMem + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE), Message, MessageSize);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;(lpMem);
}

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;{
    UNICODE_STRING  usPort;
    PORT_MESSAGE    pmSend;
    PORT_MESSAGE    pmReceive;
    NTSTATUS        ntRet;
    BOOLEAN         bBreak;
    SIZE_T          nLen;
    HANDLE          hPort;
    LPVOID          lpMem; 
    CHAR            szInput[MSG_LEN];

    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;ALPC-Example Client\n&amp;quot;&lt;/span&gt;);
    RtlInitUnicodeString(&amp;amp;usPort, &lt;span class=&#34;hljs-string&#34;&gt;L&amp;quot;\\RPC Control\\HackyBoiz&amp;quot;&lt;/span&gt;);
    RtlSecureZeroMemory(&amp;amp;pmSend, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmSend));
    pmSend.u1.s1.DataLength = MSG_LEN;
    pmSend.u1.s1.TotalLength = pmSend.u1.s1.DataLength + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmSend);
    lpMem = CreateMsgMem(&amp;amp;pmSend, MSG_LEN, &lt;span class=&#34;hljs-string&#34;&gt;L&amp;quot;Hello HackyBoiz!&amp;quot;&lt;/span&gt;);
    ntRet = NtAlpcConnectPort(&amp;amp;hPort, &amp;amp;usPort, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);

    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcConnectPort: 0x%X\n&amp;quot;&lt;/span&gt;, ntRet);
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!ntRet)
    {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] type &amp;apos;exit&amp;apos; to disconnect from the server\n&amp;quot;&lt;/span&gt;);
        bBreak = TRUE;
        &lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt; (bBreak)
        {
            RtlSecureZeroMemory(&amp;amp;pmSend, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmSend));
            RtlSecureZeroMemory(&amp;amp;szInput, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(szInput));
            &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[.] Enter Message &amp;gt; &amp;quot;&lt;/span&gt;);
            fgets(&amp;amp;szInput, MSG_LEN, &lt;span class=&#34;hljs-built_in&#34;&gt;stdin&lt;/span&gt;);
            pmSend.u1.s1.DataLength = &lt;span class=&#34;hljs-built_in&#34;&gt;strlen&lt;/span&gt;(szInput);
            pmSend.u1.s1.TotalLength = pmSend.u1.s1.DataLength + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE);
            lpMem = CreateMsgMem(&amp;amp;pmSend, pmSend.u1.s1.DataLength, &amp;amp;szInput);
            ntRet = NtAlpcSendWaitReceivePort(hPort, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, (PPORT_MESSAGE)lpMem, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;);
            &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[i] NtAlpcSendWaitReceivePort: 0x%X\n&amp;quot;&lt;/span&gt;, ntRet);
            HeapFree(GetProcessHeap(), &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, lpMem);
        }
    }
    getchar();
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you build and run Server.c, you can see that a server ALPC port is created under \RPC Control.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now let&amp;#x2019;s debug the server side with WinDbg. First, take a look at NtAlpcCreatePort:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS NTAPI &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcCreatePort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    OUT PHANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN POBJECT_ATTRIBUTES ObjectAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN OUT PALPC_INFO PortInformation OPTIONAL&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;After setting a breakpoint, you&amp;#x2019;ll see that rdx points to the ObjectAttributes. We&amp;#x2019;ll look at Attributes in more detail later, but inside this structure there is an ObjectName. The OBJECT_ATTRIBUTES structure looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;OBJECT_ATTRIBUTES&lt;/span&gt; {&lt;/span&gt;
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;   &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;#x2190; this one&lt;/span&gt;
    ULONG           Attributes;
    PVOID           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So rdx + 0x10 should be the ObjectName, right? If we inspect that:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;You can see that the port is created with the name \RPC Control\HackyBoiz!&lt;/p&gt;
&lt;p&gt;Now let&amp;#x2019;s switch to the client side and debug the communication with WinDbg.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Once we run the client, the server accepts the connection, and the client can start sending messages. Let&amp;#x2019;s look at that part in more detail.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;First, we inspect the initial connection call to &lt;code&gt;NtAlpcConnectPort&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS NTAPI &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcConnectPort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    OUT PHANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PUNICODE_STRING PortName, &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;lt;- here&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN POBJECT_ATTRIBUTES ObjectAttributes,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PALPC_INFO PortInformation OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN DWORD ConnectionFlags,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PSID pSid OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PLPC_MESSAGE ConnectionMessage OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN OUT PULONG ConnectMessageSize OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PVOID InMessageBuffer OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PVOID OutMessageBuffer OPTIONAL,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    IN PLARGE_INTEGER Timeout OPTIONAL&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rdx holds the PortName. If we dump that, we can confirm that it&amp;#x2019;s pointing to the HackyBoiz port we set up on the server!&lt;/p&gt;
&lt;p&gt;Once the Connect request is sent, the server decides whether to accept it or not.&lt;/p&gt;
&lt;p&gt;Looking at the NtAlpcAcceptConnectPort call in Server.c:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;ntRet = NtAlpcAcceptConnectPort(
    &amp;amp;hConnectedPort,   &lt;span class=&#34;hljs-comment&#34;&gt;// OUT PHANDLE PortHandle  &amp;#x2192; rcx&lt;/span&gt;
    hPort, 
    &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,   
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,   
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,   
    &amp;amp;pmRequest,     
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           
    TRUE              
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The arguments are set up like this.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rcx is the handle that the server will receive for the new communication port. After the syscall, you&amp;#x2019;ll see that hConnectedPort now holds the actual ALPC server communication port handle.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since the last argument AcceptConnection is TRUE, the connection is accepted, and both sides can now exchange messages over this communication port!&lt;/p&gt;
&lt;h2 id=&#34;3-ALPC-Messaging&#34;&gt;&lt;a href=&#34;#3-ALPC-Messaging&#34; class=&#34;headerlink&#34; title=&#34;3. ALPC Messaging&#34;&gt;&lt;/a&gt;3. ALPC Messaging&lt;/h2&gt;&lt;p&gt;Now that we&amp;#x2019;ve seen how ALPC connects, let&amp;#x2019;s look at the actual message format going back and forth.&lt;/p&gt;
&lt;p&gt;In ALPC, messages always have the following layout:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2011.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;[ PORT_MESSAGE ][ Payload(Data) ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The front is the fixed PORT_MESSAGE header, and after that comes the actual text/binary payload we want to send.&lt;/p&gt;
&lt;h3 id=&#34;3-1-PORT-MESSAGE-structure&#34;&gt;&lt;a href=&#34;#3-1-PORT-MESSAGE-structure&#34; class=&#34;headerlink&#34; title=&#34;3.1. PORT_MESSAGE structure&#34;&gt;&lt;/a&gt;3.1. PORT_MESSAGE structure&lt;/h3&gt;&lt;p&gt;The header structure looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;PORT_MESSAGE&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-class&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;union&lt;/span&gt; {
        &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; {&lt;/span&gt;
            USHORT DataLength;   &lt;span class=&#34;hljs-comment&#34;&gt;// Actual payload length&lt;/span&gt;
            USHORT TotalLength;  &lt;span class=&#34;hljs-comment&#34;&gt;// Total size = PORT_MESSAGE + payload&lt;/span&gt;
        } s1;
        ULONG Length;
    } u1;

    &lt;span class=&#34;hljs-keyword&#34;&gt;union&lt;/span&gt; {
        &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; {&lt;/span&gt;
            USHORT Type;             &lt;span class=&#34;hljs-comment&#34;&gt;// Message type&lt;/span&gt;
            USHORT DataInfoOffset;   &lt;span class=&#34;hljs-comment&#34;&gt;// Attribute area offset&lt;/span&gt;
        } s2;
        ULONG ZeroInit;
    } u2;

    &lt;span class=&#34;hljs-keyword&#34;&gt;union&lt;/span&gt; {
        CLIENT_ID ClientId;          &lt;span class=&#34;hljs-comment&#34;&gt;// Sender process/thread ID&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt;    DoNotUseThisField; &lt;span class=&#34;hljs-comment&#34;&gt;// (alignment)&lt;/span&gt;
    };

    ULONG MessageId;                 &lt;span class=&#34;hljs-comment&#34;&gt;// Message identifier&lt;/span&gt;

    &lt;span class=&#34;hljs-keyword&#34;&gt;union&lt;/span&gt; {
        SIZE_T ClientViewSize;       &lt;span class=&#34;hljs-comment&#34;&gt;// Section view size&lt;/span&gt;
        ULONG  CallbackId;           &lt;span class=&#34;hljs-comment&#34;&gt;// Callback ID&lt;/span&gt;
    };

} PORT_MESSAGE, *PPORT_MESSAGE;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In practice, we usually only care about around four fields:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;u1.s1.DataLength&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Length of the payload&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;u1.s1.TotalLength&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; sizeof(PORT_MESSAGE) + DataLength&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Used by the kernel to know the total size of the message&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ClientId&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Process and thread ID of the sender&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MessageId / CallbackId&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Used to match requests and responses&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the actual format is pretty straightforward.&lt;/p&gt;
&lt;p&gt;If we look again at the example client code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;define&lt;/span&gt; MSG_LEN 0x100&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;LPVOID &lt;span class=&#34;hljs-title&#34;&gt;CreateMsgMem&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(PPORT_MESSAGE PortMessage, SIZE_T MessageSize, LPVOID Message)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;    LPVOID lpMem &lt;/span&gt;= HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MessageSize + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
    memmove(lpMem, PortMessage, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE));
    memmove((BYTE*)lpMem + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE), Message, MessageSize);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;(lpMem);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, lpMem is exactly:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;[ PORT_MESSAGE ][ Payload ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A fully-formed ALPC message buffer.&lt;/p&gt;
&lt;p&gt;In main() we use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;RtlSecureZeroMemory(&amp;amp;pmSend, &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(pmSend));

&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[.] Enter Message &amp;gt; &amp;quot;&lt;/span&gt;);
fgets(&amp;amp;szInput, MSG_LEN, &lt;span class=&#34;hljs-built_in&#34;&gt;stdin&lt;/span&gt;);

pmSend.u1.s1.DataLength  = &lt;span class=&#34;hljs-built_in&#34;&gt;strlen&lt;/span&gt;(szInput);
pmSend.u1.s1.TotalLength = pmSend.u1.s1.DataLength + &lt;span class=&#34;hljs-keyword&#34;&gt;sizeof&lt;/span&gt;(PORT_MESSAGE);

lpMem = CreateMsgMem(&amp;amp;pmSend, pmSend.u1.s1.DataLength, &amp;amp;szInput);

ntRet = NtAlpcSendWaitReceivePort(
    hPort,                &lt;span class=&#34;hljs-comment&#34;&gt;// HANDLE PortHandle&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,                    &lt;span class=&#34;hljs-comment&#34;&gt;// ULONG Flags&lt;/span&gt;
    (PPORT_MESSAGE)lpMem, &lt;span class=&#34;hljs-comment&#34;&gt;// SendMessage&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,                 &lt;span class=&#34;hljs-comment&#34;&gt;// SendMessageAttributes&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,                 &lt;span class=&#34;hljs-comment&#34;&gt;// ReceiveMessage&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,                 &lt;span class=&#34;hljs-comment&#34;&gt;// BufferLength&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,                 &lt;span class=&#34;hljs-comment&#34;&gt;// ReceiveMessageAttributes&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;                  &lt;span class=&#34;hljs-comment&#34;&gt;// Timeout&lt;/span&gt;
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To summarize:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We set DataLength and TotalLength inside pmSend.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CreateMsgMem() builds a single buffer lpMem with:&lt;/p&gt;
&lt;p&gt; [ pmSend | user input string ]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We pass lpMem as SendMessage to NtAlpcSendWaitReceivePort.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course, we should also look at how the message actually looks in memory during debugging.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2012.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s check what the buffer looks like when the client sends &lt;strong&gt;&amp;#x201C;Hello HackyBoiz!&amp;#x201D;&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;ntRet = NtAlpcSendWaitReceivePort(
    hPort,          &lt;span class=&#34;hljs-comment&#34;&gt;// HANDLE PortHandle&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,              &lt;span class=&#34;hljs-comment&#34;&gt;// ULONG Flags&lt;/span&gt;
    (PPORT_MESSAGE)lpMem, &lt;span class=&#34;hljs-comment&#34;&gt;// SendMessage&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           &lt;span class=&#34;hljs-comment&#34;&gt;// SendMessageAttributes&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           &lt;span class=&#34;hljs-comment&#34;&gt;// ReceiveMessage&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           &lt;span class=&#34;hljs-comment&#34;&gt;// BufferLength&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;,           &lt;span class=&#34;hljs-comment&#34;&gt;// ReceiveMessageAttributes&lt;/span&gt;
    &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;            &lt;span class=&#34;hljs-comment&#34;&gt;// Timeout&lt;/span&gt;
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our code, NtAlpcSendWaitReceivePort is called like this.&lt;/p&gt;
&lt;p&gt;lpMem should contain the message we&amp;#x2019;re sending. Let&amp;#x2019;s inspect it!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2013.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;r8 is the pointer to the full message buffer, and we can clearly see PORT_MESSAGE followed by &amp;#x201C;Hello HackyBoiz!&amp;#x201D;.&lt;/p&gt;
&lt;p&gt;The first DWORD is 00390011 because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lower 2 bytes = 0x0011 &amp;#x2192; DataLength = 0x11 = 17 (string length)&lt;/li&gt;
&lt;li&gt;Upper 2 bytes = 0x0039 &amp;#x2192; TotalLength = 0x39 = 57 (PORT_MESSAGE + payload)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is the buffer that gets copied from user mode to kernel mode, then from the server&amp;#x2019;s kernel-side buffer to the server&amp;#x2019;s receive buffer.&lt;/p&gt;
&lt;h2 id=&#34;4-ALPC-Message-Attribute&#34;&gt;&lt;a href=&#34;#4-ALPC-Message-Attribute&#34; class=&#34;headerlink&#34; title=&#34;4. ALPC Message Attribute&#34;&gt;&lt;/a&gt;4. ALPC Message Attribute&lt;/h2&gt;&lt;p&gt;So far we&amp;#x2019;ve looked at &lt;strong&gt;how to create ports, connect them, and send messages&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;But if ALPC were only about sending messages, there&amp;#x2019;d be no reason for it to be this complex.&lt;/p&gt;
&lt;p&gt;The real reason ALPC is complicated is that, besides the message body, it can also attach various &lt;strong&gt;attributes&lt;/strong&gt; to a message:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Security context (impersonation)&lt;/li&gt;
&lt;li&gt;Shared memory sections (views)&lt;/li&gt;
&lt;li&gt;Handles (files, processes, sections, etc.)&lt;/li&gt;
&lt;li&gt;Token information&lt;/li&gt;
&lt;li&gt;User-defined context&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ALPC is basically a framework that lets you send all of this together in a single NtAlpcSendWaitReceivePort call.&lt;/p&gt;
&lt;h3 id=&#34;4-1-ALPC-Message-Attribute&#34;&gt;&lt;a href=&#34;#4-1-ALPC-Message-Attribute&#34; class=&#34;headerlink&#34; title=&#34;4.1. ALPC Message Attribute&#34;&gt;&lt;/a&gt;4.1. ALPC Message Attribute&lt;/h3&gt;&lt;p&gt;If we look again at the &lt;code&gt;NtAlpcSendWaitReceivePort()&lt;/code&gt; signature, we see two extra parameters for attributes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;NTSTATUS &lt;span class=&#34;hljs-title&#34;&gt;NtAlpcSendWaitReceivePort&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    HANDLE PortHandle,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    DWORD Flags,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PPORT_MESSAGE SendMessage,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,    &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;#x2190; send-side attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PPORT_MESSAGE ReceiveMessage,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PSIZE_T BufferLength,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;#x2190; receive-side attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;    PLARGE_INTEGER Timeout&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-params&#34;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SendMessageAttributes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Attributes we want to attach when sending the message.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ReceiveMessageAttributes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Attributes we want to receive along with the response.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So you can think of it as a &amp;#x201C;mutual agreement&amp;#x201D; model for sending attributes.&lt;/p&gt;
&lt;p&gt;At the beginning of the attribute buffer, there is a common header:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_MESSAGE_ATTRIBUTES&lt;/span&gt; {&lt;/span&gt;
    ULONG AllocatedAttributes;  &lt;span class=&#34;hljs-comment&#34;&gt;// Which attribute types this buffer has space for&lt;/span&gt;
    ULONG ValidAttributes;      &lt;span class=&#34;hljs-comment&#34;&gt;// Which attributes are actually valid for this message&lt;/span&gt;
} ALPC_MESSAGE_ATTRIBUTES, *PALPC_MESSAGE_ATTRIBUTES;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;AllocatedAttributes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Bit flags indicating which attribute types this buffer can hold&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ValidAttributes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &amp;#x2192; Which attributes are actually used for this specific message&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To paraphrase it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs ini&#34;&gt;&lt;span class=&#34;hljs-attr&#34;&gt;AllocatedAttributes&lt;/span&gt; = &amp;#x201C;This buffer can hold these attributes.&amp;#x201D;

&lt;span class=&#34;hljs-attr&#34;&gt;ValidAttributes&lt;/span&gt; =  &amp;#x201C;These are the &lt;span class=&#34;hljs-literal&#34;&gt;on&lt;/span&gt;es we&amp;#x2019;re actually using for this message.&amp;#x201D;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-2-Main-attribute-types&#34;&gt;&lt;a href=&#34;#4-2-Main-attribute-types&#34; class=&#34;headerlink&#34; title=&#34;4.2 Main attribute types&#34;&gt;&lt;/a&gt;4.2 Main attribute types&lt;/h3&gt;&lt;p&gt;There are several types of attributes, but let&amp;#x2019;s look at the most important ones.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. Security Attribute&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This includes the sender&amp;#x2019;s security context, which allows the receiver to impersonate the sender.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_SECURITY_ATTR&lt;/span&gt; {&lt;/span&gt;
    ULONG Flags;
    PSECURITY_QUALITY_OF_SERVICE pQOS;
    HANDLE ContextHandle;
} ALPC_SECURITY_ATTR, *PALPC_SECURITY_ATTR;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pQOS&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Pointer to a &lt;code&gt;SECURITY_QUALITY_OF_SERVICE&lt;/code&gt; structure&lt;/li&gt;
&lt;li&gt;Controls what level of impersonation, context tracking, etc. is allowed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContextHandle&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Handle to a kernel-managed security context&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2. View Attribute (Data View Attribute)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Used to pass a shared memory section. This is how you bypass the normal 64KB message size limit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_DATA_VIEW_ATTR&lt;/span&gt; {&lt;/span&gt;
    ULONG  Flags;
    HANDLE SectionHandle;  &lt;span class=&#34;hljs-comment&#34;&gt;// Section handle attached to the ALPC port&lt;/span&gt;
    PVOID  ViewBase;       &lt;span class=&#34;hljs-comment&#34;&gt;// Base address where the section is mapped in this process&lt;/span&gt;
    SIZE_T ViewSize;       &lt;span class=&#34;hljs-comment&#34;&gt;// Size of the mapped view&lt;/span&gt;
} ALPC_DATA_VIEW_ATTR, *PALPC_DATA_VIEW_ATTR;&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Create a shared section and configure a view using &lt;code&gt;NtAlpcCreatePortSection&lt;/code&gt; / &lt;code&gt;NtAlpcCreateSectionView&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Fill an &lt;code&gt;ALPC_DATA_VIEW_ATTR&lt;/code&gt; with that information.&lt;/li&gt;
&lt;li&gt;Attach it to the attribute buffer and send it along with the message.&lt;/li&gt;
&lt;li&gt;The receiver maps the same section view in its own address space, effectively sharing memory.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;3. Context Attribute&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Used to attach user-defined context to a particular client or message.&lt;/p&gt;
&lt;p&gt;The server can use this to track per-client state or per-message state.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_CONTEXT_ATTR&lt;/span&gt; {&lt;/span&gt;
    PVOID PortContext;     &lt;span class=&#34;hljs-comment&#34;&gt;// Context attached to this port (client)&lt;/span&gt;
    PVOID MessageContext;  &lt;span class=&#34;hljs-comment&#34;&gt;// Context attached to this specific message&lt;/span&gt;
    ULONG Sequence;        &lt;span class=&#34;hljs-comment&#34;&gt;// Sequence number&lt;/span&gt;
    ULONG MessageId;       &lt;span class=&#34;hljs-comment&#34;&gt;// Message ID&lt;/span&gt;
    ULONG CallbackId;      &lt;span class=&#34;hljs-comment&#34;&gt;// Callback ID&lt;/span&gt;
} ALPC_CONTEXT_ATTR, *PALPC_CONTEXT_ATTR;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PortContext&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;A pointer to a structure the server associates with the client port (session ID, user info, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MessageContext&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Used when you want separate context per message&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sequence&lt;/code&gt; / &lt;code&gt;MessageId&lt;/code&gt; / &lt;code&gt;CallbackId&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Values set by the kernel&lt;/li&gt;
&lt;li&gt;Help with structured message handling, similar to how TCP tracks state for requests/responses&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;4. Handle Attribute&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Used to pass object handles along with the message.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; _&lt;span class=&#34;hljs-title&#34;&gt;ALPC_MESSAGE_HANDLE_INFORMATION&lt;/span&gt; {&lt;/span&gt;
    ULONG Index;        &lt;span class=&#34;hljs-comment&#34;&gt;// Index in the attribute buffer&lt;/span&gt;
    ULONG Flags;
    ULONG Handle;       &lt;span class=&#34;hljs-comment&#34;&gt;// Handle value (from the sender&amp;#x2019;s perspective)&lt;/span&gt;
    ULONG ObjectType;   &lt;span class=&#34;hljs-comment&#34;&gt;// Object type&lt;/span&gt;
    ACCESS_MASK GrantedAccess; &lt;span class=&#34;hljs-comment&#34;&gt;// Access rights the receiver will get&lt;/span&gt;
} ALPC_MESSAGE_HANDLE_INFORMATION, *PALPC_MESSAGE_HANDLE_INFORMATION;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The kernel checks whether the handle is valid, whether the rights make sense, and whether cross-process duplication is allowed.&lt;/li&gt;
&lt;li&gt;The receiver then uses this information to obtain a valid handle for the corresponding object in its own process.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Wrapping-Up&#34;&gt;&lt;a href=&#34;#Wrapping-Up&#34; class=&#34;headerlink&#34; title=&#34;Wrapping Up&#34;&gt;&lt;/a&gt;Wrapping Up&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;image%2014.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;So that&amp;#x2019;s the basic flow of ALPC! On the surface it just looks like &amp;#x201C;yet another IPC mechanism,&amp;#x201D; but under the hood, a single call to &lt;code&gt;NtAlpcSendWaitReceivePort()&lt;/code&gt; takes care of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Managing port objects&lt;/li&gt;
&lt;li&gt;Handling the &lt;code&gt;PORT_MESSAGE&lt;/code&gt; header&lt;/li&gt;
&lt;li&gt;Parsing various attributes&lt;/li&gt;
&lt;li&gt;Mapping section views, validating permissions, duplicating handles, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Because of this complexity, a lot of real-world vulnerabilities tend to appear in the logic that interprets and validates these attributes.&lt;/p&gt;
&lt;p&gt;If I get the chance, I&amp;#x2019;d love to write another post just focusing on ALPC-based vulnerabilities.&lt;/p&gt;
&lt;p&gt;Thanks for reading this long post &amp;#x2014; see you next time! &amp;#x1F44B;&lt;/p&gt;
&lt;h2 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://ti.qianxin.com/blog/articles/the-tragedy-of-alpc-unknown-windows-privilege-escalation-nday-vulnerability-research-in-august-en/&#34;&gt;https://ti.qianxin.com/blog/articles/the-tragedy-of-alpc-unknown-windows-privilege-escalation-nday-vulnerability-research-in-august-en/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://csandker.io/2022/05/24/Offensive-Windows-IPC-3-ALPC.html&#34;&gt;https://csandker.io/2022/05/24/Offensive-Windows-IPC-3-ALPC.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://csandker.io/2022/05/29/Debugging-And-Reversing-ALPC.html&#34;&gt;https://csandker.io/2022/05/29/Debugging-And-Reversing-ALPC.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://recon.cx/2008/a/thomas_garnier/LPC-ALPC-paper.pdf&#34;&gt;https://recon.cx/2008/a/thomas_garnier/LPC-ALPC-paper.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape&#34;&gt;https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://infocon.org/cons/SyScan/SyScan%202014%20Singapore/SyScan%202014%20presentations/SyScan2014_AlexIonescu_AllabouttheRPCLRPCALPCandLPCinyourPC.pdf&#34;&gt;https://infocon.org/cons/SyScan/SyScan%202014%20Singapore/SyScan%202014%20presentations/SyScan2014_AlexIonescu_AllabouttheRPCLRPCALPCandLPCinyourPC.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Local_Inter-Process_Communication&#34;&gt;https://en.wikipedia.org/wiki/Local_Inter-Process_Communication&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://processhacker.sourceforge.io/doc/struct___a_l_p_c___s_e_c_u_r_i_t_y___a_t_t_r.html&#34;&gt;https://processhacker.sourceforge.io/doc/struct___a_l_p_c___s_e_c_u_r_i_t_y___a_t_t_r.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://ntdoc.m417z.com/&#34;&gt;https://ntdoc.m417z.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/11/29/gongjae/Windows_ALPC/EN/image 1.png">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/11/29/gongjae/windows_alpc/en/">

  <title>[Research] Windows ALPC (EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!--  -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!--  -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-11-29 21:00" pubdate>
      2025 11 29 
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.5k 
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      69
       
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Windows ALPC (EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Hello! I&#x2019;m <code>gongjae</code>, a new member who recently joined HackyBoiz! &#x1F47B;</p>
<p>During my time as a trainee at HackyBoiz, I had a question related to the Kernel Driver and Named Pipe bug hunting project I had previously worked on.</p>
<p><img src="image.png" srcset="/img/loading.gif" alt="image.png"></p>
<p><del>Nope</del></p>
<p>Actually, I already knew that ALPC is one of the IPC communication methods, but I decided to take this opportunity to study it properly. </p>
<p>So today, we&#x2019;ll explore the concept of ALPC, its communication flow, and how messages are transmitted &#x2014; all while debugging it directly! :)</p>
<p><img src="image%201.png" srcset="/img/loading.gif" alt="image.png"></p>
<h2 id="1-About-ALPC"><a href="#1-About-ALPC" class="headerlink" title="1. About ALPC"></a>1. About ALPC</h2><p>In the Windows environment, IPC mechanisms that can be used both remotely and locally include Named Pipes and RPC. However, ALPC is unique in that it can only be used locally.</p>
<p>While RPC stands for Remote Procedure Call, ALPC stands for Advanced Local Procedure Call and is sometimes also referred to as Asynchronous Local Call.</p>
<p>The term &#x201C;asynchronous&#x201D; reflects the Windows Vista era, during which ALPC was introduced to replace the existing LPC mechanism.</p>
<p>ALPC enables high-speed message communication and is used for data transmission between processes.</p>
<h3 id="1-1-LPC-to-ALPC"><a href="#1-1-LPC-to-ALPC" class="headerlink" title="1.1. LPC to ALPC"></a>1.1. LPC to ALPC</h3><p><img src="image%202.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Before Windows Vista, LPC was an undocumented internal IPC mechanism provided by the Microsoft Windows NT kernel, used for lightweight communication between processes on the same machine.</p>
<p>Due to LPC&#x2019;s synchronous nature, both the client and server had to wait until a message was processed, which resulted in continuous blocking and performance issues.</p>
<p>As a result, from Windows Vista onward, the existing LPC mechanism was effectively reimplemented on top of ALPC, and later versions of Windows internally rely on ALPC as the core IPC mechanism. However, LPC APIs themselves did not completely disappear; rather, their internal implementation was redirected to ALPC.</p>
<p>&#x1F4A1;As seen in the image below, existing functions for creating LPC ports remain, but internally they are redirected to create ALPC ports instead. @.@</p>
<p><img src="image%203.png" srcset="/img/loading.gif" alt="image.png"></p>
<h3 id="1-2-ALPC-Internal-Structure"><a href="#1-2-ALPC-Internal-Structure" class="headerlink" title="1.2. ALPC Internal Structure"></a>1.2. ALPC Internal Structure</h3><p>The main component of ALPC communication is the ALPC port object, and its usage is similar to a network socket.</p>
<p>&#x2192; The server opens a socket that clients can connect to in order to exchange messages.</p>
<p>Using Sysinternals Suite&#x2019;s WinObj.exe, we can inspect ALPC ports.</p>
<p><img src="image%204.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Although some ALPC ports exist in the root path, most of them are located under the \RPC Control path.</p>
<p>In ALPC communication, three ALPC ports are involved (2 on the server side, 1 on the client side). The ALPC ports shown in WinObj are ALPC Communication Ports that clients can connect to.</p>
<p>Before explaining the communication process, let&#x2019;s briefly go over some important functions we will repeatedly encounter.</p>
<blockquote>
<p><strong>NtAlpcCreatePort()</strong></p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">NtAlpcCreatePort</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    OUT PHANDLE PortHandle,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN POBJECT_ATTRIBUTES ObjectAttributes,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN OUT PALPC_INFO PortInformation OPTIONAL</span></span>
<span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>
<ul>
<li>This function is used to create an ALPC port. Unlike LPC, instead of listing options individually, ALPC bundles them into an ALPC_INFO structure and passes it as the final parameter.</li>
<li>This structure is copied into the ALPC object when the port is created and later referenced internally.</li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ALPC_INFO</span></span>
<span class="hljs-class">{</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT_INFO_LPCMODE               0x001000 <span class="hljs-comment">// Operate like an LPC port</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT_INFO_CANIMPERSONATE        0x010000 <span class="hljs-comment">// Allow impersonation</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT_INFO_REQUEST_ALLOWED       0x020000 <span class="hljs-comment">// Allow message requests</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT_INFO_SEMAPHORE             0x040000 <span class="hljs-comment">// Enable synchronization mechanism</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT_INFO_HANDLE_EXPOSE         0x080000 <span class="hljs-comment">// Allow handle exposure</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT_INFO_PARENT_SYSTEM_PRACESS 0x100000 <span class="hljs-comment">// Kernel ALPC interface (system process parent)</span></span>

    ULONG Flags;
    SECURITY_QUALITY_OF_SERVICE PortQos;
    ULONG MaxMessageSize;
    ULONG unknown1;
    CHAR  cReserved1[<span class="hljs-number">8</span>];
    ULONG MaxViewSize;
    CHAR  cReserved2[<span class="hljs-number">8</span>];
} ALPC_INFO, *PALPC_INFO;
</code></pre>
<blockquote>
<p><strong>NtAlpcConnectPort()</strong></p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">NtAlpcConnectPort</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    OUT PHANDLE PortHandle,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PUNICODE_STRING PortName,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN POBJECT_ATTRIBUTES ObjectAttributes,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PALPC_INFO PortInformation OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN DWORD ConnectionFlags,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PSID pSid OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PLPC_MESSAGE ConnectionMessage OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN OUT PULONG ConnectMessageSize OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PVOID InMessageBuffer OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PVOID OutMessageBuffer OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PLARGE_INTEGER Timeout OPTIONAL</span></span>
<span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>
<ul>
<li>The PortName parameter specifies the name of the port to connect to, along with various optional settings. The kernel searches for the ALPC Connection Port object with the given name and then proceeds to request a connection.</li>
</ul>
<p><strong>Important ConnectionFlags values</strong></p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALPC_SYNC_CONNECTION   0x020000 <span class="hljs-comment">// Synchronous connection</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALPC_USER_WAIT_MODE    0x100000 <span class="hljs-comment">// Wait in user mode</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALPC_WAIT_IS_ALERTABLE 0x200000 <span class="hljs-comment">// Alertable wait</span></span></code></pre>
<ul>
<li>By default, the connection is asynchronous.<ul>
<li>This means the client can obtain a handle <strong>before</strong> the server has actually processed and accepted the connection request.</li>
<li>So if the client sends a message while the server hasn&#x2019;t handled the connection yet, it can result in an error.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>NtAlpcSendWaitReceivePort()</strong></p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">NtAlpcSendWaitReceivePort</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    HANDLE PortHandle,</span></span>
<span class="hljs-function"><span class="hljs-params">    DWORD Flags,</span></span>
<span class="hljs-function"><span class="hljs-params">    PPORT_MESSAGE SendMessage,</span></span>
<span class="hljs-function"><span class="hljs-params">    PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,</span></span>
<span class="hljs-function"><span class="hljs-params">    PPORT_MESSAGE ReceiveMessage,</span></span>
<span class="hljs-function"><span class="hljs-params">    PSIZE_T BufferLength,</span></span>
<span class="hljs-function"><span class="hljs-params">    PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes,</span></span>
<span class="hljs-function"><span class="hljs-params">    PLARGE_INTEGER Timeout</span></span>
<span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>
<ul>
<li>This is the most important function: with this single function, you can send and receive messages at the same time!!</li>
<li>SendMessage, ReceiveMessage are literally the send/receive message buffers.</li>
<li>SendMessageAttributes, ReceiveMessageAttributes are used to request or receive extra actions along with the message (section mapping, passing handles, etc.).</li>
</ul>
<h2 id="2-ALPC-Communication-Flow"><a href="#2-ALPC-Communication-Flow" class="headerlink" title="2. ALPC Communication Flow"></a>2. ALPC Communication Flow</h2><p>Alright, now that we roughly know what each function does, let&#x2019;s look at the actual communication flow. Earlier, I mentioned that an ALPC communication scenario involves <strong>three</strong> ALPC ports:</p>
<ol>
<li>The ALPC connection port created by the server process</li>
<li>The ALPC server communication port newly created by the kernel when a client connects</li>
<li>The ALPC client communication port</li>
</ol>
<p>We use these three, but just listing them like this doesn&#x2019;t make it very intuitive&#x2026;</p>
<p><del>At least it didn&#x2019;t for me&#x3160;</del></p>
<p>In reality, it <em>looks</em> like three logical ports exist during ALPC communication, but under the hood it&#x2019;s more like multiple endpoints being created on top of a single ALPC port object.</p>
<p>Let&#x2019;s walk through the communication flow step by step!</p>
<p><img src="image%205.png" srcset="/img/loading.gif" alt="[&#xBAA8;&#xB4E0; &#xAC83;&#xC744; &#xD0C0;&#xD611;&#xD558;&#xAE30; &#xC704;&#xD574; N&#xC77C; &#xCCB4;&#xC778;: 2&#xBD80; &#x2014; Windows &#xCEE4;&#xB110; LPE (&#xC77C;&#xBA85; &#xD06C;&#xB86C; &#xC0CC;&#xB4DC;&#xBC15;&#xC2A4; Escape) - Theori BLOG](https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape)"></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape">&#xBAA8;&#xB4E0; &#xAC83;&#xC744; &#xD0C0;&#xD611;&#xD558;&#xAE30; &#xC704;&#xD574; N&#xC77C; &#xCCB4;&#xC778;: 2&#xBD80; &#x2014; Windows &#xCEE4;&#xB110; LPE (&#xC77C;&#xBA85; &#xD06C;&#xB86C; &#xC0CC;&#xB4DC;&#xBC15;&#xC2A4; Escape) - Theori BLOG</a></p>
<p>The function we should pay the most attention to is, again, <code>NtAlpcSendWaitReceivePort()</code>. This guy is basically responsible for all the request/response message exchange. In order, the flow looks like this:</p>
<ol>
<li>The server process calls <code>NtAlpcCreatePort()</code> to create an ALPC port.<ul>
<li>Example name: <code>\RPC Control\HackyBoiz</code></li>
</ul>
</li>
<li><p>The kernel creates the ALPC port object and returns a handle to the server.</p>
<p> &#x2192; This is the <strong>ALPC Connection Port!</strong></p>
</li>
<li><p>The server calls <code>NtAlpcSendWaitReceivePort()</code> and waits for a client connection.</p>
</li>
<li>The client calls <code>NtAlpcConnectPort()</code>.<ul>
<li>Name of the server port to connect to: <code>\RPC Control\HackyBoiz</code></li>
<li>(Optional) Initial message to send to the server</li>
<li>(Optional) Server SID to verify it&#x2019;s talking to the correct server</li>
<li>(Optional) Additional message attributes</li>
</ul>
</li>
<li>This connection request is delivered to the server, and the server calls <code>NtAlpcAcceptConnectPort()</code> to either accept or reject the connection.<ul>
<li>The last argument is a boolean: <code>TRUE</code> means accept, <code>FALSE</code> means reject.</li>
</ul>
</li>
<li>If the connection is accepted, the kernel creates a new ALPC Communication Port and returns handles to both the server and the client.</li>
<li>From this point on, messages are no longer sent through the Connection Port, but through this new Communication Port.</li>
</ol>
<p>Now it&#x2019;s starting to make a bit more sense, right?</p>
<p>Good. Then let&#x2019;s actually debug it and see it in action.</p>
<p>You can grab an example ALPC implementation here:</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/DownWithUp/ALPC-Example">https://github.com/DownWithUp/ALPC-Example</a></p>
<p>We&#x2019;ll run this code and walk through the communication process ourselves! XD</p>
<blockquote>
<p>Server.c</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winternl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ntalpcapi.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;ntdll.lib&quot;</span>)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_MSG_LEN 0x500</span>

<span class="hljs-function">LPVOID <span class="hljs-title">AllocMsgMem</span><span class="hljs-params">(SIZE_T Size)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">return</span>(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE)));
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreatePortAndListen</span><span class="hljs-params">(LPCWSTR PortName)</span></span>
<span class="hljs-function"></span>{
    ALPC_PORT_ATTRIBUTES    serverPortAttr;
    OBJECT_ATTRIBUTES       objPort;
    UNICODE_STRING          usPortName;
    PORT_MESSAGE            pmRequest;
    PORT_MESSAGE            pmReceive;
    NTSTATUS                ntRet;
    BOOLEAN                 bBreak;
    HANDLE                  hConnectedPort;
    HANDLE                  hPort;
    SIZE_T                  nLen;
    LPVOID                  lpMem;
    BYTE                    bTemp;
  
    RtlInitUnicodeString(&amp;usPortName, PortName);
    InitializeObjectAttributes(&amp;objPort, &amp;usPortName, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    RtlSecureZeroMemory(&amp;serverPortAttr, <span class="hljs-keyword">sizeof</span>(serverPortAttr));
    serverPortAttr.MaxMessageLength = MAX_MSG_LEN;

    ntRet = NtAlpcCreatePort(&amp;hPort, &amp;objPort, &amp;serverPortAttr);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[i] NtAlpcCreatePort: 0x%X\n&quot;</span>, ntRet);
    <span class="hljs-keyword">if</span> (!ntRet)
    {
        nLen = <span class="hljs-keyword">sizeof</span>(pmReceive);
        ntRet = NtAlpcSendWaitReceivePort(hPort, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;pmReceive, &amp;nLen, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">if</span> (!ntRet)
        {
            RtlSecureZeroMemory(&amp;pmRequest, <span class="hljs-keyword">sizeof</span>(pmRequest));
            pmRequest.MessageId = pmReceive.MessageId;
            pmRequest.u1.s1.DataLength = <span class="hljs-number">0x0</span>;
            pmRequest.u1.s1.TotalLength = pmRequest.u1.s1.DataLength + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE);
            ntRet = NtAlpcAcceptConnectPort(&amp;hConnectedPort, hPort, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;pmRequest, <span class="hljs-literal">NULL</span>, TRUE); <span class="hljs-comment">// 0</span>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[i] NtAlpcAcceptConnectPort: 0x%X\n&quot;</span>, ntRet);
            <span class="hljs-keyword">if</span> (!ntRet)
            {
                bBreak = TRUE;
                <span class="hljs-keyword">while</span> (bBreak)
                {	
                    nLen = MAX_MSG_LEN;
                    lpMem = AllocMsgMem(nLen);
                    NtAlpcSendWaitReceivePort(hPort, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, (PPORT_MESSAGE)lpMem, &amp;nLen, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
                    pmReceive = *(PORT_MESSAGE*)lpMem;
                    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>((BYTE*)lpMem + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE), <span class="hljs-string">&quot;exit\n&quot;</span>))
                    {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[i] Received &apos;exit&apos; command\n&quot;</span>);
                        HeapFree(GetProcessHeap(), <span class="hljs-number">0</span>, lpMem);
                        ntRet = NtAlpcDisconnectPort(hPort, <span class="hljs-number">0</span>);
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[i] NtAlpcDisconnectPort: %X\n&quot;</span>, ntRet);
                        CloseHandle(hConnectedPort);
                        CloseHandle(hPort);
                        ExitThread(<span class="hljs-number">0</span>);
                    }
                    <span class="hljs-keyword">else</span>
                    {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[i] Received Data: &quot;</span>);
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= pmReceive.u1.s1.DataLength; i++)
                        {
                            bTemp = *(BYTE*)((BYTE*)lpMem + i + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE));
                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%X &quot;</span>, bTemp);
                        }
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
                        HeapFree(GetProcessHeap(), <span class="hljs-number">0</span>, lpMem);
                    }
                }
            }
        }
    }
    ExitThread(<span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    HANDLE hThread;

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[i] ALPC-Example Server\n&quot;</span>);
    hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)&amp;CreatePortAndListen, <span class="hljs-string">L&quot;\\RPC Control\\HackyBoiz&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);
    WaitForSingleObject(hThread, INFINITE);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Shuting down server\n&quot;</span>);
    getchar();
    <span class="hljs-keyword">return</span>;
}
</code></pre>
<blockquote>
<p>Client.c</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winternl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ntalpcapi.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;ntdll.lib&quot;</span>)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSG_LEN 0x100</span>

<span class="hljs-function">LPVOID <span class="hljs-title">CreateMsgMem</span><span class="hljs-params">(PPORT_MESSAGE PortMessage, SIZE_T MessageSize, LPVOID Message)</span></span>
<span class="hljs-function"></span>{
    LPVOID lpMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MessageSize + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE));
    memmove(lpMem, PortMessage, <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE));
    memmove((BYTE*)lpMem + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE), Message, MessageSize);
    <span class="hljs-keyword">return</span>(lpMem);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    UNICODE_STRING  usPort;
    PORT_MESSAGE    pmSend;
    PORT_MESSAGE    pmReceive;
    NTSTATUS        ntRet;
    BOOLEAN         bBreak;
    SIZE_T          nLen;
    HANDLE          hPort;
    LPVOID          lpMem; 
    CHAR            szInput[MSG_LEN];

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ALPC-Example Client\n&quot;</span>);
    RtlInitUnicodeString(&amp;usPort, <span class="hljs-string">L&quot;\\RPC Control\\HackyBoiz&quot;</span>);
    RtlSecureZeroMemory(&amp;pmSend, <span class="hljs-keyword">sizeof</span>(pmSend));
    pmSend.u1.s1.DataLength = MSG_LEN;
    pmSend.u1.s1.TotalLength = pmSend.u1.s1.DataLength + <span class="hljs-keyword">sizeof</span>(pmSend);
    lpMem = CreateMsgMem(&amp;pmSend, MSG_LEN, <span class="hljs-string">L&quot;Hello HackyBoiz!&quot;</span>);
    ntRet = NtAlpcConnectPort(&amp;hPort, &amp;usPort, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[i] NtAlpcConnectPort: 0x%X\n&quot;</span>, ntRet);
    <span class="hljs-keyword">if</span> (!ntRet)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[i] type &apos;exit&apos; to disconnect from the server\n&quot;</span>);
        bBreak = TRUE;
        <span class="hljs-keyword">while</span> (bBreak)
        {
            RtlSecureZeroMemory(&amp;pmSend, <span class="hljs-keyword">sizeof</span>(pmSend));
            RtlSecureZeroMemory(&amp;szInput, <span class="hljs-keyword">sizeof</span>(szInput));
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[.] Enter Message &gt; &quot;</span>);
            fgets(&amp;szInput, MSG_LEN, <span class="hljs-built_in">stdin</span>);
            pmSend.u1.s1.DataLength = <span class="hljs-built_in">strlen</span>(szInput);
            pmSend.u1.s1.TotalLength = pmSend.u1.s1.DataLength + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE);
            lpMem = CreateMsgMem(&amp;pmSend, pmSend.u1.s1.DataLength, &amp;szInput);
            ntRet = NtAlpcSendWaitReceivePort(hPort, <span class="hljs-number">0</span>, (PPORT_MESSAGE)lpMem, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[i] NtAlpcSendWaitReceivePort: 0x%X\n&quot;</span>, ntRet);
            HeapFree(GetProcessHeap(), <span class="hljs-number">0</span>, lpMem);
        }
    }
    getchar();
    <span class="hljs-keyword">return</span>;
}
</code></pre>
<p>If you build and run Server.c, you can see that a server ALPC port is created under \RPC Control.</p>
<p><img src="image%206.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Now let&#x2019;s debug the server side with WinDbg. First, take a look at NtAlpcCreatePort:</p>
<pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">NtAlpcCreatePort</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    OUT PHANDLE PortHandle,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN POBJECT_ATTRIBUTES ObjectAttributes,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN OUT PALPC_INFO PortInformation OPTIONAL</span></span>
<span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>
<p><img src="image%207.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>After setting a breakpoint, you&#x2019;ll see that rdx points to the ObjectAttributes. We&#x2019;ll look at Attributes in more detail later, but inside this structure there is an ObjectName. The OBJECT_ATTRIBUTES structure looks like this:</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">OBJECT_ATTRIBUTES</span> {</span>
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;   <span class="hljs-comment">// &#x2190; this one</span>
    ULONG           Attributes;
    PVOID           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;</code></pre>
<p>So rdx + 0x10 should be the ObjectName, right? If we inspect that:</p>
<p><img src="image%208.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>You can see that the port is created with the name \RPC Control\HackyBoiz!</p>
<p>Now let&#x2019;s switch to the client side and debug the communication with WinDbg.</p>
<p><img src="image%209.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Once we run the client, the server accepts the connection, and the client can start sending messages. Let&#x2019;s look at that part in more detail.</p>
<p><img src="image%2010.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>First, we inspect the initial connection call to <code>NtAlpcConnectPort</code>:</p>
<pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">NtAlpcConnectPort</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    OUT PHANDLE PortHandle,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PUNICODE_STRING PortName, <span class="hljs-comment">// &lt;- here</span></span></span>
<span class="hljs-function"><span class="hljs-params">    IN POBJECT_ATTRIBUTES ObjectAttributes,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PALPC_INFO PortInformation OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN DWORD ConnectionFlags,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PSID pSid OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PLPC_MESSAGE ConnectionMessage OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN OUT PULONG ConnectMessageSize OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PVOID InMessageBuffer OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PVOID OutMessageBuffer OPTIONAL,</span></span>
<span class="hljs-function"><span class="hljs-params">    IN PLARGE_INTEGER Timeout OPTIONAL</span></span>
<span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>
<p>rdx holds the PortName. If we dump that, we can confirm that it&#x2019;s pointing to the HackyBoiz port we set up on the server!</p>
<p>Once the Connect request is sent, the server decides whether to accept it or not.</p>
<p>Looking at the NtAlpcAcceptConnectPort call in Server.c:</p>
<pre><code class="hljs cpp">ntRet = NtAlpcAcceptConnectPort(
    &amp;hConnectedPort,   <span class="hljs-comment">// OUT PHANDLE PortHandle  &#x2192; rcx</span>
    hPort, 
    <span class="hljs-number">0</span>,
    <span class="hljs-literal">NULL</span>,   
    <span class="hljs-literal">NULL</span>,   
    <span class="hljs-literal">NULL</span>,   
    &amp;pmRequest,     
    <span class="hljs-literal">NULL</span>,           
    TRUE              
);</code></pre>
<p>The arguments are set up like this.</p>
<ul>
<li>rcx is the handle that the server will receive for the new communication port. After the syscall, you&#x2019;ll see that hConnectedPort now holds the actual ALPC server communication port handle.</li>
</ul>
<p>Since the last argument AcceptConnection is TRUE, the connection is accepted, and both sides can now exchange messages over this communication port!</p>
<h2 id="3-ALPC-Messaging"><a href="#3-ALPC-Messaging" class="headerlink" title="3. ALPC Messaging"></a>3. ALPC Messaging</h2><p>Now that we&#x2019;ve seen how ALPC connects, let&#x2019;s look at the actual message format going back and forth.</p>
<p>In ALPC, messages always have the following layout:</p>
<p><img src="image%2011.png" srcset="/img/loading.gif" alt="image.png"></p>
<pre><code class="hljs cpp">[ PORT_MESSAGE ][ Payload(Data) ]</code></pre>
<p>The front is the fixed PORT_MESSAGE header, and after that comes the actual text/binary payload we want to send.</p>
<h3 id="3-1-PORT-MESSAGE-structure"><a href="#3-1-PORT-MESSAGE-structure" class="headerlink" title="3.1. PORT_MESSAGE structure"></a>3.1. PORT_MESSAGE structure</h3><p>The header structure looks like this:</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PORT_MESSAGE</span></span>
<span class="hljs-class">{</span>
    <span class="hljs-keyword">union</span> {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
            USHORT DataLength;   <span class="hljs-comment">// Actual payload length</span>
            USHORT TotalLength;  <span class="hljs-comment">// Total size = PORT_MESSAGE + payload</span>
        } s1;
        ULONG Length;
    } u1;

    <span class="hljs-keyword">union</span> {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
            USHORT Type;             <span class="hljs-comment">// Message type</span>
            USHORT DataInfoOffset;   <span class="hljs-comment">// Attribute area offset</span>
        } s2;
        ULONG ZeroInit;
    } u2;

    <span class="hljs-keyword">union</span> {
        CLIENT_ID ClientId;          <span class="hljs-comment">// Sender process/thread ID</span>
        <span class="hljs-keyword">double</span>    DoNotUseThisField; <span class="hljs-comment">// (alignment)</span>
    };

    ULONG MessageId;                 <span class="hljs-comment">// Message identifier</span>

    <span class="hljs-keyword">union</span> {
        SIZE_T ClientViewSize;       <span class="hljs-comment">// Section view size</span>
        ULONG  CallbackId;           <span class="hljs-comment">// Callback ID</span>
    };

} PORT_MESSAGE, *PPORT_MESSAGE;</code></pre>
<p>In practice, we usually only care about around four fields:</p>
<ul>
<li><p>u1.s1.DataLength</p>
<p>  &#x2192; Length of the payload</p>
</li>
<li><p>u1.s1.TotalLength</p>
<p>  &#x2192; sizeof(PORT_MESSAGE) + DataLength</p>
<p>  &#x2192; Used by the kernel to know the total size of the message</p>
</li>
<li><p>ClientId</p>
<p>  &#x2192; Process and thread ID of the sender</p>
</li>
<li><p>MessageId / CallbackId</p>
<p>  &#x2192; Used to match requests and responses</p>
</li>
</ul>
<p>So the actual format is pretty straightforward.</p>
<p>If we look again at the example client code:</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSG_LEN 0x100</span>

<span class="hljs-function">LPVOID <span class="hljs-title">CreateMsgMem</span><span class="hljs-params">(PPORT_MESSAGE PortMessage, SIZE_T MessageSize, LPVOID Message)</span></span>
<span class="hljs-function"></span>
<span class="hljs-function">    LPVOID lpMem </span>= HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MessageSize + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE));
    memmove(lpMem, PortMessage, <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE));
    memmove((BYTE*)lpMem + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE), Message, MessageSize);
    <span class="hljs-keyword">return</span>(lpMem);
}</code></pre>
<p>Here, lpMem is exactly:</p>
<pre><code class="hljs cpp">[ PORT_MESSAGE ][ Payload ]</code></pre>
<p>A fully-formed ALPC message buffer.</p>
<p>In main() we use it like this:</p>
<pre><code class="hljs cpp">RtlSecureZeroMemory(&amp;pmSend, <span class="hljs-keyword">sizeof</span>(pmSend));

<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[.] Enter Message &gt; &quot;</span>);
fgets(&amp;szInput, MSG_LEN, <span class="hljs-built_in">stdin</span>);

pmSend.u1.s1.DataLength  = <span class="hljs-built_in">strlen</span>(szInput);
pmSend.u1.s1.TotalLength = pmSend.u1.s1.DataLength + <span class="hljs-keyword">sizeof</span>(PORT_MESSAGE);

lpMem = CreateMsgMem(&amp;pmSend, pmSend.u1.s1.DataLength, &amp;szInput);

ntRet = NtAlpcSendWaitReceivePort(
    hPort,                <span class="hljs-comment">// HANDLE PortHandle</span>
    <span class="hljs-number">0</span>,                    <span class="hljs-comment">// ULONG Flags</span>
    (PPORT_MESSAGE)lpMem, <span class="hljs-comment">// SendMessage</span>
    <span class="hljs-literal">NULL</span>,                 <span class="hljs-comment">// SendMessageAttributes</span>
    <span class="hljs-literal">NULL</span>,                 <span class="hljs-comment">// ReceiveMessage</span>
    <span class="hljs-literal">NULL</span>,                 <span class="hljs-comment">// BufferLength</span>
    <span class="hljs-literal">NULL</span>,                 <span class="hljs-comment">// ReceiveMessageAttributes</span>
    <span class="hljs-literal">NULL</span>                  <span class="hljs-comment">// Timeout</span>
);</code></pre>
<p>To summarize:</p>
<ol>
<li>We set DataLength and TotalLength inside pmSend.</li>
<li><p>CreateMsgMem() builds a single buffer lpMem with:</p>
<p> [ pmSend | user input string ]</p>
</li>
<li><p>We pass lpMem as SendMessage to NtAlpcSendWaitReceivePort.</p>
</li>
</ol>
<p>Of course, we should also look at how the message actually looks in memory during debugging.</p>
<p><img src="image%2012.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Let&#x2019;s check what the buffer looks like when the client sends <strong>&#x201C;Hello HackyBoiz!&#x201D;</strong>.</p>
<pre><code class="hljs cpp">ntRet = NtAlpcSendWaitReceivePort(
    hPort,          <span class="hljs-comment">// HANDLE PortHandle</span>
    <span class="hljs-number">0</span>,              <span class="hljs-comment">// ULONG Flags</span>
    (PPORT_MESSAGE)lpMem, <span class="hljs-comment">// SendMessage</span>
    <span class="hljs-literal">NULL</span>,           <span class="hljs-comment">// SendMessageAttributes</span>
    <span class="hljs-literal">NULL</span>,           <span class="hljs-comment">// ReceiveMessage</span>
    <span class="hljs-literal">NULL</span>,           <span class="hljs-comment">// BufferLength</span>
    <span class="hljs-literal">NULL</span>,           <span class="hljs-comment">// ReceiveMessageAttributes</span>
    <span class="hljs-literal">NULL</span>            <span class="hljs-comment">// Timeout</span>
);</code></pre>
<p>In our code, NtAlpcSendWaitReceivePort is called like this.</p>
<p>lpMem should contain the message we&#x2019;re sending. Let&#x2019;s inspect it!</p>
<p><img src="image%2013.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>r8 is the pointer to the full message buffer, and we can clearly see PORT_MESSAGE followed by &#x201C;Hello HackyBoiz!&#x201D;.</p>
<p>The first DWORD is 00390011 because:</p>
<ul>
<li>Lower 2 bytes = 0x0011 &#x2192; DataLength = 0x11 = 17 (string length)</li>
<li>Upper 2 bytes = 0x0039 &#x2192; TotalLength = 0x39 = 57 (PORT_MESSAGE + payload)</li>
</ul>
<p>This is the buffer that gets copied from user mode to kernel mode, then from the server&#x2019;s kernel-side buffer to the server&#x2019;s receive buffer.</p>
<h2 id="4-ALPC-Message-Attribute"><a href="#4-ALPC-Message-Attribute" class="headerlink" title="4. ALPC Message Attribute"></a>4. ALPC Message Attribute</h2><p>So far we&#x2019;ve looked at <strong>how to create ports, connect them, and send messages</strong>.</p>
<p>But if ALPC were only about sending messages, there&#x2019;d be no reason for it to be this complex.</p>
<p>The real reason ALPC is complicated is that, besides the message body, it can also attach various <strong>attributes</strong> to a message:</p>
<ul>
<li>Security context (impersonation)</li>
<li>Shared memory sections (views)</li>
<li>Handles (files, processes, sections, etc.)</li>
<li>Token information</li>
<li>User-defined context</li>
</ul>
<p>ALPC is basically a framework that lets you send all of this together in a single NtAlpcSendWaitReceivePort call.</p>
<h3 id="4-1-ALPC-Message-Attribute"><a href="#4-1-ALPC-Message-Attribute" class="headerlink" title="4.1. ALPC Message Attribute"></a>4.1. ALPC Message Attribute</h3><p>If we look again at the <code>NtAlpcSendWaitReceivePort()</code> signature, we see two extra parameters for attributes:</p>
<pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">NtAlpcSendWaitReceivePort</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    HANDLE PortHandle,</span></span>
<span class="hljs-function"><span class="hljs-params">    DWORD Flags,</span></span>
<span class="hljs-function"><span class="hljs-params">    PPORT_MESSAGE SendMessage,</span></span>
<span class="hljs-function"><span class="hljs-params">    PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,    <span class="hljs-comment">// &#x2190; send-side attributes</span></span></span>
<span class="hljs-function"><span class="hljs-params">    PPORT_MESSAGE ReceiveMessage,</span></span>
<span class="hljs-function"><span class="hljs-params">    PSIZE_T BufferLength,</span></span>
<span class="hljs-function"><span class="hljs-params">    PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, <span class="hljs-comment">// &#x2190; receive-side attributes</span></span></span>
<span class="hljs-function"><span class="hljs-params">    PLARGE_INTEGER Timeout</span></span>
<span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>
<ul>
<li><p><code>SendMessageAttributes</code></p>
<p>  &#x2192; Attributes we want to attach when sending the message.</p>
</li>
<li><p><code>ReceiveMessageAttributes</code></p>
<p>  &#x2192; Attributes we want to receive along with the response.</p>
</li>
</ul>
<p>So you can think of it as a &#x201C;mutual agreement&#x201D; model for sending attributes.</p>
<p>At the beginning of the attribute buffer, there is a common header:</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ALPC_MESSAGE_ATTRIBUTES</span> {</span>
    ULONG AllocatedAttributes;  <span class="hljs-comment">// Which attribute types this buffer has space for</span>
    ULONG ValidAttributes;      <span class="hljs-comment">// Which attributes are actually valid for this message</span>
} ALPC_MESSAGE_ATTRIBUTES, *PALPC_MESSAGE_ATTRIBUTES;</code></pre>
<ul>
<li><p><code>AllocatedAttributes</code></p>
<p>  &#x2192; Bit flags indicating which attribute types this buffer can hold</p>
</li>
<li><p><code>ValidAttributes</code></p>
<p>  &#x2192; Which attributes are actually used for this specific message</p>
</li>
</ul>
<p>To paraphrase it:</p>
<pre><code class="hljs ini"><span class="hljs-attr">AllocatedAttributes</span> = &#x201C;This buffer can hold these attributes.&#x201D;

<span class="hljs-attr">ValidAttributes</span> =  &#x201C;These are the <span class="hljs-literal">on</span>es we&#x2019;re actually using for this message.&#x201D;</code></pre>
<h3 id="4-2-Main-attribute-types"><a href="#4-2-Main-attribute-types" class="headerlink" title="4.2 Main attribute types"></a>4.2 Main attribute types</h3><p>There are several types of attributes, but let&#x2019;s look at the most important ones.</p>
<blockquote>
<p><strong>1. Security Attribute</strong></p>
</blockquote>
<p>This includes the sender&#x2019;s security context, which allows the receiver to impersonate the sender.</p>
<pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ALPC_SECURITY_ATTR</span> {</span>
    ULONG Flags;
    PSECURITY_QUALITY_OF_SERVICE pQOS;
    HANDLE ContextHandle;
} ALPC_SECURITY_ATTR, *PALPC_SECURITY_ATTR;</code></pre>
<ul>
<li><code>pQOS</code><ul>
<li>Pointer to a <code>SECURITY_QUALITY_OF_SERVICE</code> structure</li>
<li>Controls what level of impersonation, context tracking, etc. is allowed</li>
</ul>
</li>
<li><code>ContextHandle</code><ul>
<li>Handle to a kernel-managed security context</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p><strong>2. View Attribute (Data View Attribute)</strong></p>
</blockquote>
<p>Used to pass a shared memory section. This is how you bypass the normal 64KB message size limit.</p>
<pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ALPC_DATA_VIEW_ATTR</span> {</span>
    ULONG  Flags;
    HANDLE SectionHandle;  <span class="hljs-comment">// Section handle attached to the ALPC port</span>
    PVOID  ViewBase;       <span class="hljs-comment">// Base address where the section is mapped in this process</span>
    SIZE_T ViewSize;       <span class="hljs-comment">// Size of the mapped view</span>
} ALPC_DATA_VIEW_ATTR, *PALPC_DATA_VIEW_ATTR;</code></pre>
<ol>
<li>Create a shared section and configure a view using <code>NtAlpcCreatePortSection</code> / <code>NtAlpcCreateSectionView</code>.</li>
<li>Fill an <code>ALPC_DATA_VIEW_ATTR</code> with that information.</li>
<li>Attach it to the attribute buffer and send it along with the message.</li>
<li>The receiver maps the same section view in its own address space, effectively sharing memory.</li>
</ol>
<hr>
<blockquote>
<p><strong>3. Context Attribute</strong></p>
</blockquote>
<p>Used to attach user-defined context to a particular client or message.</p>
<p>The server can use this to track per-client state or per-message state.</p>
<pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ALPC_CONTEXT_ATTR</span> {</span>
    PVOID PortContext;     <span class="hljs-comment">// Context attached to this port (client)</span>
    PVOID MessageContext;  <span class="hljs-comment">// Context attached to this specific message</span>
    ULONG Sequence;        <span class="hljs-comment">// Sequence number</span>
    ULONG MessageId;       <span class="hljs-comment">// Message ID</span>
    ULONG CallbackId;      <span class="hljs-comment">// Callback ID</span>
} ALPC_CONTEXT_ATTR, *PALPC_CONTEXT_ATTR;</code></pre>
<ul>
<li><code>PortContext</code><ul>
<li>A pointer to a structure the server associates with the client port (session ID, user info, etc.)</li>
</ul>
</li>
<li><code>MessageContext</code><ul>
<li>Used when you want separate context per message</li>
</ul>
</li>
<li><code>Sequence</code> / <code>MessageId</code> / <code>CallbackId</code><ul>
<li>Values set by the kernel</li>
<li>Help with structured message handling, similar to how TCP tracks state for requests/responses</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p><strong>4. Handle Attribute</strong></p>
</blockquote>
<p>Used to pass object handles along with the message.</p>
<pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ALPC_MESSAGE_HANDLE_INFORMATION</span> {</span>
    ULONG Index;        <span class="hljs-comment">// Index in the attribute buffer</span>
    ULONG Flags;
    ULONG Handle;       <span class="hljs-comment">// Handle value (from the sender&#x2019;s perspective)</span>
    ULONG ObjectType;   <span class="hljs-comment">// Object type</span>
    ACCESS_MASK GrantedAccess; <span class="hljs-comment">// Access rights the receiver will get</span>
} ALPC_MESSAGE_HANDLE_INFORMATION, *PALPC_MESSAGE_HANDLE_INFORMATION;</code></pre>
<ul>
<li>The kernel checks whether the handle is valid, whether the rights make sense, and whether cross-process duplication is allowed.</li>
<li>The receiver then uses this information to obtain a valid handle for the corresponding object in its own process.</li>
</ul>
<h2 id="Wrapping-Up"><a href="#Wrapping-Up" class="headerlink" title="Wrapping Up"></a>Wrapping Up</h2><p><img src="image%2014.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>So that&#x2019;s the basic flow of ALPC! On the surface it just looks like &#x201C;yet another IPC mechanism,&#x201D; but under the hood, a single call to <code>NtAlpcSendWaitReceivePort()</code> takes care of:</p>
<ul>
<li>Managing port objects</li>
<li>Handling the <code>PORT_MESSAGE</code> header</li>
<li>Parsing various attributes</li>
<li>Mapping section views, validating permissions, duplicating handles, etc.</li>
</ul>
<p>Because of this complexity, a lot of real-world vulnerabilities tend to appear in the logic that interprets and validates these attributes.</p>
<p>If I get the chance, I&#x2019;d love to write another post just focusing on ALPC-based vulnerabilities.</p>
<p>Thanks for reading this long post &#x2014; see you next time! &#x1F44B;</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://ti.qianxin.com/blog/articles/the-tragedy-of-alpc-unknown-windows-privilege-escalation-nday-vulnerability-research-in-august-en/">https://ti.qianxin.com/blog/articles/the-tragedy-of-alpc-unknown-windows-privilege-escalation-nday-vulnerability-research-in-august-en/</a></p>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://csandker.io/2022/05/24/Offensive-Windows-IPC-3-ALPC.html">https://csandker.io/2022/05/24/Offensive-Windows-IPC-3-ALPC.html</a></p>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://csandker.io/2022/05/29/Debugging-And-Reversing-ALPC.html">https://csandker.io/2022/05/29/Debugging-And-Reversing-ALPC.html</a></p>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://recon.cx/2008/a/thomas_garnier/LPC-ALPC-paper.pdf">https://recon.cx/2008/a/thomas_garnier/LPC-ALPC-paper.pdf</a></p>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape">https://theori.io/blog/chaining-n-days-to-compromise-all-part-2-windows-kernel-lpe-a-k-a-chrome-sandbox-escape</a></p>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://infocon.org/cons/SyScan/SyScan%202014%20Singapore/SyScan%202014%20presentations/SyScan2014_AlexIonescu_AllabouttheRPCLRPCALPCandLPCinyourPC.pdf">https://infocon.org/cons/SyScan/SyScan%202014%20Singapore/SyScan%202014%20presentations/SyScan2014_AlexIonescu_AllabouttheRPCLRPCALPCandLPCinyourPC.pdf</a></p>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Local_Inter-Process_Communication">https://en.wikipedia.org/wiki/Local_Inter-Process_Communication</a></p>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://processhacker.sourceforge.io/doc/struct___a_l_p_c___s_e_c_u_r_i_t_y___a_t_t_r.html">https://processhacker.sourceforge.io/doc/struct___a_l_p_c___s_e_c_u_r_i_t_y___a_t_t_r.html</a></p>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://ntdoc.m417z.com/">https://ntdoc.m417z.com/</a></p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/Windows/">Windows</a>
                  
                  <a class="hover-with-bg" href="/tags/gongjae/">gongjae</a>
                  
                  <a class="hover-with-bg" href="/tags/IPC/">IPC</a>
                  
                  <a class="hover-with-bg" href="/tags/ALPC/">ALPC</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_gongjae.jpg" srcset="/img/loading.gif" alt="gongjae">
                  </div>

                  <div class="link-text">
                    <div class="link-title">gongjae</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/gongjae">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">  <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a>  .        .</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/12/03/millet/cve-2025-4802/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[] CVE-2025-4802 : GLIBC  setuid      </span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/11/29/gongjae/Windows_ALPC/KR/">
                    <span class="hidden-mobile">[Research] Windows ALPC (KR)</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/11/29/gongjae/Windows_ALPC/EN/';
        this.page.identifier = '/2025/11/29/gongjae/Windows_ALPC/EN/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] Windows ALPC (EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
