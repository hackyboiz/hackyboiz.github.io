

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;p&gt;Bypassing Windows Kernel Mitigations: Part0 - Deep Dive into KASLR Leaks Restriction (Ko) &amp;#x2190; Now&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hackyboiz.github.io/2024/12/08/l0ch/bypassing-kernel-mitigation-part1/eo/&#34;&gt;Bypassing Windows Kernel Mitigations: Part1 - Overview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hackyboiz.github.io/2025/01/12/l0ch/bypassing-kernel-mitigation-part2/eo/&#34;&gt;Bypassing Windows Kernel Mitigations: Part2 - CVE-2024-21338&lt;/a&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Hello, this is L0ch!&lt;br&gt;Originally, I was planning to write a post on the I/O Ring exploit, but I ended up diving deeper into a topic from Part 1 and decided to create this as a kind of side story. That&amp;#x2019;s why I&amp;#x2019;ve numbered this part as 0 &amp;#x1F604;&lt;/p&gt;
&lt;p&gt;In this post, we&amp;#x2019;ll take a closer look at the new KASLR-related mitigation introduced in Windows 11 and Windows Server 24H2, and explore a novel method for bypassing it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Before we begin, I highly recommend reading the &lt;a href=&#34;https://hackyboiz.github.io/2024/12/08/l0ch/bypassing-kernel-mitigation-part1/ko/#kASLR-Kernel-Address-Layout-Rnadomization&#34;&gt;Windows Kernel Mitigation Part 1&lt;/a&gt;, especially the section on kASLR (Kernel Address Space Layout Randomization).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;KASLR-Bypass&#34;&gt;&lt;a href=&#34;#KASLR-Bypass&#34; class=&#34;headerlink&#34; title=&#34;KASLR Bypass&#34;&gt;&lt;/a&gt;KASLR Bypass&lt;/h2&gt;&lt;p&gt;Prior to version 24H2, it was possible to call &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; from a process running at Medium Integrity Level and obtain various kernel object addresses, including the image base of &lt;code&gt;ntoskrnl.exe&lt;/code&gt;&amp;#x2014;all at once. These details were highly useful for kernel exploitation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;img src=&#34;image1.png&#34; alt=&#34;image1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;By leveraging these leaked addresses, an attacker could locate gadgets in &lt;code&gt;ntoskrnl.exe&lt;/code&gt;, tamper with fields like &lt;code&gt;PreviousMode&lt;/code&gt; or &lt;code&gt;SeDebugPrivilege&lt;/code&gt;, and so on.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;Analysis-of-KASLR-Mitigation-in-24H2&#34;&gt;&lt;a href=&#34;#Analysis-of-KASLR-Mitigation-in-24H2&#34; class=&#34;headerlink&#34; title=&#34;Analysis of KASLR Mitigation in 24H2&#34;&gt;&lt;/a&gt;&lt;strong&gt;Analysis of KASLR Mitigation in 24H2&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;To utilize &lt;code&gt;NtQuerySystemInformation&lt;/code&gt;, one would typically load &lt;code&gt;ntdll.dll&lt;/code&gt;, retrieve the address of the function using &lt;code&gt;GetProcAddress&lt;/code&gt;, and then invoke it. The actual implementation follows this call chain:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;(ntdll) NtQuerySystemInformation&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;(ntoskrnl) NtQuerySystemInformation(EX)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;(ntoskrnl) ExpQuerySystemInformation&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;image2.png&#34; alt=&#34;image2.png&#34;&gt;&lt;img src=&#34;image3.png&#34; alt=&#34;image3.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ultimately, the &lt;code&gt;ExpQuerySystemInformation&lt;/code&gt; function receives an enumeration value that determines which internal subroutine is executed to return the requested system information.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image4.png&#34; alt=&#34;image4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;When examining the xrefs of these subroutines, many of those that deal with kernel-related information invoke the &lt;code&gt;ExIsRestrictedCaller&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image5.png&#34; alt=&#34;image5.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s look into &lt;code&gt;ExIsRestrictedCaller&lt;/code&gt;. We can see a call to &lt;code&gt;Feature_RestrictKernelAddressLeaks_private_IsEnabledDeviceUsageNoInline()&lt;/code&gt;, which is a new feature flag introduced in 24H2. If this flag returns true, the function checks whether the caller possesses &lt;code&gt;SeDebugPrivilege&lt;/code&gt; via a call to &lt;code&gt;SeSinglePrivilegeCheck(SeDebugPrivilege, a1)&lt;/code&gt;. If the privilege is absent, &lt;code&gt;ExIsRestrictedCaller&lt;/code&gt; returns true, indicating that the caller is restricted.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image6.png&#34; alt=&#34;image6.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;The code snippet below shows a subroutine invoked when the enumeration value is &lt;code&gt;SystemModuleInformation&lt;/code&gt;. If &lt;code&gt;ExIsRestrictedCaller&lt;/code&gt; returns true, the subroutine skips the call to &lt;code&gt;ExQueryModuleInformation&lt;/code&gt; and returns an error instead.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image7.png&#34; alt=&#34;image7.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;As a result, processes running at Medium Integrity Level without &lt;code&gt;SeDebugPrivilege&lt;/code&gt; can no longer retrieve any meaningful results using &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; to leak kernel addresses.&lt;/p&gt;
&lt;p&gt;At this point, one might wonder: &lt;em&gt;Do we now need to find additional infoleaks when developing LPE exploits for Windows?&lt;/em&gt; Fortunately, there&amp;#x2019;s still a viable sidechannel-based bypass.&lt;/p&gt;
&lt;h2 id=&#34;EntryBleed-CVE-2022-4543-and-Prefetch-Sidechannel&#34;&gt;&lt;a href=&#34;#EntryBleed-CVE-2022-4543-and-Prefetch-Sidechannel&#34; class=&#34;headerlink&#34; title=&#34;EntryBleed (CVE-2022-4543) and Prefetch Sidechannel&#34;&gt;&lt;/a&gt;EntryBleed (CVE-2022-4543) and Prefetch Sidechannel&lt;/h2&gt;&lt;p&gt;Before diving into the bypass, we need to understand the KPTI (Kernel Page Table Isolation) protection used in Linux and the EntryBleed vulnerability (CVE-2022-4543).&lt;/p&gt;
&lt;p&gt;KPTI removes most kernel memory mappings from user-mode page tables, only retaining minimal virtual kernel memory required for exception/signal/syscall handling. This prevents user-mode from learning kernel address mappings.&lt;/p&gt;
&lt;p&gt;This was introduced in response to the infamous Meltdown and Spectre attacks disclosed in 2018. Since those vulnerabilities rendered KASLR ineffective, OS vendors adopted stricter memory isolation at the page table level.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fun fact: back then, there was widespread concern that CPU vendors would go under. And well&amp;#x2026; Intel&amp;#x2019;s current trajectory isn&amp;#x2019;t looking so great either. &amp;#x1F605;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;image8.png&#34; alt=&#34;image8.png&#34;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;With KPTI enabled, only minimal kernel mappings (e.g., for syscalls and interrupts) remain in the user address space.&lt;br&gt;Source: &lt;a href=&#34;https://en.wikipedia.org/wiki/Kernel_page-table_isolation&#34;&gt;https://en.wikipedia.org/wiki/Kernel_page-table_isolation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The EntryBleed vulnerability leverages a prefetch sidechannel to identify syscall handler addresses residing in the user-mode page tables, thus bypassing KPTI.&lt;/p&gt;
&lt;p&gt;Even with KPTI enabled, the kernel&amp;#x2019;s &lt;code&gt;entry_SYSCALL_64&lt;/code&gt; address (used during 64-bit syscall transitions) remains mapped. The attack uses this fact to infer kernel base addresses.&lt;/p&gt;
&lt;p&gt;x86_64 architecture features a TLB (Translation Lookaside Buffer) to cache recent virtual-to-physical address translations, and supports prefetch instructions that load data into the CPU cache.&lt;/p&gt;
&lt;p&gt;When a prefetch instruction targets an address already present in the TLB, it skips the page walk and executes faster.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image9.png&#34; alt=&#34;image9.png&#34;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Execution time differences depending on whether the page is cached&lt;br&gt;Source: &lt;a href=&#34;https://gruss.cc/files/prefetch.pdf&#34;&gt;https://gruss.cc/files/prefetch.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This timing difference can be exploited as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Repeatedly invoke a syscall to ensure &lt;code&gt;entry_SYSCALL_64&lt;/code&gt; is cached in the TLB.&lt;/li&gt;
&lt;li&gt;Iteratively execute prefetch instructions over the potential kernel address range:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0xffffffff80000000 - 0xffffffffc0000000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If execution is slow &amp;#x2192; address likely not cached &amp;#x2192; continue scanning.&lt;/li&gt;
&lt;li&gt;If execution is fast &amp;#x2192; cached &lt;code&gt;entry_SYSCALL_64&lt;/code&gt; hit &amp;#x2192; compute the kernel base via known offset.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;image10.png&#34; alt=&#34;image10.png&#34;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using timing differences of prefetch instructions to leak kernel addresses&lt;br&gt;Source: &lt;a href=&#34;https://gruss.cc/files/prefetch.pdf&#34;&gt;https://gruss.cc/files/prefetch.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;Bypassing-KASLR-Mitigation-in-24H2&#34;&gt;&lt;a href=&#34;#Bypassing-KASLR-Mitigation-in-24H2&#34; class=&#34;headerlink&#34; title=&#34;Bypassing KASLR Mitigation in 24H2&#34;&gt;&lt;/a&gt;Bypassing KASLR Mitigation in 24H2&lt;/h3&gt;&lt;p&gt;The same prefetch-based sidechannel technique from EntryBleed is also applicable to Windows!&lt;/p&gt;
&lt;p&gt;Windows has a similar KPTI-inspired mitigation called &lt;strong&gt;KVA (Kernel Virtual Address) Shadowing&lt;/strong&gt;. This was Microsoft&amp;#x2019;s response to Meltdown/Spectre, implementing kernel/user address space separation at the software level. However, recent Windows builds have KVA Shadowing disabled by default.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image11.png&#34; alt=&#34;image11.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;We can tell it&amp;#x2019;s disabled because &lt;code&gt;KPROCESS.UserDirectoryTableBase&lt;/code&gt; contains a null value, which would otherwise point to a valid address if KVAS were active. Since modern CPUs are generally immune to Meltdown/Spectre, Microsoft likely chose to disable KVAS by default to avoid performance degradation.&lt;/p&gt;
&lt;p&gt;This means: &lt;strong&gt;kernel addresses are still mapped in the user-mode page table&lt;/strong&gt;&amp;#x2014;and thus, prefetch-based leaks are feasible.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s analyze the sidechannel procedure from a PoC shared by exploits-forsale.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image12.png&#34; alt=&#34;image12.png&#34;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Source: &lt;a href=&#34;https://github.com/exploits-forsale/prefetch-tool/blob/main/prefetch_tool/prefetch_asm.asm&#34;&gt;https://github.com/exploits-forsale/prefetch-tool/blob/main/prefetch_tool/prefetch_asm.asm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Orange box&lt;/strong&gt;: Accepts the first prefetch target address in &lt;code&gt;rcx&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red box&lt;/strong&gt;: Uses &lt;code&gt;prefetchnta&lt;/code&gt; to specify non-temporal prefetching and &lt;code&gt;prefetcht2&lt;/code&gt; to load the operand into the L2 cache. Measures execution time to infer TLB caching.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Blue box&lt;/strong&gt;: Uses &lt;code&gt;lfence&lt;/code&gt; and &lt;code&gt;mfence&lt;/code&gt; for instruction serialization to ensure accurate timing.&lt;ul&gt;
&lt;li&gt;Execute all previously loaded instructions in memory and enter&lt;/li&gt;
&lt;li&gt;Force instruction execution order, remove optimization&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image13.png&#34; alt=&#34;image13.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;On my test environment (13th-gen Intel CPU), I was able to resolve the &lt;code&gt;ntoskrnl.exe&lt;/code&gt; base address within a few seconds.&lt;/p&gt;
&lt;p&gt;There are, however, two major caveats:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;This technique is reliable only on recent Intel processors. On AMD CPUs, results are inconsistent.&lt;/li&gt;
&lt;li&gt;Unlike the legacy &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; method, which could reveal addresses of various kernel objects (e.g., KTHREAD, pools), this approach only leaks the kernel image base&amp;#x2014;making it comparatively less versatile.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ultimately, the permission restrictions added to &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; in 24H2 have a significant impact on kernel exploitation strategies.&lt;br&gt;&lt;del&gt;Looks like understanding the CPU manual is now a prerequisite for kernel work&amp;#x2026;&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;Conclusion&#34;&gt;&lt;a href=&#34;#Conclusion&#34; class=&#34;headerlink&#34; title=&#34;Conclusion&#34;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;In this post, we examined the mitigation patch applied to &lt;code&gt;NtQuerySystemInformation&lt;/code&gt;, a long-time staple in Windows kernel exploitation. We also explored how this led to the need for new KASLR bypass techniques, specifically through sidechannel-based kernel infoleaks.&lt;/p&gt;
&lt;p&gt;In my opinion, the availability of &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; had previously stifled research into novel KASLR bypasses. With the new 24H2 mitigation in place, we may finally see a renewed wave of creative approaches in the kernel exploitation space.&lt;/p&gt;
&lt;p&gt;See you in the next post&amp;#x2014;where we&amp;#x2019;ll return to the I/O Ring exploit!&lt;/p&gt;
&lt;h2 id=&#34;References&#34;&gt;&lt;a href=&#34;#References&#34; class=&#34;headerlink&#34; title=&#34;References&#34;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://windows-internals.com/kaslr-leaks-restriction/&#34;&gt;https://windows-internals.com/kaslr-leaks-restriction/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://exploits.forsale/24h2-nt-exploit/&#34;&gt;https://exploits.forsale/24h2-nt-exploit/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/exploits-forsale/prefetch-tool&#34;&gt;https://github.com/exploits-forsale/prefetch-tool&lt;/a&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] Bypassing Windows Kernel Mitigations: Part0 - Deep Dive into KASLR Leaks Restriction (En) - hackyboiz">
  <meta property="og:description" content="&lt;p&gt;Bypassing Windows Kernel Mitigations: Part0 - Deep Dive into KASLR Leaks Restriction (Ko) &amp;#x2190; Now&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hackyboiz.github.io/2024/12/08/l0ch/bypassing-kernel-mitigation-part1/eo/&#34;&gt;Bypassing Windows Kernel Mitigations: Part1 - Overview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hackyboiz.github.io/2025/01/12/l0ch/bypassing-kernel-mitigation-part2/eo/&#34;&gt;Bypassing Windows Kernel Mitigations: Part2 - CVE-2024-21338&lt;/a&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Hello, this is L0ch!&lt;br&gt;Originally, I was planning to write a post on the I/O Ring exploit, but I ended up diving deeper into a topic from Part 1 and decided to create this as a kind of side story. That&amp;#x2019;s why I&amp;#x2019;ve numbered this part as 0 &amp;#x1F604;&lt;/p&gt;
&lt;p&gt;In this post, we&amp;#x2019;ll take a closer look at the new KASLR-related mitigation introduced in Windows 11 and Windows Server 24H2, and explore a novel method for bypassing it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Before we begin, I highly recommend reading the &lt;a href=&#34;https://hackyboiz.github.io/2024/12/08/l0ch/bypassing-kernel-mitigation-part1/ko/#kASLR-Kernel-Address-Layout-Rnadomization&#34;&gt;Windows Kernel Mitigation Part 1&lt;/a&gt;, especially the section on kASLR (Kernel Address Space Layout Randomization).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;KASLR-Bypass&#34;&gt;&lt;a href=&#34;#KASLR-Bypass&#34; class=&#34;headerlink&#34; title=&#34;KASLR Bypass&#34;&gt;&lt;/a&gt;KASLR Bypass&lt;/h2&gt;&lt;p&gt;Prior to version 24H2, it was possible to call &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; from a process running at Medium Integrity Level and obtain various kernel object addresses, including the image base of &lt;code&gt;ntoskrnl.exe&lt;/code&gt;&amp;#x2014;all at once. These details were highly useful for kernel exploitation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;img src=&#34;image1.png&#34; alt=&#34;image1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;By leveraging these leaked addresses, an attacker could locate gadgets in &lt;code&gt;ntoskrnl.exe&lt;/code&gt;, tamper with fields like &lt;code&gt;PreviousMode&lt;/code&gt; or &lt;code&gt;SeDebugPrivilege&lt;/code&gt;, and so on.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;Analysis-of-KASLR-Mitigation-in-24H2&#34;&gt;&lt;a href=&#34;#Analysis-of-KASLR-Mitigation-in-24H2&#34; class=&#34;headerlink&#34; title=&#34;Analysis of KASLR Mitigation in 24H2&#34;&gt;&lt;/a&gt;&lt;strong&gt;Analysis of KASLR Mitigation in 24H2&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;To utilize &lt;code&gt;NtQuerySystemInformation&lt;/code&gt;, one would typically load &lt;code&gt;ntdll.dll&lt;/code&gt;, retrieve the address of the function using &lt;code&gt;GetProcAddress&lt;/code&gt;, and then invoke it. The actual implementation follows this call chain:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;(ntdll) NtQuerySystemInformation&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;(ntoskrnl) NtQuerySystemInformation(EX)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;(ntoskrnl) ExpQuerySystemInformation&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;image2.png&#34; alt=&#34;image2.png&#34;&gt;&lt;img src=&#34;image3.png&#34; alt=&#34;image3.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ultimately, the &lt;code&gt;ExpQuerySystemInformation&lt;/code&gt; function receives an enumeration value that determines which internal subroutine is executed to return the requested system information.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image4.png&#34; alt=&#34;image4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;When examining the xrefs of these subroutines, many of those that deal with kernel-related information invoke the &lt;code&gt;ExIsRestrictedCaller&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image5.png&#34; alt=&#34;image5.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s look into &lt;code&gt;ExIsRestrictedCaller&lt;/code&gt;. We can see a call to &lt;code&gt;Feature_RestrictKernelAddressLeaks_private_IsEnabledDeviceUsageNoInline()&lt;/code&gt;, which is a new feature flag introduced in 24H2. If this flag returns true, the function checks whether the caller possesses &lt;code&gt;SeDebugPrivilege&lt;/code&gt; via a call to &lt;code&gt;SeSinglePrivilegeCheck(SeDebugPrivilege, a1)&lt;/code&gt;. If the privilege is absent, &lt;code&gt;ExIsRestrictedCaller&lt;/code&gt; returns true, indicating that the caller is restricted.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image6.png&#34; alt=&#34;image6.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;The code snippet below shows a subroutine invoked when the enumeration value is &lt;code&gt;SystemModuleInformation&lt;/code&gt;. If &lt;code&gt;ExIsRestrictedCaller&lt;/code&gt; returns true, the subroutine skips the call to &lt;code&gt;ExQueryModuleInformation&lt;/code&gt; and returns an error instead.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image7.png&#34; alt=&#34;image7.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;As a result, processes running at Medium Integrity Level without &lt;code&gt;SeDebugPrivilege&lt;/code&gt; can no longer retrieve any meaningful results using &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; to leak kernel addresses.&lt;/p&gt;
&lt;p&gt;At this point, one might wonder: &lt;em&gt;Do we now need to find additional infoleaks when developing LPE exploits for Windows?&lt;/em&gt; Fortunately, there&amp;#x2019;s still a viable sidechannel-based bypass.&lt;/p&gt;
&lt;h2 id=&#34;EntryBleed-CVE-2022-4543-and-Prefetch-Sidechannel&#34;&gt;&lt;a href=&#34;#EntryBleed-CVE-2022-4543-and-Prefetch-Sidechannel&#34; class=&#34;headerlink&#34; title=&#34;EntryBleed (CVE-2022-4543) and Prefetch Sidechannel&#34;&gt;&lt;/a&gt;EntryBleed (CVE-2022-4543) and Prefetch Sidechannel&lt;/h2&gt;&lt;p&gt;Before diving into the bypass, we need to understand the KPTI (Kernel Page Table Isolation) protection used in Linux and the EntryBleed vulnerability (CVE-2022-4543).&lt;/p&gt;
&lt;p&gt;KPTI removes most kernel memory mappings from user-mode page tables, only retaining minimal virtual kernel memory required for exception/signal/syscall handling. This prevents user-mode from learning kernel address mappings.&lt;/p&gt;
&lt;p&gt;This was introduced in response to the infamous Meltdown and Spectre attacks disclosed in 2018. Since those vulnerabilities rendered KASLR ineffective, OS vendors adopted stricter memory isolation at the page table level.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fun fact: back then, there was widespread concern that CPU vendors would go under. And well&amp;#x2026; Intel&amp;#x2019;s current trajectory isn&amp;#x2019;t looking so great either. &amp;#x1F605;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;image8.png&#34; alt=&#34;image8.png&#34;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;With KPTI enabled, only minimal kernel mappings (e.g., for syscalls and interrupts) remain in the user address space.&lt;br&gt;Source: &lt;a href=&#34;https://en.wikipedia.org/wiki/Kernel_page-table_isolation&#34;&gt;https://en.wikipedia.org/wiki/Kernel_page-table_isolation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The EntryBleed vulnerability leverages a prefetch sidechannel to identify syscall handler addresses residing in the user-mode page tables, thus bypassing KPTI.&lt;/p&gt;
&lt;p&gt;Even with KPTI enabled, the kernel&amp;#x2019;s &lt;code&gt;entry_SYSCALL_64&lt;/code&gt; address (used during 64-bit syscall transitions) remains mapped. The attack uses this fact to infer kernel base addresses.&lt;/p&gt;
&lt;p&gt;x86_64 architecture features a TLB (Translation Lookaside Buffer) to cache recent virtual-to-physical address translations, and supports prefetch instructions that load data into the CPU cache.&lt;/p&gt;
&lt;p&gt;When a prefetch instruction targets an address already present in the TLB, it skips the page walk and executes faster.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image9.png&#34; alt=&#34;image9.png&#34;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Execution time differences depending on whether the page is cached&lt;br&gt;Source: &lt;a href=&#34;https://gruss.cc/files/prefetch.pdf&#34;&gt;https://gruss.cc/files/prefetch.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This timing difference can be exploited as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Repeatedly invoke a syscall to ensure &lt;code&gt;entry_SYSCALL_64&lt;/code&gt; is cached in the TLB.&lt;/li&gt;
&lt;li&gt;Iteratively execute prefetch instructions over the potential kernel address range:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0xffffffff80000000 - 0xffffffffc0000000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If execution is slow &amp;#x2192; address likely not cached &amp;#x2192; continue scanning.&lt;/li&gt;
&lt;li&gt;If execution is fast &amp;#x2192; cached &lt;code&gt;entry_SYSCALL_64&lt;/code&gt; hit &amp;#x2192; compute the kernel base via known offset.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;image10.png&#34; alt=&#34;image10.png&#34;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using timing differences of prefetch instructions to leak kernel addresses&lt;br&gt;Source: &lt;a href=&#34;https://gruss.cc/files/prefetch.pdf&#34;&gt;https://gruss.cc/files/prefetch.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;Bypassing-KASLR-Mitigation-in-24H2&#34;&gt;&lt;a href=&#34;#Bypassing-KASLR-Mitigation-in-24H2&#34; class=&#34;headerlink&#34; title=&#34;Bypassing KASLR Mitigation in 24H2&#34;&gt;&lt;/a&gt;Bypassing KASLR Mitigation in 24H2&lt;/h3&gt;&lt;p&gt;The same prefetch-based sidechannel technique from EntryBleed is also applicable to Windows!&lt;/p&gt;
&lt;p&gt;Windows has a similar KPTI-inspired mitigation called &lt;strong&gt;KVA (Kernel Virtual Address) Shadowing&lt;/strong&gt;. This was Microsoft&amp;#x2019;s response to Meltdown/Spectre, implementing kernel/user address space separation at the software level. However, recent Windows builds have KVA Shadowing disabled by default.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image11.png&#34; alt=&#34;image11.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;We can tell it&amp;#x2019;s disabled because &lt;code&gt;KPROCESS.UserDirectoryTableBase&lt;/code&gt; contains a null value, which would otherwise point to a valid address if KVAS were active. Since modern CPUs are generally immune to Meltdown/Spectre, Microsoft likely chose to disable KVAS by default to avoid performance degradation.&lt;/p&gt;
&lt;p&gt;This means: &lt;strong&gt;kernel addresses are still mapped in the user-mode page table&lt;/strong&gt;&amp;#x2014;and thus, prefetch-based leaks are feasible.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s analyze the sidechannel procedure from a PoC shared by exploits-forsale.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image12.png&#34; alt=&#34;image12.png&#34;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Source: &lt;a href=&#34;https://github.com/exploits-forsale/prefetch-tool/blob/main/prefetch_tool/prefetch_asm.asm&#34;&gt;https://github.com/exploits-forsale/prefetch-tool/blob/main/prefetch_tool/prefetch_asm.asm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Orange box&lt;/strong&gt;: Accepts the first prefetch target address in &lt;code&gt;rcx&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red box&lt;/strong&gt;: Uses &lt;code&gt;prefetchnta&lt;/code&gt; to specify non-temporal prefetching and &lt;code&gt;prefetcht2&lt;/code&gt; to load the operand into the L2 cache. Measures execution time to infer TLB caching.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Blue box&lt;/strong&gt;: Uses &lt;code&gt;lfence&lt;/code&gt; and &lt;code&gt;mfence&lt;/code&gt; for instruction serialization to ensure accurate timing.&lt;ul&gt;
&lt;li&gt;Execute all previously loaded instructions in memory and enter&lt;/li&gt;
&lt;li&gt;Force instruction execution order, remove optimization&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image13.png&#34; alt=&#34;image13.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;On my test environment (13th-gen Intel CPU), I was able to resolve the &lt;code&gt;ntoskrnl.exe&lt;/code&gt; base address within a few seconds.&lt;/p&gt;
&lt;p&gt;There are, however, two major caveats:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;This technique is reliable only on recent Intel processors. On AMD CPUs, results are inconsistent.&lt;/li&gt;
&lt;li&gt;Unlike the legacy &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; method, which could reveal addresses of various kernel objects (e.g., KTHREAD, pools), this approach only leaks the kernel image base&amp;#x2014;making it comparatively less versatile.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ultimately, the permission restrictions added to &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; in 24H2 have a significant impact on kernel exploitation strategies.&lt;br&gt;&lt;del&gt;Looks like understanding the CPU manual is now a prerequisite for kernel work&amp;#x2026;&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;Conclusion&#34;&gt;&lt;a href=&#34;#Conclusion&#34; class=&#34;headerlink&#34; title=&#34;Conclusion&#34;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;In this post, we examined the mitigation patch applied to &lt;code&gt;NtQuerySystemInformation&lt;/code&gt;, a long-time staple in Windows kernel exploitation. We also explored how this led to the need for new KASLR bypass techniques, specifically through sidechannel-based kernel infoleaks.&lt;/p&gt;
&lt;p&gt;In my opinion, the availability of &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; had previously stifled research into novel KASLR bypasses. With the new 24H2 mitigation in place, we may finally see a renewed wave of creative approaches in the kernel exploitation space.&lt;/p&gt;
&lt;p&gt;See you in the next post&amp;#x2014;where we&amp;#x2019;ll return to the I/O Ring exploit!&lt;/p&gt;
&lt;h2 id=&#34;References&#34;&gt;&lt;a href=&#34;#References&#34; class=&#34;headerlink&#34; title=&#34;References&#34;&gt;&lt;/a&gt;References&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://windows-internals.com/kaslr-leaks-restriction/&#34;&gt;https://windows-internals.com/kaslr-leaks-restriction/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://exploits.forsale/24h2-nt-exploit/&#34;&gt;https://exploits.forsale/24h2-nt-exploit/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/exploits-forsale/prefetch-tool&#34;&gt;https://github.com/exploits-forsale/prefetch-tool&lt;/a&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io2025/04/13/l0ch/bypassing-kernel-mitigation-part0/ko/thumbnail.jpg">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/04/13/l0ch/bypassing-kernel-mitigation-part0/en/">

  <title>[Research] Bypassing Windows Kernel Mitigations: Part0 - Deep Dive into KASLR Leaks Restriction (En) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-04-13 19:00" pubdate>
      2025년 4월 13일 오후
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      1.2k 자
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      24
       분
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Bypassing Windows Kernel Mitigations: Part0 - Deep Dive into KASLR Leaks Restriction (En)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <p>Bypassing Windows Kernel Mitigations: Part0 - Deep Dive into KASLR Leaks Restriction (Ko) &#x2190; Now</p>
<p><a href="https://hackyboiz.github.io/2024/12/08/l0ch/bypassing-kernel-mitigation-part1/eo/">Bypassing Windows Kernel Mitigations: Part1 - Overview</a></p>
<p><a href="https://hackyboiz.github.io/2025/01/12/l0ch/bypassing-kernel-mitigation-part2/eo/">Bypassing Windows Kernel Mitigations: Part2 - CVE-2024-21338</a> </p>
<hr>
<p>Hello, this is L0ch!<br>Originally, I was planning to write a post on the I/O Ring exploit, but I ended up diving deeper into a topic from Part 1 and decided to create this as a kind of side story. That&#x2019;s why I&#x2019;ve numbered this part as 0 &#x1F604;</p>
<p>In this post, we&#x2019;ll take a closer look at the new KASLR-related mitigation introduced in Windows 11 and Windows Server 24H2, and explore a novel method for bypassing it.</p>
<blockquote>
<p>Before we begin, I highly recommend reading the <a href="https://hackyboiz.github.io/2024/12/08/l0ch/bypassing-kernel-mitigation-part1/ko/#kASLR-Kernel-Address-Layout-Rnadomization">Windows Kernel Mitigation Part 1</a>, especially the section on kASLR (Kernel Address Space Layout Randomization).</p>
</blockquote>
<h2 id="KASLR-Bypass"><a href="#KASLR-Bypass" class="headerlink" title="KASLR Bypass"></a>KASLR Bypass</h2><p>Prior to version 24H2, it was possible to call <code>NtQuerySystemInformation</code> from a process running at Medium Integrity Level and obtain various kernel object addresses, including the image base of <code>ntoskrnl.exe</code>&#x2014;all at once. These details were highly useful for kernel exploitation.</p>
<p><img src="image.png" srcset="/img/loading.gif" alt="image.png"><img src="image1.png" srcset="/img/loading.gif" alt="image1.png"></p>
<p>By leveraging these leaked addresses, an attacker could locate gadgets in <code>ntoskrnl.exe</code>, tamper with fields like <code>PreviousMode</code> or <code>SeDebugPrivilege</code>, and so on.</p>
<hr>
<h2 id="Analysis-of-KASLR-Mitigation-in-24H2"><a href="#Analysis-of-KASLR-Mitigation-in-24H2" class="headerlink" title="Analysis of KASLR Mitigation in 24H2"></a><strong>Analysis of KASLR Mitigation in 24H2</strong></h2><p>To utilize <code>NtQuerySystemInformation</code>, one would typically load <code>ntdll.dll</code>, retrieve the address of the function using <code>GetProcAddress</code>, and then invoke it. The actual implementation follows this call chain:</p>
<ol>
<li><code>(ntdll) NtQuerySystemInformation</code>  </li>
<li><code>(ntoskrnl) NtQuerySystemInformation(EX)</code>  </li>
<li><code>(ntoskrnl) ExpQuerySystemInformation</code>  </li>
</ol>
<p><img src="image2.png" srcset="/img/loading.gif" alt="image2.png"><img src="image3.png" srcset="/img/loading.gif" alt="image3.png"></p>
<p>Ultimately, the <code>ExpQuerySystemInformation</code> function receives an enumeration value that determines which internal subroutine is executed to return the requested system information.</p>
<p><img src="image4.png" srcset="/img/loading.gif" alt="image4.png"></p>
<p>When examining the xrefs of these subroutines, many of those that deal with kernel-related information invoke the <code>ExIsRestrictedCaller</code> function.</p>
<p><img src="image5.png" srcset="/img/loading.gif" alt="image5.png"></p>
<p>Let&#x2019;s look into <code>ExIsRestrictedCaller</code>. We can see a call to <code>Feature_RestrictKernelAddressLeaks_private_IsEnabledDeviceUsageNoInline()</code>, which is a new feature flag introduced in 24H2. If this flag returns true, the function checks whether the caller possesses <code>SeDebugPrivilege</code> via a call to <code>SeSinglePrivilegeCheck(SeDebugPrivilege, a1)</code>. If the privilege is absent, <code>ExIsRestrictedCaller</code> returns true, indicating that the caller is restricted.</p>
<p><img src="image6.png" srcset="/img/loading.gif" alt="image6.png"></p>
<p>The code snippet below shows a subroutine invoked when the enumeration value is <code>SystemModuleInformation</code>. If <code>ExIsRestrictedCaller</code> returns true, the subroutine skips the call to <code>ExQueryModuleInformation</code> and returns an error instead.</p>
<p><img src="image7.png" srcset="/img/loading.gif" alt="image7.png"></p>
<p>As a result, processes running at Medium Integrity Level without <code>SeDebugPrivilege</code> can no longer retrieve any meaningful results using <code>NtQuerySystemInformation</code> to leak kernel addresses.</p>
<p>At this point, one might wonder: <em>Do we now need to find additional infoleaks when developing LPE exploits for Windows?</em> Fortunately, there&#x2019;s still a viable sidechannel-based bypass.</p>
<h2 id="EntryBleed-CVE-2022-4543-and-Prefetch-Sidechannel"><a href="#EntryBleed-CVE-2022-4543-and-Prefetch-Sidechannel" class="headerlink" title="EntryBleed (CVE-2022-4543) and Prefetch Sidechannel"></a>EntryBleed (CVE-2022-4543) and Prefetch Sidechannel</h2><p>Before diving into the bypass, we need to understand the KPTI (Kernel Page Table Isolation) protection used in Linux and the EntryBleed vulnerability (CVE-2022-4543).</p>
<p>KPTI removes most kernel memory mappings from user-mode page tables, only retaining minimal virtual kernel memory required for exception/signal/syscall handling. This prevents user-mode from learning kernel address mappings.</p>
<p>This was introduced in response to the infamous Meltdown and Spectre attacks disclosed in 2018. Since those vulnerabilities rendered KASLR ineffective, OS vendors adopted stricter memory isolation at the page table level.</p>
<blockquote>
<p>Fun fact: back then, there was widespread concern that CPU vendors would go under. And well&#x2026; Intel&#x2019;s current trajectory isn&#x2019;t looking so great either. &#x1F605;  </p>
</blockquote>
<p><img src="image8.png" srcset="/img/loading.gif" alt="image8.png">  </p>
<blockquote>
<p>With KPTI enabled, only minimal kernel mappings (e.g., for syscalls and interrupts) remain in the user address space.<br>Source: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation">https://en.wikipedia.org/wiki/Kernel_page-table_isolation</a></p>
</blockquote>
<p>The EntryBleed vulnerability leverages a prefetch sidechannel to identify syscall handler addresses residing in the user-mode page tables, thus bypassing KPTI.</p>
<p>Even with KPTI enabled, the kernel&#x2019;s <code>entry_SYSCALL_64</code> address (used during 64-bit syscall transitions) remains mapped. The attack uses this fact to infer kernel base addresses.</p>
<p>x86_64 architecture features a TLB (Translation Lookaside Buffer) to cache recent virtual-to-physical address translations, and supports prefetch instructions that load data into the CPU cache.</p>
<p>When a prefetch instruction targets an address already present in the TLB, it skips the page walk and executes faster.</p>
<p><img src="image9.png" srcset="/img/loading.gif" alt="image9.png">  </p>
<blockquote>
<p>Execution time differences depending on whether the page is cached<br>Source: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://gruss.cc/files/prefetch.pdf">https://gruss.cc/files/prefetch.pdf</a></p>
</blockquote>
<p>This timing difference can be exploited as follows:</p>
<ol>
<li>Repeatedly invoke a syscall to ensure <code>entry_SYSCALL_64</code> is cached in the TLB.</li>
<li>Iteratively execute prefetch instructions over the potential kernel address range:<ul>
<li><code>0xffffffff80000000 - 0xffffffffc0000000</code></li>
</ul>
</li>
<li>If execution is slow &#x2192; address likely not cached &#x2192; continue scanning.</li>
<li>If execution is fast &#x2192; cached <code>entry_SYSCALL_64</code> hit &#x2192; compute the kernel base via known offset.</li>
</ol>
<p><img src="image10.png" srcset="/img/loading.gif" alt="image10.png">  </p>
<blockquote>
<p>Using timing differences of prefetch instructions to leak kernel addresses<br>Source: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://gruss.cc/files/prefetch.pdf">https://gruss.cc/files/prefetch.pdf</a></p>
</blockquote>
<h3 id="Bypassing-KASLR-Mitigation-in-24H2"><a href="#Bypassing-KASLR-Mitigation-in-24H2" class="headerlink" title="Bypassing KASLR Mitigation in 24H2"></a>Bypassing KASLR Mitigation in 24H2</h3><p>The same prefetch-based sidechannel technique from EntryBleed is also applicable to Windows!</p>
<p>Windows has a similar KPTI-inspired mitigation called <strong>KVA (Kernel Virtual Address) Shadowing</strong>. This was Microsoft&#x2019;s response to Meltdown/Spectre, implementing kernel/user address space separation at the software level. However, recent Windows builds have KVA Shadowing disabled by default.</p>
<p><img src="image11.png" srcset="/img/loading.gif" alt="image11.png"></p>
<p>We can tell it&#x2019;s disabled because <code>KPROCESS.UserDirectoryTableBase</code> contains a null value, which would otherwise point to a valid address if KVAS were active. Since modern CPUs are generally immune to Meltdown/Spectre, Microsoft likely chose to disable KVAS by default to avoid performance degradation.</p>
<p>This means: <strong>kernel addresses are still mapped in the user-mode page table</strong>&#x2014;and thus, prefetch-based leaks are feasible.</p>
<p>Let&#x2019;s analyze the sidechannel procedure from a PoC shared by exploits-forsale.</p>
<p><img src="image12.png" srcset="/img/loading.gif" alt="image12.png">  </p>
<blockquote>
<p>Source: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/exploits-forsale/prefetch-tool/blob/main/prefetch_tool/prefetch_asm.asm">https://github.com/exploits-forsale/prefetch-tool/blob/main/prefetch_tool/prefetch_asm.asm</a></p>
</blockquote>
<ul>
<li><strong>Orange box</strong>: Accepts the first prefetch target address in <code>rcx</code>.</li>
<li><strong>Red box</strong>: Uses <code>prefetchnta</code> to specify non-temporal prefetching and <code>prefetcht2</code> to load the operand into the L2 cache. Measures execution time to infer TLB caching.</li>
<li><strong>Blue box</strong>: Uses <code>lfence</code> and <code>mfence</code> for instruction serialization to ensure accurate timing.<ul>
<li>Execute all previously loaded instructions in memory and enter</li>
<li>Force instruction execution order, remove optimization</li>
</ul>
</li>
</ul>
<p><img src="image13.png" srcset="/img/loading.gif" alt="image13.png"></p>
<p>On my test environment (13th-gen Intel CPU), I was able to resolve the <code>ntoskrnl.exe</code> base address within a few seconds.</p>
<p>There are, however, two major caveats:</p>
<ol>
<li>This technique is reliable only on recent Intel processors. On AMD CPUs, results are inconsistent.</li>
<li>Unlike the legacy <code>NtQuerySystemInformation</code> method, which could reveal addresses of various kernel objects (e.g., KTHREAD, pools), this approach only leaks the kernel image base&#x2014;making it comparatively less versatile.</li>
</ol>
<p>Ultimately, the permission restrictions added to <code>NtQuerySystemInformation</code> in 24H2 have a significant impact on kernel exploitation strategies.<br><del>Looks like understanding the CPU manual is now a prerequisite for kernel work&#x2026;</del></p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this post, we examined the mitigation patch applied to <code>NtQuerySystemInformation</code>, a long-time staple in Windows kernel exploitation. We also explored how this led to the need for new KASLR bypass techniques, specifically through sidechannel-based kernel infoleaks.</p>
<p>In my opinion, the availability of <code>NtQuerySystemInformation</code> had previously stifled research into novel KASLR bypasses. With the new 24H2 mitigation in place, we may finally see a renewed wave of creative approaches in the kernel exploitation space.</p>
<p>See you in the next post&#x2014;where we&#x2019;ll return to the I/O Ring exploit!</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://windows-internals.com/kaslr-leaks-restriction/">https://windows-internals.com/kaslr-leaks-restriction/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://exploits.forsale/24h2-nt-exploit/">https://exploits.forsale/24h2-nt-exploit/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/exploits-forsale/prefetch-tool">https://github.com/exploits-forsale/prefetch-tool</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/kernel/">kernel</a>
                  
                  <a class="hover-with-bg" href="/tags/bypass/">bypass</a>
                  
                  <a class="hover-with-bg" href="/tags/windows/">windows</a>
                  
                  <a class="hover-with-bg" href="/tags/L0ch/">L0ch</a>
                  
                  <a class="hover-with-bg" href="/tags/mitigation/">mitigation</a>
                  
                  <a class="hover-with-bg" href="/tags/kaslr/">kaslr</a>
                  
                  <a class="hover-with-bg" href="/tags/entrybleed/">entrybleed</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_L0ch.jpg" srcset="/img/loading.gif" alt="L0ch">
                  </div>

                  <div class="link-text">
                    <div class="link-title">L0ch</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/L0ch">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/04/13/l0ch/bypassing-kernel-mitigation-part0/ko/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[Research] Bypassing Windows Kernel Mitigations: Part0 - Deep Dive into KASLR Leaks Restriction (Ko)</span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/04/13/mungsul/2025-04-12/">
                    <span class="hidden-mobile">[하루한줄] CVE-2025-3248: LangFlow Code Injection Vulnerability</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/04/13/l0ch/bypassing-kernel-mitigation-part0/en/';
        this.page.identifier = '/2025/04/13/l0ch/bypassing-kernel-mitigation-part0/en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] Bypassing Windows Kernel Mitigations: Part0 - Deep Dive into KASLR Leaks Restriction (En)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
