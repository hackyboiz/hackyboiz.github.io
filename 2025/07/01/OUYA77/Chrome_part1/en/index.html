

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;h2 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Hello, I&amp;#x2019;m OUYA77.&lt;/p&gt;
&lt;p&gt;You might be surprised to suddenly see Chrome appear out of nowhere. Honestly, I was just as surprised myself.&lt;/p&gt;
&lt;p&gt;I never expected to dive into Chrome, but I happened to watch a conference video by chance, and thought, &amp;#x201C;Wow, this is actually fun.&amp;#x201D; So without much thought, I started studying it. (&lt;a href=&#34;https://www.youtube.com/watch?v=RL2po1swXO4&#34;&gt;Link&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;I don&amp;#x2019;t have any grand ambitions like hunting for zero-days or making money through bug bounty programs. It&amp;#x2019;s really just that&amp;#x2014;I found it interesting and wanted to learn more. While digging into Chrome vulnerability research, I kept encountering the term &lt;strong&gt;Type Confusion&lt;/strong&gt;. Naturally, I got curious: what exactly &lt;em&gt;is&lt;/em&gt; Type Confusion?&lt;/p&gt;
&lt;p&gt;I browsed through various blog posts online, but since I had zero background in JavaScript or web stuff, most of it went way over my head. Still, I pushed through and eventually realized, &amp;#x201C;Ah, &lt;em&gt;this&lt;/em&gt; is how Type Confusion happens&amp;#x2014;and &lt;em&gt;this&lt;/em&gt; is how it&amp;#x2019;s exploited.&amp;#x201D;&lt;/p&gt;
&lt;p&gt;I started thinking about how I could make my learning process more productive and meaningful. Then I thought of this: If I could explain Type Confusion&amp;#x2014;a foundational concept in Chrome exploitation&amp;#x2014;in a way that&amp;#x2019;s approachable for beginners like myself, wouldn&amp;#x2019;t that be a meaningful contribution already?&lt;/p&gt;
&lt;p&gt;So&amp;#x2026; here it is!!!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;TypeConfusion101.png&#34; alt=&#34;TypeConfusion101.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s take a look at what Type Confusion actually is, why it occurs in Chrome, and what we can do with it! &lt;/p&gt;
&lt;p&gt;To be honest, I&amp;#x2019;ve already dropped a few spoilers about Type Confusion here and there&amp;#x2014;couldn&amp;#x2019;t help myself. &amp;#x1F605; In fact, I even wrote a short piece introducing Type Confusion in our hacking team&amp;#x2019;s newsletter:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://maily.so/hackyboiz/posts/1gz2v4jxr3q&#34;&gt;https://maily.so/hackyboiz/posts/1gz2v4jxr3q&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#x314B;&amp;#x314B;&amp;#x314B;&amp;#x314B;&amp;#x314B;&amp;#x314B;&amp;#x314B;^^&lt;/p&gt;
&lt;p&gt;I&amp;#x2019;m planning for this &amp;#x201C;Type Confusion 101 in Chrome&amp;#x201D; series to be a four-part journey&amp;#x2014;but hey, life never goes as planned, and that&amp;#x2019;s what makes it fun, right? Let&amp;#x2019;s see how far we get together! &amp;#x1F604;&lt;/p&gt;
&lt;p&gt;Today, we&amp;#x2019;re starting with the basics.&lt;/p&gt;
&lt;p&gt;You probably already know what Chrome is, but let&amp;#x2019;s briefly go over it&amp;#x2014;along with V8, the component where Type Confusion typically happens.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-Overview-of-Chrome&amp;#x2019;s-Architecture&#34;&gt;&lt;a href=&#34;#1-Overview-of-Chrome&amp;#x2019;s-Architecture&#34; class=&#34;headerlink&#34; title=&#34;1. Overview of Chrome&amp;#x2019;s Architecture&#34;&gt;&lt;/a&gt;1. Overview of Chrome&amp;#x2019;s Architecture&lt;/h2&gt;&lt;h3 id=&#34;1-1-Multi-process-Architecture&#34;&gt;&lt;a href=&#34;#1-1-Multi-process-Architecture&#34; class=&#34;headerlink&#34; title=&#34;1.1 Multi-process Architecture&#34;&gt;&lt;/a&gt;1.1 Multi-process Architecture&lt;/h3&gt;&lt;p&gt;When you double-click the Chrome icon, it may seem like you&amp;#x2019;re launching a single program&amp;#x2014;but in reality, Chrome is composed of multiple processes that communicate via IPC. (If you&amp;#x2019;re curious about IPC, check this out &amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/05/12/ogu123/NamedPipe/EN/&#34;&gt;&lt;strong&gt;[Research] Windows Named Pipe (EN)&lt;/strong&gt;&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&#34;https://developer.chrome.com/blog/inside-browser-part1&#34;&gt;https://developer.chrome.com/blog/inside-browser-part1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s briefly explore the core processes involved.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;Browser Process&lt;/strong&gt; is responsible for the user interface (UI) of Chrome&amp;#x2014;what you see every day: tabs, address bar, bookmarks, and so on. It&amp;#x2019;s essentially the first thing you interact with when Chrome starts.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Renderer Process&lt;/strong&gt; handles the actual rendering of web content. It interprets HTML, CSS, and JavaScript and transforms them into the visual web pages we see.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;GPU Process&lt;/strong&gt; takes care of graphics-related tasks, offloading work from the CPU for better performance.&lt;/li&gt;
&lt;li&gt;There are also other specialized processes like &lt;strong&gt;Utility&lt;/strong&gt;, &lt;strong&gt;Network&lt;/strong&gt;, and &lt;strong&gt;Extension Processes&lt;/strong&gt; that handle things such as network communication or running Chrome extensions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Together, these modular processes make up Chrome&amp;#x2019;s &lt;strong&gt;multi-process architecture&lt;/strong&gt;&amp;#x2014;a system where each component runs independently but collaborates to form a cohesive user experience.&lt;/p&gt;
&lt;p&gt;Why all this complexity? The main reasons are &lt;strong&gt;security&lt;/strong&gt; and &lt;strong&gt;stability&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Each process is &lt;strong&gt;isolated&lt;/strong&gt; from the others. So even if something crashes the whole browser doesn&amp;#x2019;t go down with it. For example, if a bug causes the Renderer Process to crash, the Browser Process can still display a message like &amp;#x201C;This page has become unresponsive&amp;#x201D; instead of crashing the entire application.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;This concept of &lt;strong&gt;isolation&lt;/strong&gt; is at the heart of Chrome&amp;#x2019;s &lt;strong&gt;sandboxing security model&lt;/strong&gt;. (More on sandboxing in the next post!)&lt;/p&gt;
&lt;h3 id=&#34;1-2-How-Chrome-Handles-Front-End-Resources&#34;&gt;&lt;a href=&#34;#1-2-How-Chrome-Handles-Front-End-Resources&#34; class=&#34;headerlink&#34; title=&#34;1.2 How Chrome Handles Front-End Resources&#34;&gt;&lt;/a&gt;1.2 How Chrome Handles Front-End Resources&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Chrome processes various front-end resources&amp;#x2014;such as HTML, CSS, and JavaScript files&amp;#x2014;to render web pages. Even during that brief moment when you open a new tab and load a website, the underlying multi-process system is already working hard behind the scenes.&lt;/p&gt;
&lt;p&gt;It all starts when Chrome fetches the &lt;strong&gt;HTML document&lt;/strong&gt; from the server and begins parsing it. As it encounters &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, it then requests additional &lt;strong&gt;CSS&lt;/strong&gt; and &lt;strong&gt;JavaScript&lt;/strong&gt; files. Each resource plays a specific role:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTML&lt;/strong&gt; defines the structural skeleton of the page.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CSS&lt;/strong&gt; adds styling&amp;#x2014;colors, layouts, fonts&amp;#x2014;to shape the page&amp;#x2019;s appearance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; brings the page to life, enabling dynamic behavior, user interaction, animations, and logic.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JavaScript is particularly interesting because it&amp;#x2019;s &lt;strong&gt;dynamically typed&lt;/strong&gt; and can &lt;strong&gt;create or modify objects on the fly&lt;/strong&gt;. While this makes web development incredibly flexible, it also adds complexity to how browsers execute and manage this code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%205.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Enter the &lt;strong&gt;V8 JavaScript engine&lt;/strong&gt; designed to process JavaScript quickly and efficiently. All of this happens inside the &lt;strong&gt;Renderer Process&lt;/strong&gt;, a dedicated and isolated environment for executing front-end code.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s dive deeper into what the Renderer Process actually does!&lt;/p&gt;
&lt;h2 id=&#34;2-About-Render-Process&#34;&gt;&lt;a href=&#34;#2-About-Render-Process&#34; class=&#34;headerlink&#34; title=&#34;2. About Render Process&#34;&gt;&lt;/a&gt;2. About Render Process&lt;/h2&gt;&lt;p&gt;Everything involved in visually displaying and making a web page interactive happens inside the &lt;strong&gt;Renderer Process&lt;/strong&gt;. Each tab in Chrome is handled by its own renderer, and within that process, the entire rendering pipeline takes place: HTML parsing, CSS application, DOM construction, JavaScript execution, layout calculation, painting, and compositing.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;JavaScript is a very flexible language that allows types to change during execution and object structures to be modified dynamically. While this makes development powerful, it also introduces risks such as memory corruption and vulnerabilities like &lt;strong&gt;Type Confusion&lt;/strong&gt;. To reduce these risks, Chrome isolates JavaScript execution inside separate Renderer Processes. Even if something goes wrong in one tab, only that specific process needs to be terminated, without affecting other tabs or the browser as a whole.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s now take a look at how JavaScript is executed inside the renderer.&lt;/p&gt;
&lt;h3 id=&#34;2-1-From-Blink-to-V8&#34;&gt;&lt;a href=&#34;#2-1-From-Blink-to-V8&#34; class=&#34;headerlink&#34; title=&#34;2.1 From Blink to V8&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.1 From Blink to V8&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;In Chrome&amp;#x2019;s rendering pipeline, the &lt;strong&gt;Blink engine&lt;/strong&gt; is responsible for parsing HTML and rendering the visual structure of the page, while the &lt;strong&gt;V8 engine&lt;/strong&gt; is responsible for executing JavaScript. These two engines work closely together to create a fully functional web experience.&lt;/p&gt;
&lt;p&gt;Now, let&amp;#x2019;s take a look at how control flows from Blink to V8.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2460; When a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is encountered&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;While Blink is parsing HTML, if it comes across a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, it begins to stream the corresponding JavaScript file. The streamed JS code is passed to the V8 engine as a string. From this point on, V8 takes over the execution flow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2461; Scanner: Converting the string into tokens&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Inside V8, the first component to process the UTF-16 JavaScript string received from Blink is the &lt;strong&gt;scanner&lt;/strong&gt;. The scanner breaks down the string into meaningful tokens based on JavaScript grammar. For example, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;123&lt;/code&gt;, and &lt;code&gt;&amp;apos;hello&amp;apos;&lt;/code&gt; are all separate tokens. These tokens are then passed on to the parser.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2462; Parser: Building the AST&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;parser&lt;/strong&gt; analyzes the tokens and constructs an Abstract Syntax Tree (AST) that represents the structure and semantics of the code. Since this involves compiler theory, we&amp;#x2019;ll skip the deep details for now.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2463; Ignition: Converting to bytecode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The AST is handed off to &lt;strong&gt;Ignition&lt;/strong&gt;, V8&amp;#x2019;s interpreter. Ignition walks through the AST and translates the JavaScript into &lt;strong&gt;bytecode&lt;/strong&gt;, a lower-level representation optimized for fast execution within V8. This bytecode sits at a level of abstraction between source code and machine code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2464; Execution!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Finally, the generated bytecode is executed sequentially by the &lt;strong&gt;Ignition interpreter&lt;/strong&gt;. At this stage, the JavaScript code we wrote actually runs&amp;#x2014;registering event listeners, modifying the DOM, animating elements, and more. While executing, V8 monitors code behavior. If certain functions are called frequently or specific code paths are executed often, V8 activates its optimizing compiler, &lt;strong&gt;TurboFan&lt;/strong&gt;, to generate &lt;strong&gt;Just-In-Time (JIT)&lt;/strong&gt; compiled native machine code. This results in a significant performance boost.&lt;/p&gt;
&lt;p&gt;Now that we&amp;#x2019;ve seen the full JavaScript execution process, let&amp;#x2019;s take a deeper look into the &lt;strong&gt;internal structure of the V8 engine&lt;/strong&gt; that powers it.&lt;/p&gt;
&lt;h3 id=&#34;2-2-Introduction-to-the-V8-Engine&#34;&gt;&lt;a href=&#34;#2-2-Introduction-to-the-V8-Engine&#34; class=&#34;headerlink&#34; title=&#34;2.2 Introduction to the V8 Engine&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.2 Introduction to the V8 Engine&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;image%2011.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;The name &amp;#x201C;V8&amp;#x201D; was inspired by high-performance car engines. The Chrome team chose this name to reflect their hope that their JavaScript engine would be just as fast and powerful. And in reality, V8 is far more than a simple interpreter&amp;#x2014;it&amp;#x2019;s a complex and highly optimized execution engine that combines multiple tiers of performance techniques.&lt;/p&gt;
&lt;p&gt;As mentioned earlier, JavaScript is a &lt;strong&gt;dynamically typed language&lt;/strong&gt;, meaning the types of variables and object structures are not known until runtime. This provides great flexibility for developers, but it also presents serious challenges for performance and security in the engine. To address these, V8 adopts a &lt;strong&gt;multi-phase execution pipeline&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Initially, V8 used &lt;strong&gt;Crankshaft&lt;/strong&gt;, a JIT compiler that compiled JavaScript straight to machine code without interpreting it first. However, this approach had limitations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Attempting to optimize all code resulted in &lt;strong&gt;high memory usage&lt;/strong&gt; and &lt;strong&gt;slow startup times&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Due to JavaScript&amp;#x2019;s dynamic nature, &lt;strong&gt;deoptimizations&lt;/strong&gt; were frequent and costly.&lt;/li&gt;
&lt;li&gt;Supporting newer ECMAScript features was becoming increasingly difficult, making Crankshaft &lt;strong&gt;hard to maintain&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a result, the V8 team designed a new compiler architecture: &lt;strong&gt;TurboFan&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2012.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TurboFan (since v5.9)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TurboFan replaced Crankshaft as V8&amp;#x2019;s new optimizing compiler. It was built with the following goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Full support for the modern JavaScript language spec&lt;/li&gt;
&lt;li&gt;A robust optimization pipeline centered on intermediate representations (IR)&lt;/li&gt;
&lt;li&gt;High portability and scalability across various platforms and architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While TurboFan delivered powerful optimizations, it still had a drawback&amp;#x2014;it took time to kick in. For short-lived scripts that run briefly (which is common on the web), the benefits often didn&amp;#x2019;t justify the cost.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SparkPlug (introduced in 2021)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To bridge this gap, the V8 team introduced &lt;strong&gt;SparkPlug&lt;/strong&gt;, a lightweight JIT compiler designed for quick compilation. SparkPlug aimed to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compile from bytecode that had already been parsed and interpreted&lt;/li&gt;
&lt;li&gt;Skip deep type analysis and complex optimizations in favor of &lt;strong&gt;speed&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Generate machine code faster than TurboFan, albeit less optimized&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SparkPlug offered a significant boost during the early execution stages&amp;#x2014;particularly helpful for page loading and initial user interactions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maglev (2022 and onward)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;While SparkPlug worked well, its optimizations were still limited. The V8 team wanted something &lt;strong&gt;faster than TurboFan&lt;/strong&gt; and &lt;strong&gt;smarter than SparkPlug&lt;/strong&gt;, especially for resource-constrained environments like mobile. Enter &lt;strong&gt;Maglev&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Maglev was designed to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Generate register-based machine code more aggressively than SparkPlug&lt;/li&gt;
&lt;li&gt;Incorporate lightweight type feedback to improve performance&lt;/li&gt;
&lt;li&gt;Match SparkPlug&amp;#x2019;s compile speed while approaching TurboFan-level performance at runtime&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Maglev is especially useful for devices with limited resources and helps strike a balance between speed and optimization.&lt;/p&gt;
&lt;p&gt;Today, V8 uses a &lt;strong&gt;tiered execution model&lt;/strong&gt; that progresses through multiple stages based on code &amp;#x201C;hotness&amp;#x201D;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ignition &amp;#x2192; Maglev &amp;#x2192; TurboFan&lt;/strong&gt;. This dynamic system allows V8 to adjust the level of optimization depending on how frequently the code is executed.&lt;/p&gt;
&lt;h3 id=&#34;2-3-The-V8-Execution-Pipeline&#34;&gt;&lt;a href=&#34;#2-3-The-V8-Execution-Pipeline&#34; class=&#34;headerlink&#34; title=&#34;2.3 The V8 Execution Pipeline&#34;&gt;&lt;/a&gt;2.3 The V8 Execution Pipeline&lt;/h3&gt;&lt;p&gt;Based on what we&amp;#x2019;ve discussed so far, let&amp;#x2019;s summarize how V8&amp;#x2019;s execution pipeline works.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2013.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;At the heart of V8&amp;#x2019;s pipeline is the &lt;strong&gt;Ignition interpreter&lt;/strong&gt;. It converts JavaScript source code into bytecode and begins executing it sequentially while collecting runtime feedback. Ignition was designed for &lt;strong&gt;fast startup and low memory consumption&lt;/strong&gt;, and replaced the older Full-codegen system in Chrome v5.9. However, interpreters alone can&amp;#x2019;t offer high performance, so once certain parts of the code become &amp;#x201C;hot&amp;#x201D; (frequently executed), they are promoted to the next stage for Just-In-Time (JIT) compilation.&lt;/p&gt;
&lt;p&gt;That&amp;#x2019;s where &lt;strong&gt;SparkPlug&lt;/strong&gt; comes in. SparkPlug compiles bytecode into &lt;strong&gt;native machine code quickly&lt;/strong&gt;, without performing deep type analysis or applying complex optimizations. This makes it ideal for scenarios where &lt;strong&gt;fast, lightweight performance is required&lt;/strong&gt;, such as during page loading or initial user interactions. It&amp;#x2019;s efficient in both speed and resource usage, acting as a smart middle ground between interpretation and full optimization.&lt;/p&gt;
&lt;p&gt;When higher performance is needed, V8 turns to its full optimizing compiler, &lt;strong&gt;TurboFan&lt;/strong&gt;. TurboFan uses the &lt;strong&gt;type feedback, call patterns, and loop structures&lt;/strong&gt; collected during earlier execution to apply advanced optimizations&amp;#x2014;such as inlining, loop unrolling, and type specialization. The result is &lt;strong&gt;highly optimized native code&lt;/strong&gt; that performs similarly to code in statically typed languages. Since optimized code is cached, subsequent calls execute very quickly, making TurboFan particularly effective for hot, long-running code paths.&lt;/p&gt;
&lt;p&gt;However, TurboFan comes with a cost. Compilation can be expensive, and failed optimizations (deopts) can hurt performance. To bridge the gap between SparkPlug and TurboFan, V8 introduced &lt;strong&gt;Maglev&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maglev&lt;/strong&gt; is a &lt;strong&gt;mid-tier JIT compiler&lt;/strong&gt; designed to balance &lt;strong&gt;optimization quality and compilation speed&lt;/strong&gt;. It generates more efficient register-based machine code than SparkPlug and incorporates some degree of type feedback, but without the heavy compilation cost of TurboFan. Introduced gradually starting in 2022, Maglev performs particularly well on &lt;strong&gt;resource-constrained environments like mobile devices&lt;/strong&gt; and provides a flexible middle layer that adapts to various runtime scenarios.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2014.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;To summarize, V8 doesn&amp;#x2019;t rely on a single compiler strategy. Instead, it uses a &lt;strong&gt;tiered execution pipeline&lt;/strong&gt; that dynamically escalates optimization based on how frequently code is executed. This means it doesn&amp;#x2019;t waste resources upfront, but rather &lt;strong&gt;invests incrementally&lt;/strong&gt; to achieve better performance over time.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Thanks to this layered approach, V8 can successfully balance &lt;strong&gt;fast startup, low memory usage, and high execution performance&lt;/strong&gt;&amp;#x2014;all at once.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2015.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;However, this sophisticated execution pipeline also introduces potential &lt;strong&gt;security vulnerabilities&lt;/strong&gt;. Most of V8&amp;#x2019;s optimizations rely on assumptions such as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;#x201C;This object will continue to have the same structure,&amp;#x201D;&lt;/em&gt; or &lt;em&gt;&amp;#x201C;This function will always be called in the same way.&amp;#x201D;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But when these assumptions are broken, V8 ends up performing &lt;strong&gt;memory access or object interpretation based on incorrect premises&lt;/strong&gt;, and this is where one of the most common vulnerabilities, &lt;strong&gt;Type Confusion&lt;/strong&gt;, can occur.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Type Confusion&lt;/strong&gt;, as the name suggests, happens when the engine makes incorrect inferences about the type of an object or value. It may also occur when the type changes, but the engine continues to treat it as if it hasn&amp;#x2019;t. For example, suppose an object starts off as a simple array of integers. If, during runtime, it becomes an array of complex objects but V8 still assumes it&amp;#x2019;s just an integer array and runs optimized code based on that assumption, it could result in &lt;strong&gt;invalid memory access or corruption of internal structures&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;These issues tend to happen more often during advanced optimizations performed by &lt;strong&gt;TurboFan&lt;/strong&gt; or &lt;strong&gt;Maglev&lt;/strong&gt;. Techniques like type specialization, function inlining, and hidden class assumptions can lock in certain behaviors to boost performance. However, if the code path changes or an object&amp;#x2019;s structure is altered afterward, these optimizations can become dangerous. For instance, an attacker might repeatedly call a function in a consistent way to convince the engine it&amp;#x2019;s safe to optimize. Then, at a specific moment, they intentionally alter the object&amp;#x2019;s type or structure, which triggers unexpected behavior in the native code that V8 already compiled. This technique has been used in several real-world Chrome exploits, and &lt;strong&gt;Type Confusion vulnerabilities in V8 are still considered high-risk attack vectors today&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now that we&amp;#x2019;ve walked through how JavaScript runs inside V8, the next step is to look deeper into how the engine represents and optimizes objects internally, and how this design can lead to security issues like Type Confusion.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s take a breath here.&lt;/p&gt;
&lt;p&gt;I&amp;#x2019;ll be back with &lt;strong&gt;Part 2&lt;/strong&gt; of the series. See you soon!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UP Next: Part2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image%2016.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;p&gt;v &lt;strong&gt;Conference Video&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=RL2po1swXO4&#34;&gt;https://www.youtube.com/watch?v=RL2po1swXO4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;v &lt;strong&gt;V8 Engine&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://v8.dev/&#34;&gt;https://v8.dev/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/V8_(JavaScript_engine&#34;&gt;https://en.wikipedia.org/wiki/V8_(JavaScript_engine&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://evan-moon.github.io/2019/06/28/v8-analysis/&#34;&gt;https://evan-moon.github.io/2019/06/28/v8-analysis/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.bitsrc.io/secret-behind-javascript-performance-v8-hidden-classes-ba4d0ebfb89d&#34;&gt;https://blog.bitsrc.io/secret-behind-javascript-performance-v8-hidden-classes-ba4d0ebfb89d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@yanguly/sparkplug-v8-baseline-javascript-compiler-758a7bc96e84&#34;&gt;https://medium.com/@yanguly/sparkplug-v8-baseline-javascript-compiler-758a7bc96e84&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pks2974.medium.com/v8-%EC%97%90%EC%84%9C-javascript-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0-25837f61f551&#34;&gt;https://pks2974.medium.com/v8-%EC%97%90%EC%84%9C-javascript-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0-25837f61f551&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^☆ Part 1.(EN) - hackyboiz">
  <meta property="og:description" content="&lt;h2 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Hello, I&amp;#x2019;m OUYA77.&lt;/p&gt;
&lt;p&gt;You might be surprised to suddenly see Chrome appear out of nowhere. Honestly, I was just as surprised myself.&lt;/p&gt;
&lt;p&gt;I never expected to dive into Chrome, but I happened to watch a conference video by chance, and thought, &amp;#x201C;Wow, this is actually fun.&amp;#x201D; So without much thought, I started studying it. (&lt;a href=&#34;https://www.youtube.com/watch?v=RL2po1swXO4&#34;&gt;Link&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;I don&amp;#x2019;t have any grand ambitions like hunting for zero-days or making money through bug bounty programs. It&amp;#x2019;s really just that&amp;#x2014;I found it interesting and wanted to learn more. While digging into Chrome vulnerability research, I kept encountering the term &lt;strong&gt;Type Confusion&lt;/strong&gt;. Naturally, I got curious: what exactly &lt;em&gt;is&lt;/em&gt; Type Confusion?&lt;/p&gt;
&lt;p&gt;I browsed through various blog posts online, but since I had zero background in JavaScript or web stuff, most of it went way over my head. Still, I pushed through and eventually realized, &amp;#x201C;Ah, &lt;em&gt;this&lt;/em&gt; is how Type Confusion happens&amp;#x2014;and &lt;em&gt;this&lt;/em&gt; is how it&amp;#x2019;s exploited.&amp;#x201D;&lt;/p&gt;
&lt;p&gt;I started thinking about how I could make my learning process more productive and meaningful. Then I thought of this: If I could explain Type Confusion&amp;#x2014;a foundational concept in Chrome exploitation&amp;#x2014;in a way that&amp;#x2019;s approachable for beginners like myself, wouldn&amp;#x2019;t that be a meaningful contribution already?&lt;/p&gt;
&lt;p&gt;So&amp;#x2026; here it is!!!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;TypeConfusion101.png&#34; alt=&#34;TypeConfusion101.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s take a look at what Type Confusion actually is, why it occurs in Chrome, and what we can do with it! &lt;/p&gt;
&lt;p&gt;To be honest, I&amp;#x2019;ve already dropped a few spoilers about Type Confusion here and there&amp;#x2014;couldn&amp;#x2019;t help myself. &amp;#x1F605; In fact, I even wrote a short piece introducing Type Confusion in our hacking team&amp;#x2019;s newsletter:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://maily.so/hackyboiz/posts/1gz2v4jxr3q&#34;&gt;https://maily.so/hackyboiz/posts/1gz2v4jxr3q&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#x314B;&amp;#x314B;&amp;#x314B;&amp;#x314B;&amp;#x314B;&amp;#x314B;&amp;#x314B;^^&lt;/p&gt;
&lt;p&gt;I&amp;#x2019;m planning for this &amp;#x201C;Type Confusion 101 in Chrome&amp;#x201D; series to be a four-part journey&amp;#x2014;but hey, life never goes as planned, and that&amp;#x2019;s what makes it fun, right? Let&amp;#x2019;s see how far we get together! &amp;#x1F604;&lt;/p&gt;
&lt;p&gt;Today, we&amp;#x2019;re starting with the basics.&lt;/p&gt;
&lt;p&gt;You probably already know what Chrome is, but let&amp;#x2019;s briefly go over it&amp;#x2014;along with V8, the component where Type Confusion typically happens.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%201.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-Overview-of-Chrome&amp;#x2019;s-Architecture&#34;&gt;&lt;a href=&#34;#1-Overview-of-Chrome&amp;#x2019;s-Architecture&#34; class=&#34;headerlink&#34; title=&#34;1. Overview of Chrome&amp;#x2019;s Architecture&#34;&gt;&lt;/a&gt;1. Overview of Chrome&amp;#x2019;s Architecture&lt;/h2&gt;&lt;h3 id=&#34;1-1-Multi-process-Architecture&#34;&gt;&lt;a href=&#34;#1-1-Multi-process-Architecture&#34; class=&#34;headerlink&#34; title=&#34;1.1 Multi-process Architecture&#34;&gt;&lt;/a&gt;1.1 Multi-process Architecture&lt;/h3&gt;&lt;p&gt;When you double-click the Chrome icon, it may seem like you&amp;#x2019;re launching a single program&amp;#x2014;but in reality, Chrome is composed of multiple processes that communicate via IPC. (If you&amp;#x2019;re curious about IPC, check this out &amp;#x2192; &lt;a href=&#34;https://hackyboiz.github.io/2025/05/12/ogu123/NamedPipe/EN/&#34;&gt;&lt;strong&gt;[Research] Windows Named Pipe (EN)&lt;/strong&gt;&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%202.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&#34;https://developer.chrome.com/blog/inside-browser-part1&#34;&gt;https://developer.chrome.com/blog/inside-browser-part1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s briefly explore the core processes involved.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;Browser Process&lt;/strong&gt; is responsible for the user interface (UI) of Chrome&amp;#x2014;what you see every day: tabs, address bar, bookmarks, and so on. It&amp;#x2019;s essentially the first thing you interact with when Chrome starts.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Renderer Process&lt;/strong&gt; handles the actual rendering of web content. It interprets HTML, CSS, and JavaScript and transforms them into the visual web pages we see.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;GPU Process&lt;/strong&gt; takes care of graphics-related tasks, offloading work from the CPU for better performance.&lt;/li&gt;
&lt;li&gt;There are also other specialized processes like &lt;strong&gt;Utility&lt;/strong&gt;, &lt;strong&gt;Network&lt;/strong&gt;, and &lt;strong&gt;Extension Processes&lt;/strong&gt; that handle things such as network communication or running Chrome extensions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Together, these modular processes make up Chrome&amp;#x2019;s &lt;strong&gt;multi-process architecture&lt;/strong&gt;&amp;#x2014;a system where each component runs independently but collaborates to form a cohesive user experience.&lt;/p&gt;
&lt;p&gt;Why all this complexity? The main reasons are &lt;strong&gt;security&lt;/strong&gt; and &lt;strong&gt;stability&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Each process is &lt;strong&gt;isolated&lt;/strong&gt; from the others. So even if something crashes the whole browser doesn&amp;#x2019;t go down with it. For example, if a bug causes the Renderer Process to crash, the Browser Process can still display a message like &amp;#x201C;This page has become unresponsive&amp;#x201D; instead of crashing the entire application.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%203.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;This concept of &lt;strong&gt;isolation&lt;/strong&gt; is at the heart of Chrome&amp;#x2019;s &lt;strong&gt;sandboxing security model&lt;/strong&gt;. (More on sandboxing in the next post!)&lt;/p&gt;
&lt;h3 id=&#34;1-2-How-Chrome-Handles-Front-End-Resources&#34;&gt;&lt;a href=&#34;#1-2-How-Chrome-Handles-Front-End-Resources&#34; class=&#34;headerlink&#34; title=&#34;1.2 How Chrome Handles Front-End Resources&#34;&gt;&lt;/a&gt;1.2 How Chrome Handles Front-End Resources&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;image%204.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Chrome processes various front-end resources&amp;#x2014;such as HTML, CSS, and JavaScript files&amp;#x2014;to render web pages. Even during that brief moment when you open a new tab and load a website, the underlying multi-process system is already working hard behind the scenes.&lt;/p&gt;
&lt;p&gt;It all starts when Chrome fetches the &lt;strong&gt;HTML document&lt;/strong&gt; from the server and begins parsing it. As it encounters &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, it then requests additional &lt;strong&gt;CSS&lt;/strong&gt; and &lt;strong&gt;JavaScript&lt;/strong&gt; files. Each resource plays a specific role:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTML&lt;/strong&gt; defines the structural skeleton of the page.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CSS&lt;/strong&gt; adds styling&amp;#x2014;colors, layouts, fonts&amp;#x2014;to shape the page&amp;#x2019;s appearance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; brings the page to life, enabling dynamic behavior, user interaction, animations, and logic.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JavaScript is particularly interesting because it&amp;#x2019;s &lt;strong&gt;dynamically typed&lt;/strong&gt; and can &lt;strong&gt;create or modify objects on the fly&lt;/strong&gt;. While this makes web development incredibly flexible, it also adds complexity to how browsers execute and manage this code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%205.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Enter the &lt;strong&gt;V8 JavaScript engine&lt;/strong&gt; designed to process JavaScript quickly and efficiently. All of this happens inside the &lt;strong&gt;Renderer Process&lt;/strong&gt;, a dedicated and isolated environment for executing front-end code.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s dive deeper into what the Renderer Process actually does!&lt;/p&gt;
&lt;h2 id=&#34;2-About-Render-Process&#34;&gt;&lt;a href=&#34;#2-About-Render-Process&#34; class=&#34;headerlink&#34; title=&#34;2. About Render Process&#34;&gt;&lt;/a&gt;2. About Render Process&lt;/h2&gt;&lt;p&gt;Everything involved in visually displaying and making a web page interactive happens inside the &lt;strong&gt;Renderer Process&lt;/strong&gt;. Each tab in Chrome is handled by its own renderer, and within that process, the entire rendering pipeline takes place: HTML parsing, CSS application, DOM construction, JavaScript execution, layout calculation, painting, and compositing.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%206.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;JavaScript is a very flexible language that allows types to change during execution and object structures to be modified dynamically. While this makes development powerful, it also introduces risks such as memory corruption and vulnerabilities like &lt;strong&gt;Type Confusion&lt;/strong&gt;. To reduce these risks, Chrome isolates JavaScript execution inside separate Renderer Processes. Even if something goes wrong in one tab, only that specific process needs to be terminated, without affecting other tabs or the browser as a whole.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s now take a look at how JavaScript is executed inside the renderer.&lt;/p&gt;
&lt;h3 id=&#34;2-1-From-Blink-to-V8&#34;&gt;&lt;a href=&#34;#2-1-From-Blink-to-V8&#34; class=&#34;headerlink&#34; title=&#34;2.1 From Blink to V8&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.1 From Blink to V8&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;In Chrome&amp;#x2019;s rendering pipeline, the &lt;strong&gt;Blink engine&lt;/strong&gt; is responsible for parsing HTML and rendering the visual structure of the page, while the &lt;strong&gt;V8 engine&lt;/strong&gt; is responsible for executing JavaScript. These two engines work closely together to create a fully functional web experience.&lt;/p&gt;
&lt;p&gt;Now, let&amp;#x2019;s take a look at how control flows from Blink to V8.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2460; When a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is encountered&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;While Blink is parsing HTML, if it comes across a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, it begins to stream the corresponding JavaScript file. The streamed JS code is passed to the V8 engine as a string. From this point on, V8 takes over the execution flow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%207.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2461; Scanner: Converting the string into tokens&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Inside V8, the first component to process the UTF-16 JavaScript string received from Blink is the &lt;strong&gt;scanner&lt;/strong&gt;. The scanner breaks down the string into meaningful tokens based on JavaScript grammar. For example, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;123&lt;/code&gt;, and &lt;code&gt;&amp;apos;hello&amp;apos;&lt;/code&gt; are all separate tokens. These tokens are then passed on to the parser.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%208.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2462; Parser: Building the AST&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;parser&lt;/strong&gt; analyzes the tokens and constructs an Abstract Syntax Tree (AST) that represents the structure and semantics of the code. Since this involves compiler theory, we&amp;#x2019;ll skip the deep details for now.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%209.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2463; Ignition: Converting to bytecode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The AST is handed off to &lt;strong&gt;Ignition&lt;/strong&gt;, V8&amp;#x2019;s interpreter. Ignition walks through the AST and translates the JavaScript into &lt;strong&gt;bytecode&lt;/strong&gt;, a lower-level representation optimized for fast execution within V8. This bytecode sits at a level of abstraction between source code and machine code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2010.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&amp;#x2464; Execution!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Finally, the generated bytecode is executed sequentially by the &lt;strong&gt;Ignition interpreter&lt;/strong&gt;. At this stage, the JavaScript code we wrote actually runs&amp;#x2014;registering event listeners, modifying the DOM, animating elements, and more. While executing, V8 monitors code behavior. If certain functions are called frequently or specific code paths are executed often, V8 activates its optimizing compiler, &lt;strong&gt;TurboFan&lt;/strong&gt;, to generate &lt;strong&gt;Just-In-Time (JIT)&lt;/strong&gt; compiled native machine code. This results in a significant performance boost.&lt;/p&gt;
&lt;p&gt;Now that we&amp;#x2019;ve seen the full JavaScript execution process, let&amp;#x2019;s take a deeper look into the &lt;strong&gt;internal structure of the V8 engine&lt;/strong&gt; that powers it.&lt;/p&gt;
&lt;h3 id=&#34;2-2-Introduction-to-the-V8-Engine&#34;&gt;&lt;a href=&#34;#2-2-Introduction-to-the-V8-Engine&#34; class=&#34;headerlink&#34; title=&#34;2.2 Introduction to the V8 Engine&#34;&gt;&lt;/a&gt;&lt;strong&gt;2.2 Introduction to the V8 Engine&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;image%2011.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;The name &amp;#x201C;V8&amp;#x201D; was inspired by high-performance car engines. The Chrome team chose this name to reflect their hope that their JavaScript engine would be just as fast and powerful. And in reality, V8 is far more than a simple interpreter&amp;#x2014;it&amp;#x2019;s a complex and highly optimized execution engine that combines multiple tiers of performance techniques.&lt;/p&gt;
&lt;p&gt;As mentioned earlier, JavaScript is a &lt;strong&gt;dynamically typed language&lt;/strong&gt;, meaning the types of variables and object structures are not known until runtime. This provides great flexibility for developers, but it also presents serious challenges for performance and security in the engine. To address these, V8 adopts a &lt;strong&gt;multi-phase execution pipeline&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Initially, V8 used &lt;strong&gt;Crankshaft&lt;/strong&gt;, a JIT compiler that compiled JavaScript straight to machine code without interpreting it first. However, this approach had limitations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Attempting to optimize all code resulted in &lt;strong&gt;high memory usage&lt;/strong&gt; and &lt;strong&gt;slow startup times&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Due to JavaScript&amp;#x2019;s dynamic nature, &lt;strong&gt;deoptimizations&lt;/strong&gt; were frequent and costly.&lt;/li&gt;
&lt;li&gt;Supporting newer ECMAScript features was becoming increasingly difficult, making Crankshaft &lt;strong&gt;hard to maintain&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a result, the V8 team designed a new compiler architecture: &lt;strong&gt;TurboFan&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2012.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TurboFan (since v5.9)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TurboFan replaced Crankshaft as V8&amp;#x2019;s new optimizing compiler. It was built with the following goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Full support for the modern JavaScript language spec&lt;/li&gt;
&lt;li&gt;A robust optimization pipeline centered on intermediate representations (IR)&lt;/li&gt;
&lt;li&gt;High portability and scalability across various platforms and architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While TurboFan delivered powerful optimizations, it still had a drawback&amp;#x2014;it took time to kick in. For short-lived scripts that run briefly (which is common on the web), the benefits often didn&amp;#x2019;t justify the cost.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SparkPlug (introduced in 2021)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To bridge this gap, the V8 team introduced &lt;strong&gt;SparkPlug&lt;/strong&gt;, a lightweight JIT compiler designed for quick compilation. SparkPlug aimed to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compile from bytecode that had already been parsed and interpreted&lt;/li&gt;
&lt;li&gt;Skip deep type analysis and complex optimizations in favor of &lt;strong&gt;speed&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Generate machine code faster than TurboFan, albeit less optimized&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SparkPlug offered a significant boost during the early execution stages&amp;#x2014;particularly helpful for page loading and initial user interactions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maglev (2022 and onward)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;While SparkPlug worked well, its optimizations were still limited. The V8 team wanted something &lt;strong&gt;faster than TurboFan&lt;/strong&gt; and &lt;strong&gt;smarter than SparkPlug&lt;/strong&gt;, especially for resource-constrained environments like mobile. Enter &lt;strong&gt;Maglev&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Maglev was designed to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Generate register-based machine code more aggressively than SparkPlug&lt;/li&gt;
&lt;li&gt;Incorporate lightweight type feedback to improve performance&lt;/li&gt;
&lt;li&gt;Match SparkPlug&amp;#x2019;s compile speed while approaching TurboFan-level performance at runtime&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Maglev is especially useful for devices with limited resources and helps strike a balance between speed and optimization.&lt;/p&gt;
&lt;p&gt;Today, V8 uses a &lt;strong&gt;tiered execution model&lt;/strong&gt; that progresses through multiple stages based on code &amp;#x201C;hotness&amp;#x201D;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ignition &amp;#x2192; Maglev &amp;#x2192; TurboFan&lt;/strong&gt;. This dynamic system allows V8 to adjust the level of optimization depending on how frequently the code is executed.&lt;/p&gt;
&lt;h3 id=&#34;2-3-The-V8-Execution-Pipeline&#34;&gt;&lt;a href=&#34;#2-3-The-V8-Execution-Pipeline&#34; class=&#34;headerlink&#34; title=&#34;2.3 The V8 Execution Pipeline&#34;&gt;&lt;/a&gt;2.3 The V8 Execution Pipeline&lt;/h3&gt;&lt;p&gt;Based on what we&amp;#x2019;ve discussed so far, let&amp;#x2019;s summarize how V8&amp;#x2019;s execution pipeline works.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2013.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;At the heart of V8&amp;#x2019;s pipeline is the &lt;strong&gt;Ignition interpreter&lt;/strong&gt;. It converts JavaScript source code into bytecode and begins executing it sequentially while collecting runtime feedback. Ignition was designed for &lt;strong&gt;fast startup and low memory consumption&lt;/strong&gt;, and replaced the older Full-codegen system in Chrome v5.9. However, interpreters alone can&amp;#x2019;t offer high performance, so once certain parts of the code become &amp;#x201C;hot&amp;#x201D; (frequently executed), they are promoted to the next stage for Just-In-Time (JIT) compilation.&lt;/p&gt;
&lt;p&gt;That&amp;#x2019;s where &lt;strong&gt;SparkPlug&lt;/strong&gt; comes in. SparkPlug compiles bytecode into &lt;strong&gt;native machine code quickly&lt;/strong&gt;, without performing deep type analysis or applying complex optimizations. This makes it ideal for scenarios where &lt;strong&gt;fast, lightweight performance is required&lt;/strong&gt;, such as during page loading or initial user interactions. It&amp;#x2019;s efficient in both speed and resource usage, acting as a smart middle ground between interpretation and full optimization.&lt;/p&gt;
&lt;p&gt;When higher performance is needed, V8 turns to its full optimizing compiler, &lt;strong&gt;TurboFan&lt;/strong&gt;. TurboFan uses the &lt;strong&gt;type feedback, call patterns, and loop structures&lt;/strong&gt; collected during earlier execution to apply advanced optimizations&amp;#x2014;such as inlining, loop unrolling, and type specialization. The result is &lt;strong&gt;highly optimized native code&lt;/strong&gt; that performs similarly to code in statically typed languages. Since optimized code is cached, subsequent calls execute very quickly, making TurboFan particularly effective for hot, long-running code paths.&lt;/p&gt;
&lt;p&gt;However, TurboFan comes with a cost. Compilation can be expensive, and failed optimizations (deopts) can hurt performance. To bridge the gap between SparkPlug and TurboFan, V8 introduced &lt;strong&gt;Maglev&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maglev&lt;/strong&gt; is a &lt;strong&gt;mid-tier JIT compiler&lt;/strong&gt; designed to balance &lt;strong&gt;optimization quality and compilation speed&lt;/strong&gt;. It generates more efficient register-based machine code than SparkPlug and incorporates some degree of type feedback, but without the heavy compilation cost of TurboFan. Introduced gradually starting in 2022, Maglev performs particularly well on &lt;strong&gt;resource-constrained environments like mobile devices&lt;/strong&gt; and provides a flexible middle layer that adapts to various runtime scenarios.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2014.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;To summarize, V8 doesn&amp;#x2019;t rely on a single compiler strategy. Instead, it uses a &lt;strong&gt;tiered execution pipeline&lt;/strong&gt; that dynamically escalates optimization based on how frequently code is executed. This means it doesn&amp;#x2019;t waste resources upfront, but rather &lt;strong&gt;invests incrementally&lt;/strong&gt; to achieve better performance over time.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Thanks to this layered approach, V8 can successfully balance &lt;strong&gt;fast startup, low memory usage, and high execution performance&lt;/strong&gt;&amp;#x2014;all at once.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image%2015.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;However, this sophisticated execution pipeline also introduces potential &lt;strong&gt;security vulnerabilities&lt;/strong&gt;. Most of V8&amp;#x2019;s optimizations rely on assumptions such as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;#x201C;This object will continue to have the same structure,&amp;#x201D;&lt;/em&gt; or &lt;em&gt;&amp;#x201C;This function will always be called in the same way.&amp;#x201D;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But when these assumptions are broken, V8 ends up performing &lt;strong&gt;memory access or object interpretation based on incorrect premises&lt;/strong&gt;, and this is where one of the most common vulnerabilities, &lt;strong&gt;Type Confusion&lt;/strong&gt;, can occur.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Type Confusion&lt;/strong&gt;, as the name suggests, happens when the engine makes incorrect inferences about the type of an object or value. It may also occur when the type changes, but the engine continues to treat it as if it hasn&amp;#x2019;t. For example, suppose an object starts off as a simple array of integers. If, during runtime, it becomes an array of complex objects but V8 still assumes it&amp;#x2019;s just an integer array and runs optimized code based on that assumption, it could result in &lt;strong&gt;invalid memory access or corruption of internal structures&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;These issues tend to happen more often during advanced optimizations performed by &lt;strong&gt;TurboFan&lt;/strong&gt; or &lt;strong&gt;Maglev&lt;/strong&gt;. Techniques like type specialization, function inlining, and hidden class assumptions can lock in certain behaviors to boost performance. However, if the code path changes or an object&amp;#x2019;s structure is altered afterward, these optimizations can become dangerous. For instance, an attacker might repeatedly call a function in a consistent way to convince the engine it&amp;#x2019;s safe to optimize. Then, at a specific moment, they intentionally alter the object&amp;#x2019;s type or structure, which triggers unexpected behavior in the native code that V8 already compiled. This technique has been used in several real-world Chrome exploits, and &lt;strong&gt;Type Confusion vulnerabilities in V8 are still considered high-risk attack vectors today&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now that we&amp;#x2019;ve walked through how JavaScript runs inside V8, the next step is to look deeper into how the engine represents and optimizes objects internally, and how this design can lead to security issues like Type Confusion.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s take a breath here.&lt;/p&gt;
&lt;p&gt;I&amp;#x2019;ll be back with &lt;strong&gt;Part 2&lt;/strong&gt; of the series. See you soon!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UP Next: Part2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image%2016.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Reference&#34;&gt;&lt;a href=&#34;#Reference&#34; class=&#34;headerlink&#34; title=&#34;Reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;p&gt;v &lt;strong&gt;Conference Video&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=RL2po1swXO4&#34;&gt;https://www.youtube.com/watch?v=RL2po1swXO4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;v &lt;strong&gt;V8 Engine&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://v8.dev/&#34;&gt;https://v8.dev/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/V8_(JavaScript_engine&#34;&gt;https://en.wikipedia.org/wiki/V8_(JavaScript_engine&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://evan-moon.github.io/2019/06/28/v8-analysis/&#34;&gt;https://evan-moon.github.io/2019/06/28/v8-analysis/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.bitsrc.io/secret-behind-javascript-performance-v8-hidden-classes-ba4d0ebfb89d&#34;&gt;https://blog.bitsrc.io/secret-behind-javascript-performance-v8-hidden-classes-ba4d0ebfb89d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@yanguly/sparkplug-v8-baseline-javascript-compiler-758a7bc96e84&#34;&gt;https://medium.com/@yanguly/sparkplug-v8-baseline-javascript-compiler-758a7bc96e84&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pks2974.medium.com/v8-%EC%97%90%EC%84%9C-javascript-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0-25837f61f551&#34;&gt;https://pks2974.medium.com/v8-%EC%97%90%EC%84%9C-javascript-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0-25837f61f551&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/07/01/OUYA77/Chrome_part1/kr/TypeConfusion101.png">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/07/01/ouya77/chrome_part1/en/">

  <title>[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^☆ Part 1.(EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-07-01 17:20" pubdate>
      2025년 7월 1일 오후
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.8k 자
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      55
       분
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^☆ Part 1.(EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Hello, I&#x2019;m OUYA77.</p>
<p>You might be surprised to suddenly see Chrome appear out of nowhere. Honestly, I was just as surprised myself.</p>
<p>I never expected to dive into Chrome, but I happened to watch a conference video by chance, and thought, &#x201C;Wow, this is actually fun.&#x201D; So without much thought, I started studying it. (<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.youtube.com/watch?v=RL2po1swXO4">Link</a>)</p>
<p><img src="image.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>I don&#x2019;t have any grand ambitions like hunting for zero-days or making money through bug bounty programs. It&#x2019;s really just that&#x2014;I found it interesting and wanted to learn more. While digging into Chrome vulnerability research, I kept encountering the term <strong>Type Confusion</strong>. Naturally, I got curious: what exactly <em>is</em> Type Confusion?</p>
<p>I browsed through various blog posts online, but since I had zero background in JavaScript or web stuff, most of it went way over my head. Still, I pushed through and eventually realized, &#x201C;Ah, <em>this</em> is how Type Confusion happens&#x2014;and <em>this</em> is how it&#x2019;s exploited.&#x201D;</p>
<p>I started thinking about how I could make my learning process more productive and meaningful. Then I thought of this: If I could explain Type Confusion&#x2014;a foundational concept in Chrome exploitation&#x2014;in a way that&#x2019;s approachable for beginners like myself, wouldn&#x2019;t that be a meaningful contribution already?</p>
<p>So&#x2026; here it is!!!!</p>
<p><img src="TypeConfusion101.png" srcset="/img/loading.gif" alt="TypeConfusion101.png"></p>
<p>Let&#x2019;s take a look at what Type Confusion actually is, why it occurs in Chrome, and what we can do with it! </p>
<p>To be honest, I&#x2019;ve already dropped a few spoilers about Type Confusion here and there&#x2014;couldn&#x2019;t help myself. &#x1F605; In fact, I even wrote a short piece introducing Type Confusion in our hacking team&#x2019;s newsletter:</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://maily.so/hackyboiz/posts/1gz2v4jxr3q">https://maily.so/hackyboiz/posts/1gz2v4jxr3q</a></p>
<p>&#x314B;&#x314B;&#x314B;&#x314B;&#x314B;&#x314B;&#x314B;^^</p>
<p>I&#x2019;m planning for this &#x201C;Type Confusion 101 in Chrome&#x201D; series to be a four-part journey&#x2014;but hey, life never goes as planned, and that&#x2019;s what makes it fun, right? Let&#x2019;s see how far we get together! &#x1F604;</p>
<p>Today, we&#x2019;re starting with the basics.</p>
<p>You probably already know what Chrome is, but let&#x2019;s briefly go over it&#x2014;along with V8, the component where Type Confusion typically happens.</p>
<p><img src="image%201.png" srcset="/img/loading.gif" alt="image.png"></p>
<h2 id="1-Overview-of-Chrome&#x2019;s-Architecture"><a href="#1-Overview-of-Chrome&#x2019;s-Architecture" class="headerlink" title="1. Overview of Chrome&#x2019;s Architecture"></a>1. Overview of Chrome&#x2019;s Architecture</h2><h3 id="1-1-Multi-process-Architecture"><a href="#1-1-Multi-process-Architecture" class="headerlink" title="1.1 Multi-process Architecture"></a>1.1 Multi-process Architecture</h3><p>When you double-click the Chrome icon, it may seem like you&#x2019;re launching a single program&#x2014;but in reality, Chrome is composed of multiple processes that communicate via IPC. (If you&#x2019;re curious about IPC, check this out &#x2192; <a href="https://hackyboiz.github.io/2025/05/12/ogu123/NamedPipe/EN/"><strong>[Research] Windows Named Pipe (EN)</strong></a> )</p>
<p><img src="image%202.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>ref. <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.chrome.com/blog/inside-browser-part1">https://developer.chrome.com/blog/inside-browser-part1</a></p>
<p>Let&#x2019;s briefly explore the core processes involved.</p>
<ul>
<li>The <strong>Browser Process</strong> is responsible for the user interface (UI) of Chrome&#x2014;what you see every day: tabs, address bar, bookmarks, and so on. It&#x2019;s essentially the first thing you interact with when Chrome starts.</li>
<li>The <strong>Renderer Process</strong> handles the actual rendering of web content. It interprets HTML, CSS, and JavaScript and transforms them into the visual web pages we see.</li>
<li>The <strong>GPU Process</strong> takes care of graphics-related tasks, offloading work from the CPU for better performance.</li>
<li>There are also other specialized processes like <strong>Utility</strong>, <strong>Network</strong>, and <strong>Extension Processes</strong> that handle things such as network communication or running Chrome extensions.</li>
</ul>
<p>Together, these modular processes make up Chrome&#x2019;s <strong>multi-process architecture</strong>&#x2014;a system where each component runs independently but collaborates to form a cohesive user experience.</p>
<p>Why all this complexity? The main reasons are <strong>security</strong> and <strong>stability</strong>.</p>
<p>Each process is <strong>isolated</strong> from the others. So even if something crashes the whole browser doesn&#x2019;t go down with it. For example, if a bug causes the Renderer Process to crash, the Browser Process can still display a message like &#x201C;This page has become unresponsive&#x201D; instead of crashing the entire application.</p>
<p><img src="image%203.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>This concept of <strong>isolation</strong> is at the heart of Chrome&#x2019;s <strong>sandboxing security model</strong>. (More on sandboxing in the next post!)</p>
<h3 id="1-2-How-Chrome-Handles-Front-End-Resources"><a href="#1-2-How-Chrome-Handles-Front-End-Resources" class="headerlink" title="1.2 How Chrome Handles Front-End Resources"></a>1.2 How Chrome Handles Front-End Resources</h3><p><img src="image%204.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Chrome processes various front-end resources&#x2014;such as HTML, CSS, and JavaScript files&#x2014;to render web pages. Even during that brief moment when you open a new tab and load a website, the underlying multi-process system is already working hard behind the scenes.</p>
<p>It all starts when Chrome fetches the <strong>HTML document</strong> from the server and begins parsing it. As it encounters <code>&lt;link&gt;</code> and <code>&lt;script&gt;</code> tags, it then requests additional <strong>CSS</strong> and <strong>JavaScript</strong> files. Each resource plays a specific role:</p>
<ul>
<li><strong>HTML</strong> defines the structural skeleton of the page.</li>
<li><strong>CSS</strong> adds styling&#x2014;colors, layouts, fonts&#x2014;to shape the page&#x2019;s appearance.</li>
<li><strong>JavaScript</strong> brings the page to life, enabling dynamic behavior, user interaction, animations, and logic.</li>
</ul>
<p>JavaScript is particularly interesting because it&#x2019;s <strong>dynamically typed</strong> and can <strong>create or modify objects on the fly</strong>. While this makes web development incredibly flexible, it also adds complexity to how browsers execute and manage this code.</p>
<p><img src="image%205.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>Enter the <strong>V8 JavaScript engine</strong> designed to process JavaScript quickly and efficiently. All of this happens inside the <strong>Renderer Process</strong>, a dedicated and isolated environment for executing front-end code.</p>
<p>Let&#x2019;s dive deeper into what the Renderer Process actually does!</p>
<h2 id="2-About-Render-Process"><a href="#2-About-Render-Process" class="headerlink" title="2. About Render Process"></a>2. About Render Process</h2><p>Everything involved in visually displaying and making a web page interactive happens inside the <strong>Renderer Process</strong>. Each tab in Chrome is handled by its own renderer, and within that process, the entire rendering pipeline takes place: HTML parsing, CSS application, DOM construction, JavaScript execution, layout calculation, painting, and compositing.</p>
<p><img src="image%206.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>JavaScript is a very flexible language that allows types to change during execution and object structures to be modified dynamically. While this makes development powerful, it also introduces risks such as memory corruption and vulnerabilities like <strong>Type Confusion</strong>. To reduce these risks, Chrome isolates JavaScript execution inside separate Renderer Processes. Even if something goes wrong in one tab, only that specific process needs to be terminated, without affecting other tabs or the browser as a whole.</p>
<p>Let&#x2019;s now take a look at how JavaScript is executed inside the renderer.</p>
<h3 id="2-1-From-Blink-to-V8"><a href="#2-1-From-Blink-to-V8" class="headerlink" title="2.1 From Blink to V8"></a><strong>2.1 From Blink to V8</strong></h3><p>In Chrome&#x2019;s rendering pipeline, the <strong>Blink engine</strong> is responsible for parsing HTML and rendering the visual structure of the page, while the <strong>V8 engine</strong> is responsible for executing JavaScript. These two engines work closely together to create a fully functional web experience.</p>
<p>Now, let&#x2019;s take a look at how control flows from Blink to V8.</p>
<p><strong>&#x2460; When a <code>&lt;script&gt;</code> tag is encountered</strong></p>
<p>While Blink is parsing HTML, if it comes across a <code>&lt;script&gt;</code> tag, it begins to stream the corresponding JavaScript file. The streamed JS code is passed to the V8 engine as a string. From this point on, V8 takes over the execution flow.</p>
<p><img src="image%207.png" srcset="/img/loading.gif" alt="image.png"></p>
<hr>
<p><strong>&#x2461; Scanner: Converting the string into tokens</strong></p>
<p>Inside V8, the first component to process the UTF-16 JavaScript string received from Blink is the <strong>scanner</strong>. The scanner breaks down the string into meaningful tokens based on JavaScript grammar. For example, <code>function</code>, <code>if</code>, <code>=</code>, <code>123</code>, and <code>&apos;hello&apos;</code> are all separate tokens. These tokens are then passed on to the parser.</p>
<p><img src="image%208.png" srcset="/img/loading.gif" alt="image.png"></p>
<hr>
<p><strong>&#x2462; Parser: Building the AST</strong></p>
<p>The <strong>parser</strong> analyzes the tokens and constructs an Abstract Syntax Tree (AST) that represents the structure and semantics of the code. Since this involves compiler theory, we&#x2019;ll skip the deep details for now.</p>
<p><img src="image%209.png" srcset="/img/loading.gif" alt="image.png"></p>
<hr>
<p><strong>&#x2463; Ignition: Converting to bytecode</strong></p>
<p>The AST is handed off to <strong>Ignition</strong>, V8&#x2019;s interpreter. Ignition walks through the AST and translates the JavaScript into <strong>bytecode</strong>, a lower-level representation optimized for fast execution within V8. This bytecode sits at a level of abstraction between source code and machine code.</p>
<p><img src="image%2010.png" srcset="/img/loading.gif" alt="image.png"></p>
<hr>
<p><strong>&#x2464; Execution!</strong></p>
<p>Finally, the generated bytecode is executed sequentially by the <strong>Ignition interpreter</strong>. At this stage, the JavaScript code we wrote actually runs&#x2014;registering event listeners, modifying the DOM, animating elements, and more. While executing, V8 monitors code behavior. If certain functions are called frequently or specific code paths are executed often, V8 activates its optimizing compiler, <strong>TurboFan</strong>, to generate <strong>Just-In-Time (JIT)</strong> compiled native machine code. This results in a significant performance boost.</p>
<p>Now that we&#x2019;ve seen the full JavaScript execution process, let&#x2019;s take a deeper look into the <strong>internal structure of the V8 engine</strong> that powers it.</p>
<h3 id="2-2-Introduction-to-the-V8-Engine"><a href="#2-2-Introduction-to-the-V8-Engine" class="headerlink" title="2.2 Introduction to the V8 Engine"></a><strong>2.2 Introduction to the V8 Engine</strong></h3><p><img src="image%2011.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>.</p>
<p>The name &#x201C;V8&#x201D; was inspired by high-performance car engines. The Chrome team chose this name to reflect their hope that their JavaScript engine would be just as fast and powerful. And in reality, V8 is far more than a simple interpreter&#x2014;it&#x2019;s a complex and highly optimized execution engine that combines multiple tiers of performance techniques.</p>
<p>As mentioned earlier, JavaScript is a <strong>dynamically typed language</strong>, meaning the types of variables and object structures are not known until runtime. This provides great flexibility for developers, but it also presents serious challenges for performance and security in the engine. To address these, V8 adopts a <strong>multi-phase execution pipeline</strong>.</p>
<p>Initially, V8 used <strong>Crankshaft</strong>, a JIT compiler that compiled JavaScript straight to machine code without interpreting it first. However, this approach had limitations:</p>
<ul>
<li>Attempting to optimize all code resulted in <strong>high memory usage</strong> and <strong>slow startup times</strong>.</li>
<li>Due to JavaScript&#x2019;s dynamic nature, <strong>deoptimizations</strong> were frequent and costly.</li>
<li>Supporting newer ECMAScript features was becoming increasingly difficult, making Crankshaft <strong>hard to maintain</strong>.</li>
</ul>
<p>As a result, the V8 team designed a new compiler architecture: <strong>TurboFan</strong>.</p>
<p><img src="image%2012.png" srcset="/img/loading.gif" alt="image.png"></p>
<p><strong>TurboFan (since v5.9)</strong></p>
<p>TurboFan replaced Crankshaft as V8&#x2019;s new optimizing compiler. It was built with the following goals:</p>
<ul>
<li>Full support for the modern JavaScript language spec</li>
<li>A robust optimization pipeline centered on intermediate representations (IR)</li>
<li>High portability and scalability across various platforms and architectures</li>
</ul>
<p>While TurboFan delivered powerful optimizations, it still had a drawback&#x2014;it took time to kick in. For short-lived scripts that run briefly (which is common on the web), the benefits often didn&#x2019;t justify the cost.</p>
<p><strong>SparkPlug (introduced in 2021)</strong></p>
<p>To bridge this gap, the V8 team introduced <strong>SparkPlug</strong>, a lightweight JIT compiler designed for quick compilation. SparkPlug aimed to:</p>
<ul>
<li>Compile from bytecode that had already been parsed and interpreted</li>
<li>Skip deep type analysis and complex optimizations in favor of <strong>speed</strong></li>
<li>Generate machine code faster than TurboFan, albeit less optimized</li>
</ul>
<p>SparkPlug offered a significant boost during the early execution stages&#x2014;particularly helpful for page loading and initial user interactions.</p>
<p><strong>Maglev (2022 and onward)</strong></p>
<p>While SparkPlug worked well, its optimizations were still limited. The V8 team wanted something <strong>faster than TurboFan</strong> and <strong>smarter than SparkPlug</strong>, especially for resource-constrained environments like mobile. Enter <strong>Maglev</strong>.</p>
<p>Maglev was designed to:</p>
<ul>
<li>Generate register-based machine code more aggressively than SparkPlug</li>
<li>Incorporate lightweight type feedback to improve performance</li>
<li>Match SparkPlug&#x2019;s compile speed while approaching TurboFan-level performance at runtime</li>
</ul>
<p>Maglev is especially useful for devices with limited resources and helps strike a balance between speed and optimization.</p>
<p>Today, V8 uses a <strong>tiered execution model</strong> that progresses through multiple stages based on code &#x201C;hotness&#x201D;:</p>
<p><strong>Ignition &#x2192; Maglev &#x2192; TurboFan</strong>. This dynamic system allows V8 to adjust the level of optimization depending on how frequently the code is executed.</p>
<h3 id="2-3-The-V8-Execution-Pipeline"><a href="#2-3-The-V8-Execution-Pipeline" class="headerlink" title="2.3 The V8 Execution Pipeline"></a>2.3 The V8 Execution Pipeline</h3><p>Based on what we&#x2019;ve discussed so far, let&#x2019;s summarize how V8&#x2019;s execution pipeline works.</p>
<p><img src="image%2013.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>At the heart of V8&#x2019;s pipeline is the <strong>Ignition interpreter</strong>. It converts JavaScript source code into bytecode and begins executing it sequentially while collecting runtime feedback. Ignition was designed for <strong>fast startup and low memory consumption</strong>, and replaced the older Full-codegen system in Chrome v5.9. However, interpreters alone can&#x2019;t offer high performance, so once certain parts of the code become &#x201C;hot&#x201D; (frequently executed), they are promoted to the next stage for Just-In-Time (JIT) compilation.</p>
<p>That&#x2019;s where <strong>SparkPlug</strong> comes in. SparkPlug compiles bytecode into <strong>native machine code quickly</strong>, without performing deep type analysis or applying complex optimizations. This makes it ideal for scenarios where <strong>fast, lightweight performance is required</strong>, such as during page loading or initial user interactions. It&#x2019;s efficient in both speed and resource usage, acting as a smart middle ground between interpretation and full optimization.</p>
<p>When higher performance is needed, V8 turns to its full optimizing compiler, <strong>TurboFan</strong>. TurboFan uses the <strong>type feedback, call patterns, and loop structures</strong> collected during earlier execution to apply advanced optimizations&#x2014;such as inlining, loop unrolling, and type specialization. The result is <strong>highly optimized native code</strong> that performs similarly to code in statically typed languages. Since optimized code is cached, subsequent calls execute very quickly, making TurboFan particularly effective for hot, long-running code paths.</p>
<p>However, TurboFan comes with a cost. Compilation can be expensive, and failed optimizations (deopts) can hurt performance. To bridge the gap between SparkPlug and TurboFan, V8 introduced <strong>Maglev</strong>.</p>
<p><strong>Maglev</strong> is a <strong>mid-tier JIT compiler</strong> designed to balance <strong>optimization quality and compilation speed</strong>. It generates more efficient register-based machine code than SparkPlug and incorporates some degree of type feedback, but without the heavy compilation cost of TurboFan. Introduced gradually starting in 2022, Maglev performs particularly well on <strong>resource-constrained environments like mobile devices</strong> and provides a flexible middle layer that adapts to various runtime scenarios.</p>
<p><img src="image%2014.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>To summarize, V8 doesn&#x2019;t rely on a single compiler strategy. Instead, it uses a <strong>tiered execution pipeline</strong> that dynamically escalates optimization based on how frequently code is executed. This means it doesn&#x2019;t waste resources upfront, but rather <strong>invests incrementally</strong> to achieve better performance over time.</p>
<hr>
<p>Thanks to this layered approach, V8 can successfully balance <strong>fast startup, low memory usage, and high execution performance</strong>&#x2014;all at once.</p>
<p><img src="image%2015.png" srcset="/img/loading.gif" alt="image.png"></p>
<p>However, this sophisticated execution pipeline also introduces potential <strong>security vulnerabilities</strong>. Most of V8&#x2019;s optimizations rely on assumptions such as:</p>
<blockquote>
<p><em>&#x201C;This object will continue to have the same structure,&#x201D;</em> or <em>&#x201C;This function will always be called in the same way.&#x201D;</em></p>
</blockquote>
<p>But when these assumptions are broken, V8 ends up performing <strong>memory access or object interpretation based on incorrect premises</strong>, and this is where one of the most common vulnerabilities, <strong>Type Confusion</strong>, can occur.</p>
<p><strong>Type Confusion</strong>, as the name suggests, happens when the engine makes incorrect inferences about the type of an object or value. It may also occur when the type changes, but the engine continues to treat it as if it hasn&#x2019;t. For example, suppose an object starts off as a simple array of integers. If, during runtime, it becomes an array of complex objects but V8 still assumes it&#x2019;s just an integer array and runs optimized code based on that assumption, it could result in <strong>invalid memory access or corruption of internal structures</strong>.</p>
<p>These issues tend to happen more often during advanced optimizations performed by <strong>TurboFan</strong> or <strong>Maglev</strong>. Techniques like type specialization, function inlining, and hidden class assumptions can lock in certain behaviors to boost performance. However, if the code path changes or an object&#x2019;s structure is altered afterward, these optimizations can become dangerous. For instance, an attacker might repeatedly call a function in a consistent way to convince the engine it&#x2019;s safe to optimize. Then, at a specific moment, they intentionally alter the object&#x2019;s type or structure, which triggers unexpected behavior in the native code that V8 already compiled. This technique has been used in several real-world Chrome exploits, and <strong>Type Confusion vulnerabilities in V8 are still considered high-risk attack vectors today</strong>.</p>
<p>Now that we&#x2019;ve walked through how JavaScript runs inside V8, the next step is to look deeper into how the engine represents and optimizes objects internally, and how this design can lead to security issues like Type Confusion.</p>
<p>Let&#x2019;s take a breath here.</p>
<p>I&#x2019;ll be back with <strong>Part 2</strong> of the series. See you soon!</p>
<ul>
<li>UP Next: Part2)</li>
</ul>
<p><img src="image%2016.png" srcset="/img/loading.gif" alt="image.png"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>v <strong>Conference Video</strong></p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.youtube.com/watch?v=RL2po1swXO4">https://www.youtube.com/watch?v=RL2po1swXO4</a></li>
</ul>
<p>v <strong>V8 Engine</strong></p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://v8.dev/">https://v8.dev/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine">https://en.wikipedia.org/wiki/V8_(JavaScript_engine</a>)</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://evan-moon.github.io/2019/06/28/v8-analysis/">https://evan-moon.github.io/2019/06/28/v8-analysis/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.bitsrc.io/secret-behind-javascript-performance-v8-hidden-classes-ba4d0ebfb89d">https://blog.bitsrc.io/secret-behind-javascript-performance-v8-hidden-classes-ba4d0ebfb89d</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/@yanguly/sparkplug-v8-baseline-javascript-compiler-758a7bc96e84">https://medium.com/@yanguly/sparkplug-v8-baseline-javascript-compiler-758a7bc96e84</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://pks2974.medium.com/v8-%EC%97%90%EC%84%9C-javascript-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0-25837f61f551">https://pks2974.medium.com/v8-%EC%97%90%EC%84%9C-javascript-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0-25837f61f551</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/OUYA77/">OUYA77</a>
                  
                  <a class="hover-with-bg" href="/tags/Type-Confusion/">Type Confusion</a>
                  
                  <a class="hover-with-bg" href="/tags/Type-Confusion-101/">Type Confusion 101</a>
                  
                  <a class="hover-with-bg" href="/tags/Chrome/">Chrome</a>
                  
                  <a class="hover-with-bg" href="/tags/Chromium/">Chromium</a>
                  
                  <a class="hover-with-bg" href="/tags/Chrome-internal/">Chrome internal</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_OUYA77.jpg" srcset="/img/loading.gif" alt="OUYA77">
                  </div>

                  <div class="link-text">
                    <div class="link-title">OUYA77</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/OUYA77">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">본 글은 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a> 라이선스로 배포됩니다. 공유 또는 변경 시 반드시 출처를 남겨주시기 바랍니다.</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/07/01/OUYA77/Chrome_part1/kr/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[Research] Type Confusion 101으로 시작하는 Chrome Exploit ^-^☆Part 1.(KR)</span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/06/28/bekim/2025-06-28/">
                    <span class="hidden-mobile">[하루한줄] CVE‑2025‑32433: Erlang/OTP SSH의 Pre-auth RCE 취약점</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/07/01/OUYA77/Chrome_part1/en/';
        this.page.identifier = '/2025/07/01/OUYA77/Chrome_part1/en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] Starting Chrome Exploitation with Type Confusion 101 ^-^☆ Part 1.(EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
