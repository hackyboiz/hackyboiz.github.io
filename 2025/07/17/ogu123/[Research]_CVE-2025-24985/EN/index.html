

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;h2 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/1.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Hello, this is ogu123!&lt;/p&gt;
&lt;p&gt;I&amp;#x2019;ve been studying 1-day vulnerabilities through the publicly available resources, and I wanted to write my first vulnerability analysis post, so I prepared this one &lt;del&gt;(I don&amp;#x2019;t know if I&amp;#x2019;ll do it in the future, lol)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;I tried to write the analysis process in detail, and there is also a BSOD PoC, so I recommend you to practice it!&lt;/p&gt;
&lt;p&gt;So let&amp;#x2019;s get started!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/2.png&#34; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2025-24985&#34;&gt;https://nvd.nist.gov/vuln/detail/CVE-2025-24985&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once we look at the vulnerability in NVD, we can see that it&amp;#x2019;s an RCE vulnerability due to an Integer overflow in the Windows Fast FAT file system driver.&lt;/p&gt;
&lt;p&gt;Now that we have a hint that it&amp;#x2019;s an Integer overflow, let&amp;#x2019;s start diffing!&lt;/p&gt;
&lt;h2 id=&#34;Analytics-environment&#34;&gt;&lt;a href=&#34;#Analytics-environment&#34; class=&#34;headerlink&#34; title=&#34;Analytics environment&#34;&gt;&lt;/a&gt;Analytics environment&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Windows 10 version 22H2 19045.5854 for x64-based Systems education&lt;ul&gt;
&lt;li&gt;Version before the vulnerability was patched: fastfat.sys 10.0.19041.5438 (KB5051974)&lt;/li&gt;
&lt;li&gt;Version after vulnerability patch: fastfat.sys 10.0.19041.5607 (KB5053606)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Patch-Analysis-Before-vs-After&#34;&gt;&lt;a href=&#34;#Patch-Analysis-Before-vs-After&#34; class=&#34;headerlink&#34; title=&#34;Patch Analysis - Before vs After&#34;&gt;&lt;/a&gt;Patch Analysis - Before vs After&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Looking at the bindiff results, we can see that the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; and &lt;code&gt;FatExamineFatEntries()&lt;/code&gt; functions have changed after the patch. &lt;del&gt;(That&amp;#x2019;s only two changes ^^)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s compare the pre- and post-patch binaries to see what code changes were made to each function!&lt;/p&gt;
&lt;h3 id=&#34;FatSetupAllocationSupport&#34;&gt;&lt;a href=&#34;#FatSetupAllocationSupport&#34; class=&#34;headerlink&#34; title=&#34;FatSetupAllocationSupport()&#34;&gt;&lt;/a&gt;FatSetupAllocationSupport()&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/4.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Above is the patched &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function, which has been changed to the following.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Added code to validate for overflow before performing the operation in the red else statement.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;FatExamineFatEntries&#34;&gt;&lt;a href=&#34;#FatExamineFatEntries&#34; class=&#34;headerlink&#34; title=&#34;FatExamineFatEntries()&#34;&gt;&lt;/a&gt;FatExamineFatEntries()&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/5.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The above is the patched &lt;code&gt;FatExamineFatEntries()&lt;/code&gt; function, which has been changed to the following.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the if statement is true, the value *(a2 + 0x15C) is used as the value of the v47 variable and code has been added to validate overflow on the v47 variable value.&lt;/li&gt;
&lt;li&gt;If the value of V47 + 7 does not overflow, it is then used as the value for the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function Size.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The function call flow is &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; &amp;#x2192; &lt;code&gt;FatExamineFatEntries()&lt;/code&gt;, so we&amp;#x2019;ll analyze the pre-patch binary &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function from the top-down, but we&amp;#x2019;ll focus on the following points in each function!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Values used in operations&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FatExamineFatEntries()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Conditions in an if statement&lt;/li&gt;
&lt;li&gt;Value *(a2 + 0x15C)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Vulnerability-analysis&#34;&gt;&lt;a href=&#34;#Vulnerability-analysis&#34; class=&#34;headerlink&#34; title=&#34;Vulnerability analysis&#34;&gt;&lt;/a&gt;Vulnerability analysis&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/6.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;First, to analyze the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function, we created a random vhd file as shown below!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;File Name: ogu123.vhd&lt;/li&gt;
&lt;li&gt;Disk size: 1 GB&lt;/li&gt;
&lt;li&gt;Disk format: VHD&lt;/li&gt;
&lt;li&gt;Disk type: Fixed size&lt;/li&gt;
&lt;li&gt;Partition format: MBR&lt;/li&gt;
&lt;li&gt;Partition System: FAT32&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before analyzing, you can refer to the following article to learn how to set up kernel debugging! (shout out L0ch!)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hackyboiz.github.io/2021/05/30/l0ch/windows-driver/&#34;&gt;https://hackyboiz.github.io/2021/05/30/l0ch/windows-driver/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/7.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;After setting up Kernel debugging, we can set a break point in the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function and mount the ogu123.vhd file we created earlier, and we can start analyzing!&lt;/p&gt;
&lt;p&gt;After analyzing, we see the value inside the else statement as shown above.&lt;/p&gt;
&lt;p&gt;In the previously patched binary, code was added to check for overflows before computing, so we checked the vhd file thinking that it was a value that the user could control.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/8.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;I checked the vhd file and found that the else statement is using a value that exists within drive - boot_sector!&lt;/p&gt;
&lt;p&gt;The tip here is to set it to Drive and not VHD in 010 editor Templates so you can see the picture above.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/9.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Match the values in the vhd file to the variables to see what it looks like. &lt;del&gt;(It&amp;#x2019;s colorful)&lt;/del&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;V15 = (NumberOfSector32 - NumberOfFatTables * SectorsPerFat32 - ReservedSectors) /&lt;br&gt;SectorsPerCluster&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you look at the operation, you can see that it&amp;#x2019;s counting the number of clusters on a FAT file system!&lt;/p&gt;
&lt;p&gt;To summarize so far, after the patch, we saw that in the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function, code was added to validate the value used in the cluster count computation for overflow, and although not shown in the figure, it stores the number of clusters in &lt;strong&gt;*(a2 + 0x15C)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Later, in the &lt;code&gt;FatExamineFatEntries()&lt;/code&gt; function, in order to use &lt;strong&gt;the number of clusters (*(a2 + 0x15C))&lt;/strong&gt; as the size value in the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function, we first need to make sure that the if (&lt;em&gt;(a2 + 0xC8) &amp;lt;= 1u) statement is true, so let&amp;#x2019;s trace the value &lt;/em&gt;(a2 + 0xC8)!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/10.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;After analyzing, we found that the if (*(a2 + 0xC8) &amp;lt;= 1u) inside the &lt;code&gt;FatExamineFatEntries()&lt;/code&gt; function is checked first in the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;In order for the if ((a2 + 0xC8) &amp;lt;= 1u) statement to be true, we need to use the v35 variable in the if((a2 + 0x168) &amp;#x2026; v34 &amp;gt; 0x10000) statement or go into the else statement.&lt;/p&gt;
&lt;p&gt;In this case, the value of (a2 + 0x168) must be 0x20 to enter the cluster computation process and since the v34 variable is the number of clusters ((a2 + 0x15c)), we controlled the value of *(a2 + 0xC8) with the v35 variable.&lt;/p&gt;
&lt;p&gt;Once I modified the &lt;strong&gt;cluster count to a value of 0xFFFFFFFB&lt;/strong&gt;, I went through the process below to make it true in the if (*(a2 + 0xC8) &amp;lt;= 1u) statement.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v35 = (0xFFFFFFFB + 0xFFFF) = 0xFFFA&lt;/li&gt;
&lt;li&gt;(*(a2 + 0xC8) = 0xFFFA &amp;gt;&amp;gt; 0x10 = 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/11.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;After modifying the vhd file as above, the cluster count will have a value of 0xFFFFFFFB after the following operation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;V15 = (NumberOfSector32 - NumberOfFatTables * SectorsPerFat32 - ReservedSectors) /&lt;br&gt;SectorsPerCluster&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0xFFFFFFFB&lt;/strong&gt; = ( 0xFFFFFFFF - 0x2 * 0x80000000 - 0x4 ) / 0x1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/12.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;When you run the modified vhd file, you can see that the overflow within if(&lt;em&gt;(a2 + 0x168) &amp;#x2026; v34 &amp;gt; 0x10000) causes the value of &lt;/em&gt;(a2 + 0xC8) to be zero, making the if statement true and using the NumberOfClusters (0xfffffffb) as the value of the NumberOfClusters variable.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/13.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Then, while computing the value of Size in the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function, (NumberOfClusters +7), an overflow occurs, resulting in the value of rdx to be 0x2, and the value of Size finally becomes 0x0 when computing &amp;gt;&amp;gt; 3.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/14.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;This shows the block information of the memory pool page after running the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;You can see that even if the Size value of the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function is 0x0, a Size of 0x20 is allocated to the paged pool.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/15.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The allocated region is then initialized as a bitmap with the &lt;code&gt;RtlInitializeBitMap()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;You can see that the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; and &lt;code&gt;RtlInitializeBitMap()&lt;/code&gt; functions map one bit per cluster.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;){ 
  [...]   
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( !v29 &amp;amp;&amp;amp; v32 )                          &lt;span class=&#34;hljs-comment&#34;&gt;// free -&amp;gt; used &lt;/span&gt;
    { 
      v38 = v7 - v30; 
      &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v14 ) 
      { 
        *v14 += v38; 
        v10[&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;] += v38; 
        v17 = v45; 
      } 
      &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( p_BitMapHeader ) 
      { 
        RtlClearBits(p_BitMapHeader, v30 - v69, v38); 
        v17 = v45; 
        v32 = v68; 
        v28 = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; 
      } 
      v29 = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; 
      v48 = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; 
      v30 = v7; 
      v51 = v7; 
    } 
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v29 == &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; !v32 )                     &lt;span class=&#34;hljs-comment&#34;&gt;// used -&amp;gt; free &lt;/span&gt;
    { 
      &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( p_BitMapHeader ) 
      { 
        RtlSetBits(p_BitMapHeader, v30 - v69, v7 - v30); 
        v17 = v45; 
        v28 = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; 
      } 
      v29 = v28; 
      v48 = v28; 
      v30 = v7; 
      v51 = v7; 
    } 
  [...]   
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the bitmap initialization, the while statement above detects the change of state of the cluster (free -&amp;gt; used, used -&amp;gt;free) within the vhd file and writes it to the bitmap.&lt;/p&gt;
&lt;p&gt;We modify the bitmap using the &lt;code&gt;RtlClearBits()&lt;/code&gt; and &lt;code&gt;RtlSetBits()&lt;/code&gt; functions, and we can see that this manages the cluster allocation status.&lt;/p&gt;
&lt;p&gt;The while statement runs as many times as the number of clusters (0xfffffffb) to write the bitmap data, Since the bitmap size allocated via the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function is 0x20, the allocated pool area exceeds, causing a kernel pool overflow.&lt;/p&gt;
&lt;h2 id=&#34;BSOD-Triggers&#34;&gt;&lt;a href=&#34;#BSOD-Triggers&#34; class=&#34;headerlink&#34; title=&#34;BSOD Triggers&#34;&gt;&lt;/a&gt;BSOD Triggers&lt;/h2&gt;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/6ppD0oRZhXU?si=NEvYSd5jf0NMaObw&#34; title=&#34;YouTube video player&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&#34; referrerpolicy=&#34;strict-origin-when-cross-origin&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;If you run the vhd file with the cluster count 0xfffffffb, you can see that the while statement causes an Access Violation due to a kernel pool overflow, resulting in a BSOD. &lt;del&gt;(I had a hard time editing the video&amp;#x2026;^^)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Earlier, we said that the cluster&amp;#x2019;s state change (free -&amp;gt; used, used -&amp;gt;free) is recorded in the bitmap. Yes! Since the user can also control the cluster&amp;#x2019;s state, it is possible to write arbitrary data to the bitmap.&lt;/p&gt;
&lt;h2 id=&#34;Exploit&#34;&gt;&lt;a href=&#34;#Exploit&#34; class=&#34;headerlink&#34; title=&#34;Exploit&#34;&gt;&lt;/a&gt;Exploit&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/16.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Here we are starting over with the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function to analyze the while statement that records the bitmap data.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/17.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Size value overflowed and was allocated to address ffff990e`b8a58c50 by 0x20.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/18.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;This part is the process of calculating the offset of the clusters present in the VHD file within the while statement.&lt;/p&gt;
&lt;p&gt;Since the while statement checks the status information of cluster 2 first, the FAT offset (in FAT32) of the cluster 2 entry can be obtained by the following operation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FAT Entry Offset = BytesPerSector x ReservedSectors + (cluster number &amp;#xD7; 4)&lt;/li&gt;
&lt;li&gt;FAT Entry Offset = 0x200 X 0x4 + ( 0x2 X 0x4 ) = 0x808&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/19.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If we add the FAT Entry Offset to the Partition Start Offset (0x10000), we get the vhd file 0x10808 offset.&lt;br&gt;The 0x10808 offset will be the offset of cluster number 2, which is the first cluster we check for status information in the while statement.&lt;/p&gt;
&lt;p&gt;The bitmap area (ffff990eb8a58c50) allocated earlier with the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function, where 1 bit indicates the status of cluster 1.&lt;br&gt;If the 4-byte value of the cluster in the vhd file is 0x00000000, we consider it free and write the corresponding bit in the bitmap to 0x0, and if it is 0x11111111, we consider it used and write it to 0x1.&lt;/p&gt;
&lt;p&gt;So, when we processed 8 cluster values in the while statement, we modified the bitmap to have a value of 0x41, starting with cluster state value 2, as shown above.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/20.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;With the modified vhd file, the while statement works like this&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Currently processed cluster state used, previous cluster state free&lt;ul&gt;
&lt;li&gt;Write bits to 0x0 for the number of previously free clusters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Currently processed cluster state FREE, previous cluster state USED&lt;ul&gt;
&lt;li&gt;Write bit as 0x1 for the number of clusters previously used&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, since the modified vhd file is 0100 0001, we can see that 0x41 is written.&lt;/p&gt;
&lt;p&gt;Now that we have proof of writing arbitrary data to the kernel pool area,&amp;#x2026;we can spray the kernel structures that are allocated in the paged pool and blah blah blah and trigger an RCE!&lt;/p&gt;
&lt;h2 id=&#34;Conclusion&#34;&gt;&lt;a href=&#34;#Conclusion&#34; class=&#34;headerlink&#34; title=&#34;Conclusion&#34;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;I learned a lot about kernel drive analysis, delta patching, etc. while writing this research article, and I think the most memorable part was studying kernel paged pool to try full exploit!&lt;/p&gt;
&lt;p&gt;If&amp;#x2026; I succeed in full exploit, I&amp;#x2019;ll be back with the next article!&lt;/p&gt;
&lt;p&gt;Thank you for reading this long post!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/21.png&#34; alt&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] CVE-2025-24985: Windows Fast FAT Driver RCE Vulnerability (EN) - hackyboiz">
  <meta property="og:description" content="&lt;h2 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/1.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Hello, this is ogu123!&lt;/p&gt;
&lt;p&gt;I&amp;#x2019;ve been studying 1-day vulnerabilities through the publicly available resources, and I wanted to write my first vulnerability analysis post, so I prepared this one &lt;del&gt;(I don&amp;#x2019;t know if I&amp;#x2019;ll do it in the future, lol)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;I tried to write the analysis process in detail, and there is also a BSOD PoC, so I recommend you to practice it!&lt;/p&gt;
&lt;p&gt;So let&amp;#x2019;s get started!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/2.png&#34; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2025-24985&#34;&gt;https://nvd.nist.gov/vuln/detail/CVE-2025-24985&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once we look at the vulnerability in NVD, we can see that it&amp;#x2019;s an RCE vulnerability due to an Integer overflow in the Windows Fast FAT file system driver.&lt;/p&gt;
&lt;p&gt;Now that we have a hint that it&amp;#x2019;s an Integer overflow, let&amp;#x2019;s start diffing!&lt;/p&gt;
&lt;h2 id=&#34;Analytics-environment&#34;&gt;&lt;a href=&#34;#Analytics-environment&#34; class=&#34;headerlink&#34; title=&#34;Analytics environment&#34;&gt;&lt;/a&gt;Analytics environment&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Windows 10 version 22H2 19045.5854 for x64-based Systems education&lt;ul&gt;
&lt;li&gt;Version before the vulnerability was patched: fastfat.sys 10.0.19041.5438 (KB5051974)&lt;/li&gt;
&lt;li&gt;Version after vulnerability patch: fastfat.sys 10.0.19041.5607 (KB5053606)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Patch-Analysis-Before-vs-After&#34;&gt;&lt;a href=&#34;#Patch-Analysis-Before-vs-After&#34; class=&#34;headerlink&#34; title=&#34;Patch Analysis - Before vs After&#34;&gt;&lt;/a&gt;Patch Analysis - Before vs After&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Looking at the bindiff results, we can see that the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; and &lt;code&gt;FatExamineFatEntries()&lt;/code&gt; functions have changed after the patch. &lt;del&gt;(That&amp;#x2019;s only two changes ^^)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s compare the pre- and post-patch binaries to see what code changes were made to each function!&lt;/p&gt;
&lt;h3 id=&#34;FatSetupAllocationSupport&#34;&gt;&lt;a href=&#34;#FatSetupAllocationSupport&#34; class=&#34;headerlink&#34; title=&#34;FatSetupAllocationSupport()&#34;&gt;&lt;/a&gt;FatSetupAllocationSupport()&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/4.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Above is the patched &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function, which has been changed to the following.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Added code to validate for overflow before performing the operation in the red else statement.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;FatExamineFatEntries&#34;&gt;&lt;a href=&#34;#FatExamineFatEntries&#34; class=&#34;headerlink&#34; title=&#34;FatExamineFatEntries()&#34;&gt;&lt;/a&gt;FatExamineFatEntries()&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/5.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The above is the patched &lt;code&gt;FatExamineFatEntries()&lt;/code&gt; function, which has been changed to the following.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the if statement is true, the value *(a2 + 0x15C) is used as the value of the v47 variable and code has been added to validate overflow on the v47 variable value.&lt;/li&gt;
&lt;li&gt;If the value of V47 + 7 does not overflow, it is then used as the value for the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function Size.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The function call flow is &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; &amp;#x2192; &lt;code&gt;FatExamineFatEntries()&lt;/code&gt;, so we&amp;#x2019;ll analyze the pre-patch binary &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function from the top-down, but we&amp;#x2019;ll focus on the following points in each function!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Values used in operations&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FatExamineFatEntries()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Conditions in an if statement&lt;/li&gt;
&lt;li&gt;Value *(a2 + 0x15C)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Vulnerability-analysis&#34;&gt;&lt;a href=&#34;#Vulnerability-analysis&#34; class=&#34;headerlink&#34; title=&#34;Vulnerability analysis&#34;&gt;&lt;/a&gt;Vulnerability analysis&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/6.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;First, to analyze the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function, we created a random vhd file as shown below!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;File Name: ogu123.vhd&lt;/li&gt;
&lt;li&gt;Disk size: 1 GB&lt;/li&gt;
&lt;li&gt;Disk format: VHD&lt;/li&gt;
&lt;li&gt;Disk type: Fixed size&lt;/li&gt;
&lt;li&gt;Partition format: MBR&lt;/li&gt;
&lt;li&gt;Partition System: FAT32&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before analyzing, you can refer to the following article to learn how to set up kernel debugging! (shout out L0ch!)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hackyboiz.github.io/2021/05/30/l0ch/windows-driver/&#34;&gt;https://hackyboiz.github.io/2021/05/30/l0ch/windows-driver/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/7.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;After setting up Kernel debugging, we can set a break point in the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function and mount the ogu123.vhd file we created earlier, and we can start analyzing!&lt;/p&gt;
&lt;p&gt;After analyzing, we see the value inside the else statement as shown above.&lt;/p&gt;
&lt;p&gt;In the previously patched binary, code was added to check for overflows before computing, so we checked the vhd file thinking that it was a value that the user could control.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/8.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;I checked the vhd file and found that the else statement is using a value that exists within drive - boot_sector!&lt;/p&gt;
&lt;p&gt;The tip here is to set it to Drive and not VHD in 010 editor Templates so you can see the picture above.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/9.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Match the values in the vhd file to the variables to see what it looks like. &lt;del&gt;(It&amp;#x2019;s colorful)&lt;/del&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;V15 = (NumberOfSector32 - NumberOfFatTables * SectorsPerFat32 - ReservedSectors) /&lt;br&gt;SectorsPerCluster&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you look at the operation, you can see that it&amp;#x2019;s counting the number of clusters on a FAT file system!&lt;/p&gt;
&lt;p&gt;To summarize so far, after the patch, we saw that in the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function, code was added to validate the value used in the cluster count computation for overflow, and although not shown in the figure, it stores the number of clusters in &lt;strong&gt;*(a2 + 0x15C)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Later, in the &lt;code&gt;FatExamineFatEntries()&lt;/code&gt; function, in order to use &lt;strong&gt;the number of clusters (*(a2 + 0x15C))&lt;/strong&gt; as the size value in the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function, we first need to make sure that the if (&lt;em&gt;(a2 + 0xC8) &amp;lt;= 1u) statement is true, so let&amp;#x2019;s trace the value &lt;/em&gt;(a2 + 0xC8)!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/10.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;After analyzing, we found that the if (*(a2 + 0xC8) &amp;lt;= 1u) inside the &lt;code&gt;FatExamineFatEntries()&lt;/code&gt; function is checked first in the &lt;code&gt;FatSetupAllocationSupport()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;In order for the if ((a2 + 0xC8) &amp;lt;= 1u) statement to be true, we need to use the v35 variable in the if((a2 + 0x168) &amp;#x2026; v34 &amp;gt; 0x10000) statement or go into the else statement.&lt;/p&gt;
&lt;p&gt;In this case, the value of (a2 + 0x168) must be 0x20 to enter the cluster computation process and since the v34 variable is the number of clusters ((a2 + 0x15c)), we controlled the value of *(a2 + 0xC8) with the v35 variable.&lt;/p&gt;
&lt;p&gt;Once I modified the &lt;strong&gt;cluster count to a value of 0xFFFFFFFB&lt;/strong&gt;, I went through the process below to make it true in the if (*(a2 + 0xC8) &amp;lt;= 1u) statement.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v35 = (0xFFFFFFFB + 0xFFFF) = 0xFFFA&lt;/li&gt;
&lt;li&gt;(*(a2 + 0xC8) = 0xFFFA &amp;gt;&amp;gt; 0x10 = 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/11.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;After modifying the vhd file as above, the cluster count will have a value of 0xFFFFFFFB after the following operation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;V15 = (NumberOfSector32 - NumberOfFatTables * SectorsPerFat32 - ReservedSectors) /&lt;br&gt;SectorsPerCluster&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0xFFFFFFFB&lt;/strong&gt; = ( 0xFFFFFFFF - 0x2 * 0x80000000 - 0x4 ) / 0x1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/12.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;When you run the modified vhd file, you can see that the overflow within if(&lt;em&gt;(a2 + 0x168) &amp;#x2026; v34 &amp;gt; 0x10000) causes the value of &lt;/em&gt;(a2 + 0xC8) to be zero, making the if statement true and using the NumberOfClusters (0xfffffffb) as the value of the NumberOfClusters variable.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/13.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Then, while computing the value of Size in the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function, (NumberOfClusters +7), an overflow occurs, resulting in the value of rdx to be 0x2, and the value of Size finally becomes 0x0 when computing &amp;gt;&amp;gt; 3.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/14.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;This shows the block information of the memory pool page after running the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;You can see that even if the Size value of the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function is 0x0, a Size of 0x20 is allocated to the paged pool.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/15.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The allocated region is then initialized as a bitmap with the &lt;code&gt;RtlInitializeBitMap()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;You can see that the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; and &lt;code&gt;RtlInitializeBitMap()&lt;/code&gt; functions map one bit per cluster.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;){ 
  [...]   
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( !v29 &amp;amp;&amp;amp; v32 )                          &lt;span class=&#34;hljs-comment&#34;&gt;// free -&amp;gt; used &lt;/span&gt;
    { 
      v38 = v7 - v30; 
      &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v14 ) 
      { 
        *v14 += v38; 
        v10[&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;] += v38; 
        v17 = v45; 
      } 
      &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( p_BitMapHeader ) 
      { 
        RtlClearBits(p_BitMapHeader, v30 - v69, v38); 
        v17 = v45; 
        v32 = v68; 
        v28 = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; 
      } 
      v29 = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; 
      v48 = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;; 
      v30 = v7; 
      v51 = v7; 
    } 
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( v29 == &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; !v32 )                     &lt;span class=&#34;hljs-comment&#34;&gt;// used -&amp;gt; free &lt;/span&gt;
    { 
      &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; ( p_BitMapHeader ) 
      { 
        RtlSetBits(p_BitMapHeader, v30 - v69, v7 - v30); 
        v17 = v45; 
        v28 = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;; 
      } 
      v29 = v28; 
      v48 = v28; 
      v30 = v7; 
      v51 = v7; 
    } 
  [...]   
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the bitmap initialization, the while statement above detects the change of state of the cluster (free -&amp;gt; used, used -&amp;gt;free) within the vhd file and writes it to the bitmap.&lt;/p&gt;
&lt;p&gt;We modify the bitmap using the &lt;code&gt;RtlClearBits()&lt;/code&gt; and &lt;code&gt;RtlSetBits()&lt;/code&gt; functions, and we can see that this manages the cluster allocation status.&lt;/p&gt;
&lt;p&gt;The while statement runs as many times as the number of clusters (0xfffffffb) to write the bitmap data, Since the bitmap size allocated via the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function is 0x20, the allocated pool area exceeds, causing a kernel pool overflow.&lt;/p&gt;
&lt;h2 id=&#34;BSOD-Triggers&#34;&gt;&lt;a href=&#34;#BSOD-Triggers&#34; class=&#34;headerlink&#34; title=&#34;BSOD Triggers&#34;&gt;&lt;/a&gt;BSOD Triggers&lt;/h2&gt;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/6ppD0oRZhXU?si=NEvYSd5jf0NMaObw&#34; title=&#34;YouTube video player&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&#34; referrerpolicy=&#34;strict-origin-when-cross-origin&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;If you run the vhd file with the cluster count 0xfffffffb, you can see that the while statement causes an Access Violation due to a kernel pool overflow, resulting in a BSOD. &lt;del&gt;(I had a hard time editing the video&amp;#x2026;^^)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Earlier, we said that the cluster&amp;#x2019;s state change (free -&amp;gt; used, used -&amp;gt;free) is recorded in the bitmap. Yes! Since the user can also control the cluster&amp;#x2019;s state, it is possible to write arbitrary data to the bitmap.&lt;/p&gt;
&lt;h2 id=&#34;Exploit&#34;&gt;&lt;a href=&#34;#Exploit&#34; class=&#34;headerlink&#34; title=&#34;Exploit&#34;&gt;&lt;/a&gt;Exploit&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/16.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Here we are starting over with the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function to analyze the while statement that records the bitmap data.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/17.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Size value overflowed and was allocated to address ffff990e`b8a58c50 by 0x20.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/18.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;This part is the process of calculating the offset of the clusters present in the VHD file within the while statement.&lt;/p&gt;
&lt;p&gt;Since the while statement checks the status information of cluster 2 first, the FAT offset (in FAT32) of the cluster 2 entry can be obtained by the following operation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FAT Entry Offset = BytesPerSector x ReservedSectors + (cluster number &amp;#xD7; 4)&lt;/li&gt;
&lt;li&gt;FAT Entry Offset = 0x200 X 0x4 + ( 0x2 X 0x4 ) = 0x808&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/19.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;If we add the FAT Entry Offset to the Partition Start Offset (0x10000), we get the vhd file 0x10808 offset.&lt;br&gt;The 0x10808 offset will be the offset of cluster number 2, which is the first cluster we check for status information in the while statement.&lt;/p&gt;
&lt;p&gt;The bitmap area (ffff990eb8a58c50) allocated earlier with the &lt;code&gt;ExAllocatePoolWithTag()&lt;/code&gt; function, where 1 bit indicates the status of cluster 1.&lt;br&gt;If the 4-byte value of the cluster in the vhd file is 0x00000000, we consider it free and write the corresponding bit in the bitmap to 0x0, and if it is 0x11111111, we consider it used and write it to 0x1.&lt;/p&gt;
&lt;p&gt;So, when we processed 8 cluster values in the while statement, we modified the bitmap to have a value of 0x41, starting with cluster state value 2, as shown above.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/20.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;With the modified vhd file, the while statement works like this&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Currently processed cluster state used, previous cluster state free&lt;ul&gt;
&lt;li&gt;Write bits to 0x0 for the number of previously free clusters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Currently processed cluster state FREE, previous cluster state USED&lt;ul&gt;
&lt;li&gt;Write bit as 0x1 for the number of clusters previously used&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, since the modified vhd file is 0100 0001, we can see that 0x41 is written.&lt;/p&gt;
&lt;p&gt;Now that we have proof of writing arbitrary data to the kernel pool area,&amp;#x2026;we can spray the kernel structures that are allocated in the paged pool and blah blah blah and trigger an RCE!&lt;/p&gt;
&lt;h2 id=&#34;Conclusion&#34;&gt;&lt;a href=&#34;#Conclusion&#34; class=&#34;headerlink&#34; title=&#34;Conclusion&#34;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;I learned a lot about kernel drive analysis, delta patching, etc. while writing this research article, and I think the most memorable part was studying kernel paged pool to try full exploit!&lt;/p&gt;
&lt;p&gt;If&amp;#x2026; I succeed in full exploit, I&amp;#x2019;ll be back with the next article!&lt;/p&gt;
&lt;p&gt;Thank you for reading this long post!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/21.png&#34; alt&gt;&lt;/p&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/1.png">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2025/07/17/ogu123/[research]_cve-2025-24985/en/">

  <title>[Research] CVE-2025-24985: Windows Fast FAT Driver RCE Vulnerability (EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2025-07-17 17:00" pubdate>
      2025년 7월 17일 오후
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      1.7k 자
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      33
       분
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] CVE-2025-24985: Windows Fast FAT Driver RCE Vulnerability (EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/1.png" srcset="/img/loading.gif" alt></p>
<p>Hello, this is ogu123!</p>
<p>I&#x2019;ve been studying 1-day vulnerabilities through the publicly available resources, and I wanted to write my first vulnerability analysis post, so I prepared this one <del>(I don&#x2019;t know if I&#x2019;ll do it in the future, lol)</del></p>
<p>I tried to write the analysis process in detail, and there is also a BSOD PoC, so I recommend you to practice it!</p>
<p>So let&#x2019;s get started!</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/2.png" srcset="/img/loading.gif" alt></p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://nvd.nist.gov/vuln/detail/CVE-2025-24985">https://nvd.nist.gov/vuln/detail/CVE-2025-24985</a></li>
</ul>
<p>Once we look at the vulnerability in NVD, we can see that it&#x2019;s an RCE vulnerability due to an Integer overflow in the Windows Fast FAT file system driver.</p>
<p>Now that we have a hint that it&#x2019;s an Integer overflow, let&#x2019;s start diffing!</p>
<h2 id="Analytics-environment"><a href="#Analytics-environment" class="headerlink" title="Analytics environment"></a>Analytics environment</h2><ul>
<li>Windows 10 version 22H2 19045.5854 for x64-based Systems education<ul>
<li>Version before the vulnerability was patched: fastfat.sys 10.0.19041.5438 (KB5051974)</li>
<li>Version after vulnerability patch: fastfat.sys 10.0.19041.5607 (KB5053606)</li>
</ul>
</li>
</ul>
<h2 id="Patch-Analysis-Before-vs-After"><a href="#Patch-Analysis-Before-vs-After" class="headerlink" title="Patch Analysis - Before vs After"></a>Patch Analysis - Before vs After</h2><p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/3.png" srcset="/img/loading.gif" alt></p>
<p>Looking at the bindiff results, we can see that the <code>FatSetupAllocationSupport()</code> and <code>FatExamineFatEntries()</code> functions have changed after the patch. <del>(That&#x2019;s only two changes ^^)</del></p>
<p>Let&#x2019;s compare the pre- and post-patch binaries to see what code changes were made to each function!</p>
<h3 id="FatSetupAllocationSupport"><a href="#FatSetupAllocationSupport" class="headerlink" title="FatSetupAllocationSupport()"></a>FatSetupAllocationSupport()</h3><p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/4.png" srcset="/img/loading.gif" alt></p>
<p>Above is the patched <code>FatSetupAllocationSupport()</code> function, which has been changed to the following.</p>
<ul>
<li>Added code to validate for overflow before performing the operation in the red else statement.</li>
</ul>
<h3 id="FatExamineFatEntries"><a href="#FatExamineFatEntries" class="headerlink" title="FatExamineFatEntries()"></a>FatExamineFatEntries()</h3><p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/5.png" srcset="/img/loading.gif" alt></p>
<p>The above is the patched <code>FatExamineFatEntries()</code> function, which has been changed to the following.</p>
<ul>
<li>If the if statement is true, the value *(a2 + 0x15C) is used as the value of the v47 variable and code has been added to validate overflow on the v47 variable value.</li>
<li>If the value of V47 + 7 does not overflow, it is then used as the value for the <code>ExAllocatePoolWithTag()</code> function Size.</li>
</ul>
<p>The function call flow is <code>FatSetupAllocationSupport()</code> &#x2192; <code>FatExamineFatEntries()</code>, so we&#x2019;ll analyze the pre-patch binary <code>FatSetupAllocationSupport()</code> function from the top-down, but we&#x2019;ll focus on the following points in each function!</p>
<ul>
<li><code>FatSetupAllocationSupport()</code><ul>
<li>Values used in operations</li>
</ul>
</li>
<li><code>FatExamineFatEntries()</code><ul>
<li>Conditions in an if statement</li>
<li>Value *(a2 + 0x15C)</li>
</ul>
</li>
</ul>
<h2 id="Vulnerability-analysis"><a href="#Vulnerability-analysis" class="headerlink" title="Vulnerability analysis"></a>Vulnerability analysis</h2><p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/6.png" srcset="/img/loading.gif" alt></p>
<p>First, to analyze the <code>FatSetupAllocationSupport()</code> function, we created a random vhd file as shown below!</p>
<ul>
<li>File Name: ogu123.vhd</li>
<li>Disk size: 1 GB</li>
<li>Disk format: VHD</li>
<li>Disk type: Fixed size</li>
<li>Partition format: MBR</li>
<li>Partition System: FAT32</li>
</ul>
<p>Before analyzing, you can refer to the following article to learn how to set up kernel debugging! (shout out L0ch!)</p>
<ul>
<li><a href="https://hackyboiz.github.io/2021/05/30/l0ch/windows-driver/">https://hackyboiz.github.io/2021/05/30/l0ch/windows-driver/</a></li>
</ul>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/7.png" srcset="/img/loading.gif" alt></p>
<p>After setting up Kernel debugging, we can set a break point in the <code>FatSetupAllocationSupport()</code> function and mount the ogu123.vhd file we created earlier, and we can start analyzing!</p>
<p>After analyzing, we see the value inside the else statement as shown above.</p>
<p>In the previously patched binary, code was added to check for overflows before computing, so we checked the vhd file thinking that it was a value that the user could control.</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/8.png" srcset="/img/loading.gif" alt></p>
<p>I checked the vhd file and found that the else statement is using a value that exists within drive - boot_sector!</p>
<p>The tip here is to set it to Drive and not VHD in 010 editor Templates so you can see the picture above.</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/9.png" srcset="/img/loading.gif" alt></p>
<p>Match the values in the vhd file to the variables to see what it looks like. <del>(It&#x2019;s colorful)</del></p>
<ul>
<li>V15 = (NumberOfSector32 - NumberOfFatTables * SectorsPerFat32 - ReservedSectors) /<br>SectorsPerCluster</li>
</ul>
<p>If you look at the operation, you can see that it&#x2019;s counting the number of clusters on a FAT file system!</p>
<p>To summarize so far, after the patch, we saw that in the <code>FatSetupAllocationSupport()</code> function, code was added to validate the value used in the cluster count computation for overflow, and although not shown in the figure, it stores the number of clusters in <strong>*(a2 + 0x15C)</strong>.</p>
<p>Later, in the <code>FatExamineFatEntries()</code> function, in order to use <strong>the number of clusters (*(a2 + 0x15C))</strong> as the size value in the <code>ExAllocatePoolWithTag()</code> function, we first need to make sure that the if (<em>(a2 + 0xC8) &lt;= 1u) statement is true, so let&#x2019;s trace the value </em>(a2 + 0xC8)!</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/10.png" srcset="/img/loading.gif" alt></p>
<p>After analyzing, we found that the if (*(a2 + 0xC8) &lt;= 1u) inside the <code>FatExamineFatEntries()</code> function is checked first in the <code>FatSetupAllocationSupport()</code> function.</p>
<p>In order for the if ((a2 + 0xC8) &lt;= 1u) statement to be true, we need to use the v35 variable in the if((a2 + 0x168) &#x2026; v34 &gt; 0x10000) statement or go into the else statement.</p>
<p>In this case, the value of (a2 + 0x168) must be 0x20 to enter the cluster computation process and since the v34 variable is the number of clusters ((a2 + 0x15c)), we controlled the value of *(a2 + 0xC8) with the v35 variable.</p>
<p>Once I modified the <strong>cluster count to a value of 0xFFFFFFFB</strong>, I went through the process below to make it true in the if (*(a2 + 0xC8) &lt;= 1u) statement.</p>
<ul>
<li>v35 = (0xFFFFFFFB + 0xFFFF) = 0xFFFA</li>
<li>(*(a2 + 0xC8) = 0xFFFA &gt;&gt; 0x10 = 0</li>
</ul>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/11.png" srcset="/img/loading.gif" alt></p>
<p>After modifying the vhd file as above, the cluster count will have a value of 0xFFFFFFFB after the following operation.</p>
<ul>
<li>V15 = (NumberOfSector32 - NumberOfFatTables * SectorsPerFat32 - ReservedSectors) /<br>SectorsPerCluster</li>
<li><strong>0xFFFFFFFB</strong> = ( 0xFFFFFFFF - 0x2 * 0x80000000 - 0x4 ) / 0x1</li>
</ul>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/12.png" srcset="/img/loading.gif" alt></p>
<p>When you run the modified vhd file, you can see that the overflow within if(<em>(a2 + 0x168) &#x2026; v34 &gt; 0x10000) causes the value of </em>(a2 + 0xC8) to be zero, making the if statement true and using the NumberOfClusters (0xfffffffb) as the value of the NumberOfClusters variable.</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/13.png" srcset="/img/loading.gif" alt></p>
<p>Then, while computing the value of Size in the <code>ExAllocatePoolWithTag()</code> function, (NumberOfClusters +7), an overflow occurs, resulting in the value of rdx to be 0x2, and the value of Size finally becomes 0x0 when computing &gt;&gt; 3.</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/14.png" srcset="/img/loading.gif" alt></p>
<p>This shows the block information of the memory pool page after running the <code>ExAllocatePoolWithTag()</code> function.</p>
<p>You can see that even if the Size value of the <code>ExAllocatePoolWithTag()</code> function is 0x0, a Size of 0x20 is allocated to the paged pool.</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/15.png" srcset="/img/loading.gif" alt></p>
<p>The allocated region is then initialized as a bitmap with the <code>RtlInitializeBitMap()</code> function.</p>
<p>You can see that the <code>ExAllocatePoolWithTag()</code> and <code>RtlInitializeBitMap()</code> functions map one bit per cluster.</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){ 
  [...]   
    <span class="hljs-keyword">if</span> ( !v29 &amp;&amp; v32 )                          <span class="hljs-comment">// free -&gt; used </span>
    { 
      v38 = v7 - v30; 
      <span class="hljs-keyword">if</span> ( v14 ) 
      { 
        *v14 += v38; 
        v10[<span class="hljs-number">2</span>] += v38; 
        v17 = v45; 
      } 
      <span class="hljs-keyword">if</span> ( p_BitMapHeader ) 
      { 
        RtlClearBits(p_BitMapHeader, v30 - v69, v38); 
        v17 = v45; 
        v32 = v68; 
        v28 = <span class="hljs-number">0</span>; 
      } 
      v29 = <span class="hljs-number">1</span>; 
      v48 = <span class="hljs-number">1</span>; 
      v30 = v7; 
      v51 = v7; 
    } 
    <span class="hljs-keyword">if</span> ( v29 == <span class="hljs-number">1</span> &amp;&amp; !v32 )                     <span class="hljs-comment">// used -&gt; free </span>
    { 
      <span class="hljs-keyword">if</span> ( p_BitMapHeader ) 
      { 
        RtlSetBits(p_BitMapHeader, v30 - v69, v7 - v30); 
        v17 = v45; 
        v28 = <span class="hljs-number">0</span>; 
      } 
      v29 = v28; 
      v48 = v28; 
      v30 = v7; 
      v51 = v7; 
    } 
  [...]   
}</code></pre>
<p>After the bitmap initialization, the while statement above detects the change of state of the cluster (free -&gt; used, used -&gt;free) within the vhd file and writes it to the bitmap.</p>
<p>We modify the bitmap using the <code>RtlClearBits()</code> and <code>RtlSetBits()</code> functions, and we can see that this manages the cluster allocation status.</p>
<p>The while statement runs as many times as the number of clusters (0xfffffffb) to write the bitmap data, Since the bitmap size allocated via the <code>ExAllocatePoolWithTag()</code> function is 0x20, the allocated pool area exceeds, causing a kernel pool overflow.</p>
<h2 id="BSOD-Triggers"><a href="#BSOD-Triggers" class="headerlink" title="BSOD Triggers"></a>BSOD Triggers</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/6ppD0oRZhXU?si=NEvYSd5jf0NMaObw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

<p>If you run the vhd file with the cluster count 0xfffffffb, you can see that the while statement causes an Access Violation due to a kernel pool overflow, resulting in a BSOD. <del>(I had a hard time editing the video&#x2026;^^)</del></p>
<p>Earlier, we said that the cluster&#x2019;s state change (free -&gt; used, used -&gt;free) is recorded in the bitmap. Yes! Since the user can also control the cluster&#x2019;s state, it is possible to write arbitrary data to the bitmap.</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/16.png" srcset="/img/loading.gif" alt></p>
<p>Here we are starting over with the <code>ExAllocatePoolWithTag()</code> function to analyze the while statement that records the bitmap data.</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/17.png" srcset="/img/loading.gif" alt></p>
<p>Size value overflowed and was allocated to address ffff990e`b8a58c50 by 0x20.</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/18.png" srcset="/img/loading.gif" alt></p>
<p>This part is the process of calculating the offset of the clusters present in the VHD file within the while statement.</p>
<p>Since the while statement checks the status information of cluster 2 first, the FAT offset (in FAT32) of the cluster 2 entry can be obtained by the following operation.</p>
<ul>
<li>FAT Entry Offset = BytesPerSector x ReservedSectors + (cluster number &#xD7; 4)</li>
<li>FAT Entry Offset = 0x200 X 0x4 + ( 0x2 X 0x4 ) = 0x808</li>
</ul>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/19.png" srcset="/img/loading.gif" alt></p>
<p>If we add the FAT Entry Offset to the Partition Start Offset (0x10000), we get the vhd file 0x10808 offset.<br>The 0x10808 offset will be the offset of cluster number 2, which is the first cluster we check for status information in the while statement.</p>
<p>The bitmap area (ffff990eb8a58c50) allocated earlier with the <code>ExAllocatePoolWithTag()</code> function, where 1 bit indicates the status of cluster 1.<br>If the 4-byte value of the cluster in the vhd file is 0x00000000, we consider it free and write the corresponding bit in the bitmap to 0x0, and if it is 0x11111111, we consider it used and write it to 0x1.</p>
<p>So, when we processed 8 cluster values in the while statement, we modified the bitmap to have a value of 0x41, starting with cluster state value 2, as shown above.</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/20.png" srcset="/img/loading.gif" alt></p>
<p>With the modified vhd file, the while statement works like this</p>
<ul>
<li>Currently processed cluster state used, previous cluster state free<ul>
<li>Write bits to 0x0 for the number of previously free clusters</li>
</ul>
</li>
<li>Currently processed cluster state FREE, previous cluster state USED<ul>
<li>Write bit as 0x1 for the number of clusters previously used</li>
</ul>
</li>
</ul>
<p>So, since the modified vhd file is 0100 0001, we can see that 0x41 is written.</p>
<p>Now that we have proof of writing arbitrary data to the kernel pool area,&#x2026;we can spray the kernel structures that are allocated in the paged pool and blah blah blah and trigger an RCE!</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I learned a lot about kernel drive analysis, delta patching, etc. while writing this research article, and I think the most memorable part was studying kernel paged pool to try full exploit!</p>
<p>If&#x2026; I succeed in full exploit, I&#x2019;ll be back with the next article!</p>
<p>Thank you for reading this long post!</p>
<p><img src="/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/21.png" srcset="/img/loading.gif" alt></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/RCE/">RCE</a>
                  
                  <a class="hover-with-bg" href="/tags/Integer-Overflow/">Integer Overflow</a>
                  
                  <a class="hover-with-bg" href="/tags/ogu123/">ogu123</a>
                  
                  <a class="hover-with-bg" href="/tags/Windows-Fast-FAT/">Windows Fast FAT</a>
                  
                  <a class="hover-with-bg" href="/tags/CVE-2025-24985/">CVE-2025-24985</a>
                  
                  <a class="hover-with-bg" href="/tags/BSOD/">BSOD</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_ogu123.jpg" srcset="/img/loading.gif" alt="ogu123">
                  </div>

                  <div class="link-text">
                    <div class="link-title">ogu123</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/ogu123">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">본 글은 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a> 라이선스로 배포됩니다. 공유 또는 변경 시 반드시 출처를 남겨주시기 바랍니다.</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/07/19/banda/CVE-2025-25257/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[하루한줄] CVE-2025-25257: Fortinet FortiWeb Fabric Connector의 Pre‑Auth SQL Injection을 통한 RCE 취약점</span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2025/07/17/ogu123/%5BResearch%5D_CVE-2025-24985/KR/">
                    <span class="hidden-mobile">[Research] CVE-2025-24985: Windows Fast FAT Driver RCE Vulnerability (KR)</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2025/07/17/ogu123/[Research]_CVE-2025-24985/EN/';
        this.page.identifier = '/2025/07/17/ogu123/%5BResearch%5D_CVE-2025-24985/EN/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] CVE-2025-24985: Windows Fast FAT Driver RCE Vulnerability (EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
