

<!DOCTYPE html>
<html lang="ko-KR" data-default-color-scheme="&#34;auto&#34;">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="&lt;h1 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;Hello, This is OUYA77, and it&amp;#x2019;s a pleasure to greet you &amp;#x1F642; If you look at the our team&amp;#x2019;s blog posts, there are many articles from the offensive security perspective, so I&amp;#x2019;ll write a research article from the defensive security perspective&amp;#x2026;(&lt;del&gt;Offensive and defensive are just like heroes and villains ^-^&amp;#x2606;&lt;/del&gt;)&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s get started!&lt;/p&gt;
&lt;h1 id=&#34;Debugging&#34;&gt;&lt;a href=&#34;#Debugging&#34; class=&#34;headerlink&#34; title=&#34;Debugging&#34;&gt;&lt;/a&gt;Debugging&lt;/h1&gt;&lt;p&gt;Debugging is the process of finding and fixing problems, or bugs, that occur during software development. Debugging is an essential step in ensuring the quality and reliability of your software, and it plays an important role in making sure your programmes work as intended.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/1.gif&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;I&amp;#x2019;ve found a really good introduction to debugging, so I&amp;#x2019;m going to use some of it,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://okky.kr/articles/272227&#34;&gt;Introduction to Debugging for Beginners Developers&lt;/a&gt;&lt;br&gt;The way I see proper debugging is as follows:&lt;br&gt;(to ensure reproducibility) -&amp;gt; Collect clues -&amp;gt; Analyse clues -&amp;gt; Formulate hypothesis -&amp;gt; Test hypothesis.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Debugging is the process of finding and narrowing down where something is wrong in the code, analysing the cause and fixing it. Debugging tools can observe the internal state of a running program (e.g., variable values, function call order, memory state, etc.) in real time.&lt;/p&gt;
&lt;p&gt;But what happens if an attacker exploits using this feature?&lt;/p&gt;
&lt;p&gt;If an attacker exploits the software using the debugging feature, they will be able to understand how the software code behaves and analyse creative algorithms and logic&amp;#x1F480;.&lt;/p&gt;
&lt;p&gt;This debugging is also known as dynamic analysis in reverse engineering, which provides more detailed analysis than would be possible with static analysis. If anyone can use this debugging feature, attackers could exploit it to analyze all the detailed functions of the software that should be protected!&lt;/p&gt;
&lt;p&gt;That&amp;#x2019;s why Anti-Debugging comes in.&lt;/p&gt;
&lt;h1 id=&#34;Anti-Debugging&#34;&gt;&lt;a href=&#34;#Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;Anti-Debugging&#34;&gt;&lt;/a&gt;Anti-Debugging&lt;/h1&gt;&lt;p&gt;Anti-debugging refers to techniques and methods designed to detect debuggers or disrupt their operation, protecting software from vulnerabilities to reverse engineering and analysis.&lt;/p&gt;
&lt;p&gt;Over the years, a wide variety of these techniques have been extensively studied.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/2.jpg&#34; alt&gt;&lt;br&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Anti-debugging techniques are constantly evolving and are heavily dependent on debuggers and operating systems, leading to continuous research into various methods. Here, I&amp;#x2019;ll introduce some of the traditional techniques that have been widely discussed.&lt;/p&gt;
&lt;p&gt;According to the &amp;#x201C;leaf book&amp;#x201D; in Korea, often referred to as the Bible or textbook for reverse engineers (The book&amp;#x2019;s name is &amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xD575;&amp;#xC2EC;&amp;#xC6D0;&amp;#xB9AC;), anti-debugging can be broadly classified into two categories based on the &amp;#x201C;Detection method&amp;#x201D;: &lt;strong&gt;Static&lt;/strong&gt; and &lt;strong&gt;Dynamic&lt;/strong&gt; groups. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Static anti-debugging techniques&lt;/strong&gt; operate when the debugger is &amp;#x201C;running&amp;#x201D; and typically rely on examining various system details and APIs to determine if a debugger is attached to the current process. For example, these methods might check the structure of &lt;strong&gt;PEB&lt;/strong&gt; (Process Environment Block) or &lt;strong&gt;TEB&lt;/strong&gt; (Thread Environment Block) to detect debugging or utilize operating system APIs such as &lt;strong&gt;NTQueryInformationProcess()&lt;/strong&gt; to verify if a process is being debugged.&lt;/p&gt;
&lt;p&gt;On the other hand, &lt;strong&gt;Dynamic anti-debugging techniques&lt;/strong&gt; work when the debugger is actively &amp;#x201C;tracing&amp;#x201D; the process. These methods often exploit interaction during process execution, such as handling &lt;strong&gt;exceptions&lt;/strong&gt;, setting breakpoints, or measuring execution time to detect debugging activities.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s have a look at a simple example code to see the difference!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Static Anti-Debugging&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (IsDebuggerPresent()) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected!\n&amp;quot;&lt;/span&gt;);
    } &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;No debugger found.\n&amp;quot;&lt;/span&gt;);
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; function is an API provided by the Windows operatng system that checks whether the current process is being debugged. Internally, it references the PEB (Process Environment Block) structure to determine the presence of a debugger.&lt;/p&gt;
&lt;p&gt;Specifically, &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; examines the &lt;code&gt;BeingDebugged&lt;/code&gt; field within the PEB. This field is a &lt;strong&gt;one-byte flag&lt;/strong&gt; indicating the debugging state: a value of &lt;code&gt;1&lt;/code&gt; means a debugger is attached, while &lt;code&gt;0&lt;/code&gt; indicates no debugging.&lt;/p&gt;
&lt;p&gt;Static anti-debugging techniques like this rely on direct API calls or structure fields to detect the presence of a debugger. These methods are relatively straightforward to implement and can be applied quickly.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic Anti-Debugging&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dynamic methods are techniques that detect the presence of a debugger based on interactive patterns during program execution. Although they require more complex implementation compared to static methods, they offer the advantage of higher detection accuracy. For instance, the timing-based anti-debugging technique leverages the fact that attaching a debugger to a process can significantly slow down the program&amp;#x2019;s execution speed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/4.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;A code representation of the above illustration would look like this&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; start_time = t1; &lt;span class=&#34;hljs-comment&#34;&gt;// Get the current system time&lt;/span&gt;
&amp;lt;some part of the program code&amp;gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; end_time = t2;

&lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; elapsed_time = end_time - start_time; 

&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (elapsed_time &amp;gt; threshold) { 
		&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger is detected!\n&amp;quot;&lt;/span&gt;);
}&lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;{
		&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger is not detected!\n&amp;quot;&lt;/span&gt;); 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just by looking at the code above, you can see that the Dynamic method takes a bit more effort to implement than the Static method that calls the API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/part1.jpg&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;However, anti-debugging techniques in the &lt;strong&gt;static group&lt;/strong&gt; are relatively easy to bypass due to their simplicity in implementation and lower complexity compared to dynamic anti-debugging. Static methods are often analyzed and neutralized before the program even runs in a debugging environment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic anti-debugging&lt;/strong&gt;, on the other hand, works by taking advantage of environmental changes or dynamic conditions during execution, and therefore requires the analyst to fully understand the program&amp;#x2019;s runtime context in order to bypass or disable it. Because of this, Static techniques aim to detect and block quickly, while Dynamic techniques are more complex and difficult to bypass, and are often more effective at protecting the system.&lt;/p&gt;
&lt;p&gt;Beyond the differences between static and dynamic approaches, anti-debugging techniques also vary depending on the operating system. For example, the methods used in Windows and Linux diverge due to differences in system architecture and APIs. The previously mentioned &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; function is an example of an anti-debugging technique specific to Windows. Meanwhile, in Linux and Unix-like systems, the &lt;code&gt;ptrace()&lt;/code&gt; system call is used to detect whether a debugger is attached to the process.&lt;/p&gt;
&lt;p&gt;Looking through the code,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs autoit&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;sys/ptrace.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-built_in&#34;&gt;int&lt;/span&gt; main(void) {
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (ptrace(PTRACE_TRACEME, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;) == &lt;span class=&#34;hljs-number&#34;&gt;-1&lt;/span&gt;) {
        printf(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected or ptrace call failed!\n&amp;quot;&lt;/span&gt;)&lt;span class=&#34;hljs-comment&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; EXIT_FAILURE&lt;span class=&#34;hljs-comment&#34;&gt;;&lt;/span&gt;
    }
    printf(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;No debugger found.\n&amp;quot;&lt;/span&gt;)&lt;span class=&#34;hljs-comment&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; EXIT_SUCCESS&lt;span class=&#34;hljs-comment&#34;&gt;;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above is a simple example that uses the &lt;code&gt;ptrace()&lt;/code&gt; system call on Linux systems to check whether a debugger is attached to the process. The &lt;code&gt;ptrace()&lt;/code&gt; system call allows a process to be monitored and controlled, and the &lt;code&gt;PTRACE_TRACEME&lt;/code&gt; option sets the process to be traceable by a debugger. The purpose of this code is to detect the presence of a debugger and output a warning message when one is detected.&lt;/p&gt;
&lt;p&gt;Since anti-debugging techniques inherently rely on the characteristics of debuggers and operating systems, what if we leverage those very characteristics in reverse?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/6.gif&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The practice of anti-debugging techniques and their bypass methods will be covered in the next section :)&lt;/p&gt;
&lt;h1 id=&#34;Side-Note&#34;&gt;&lt;a href=&#34;#Side-Note&#34; class=&#34;headerlink&#34; title=&#34;Side Note&#34;&gt;&lt;/a&gt;Side Note&lt;/h1&gt;&lt;p&gt;As mentioned earlier, developers apply anti-debugging techniques to prevent their software from being analyzed by attackers. Similarly, malware developers use anti-debugging to protect their malicious code from being analyzed. Analysts, in turn, must employ more sophisticated techniques and tools to analyze malware, while malware developers continue to advance their anti-debugging methods to evade detection. The ongoing battle between reverse engineering and anti-reverse engineering, debugging and anti-debugging, analysts and malware developers, continues to drive technological progress, much like a battle between heroes and villains.&lt;/p&gt;
&lt;p&gt;As the saying goes, &amp;#x201C;Know yourself and your enemy, and you will never be defeated.&amp;#x201D; It&amp;#x2019;s important to familiarize yourself with various techniques. I look forward to bringing you more valuable content in the next section!&lt;/p&gt;
&lt;p&gt;Have a great end of the year, and let&amp;#x2019;s continue to grow together in 2025! &amp;#x1F64C;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/7.gif&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;&amp;#xCC38;&amp;#xACE0;&amp;#xBB38;&amp;#xD5CC;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xD575;&amp;#xC2EC; &amp;#xC6D0;&amp;#xB9AC;: &amp;#xC545;&amp;#xC131; &amp;#xCF54;&amp;#xB4DC; &amp;#xBD84;&amp;#xC11D;&amp;#xAC00;&amp;#xC758; &amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xC774;&amp;#xC57C;&amp;#xAE30;(&amp;#xC800;&amp;#xC790; &amp;#xC774;&amp;#xC2B9;&amp;#xC6D0;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.openrce.org/reference_library/anti_reversing&#34;&gt;https://www.openrce.org/reference_library/anti_reversing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/naver-cloud-platform/&amp;#xBCF4;&amp;#xB2E4;-&amp;#xC548;&amp;#xC804;&amp;#xD558;&amp;#xAC8C;-&amp;#xBAA8;&amp;#xBC14;&amp;#xC77C;-&amp;#xAC8C;&amp;#xC784;&amp;#xC744;-&amp;#xC11C;&amp;#xBE44;&amp;#xC2A4;&amp;#xD558;&amp;#xB294;-&amp;#xBC29;&amp;#xBC95;-2-b08352208672&#34;&gt;https://medium.com/naver-cloud-platform/&amp;#xBCF4;&amp;#xB2E4;-&amp;#xC548;&amp;#xC804;&amp;#xD558;&amp;#xAC8C;-&amp;#xBAA8;&amp;#xBC14;&amp;#xC77C;-&amp;#xAC8C;&amp;#xC784;&amp;#xC744;-&amp;#xC11C;&amp;#xBE44;&amp;#xC2A4;&amp;#xD558;&amp;#xB294;-&amp;#xBC29;&amp;#xBC95;-2-b08352208672&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.naver.com/kby88power/220946544312&#34;&gt;https://blog.naver.com/kby88power/220946544312&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta name="author" content="j0dev, y2sman">
  <meta name="keywords" content>
  <meta name="google-site-verification" content="DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4">
  <meta name="naver-site-verification" content="0b4fea742ed293b82621684e466d9f26c3ccee06">


  <meta property="og:type" content="website"> 
  <meta property="og:title" content="[Research] Anti-Debugging Part 1(EN) - hackyboiz">
  <meta property="og:description" content="&lt;h1 id=&#34;Introduction&#34;&gt;&lt;a href=&#34;#Introduction&#34; class=&#34;headerlink&#34; title=&#34;Introduction&#34;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;Hello, This is OUYA77, and it&amp;#x2019;s a pleasure to greet you &amp;#x1F642; If you look at the our team&amp;#x2019;s blog posts, there are many articles from the offensive security perspective, so I&amp;#x2019;ll write a research article from the defensive security perspective&amp;#x2026;(&lt;del&gt;Offensive and defensive are just like heroes and villains ^-^&amp;#x2606;&lt;/del&gt;)&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s get started!&lt;/p&gt;
&lt;h1 id=&#34;Debugging&#34;&gt;&lt;a href=&#34;#Debugging&#34; class=&#34;headerlink&#34; title=&#34;Debugging&#34;&gt;&lt;/a&gt;Debugging&lt;/h1&gt;&lt;p&gt;Debugging is the process of finding and fixing problems, or bugs, that occur during software development. Debugging is an essential step in ensuring the quality and reliability of your software, and it plays an important role in making sure your programmes work as intended.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/1.gif&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;I&amp;#x2019;ve found a really good introduction to debugging, so I&amp;#x2019;m going to use some of it,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://okky.kr/articles/272227&#34;&gt;Introduction to Debugging for Beginners Developers&lt;/a&gt;&lt;br&gt;The way I see proper debugging is as follows:&lt;br&gt;(to ensure reproducibility) -&amp;gt; Collect clues -&amp;gt; Analyse clues -&amp;gt; Formulate hypothesis -&amp;gt; Test hypothesis.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Debugging is the process of finding and narrowing down where something is wrong in the code, analysing the cause and fixing it. Debugging tools can observe the internal state of a running program (e.g., variable values, function call order, memory state, etc.) in real time.&lt;/p&gt;
&lt;p&gt;But what happens if an attacker exploits using this feature?&lt;/p&gt;
&lt;p&gt;If an attacker exploits the software using the debugging feature, they will be able to understand how the software code behaves and analyse creative algorithms and logic&amp;#x1F480;.&lt;/p&gt;
&lt;p&gt;This debugging is also known as dynamic analysis in reverse engineering, which provides more detailed analysis than would be possible with static analysis. If anyone can use this debugging feature, attackers could exploit it to analyze all the detailed functions of the software that should be protected!&lt;/p&gt;
&lt;p&gt;That&amp;#x2019;s why Anti-Debugging comes in.&lt;/p&gt;
&lt;h1 id=&#34;Anti-Debugging&#34;&gt;&lt;a href=&#34;#Anti-Debugging&#34; class=&#34;headerlink&#34; title=&#34;Anti-Debugging&#34;&gt;&lt;/a&gt;Anti-Debugging&lt;/h1&gt;&lt;p&gt;Anti-debugging refers to techniques and methods designed to detect debuggers or disrupt their operation, protecting software from vulnerabilities to reverse engineering and analysis.&lt;/p&gt;
&lt;p&gt;Over the years, a wide variety of these techniques have been extensively studied.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/2.jpg&#34; alt&gt;&lt;br&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/3.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Anti-debugging techniques are constantly evolving and are heavily dependent on debuggers and operating systems, leading to continuous research into various methods. Here, I&amp;#x2019;ll introduce some of the traditional techniques that have been widely discussed.&lt;/p&gt;
&lt;p&gt;According to the &amp;#x201C;leaf book&amp;#x201D; in Korea, often referred to as the Bible or textbook for reverse engineers (The book&amp;#x2019;s name is &amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xD575;&amp;#xC2EC;&amp;#xC6D0;&amp;#xB9AC;), anti-debugging can be broadly classified into two categories based on the &amp;#x201C;Detection method&amp;#x201D;: &lt;strong&gt;Static&lt;/strong&gt; and &lt;strong&gt;Dynamic&lt;/strong&gt; groups. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Static anti-debugging techniques&lt;/strong&gt; operate when the debugger is &amp;#x201C;running&amp;#x201D; and typically rely on examining various system details and APIs to determine if a debugger is attached to the current process. For example, these methods might check the structure of &lt;strong&gt;PEB&lt;/strong&gt; (Process Environment Block) or &lt;strong&gt;TEB&lt;/strong&gt; (Thread Environment Block) to detect debugging or utilize operating system APIs such as &lt;strong&gt;NTQueryInformationProcess()&lt;/strong&gt; to verify if a process is being debugged.&lt;/p&gt;
&lt;p&gt;On the other hand, &lt;strong&gt;Dynamic anti-debugging techniques&lt;/strong&gt; work when the debugger is actively &amp;#x201C;tracing&amp;#x201D; the process. These methods often exploit interaction during process execution, such as handling &lt;strong&gt;exceptions&lt;/strong&gt;, setting breakpoints, or measuring execution time to detect debugging activities.&lt;/p&gt;
&lt;p&gt;Let&amp;#x2019;s have a look at a simple example code to see the difference!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Static Anti-Debugging&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (IsDebuggerPresent()) {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected!\n&amp;quot;&lt;/span&gt;);
    } &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {
        &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;No debugger found.\n&amp;quot;&lt;/span&gt;);
    }
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; function is an API provided by the Windows operatng system that checks whether the current process is being debugged. Internally, it references the PEB (Process Environment Block) structure to determine the presence of a debugger.&lt;/p&gt;
&lt;p&gt;Specifically, &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; examines the &lt;code&gt;BeingDebugged&lt;/code&gt; field within the PEB. This field is a &lt;strong&gt;one-byte flag&lt;/strong&gt; indicating the debugging state: a value of &lt;code&gt;1&lt;/code&gt; means a debugger is attached, while &lt;code&gt;0&lt;/code&gt; indicates no debugging.&lt;/p&gt;
&lt;p&gt;Static anti-debugging techniques like this rely on direct API calls or structure fields to detect the presence of a debugger. These methods are relatively straightforward to implement and can be applied quickly.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic Anti-Debugging&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dynamic methods are techniques that detect the presence of a debugger based on interactive patterns during program execution. Although they require more complex implementation compared to static methods, they offer the advantage of higher detection accuracy. For instance, the timing-based anti-debugging technique leverages the fact that attaching a debugger to a process can significantly slow down the program&amp;#x2019;s execution speed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/4.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;A code representation of the above illustration would look like this&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs cpp&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; start_time = t1; &lt;span class=&#34;hljs-comment&#34;&gt;// Get the current system time&lt;/span&gt;
&amp;lt;some part of the program code&amp;gt;
&lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; end_time = t2;

&lt;span class=&#34;hljs-keyword&#34;&gt;uint64_t&lt;/span&gt; elapsed_time = end_time - start_time; 

&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (elapsed_time &amp;gt; threshold) { 
		&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger is detected!\n&amp;quot;&lt;/span&gt;);
}&lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;{
		&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger is not detected!\n&amp;quot;&lt;/span&gt;); 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just by looking at the code above, you can see that the Dynamic method takes a bit more effort to implement than the Static method that calls the API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/part1.jpg&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;However, anti-debugging techniques in the &lt;strong&gt;static group&lt;/strong&gt; are relatively easy to bypass due to their simplicity in implementation and lower complexity compared to dynamic anti-debugging. Static methods are often analyzed and neutralized before the program even runs in a debugging environment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic anti-debugging&lt;/strong&gt;, on the other hand, works by taking advantage of environmental changes or dynamic conditions during execution, and therefore requires the analyst to fully understand the program&amp;#x2019;s runtime context in order to bypass or disable it. Because of this, Static techniques aim to detect and block quickly, while Dynamic techniques are more complex and difficult to bypass, and are often more effective at protecting the system.&lt;/p&gt;
&lt;p&gt;Beyond the differences between static and dynamic approaches, anti-debugging techniques also vary depending on the operating system. For example, the methods used in Windows and Linux diverge due to differences in system architecture and APIs. The previously mentioned &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; function is an example of an anti-debugging technique specific to Windows. Meanwhile, in Linux and Unix-like systems, the &lt;code&gt;ptrace()&lt;/code&gt; system call is used to detect whether a debugger is attached to the process.&lt;/p&gt;
&lt;p&gt;Looking through the code,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;hljs autoit&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;sys/ptrace.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;hljs-built_in&#34;&gt;int&lt;/span&gt; main(void) {
    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (ptrace(PTRACE_TRACEME, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;) == &lt;span class=&#34;hljs-number&#34;&gt;-1&lt;/span&gt;) {
        printf(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Debugger detected or ptrace call failed!\n&amp;quot;&lt;/span&gt;)&lt;span class=&#34;hljs-comment&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; EXIT_FAILURE&lt;span class=&#34;hljs-comment&#34;&gt;;&lt;/span&gt;
    }
    printf(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;No debugger found.\n&amp;quot;&lt;/span&gt;)&lt;span class=&#34;hljs-comment&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; EXIT_SUCCESS&lt;span class=&#34;hljs-comment&#34;&gt;;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above is a simple example that uses the &lt;code&gt;ptrace()&lt;/code&gt; system call on Linux systems to check whether a debugger is attached to the process. The &lt;code&gt;ptrace()&lt;/code&gt; system call allows a process to be monitored and controlled, and the &lt;code&gt;PTRACE_TRACEME&lt;/code&gt; option sets the process to be traceable by a debugger. The purpose of this code is to detect the presence of a debugger and output a warning message when one is detected.&lt;/p&gt;
&lt;p&gt;Since anti-debugging techniques inherently rely on the characteristics of debuggers and operating systems, what if we leverage those very characteristics in reverse?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/6.gif&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;The practice of anti-debugging techniques and their bypass methods will be covered in the next section :)&lt;/p&gt;
&lt;h1 id=&#34;Side-Note&#34;&gt;&lt;a href=&#34;#Side-Note&#34; class=&#34;headerlink&#34; title=&#34;Side Note&#34;&gt;&lt;/a&gt;Side Note&lt;/h1&gt;&lt;p&gt;As mentioned earlier, developers apply anti-debugging techniques to prevent their software from being analyzed by attackers. Similarly, malware developers use anti-debugging to protect their malicious code from being analyzed. Analysts, in turn, must employ more sophisticated techniques and tools to analyze malware, while malware developers continue to advance their anti-debugging methods to evade detection. The ongoing battle between reverse engineering and anti-reverse engineering, debugging and anti-debugging, analysts and malware developers, continues to drive technological progress, much like a battle between heroes and villains.&lt;/p&gt;
&lt;p&gt;As the saying goes, &amp;#x201C;Know yourself and your enemy, and you will never be defeated.&amp;#x201D; It&amp;#x2019;s important to familiarize yourself with various techniques. I look forward to bringing you more valuable content in the next section!&lt;/p&gt;
&lt;p&gt;Have a great end of the year, and let&amp;#x2019;s continue to grow together in 2025! &amp;#x1F64C;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/12/29/OUYA77/Anti_part1/en/7.gif&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;&amp;#xCC38;&amp;#xACE0;&amp;#xBB38;&amp;#xD5CC;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xD575;&amp;#xC2EC; &amp;#xC6D0;&amp;#xB9AC;: &amp;#xC545;&amp;#xC131; &amp;#xCF54;&amp;#xB4DC; &amp;#xBD84;&amp;#xC11D;&amp;#xAC00;&amp;#xC758; &amp;#xB9AC;&amp;#xBC84;&amp;#xC2F1; &amp;#xC774;&amp;#xC57C;&amp;#xAE30;(&amp;#xC800;&amp;#xC790; &amp;#xC774;&amp;#xC2B9;&amp;#xC6D0;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.openrce.org/reference_library/anti_reversing&#34;&gt;https://www.openrce.org/reference_library/anti_reversing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/naver-cloud-platform/&amp;#xBCF4;&amp;#xB2E4;-&amp;#xC548;&amp;#xC804;&amp;#xD558;&amp;#xAC8C;-&amp;#xBAA8;&amp;#xBC14;&amp;#xC77C;-&amp;#xAC8C;&amp;#xC784;&amp;#xC744;-&amp;#xC11C;&amp;#xBE44;&amp;#xC2A4;&amp;#xD558;&amp;#xB294;-&amp;#xBC29;&amp;#xBC95;-2-b08352208672&#34;&gt;https://medium.com/naver-cloud-platform/&amp;#xBCF4;&amp;#xB2E4;-&amp;#xC548;&amp;#xC804;&amp;#xD558;&amp;#xAC8C;-&amp;#xBAA8;&amp;#xBC14;&amp;#xC77C;-&amp;#xAC8C;&amp;#xC784;&amp;#xC744;-&amp;#xC11C;&amp;#xBE44;&amp;#xC2A4;&amp;#xD558;&amp;#xB294;-&amp;#xBC29;&amp;#xBC95;-2-b08352208672&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.naver.com/kby88power/220946544312&#34;&gt;https://blog.naver.com/kby88power/220946544312&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
 - hack &amp; life">
  <meta property="og:image" content="https://hackyboiz.github.io/2024/12/29/OUYA77/Anti_part1/en/part1.jpg">
  <meta property="og:url" content="https://hackyboiz.github.io/">

  <link rel="canonical" href="https://hackyboiz.github.io/2024/12/29/ouya77/anti_part1/en/">

  <title>[Research] Anti-Debugging Part 1(EN) - hackyboiz</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">
<link rel="stylesheet" href="/.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">
<link rel="stylesheet" href="/.css">


<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>

<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/rss2.xml" title="hackyboiz" type="application/rss+xml">
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Hackyboiz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-addrcard"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/author/">
                <i class="iconfont icon-user-fill"></i>
                Author
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax="true" style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2024-12-29 16:00" pubdate>
      2024년 12월 29일 오후
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      1.4k 자
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      28
       분
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2">
      <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
    </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Anti-Debugging Part 1(EN)</h1>
                       
            <div class="markdown-body" id="post-body">
              <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              <!-- hackyboiz_horizen_index -->
              <!--
              <ins class="adsbygoogle"
                   style="display:block"
                   data-ad-client="ca-pub-3672652207808168"
                   data-ad-slot="8887862313"
                   data-ad-format="auto"
                   data-full-width-responsive="true"></ins>
              <script>
                   (adsbygoogle = window.adsbygoogle || []).push({});
              </script>
              -->
              <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Hello, This is OUYA77, and it&#x2019;s a pleasure to greet you &#x1F642; If you look at the our team&#x2019;s blog posts, there are many articles from the offensive security perspective, so I&#x2019;ll write a research article from the defensive security perspective&#x2026;(<del>Offensive and defensive are just like heroes and villains ^-^&#x2606;</del>)</p>
<p>Let&#x2019;s get started!</p>
<h1 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h1><p>Debugging is the process of finding and fixing problems, or bugs, that occur during software development. Debugging is an essential step in ensuring the quality and reliability of your software, and it plays an important role in making sure your programmes work as intended.</p>
<p><img src="/2024/12/29/OUYA77/Anti_part1/en/1.gif" srcset="/img/loading.gif" alt></p>
<p>I&#x2019;ve found a really good introduction to debugging, so I&#x2019;m going to use some of it,</p>
<blockquote>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://okky.kr/articles/272227">Introduction to Debugging for Beginners Developers</a><br>The way I see proper debugging is as follows:<br>(to ensure reproducibility) -&gt; Collect clues -&gt; Analyse clues -&gt; Formulate hypothesis -&gt; Test hypothesis.</p>
</blockquote>
<p>Debugging is the process of finding and narrowing down where something is wrong in the code, analysing the cause and fixing it. Debugging tools can observe the internal state of a running program (e.g., variable values, function call order, memory state, etc.) in real time.</p>
<p>But what happens if an attacker exploits using this feature?</p>
<p>If an attacker exploits the software using the debugging feature, they will be able to understand how the software code behaves and analyse creative algorithms and logic&#x1F480;.</p>
<p>This debugging is also known as dynamic analysis in reverse engineering, which provides more detailed analysis than would be possible with static analysis. If anyone can use this debugging feature, attackers could exploit it to analyze all the detailed functions of the software that should be protected!</p>
<p>That&#x2019;s why Anti-Debugging comes in.</p>
<h1 id="Anti-Debugging"><a href="#Anti-Debugging" class="headerlink" title="Anti-Debugging"></a>Anti-Debugging</h1><p>Anti-debugging refers to techniques and methods designed to detect debuggers or disrupt their operation, protecting software from vulnerabilities to reverse engineering and analysis.</p>
<p>Over the years, a wide variety of these techniques have been extensively studied.</p>
<p><img src="/2024/12/29/OUYA77/Anti_part1/en/2.jpg" srcset="/img/loading.gif" alt><br><img src="/2024/12/29/OUYA77/Anti_part1/en/3.png" srcset="/img/loading.gif" alt></p>
<p>Anti-debugging techniques are constantly evolving and are heavily dependent on debuggers and operating systems, leading to continuous research into various methods. Here, I&#x2019;ll introduce some of the traditional techniques that have been widely discussed.</p>
<p>According to the &#x201C;leaf book&#x201D; in Korea, often referred to as the Bible or textbook for reverse engineers (The book&#x2019;s name is &#xB9AC;&#xBC84;&#xC2F1; &#xD575;&#xC2EC;&#xC6D0;&#xB9AC;), anti-debugging can be broadly classified into two categories based on the &#x201C;Detection method&#x201D;: <strong>Static</strong> and <strong>Dynamic</strong> groups. </p>
<p><strong>Static anti-debugging techniques</strong> operate when the debugger is &#x201C;running&#x201D; and typically rely on examining various system details and APIs to determine if a debugger is attached to the current process. For example, these methods might check the structure of <strong>PEB</strong> (Process Environment Block) or <strong>TEB</strong> (Thread Environment Block) to detect debugging or utilize operating system APIs such as <strong>NTQueryInformationProcess()</strong> to verify if a process is being debugged.</p>
<p>On the other hand, <strong>Dynamic anti-debugging techniques</strong> work when the debugger is actively &#x201C;tracing&#x201D; the process. These methods often exploit interaction during process execution, such as handling <strong>exceptions</strong>, setting breakpoints, or measuring execution time to detect debugging activities.</p>
<p>Let&#x2019;s have a look at a simple example code to see the difference!</p>
<ul>
<li>Static Anti-Debugging</li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (IsDebuggerPresent()) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugger detected!\n&quot;</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No debugger found.\n&quot;</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>The <code>IsDebuggerPresent()</code> function is an API provided by the Windows operatng system that checks whether the current process is being debugged. Internally, it references the PEB (Process Environment Block) structure to determine the presence of a debugger.</p>
<p>Specifically, <code>IsDebuggerPresent()</code> examines the <code>BeingDebugged</code> field within the PEB. This field is a <strong>one-byte flag</strong> indicating the debugging state: a value of <code>1</code> means a debugger is attached, while <code>0</code> indicates no debugging.</p>
<p>Static anti-debugging techniques like this rely on direct API calls or structure fields to detect the presence of a debugger. These methods are relatively straightforward to implement and can be applied quickly.</p>
<ul>
<li>Dynamic Anti-Debugging</li>
</ul>
<p>Dynamic methods are techniques that detect the presence of a debugger based on interactive patterns during program execution. Although they require more complex implementation compared to static methods, they offer the advantage of higher detection accuracy. For instance, the timing-based anti-debugging technique leverages the fact that attaching a debugger to a process can significantly slow down the program&#x2019;s execution speed.</p>
<p><img src="/2024/12/29/OUYA77/Anti_part1/en/4.png" srcset="/img/loading.gif" alt></p>
<p>A code representation of the above illustration would look like this</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">uint64_t</span> start_time = t1; <span class="hljs-comment">// Get the current system time</span>
&lt;some part of the program code&gt;
<span class="hljs-keyword">uint64_t</span> end_time = t2;

<span class="hljs-keyword">uint64_t</span> elapsed_time = end_time - start_time; 

<span class="hljs-keyword">if</span> (elapsed_time &gt; threshold) { 
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugger is detected!\n&quot;</span>);
}<span class="hljs-keyword">else</span>{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugger is not detected!\n&quot;</span>); 
}</code></pre>
<p>Just by looking at the code above, you can see that the Dynamic method takes a bit more effort to implement than the Static method that calls the API.</p>
<p><img src="/2024/12/29/OUYA77/Anti_part1/en/part1.jpg" srcset="/img/loading.gif" alt></p>
<p>However, anti-debugging techniques in the <strong>static group</strong> are relatively easy to bypass due to their simplicity in implementation and lower complexity compared to dynamic anti-debugging. Static methods are often analyzed and neutralized before the program even runs in a debugging environment.</p>
<p><strong>Dynamic anti-debugging</strong>, on the other hand, works by taking advantage of environmental changes or dynamic conditions during execution, and therefore requires the analyst to fully understand the program&#x2019;s runtime context in order to bypass or disable it. Because of this, Static techniques aim to detect and block quickly, while Dynamic techniques are more complex and difficult to bypass, and are often more effective at protecting the system.</p>
<p>Beyond the differences between static and dynamic approaches, anti-debugging techniques also vary depending on the operating system. For example, the methods used in Windows and Linux diverge due to differences in system architecture and APIs. The previously mentioned <code>IsDebuggerPresent()</code> function is an example of an anti-debugging technique specific to Windows. Meanwhile, in Linux and Unix-like systems, the <code>ptrace()</code> system call is used to detect whether a debugger is attached to the process.</p>
<p>Looking through the code,</p>
<pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ptrace.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>

<span class="hljs-built_in">int</span> main(void) {
    <span class="hljs-keyword">if</span> (ptrace(PTRACE_TRACEME, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) {
        printf(<span class="hljs-string">&quot;Debugger detected or ptrace call failed!\n&quot;</span>)<span class="hljs-comment">;</span>
        <span class="hljs-keyword">return</span> EXIT_FAILURE<span class="hljs-comment">;</span>
    }
    printf(<span class="hljs-string">&quot;No debugger found.\n&quot;</span>)<span class="hljs-comment">;</span>
    <span class="hljs-keyword">return</span> EXIT_SUCCESS<span class="hljs-comment">;</span>
}
</code></pre>
<p>The code above is a simple example that uses the <code>ptrace()</code> system call on Linux systems to check whether a debugger is attached to the process. The <code>ptrace()</code> system call allows a process to be monitored and controlled, and the <code>PTRACE_TRACEME</code> option sets the process to be traceable by a debugger. The purpose of this code is to detect the presence of a debugger and output a warning message when one is detected.</p>
<p>Since anti-debugging techniques inherently rely on the characteristics of debuggers and operating systems, what if we leverage those very characteristics in reverse?</p>
<p><img src="/2024/12/29/OUYA77/Anti_part1/en/6.gif" srcset="/img/loading.gif" alt></p>
<p>The practice of anti-debugging techniques and their bypass methods will be covered in the next section :)</p>
<h1 id="Side-Note"><a href="#Side-Note" class="headerlink" title="Side Note"></a>Side Note</h1><p>As mentioned earlier, developers apply anti-debugging techniques to prevent their software from being analyzed by attackers. Similarly, malware developers use anti-debugging to protect their malicious code from being analyzed. Analysts, in turn, must employ more sophisticated techniques and tools to analyze malware, while malware developers continue to advance their anti-debugging methods to evade detection. The ongoing battle between reverse engineering and anti-reverse engineering, debugging and anti-debugging, analysts and malware developers, continues to drive technological progress, much like a battle between heroes and villains.</p>
<p>As the saying goes, &#x201C;Know yourself and your enemy, and you will never be defeated.&#x201D; It&#x2019;s important to familiarize yourself with various techniques. I look forward to bringing you more valuable content in the next section!</p>
<p>Have a great end of the year, and let&#x2019;s continue to grow together in 2025! &#x1F64C;</p>
<p><img src="/2024/12/29/OUYA77/Anti_part1/en/7.gif" srcset="/img/loading.gif" alt></p>
<p>&#xCC38;&#xACE0;&#xBB38;&#xD5CC;</p>
<ul>
<li>&#xB9AC;&#xBC84;&#xC2F1; &#xD575;&#xC2EC; &#xC6D0;&#xB9AC;: &#xC545;&#xC131; &#xCF54;&#xB4DC; &#xBD84;&#xC11D;&#xAC00;&#xC758; &#xB9AC;&#xBC84;&#xC2F1; &#xC774;&#xC57C;&#xAE30;(&#xC800;&#xC790; &#xC774;&#xC2B9;&#xC6D0;)</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.openrce.org/reference_library/anti_reversing">https://www.openrce.org/reference_library/anti_reversing</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/naver-cloud-platform/&#xBCF4;&#xB2E4;-&#xC548;&#xC804;&#xD558;&#xAC8C;-&#xBAA8;&#xBC14;&#xC77C;-&#xAC8C;&#xC784;&#xC744;-&#xC11C;&#xBE44;&#xC2A4;&#xD558;&#xB294;-&#xBC29;&#xBC95;-2-b08352208672">https://medium.com/naver-cloud-platform/&#xBCF4;&#xB2E4;-&#xC548;&#xC804;&#xD558;&#xAC8C;-&#xBAA8;&#xBC14;&#xC77C;-&#xAC8C;&#xC784;&#xC744;-&#xC11C;&#xBE44;&#xC2A4;&#xD558;&#xB294;-&#xBC29;&#xBC95;-2-b08352208672</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.naver.com/kby88power/220946544312">https://blog.naver.com/kby88power/220946544312</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                <div class="post-meta mr-3">
                  <i class="iconfont icon-category"></i>
                  
                  <a class="hover-with-bg" href="/categories/Research/">Research</a>
                  
                </div>
                
                
                <div class="post-meta">
                  <i class="iconfont icon-tags"></i>
                  
                  <a class="hover-with-bg" href="/tags/OUYA77/">OUYA77</a>
                  
                  <a class="hover-with-bg" href="/tags/Debugging/">Debugging</a>
                  
                  <a class="hover-with-bg" href="/tags/Reversing/">Reversing</a>
                  
                  <a class="hover-with-bg" href="/tags/Anti-Debugging/">Anti-Debugging</a>
                  
                  <a class="hover-with-bg" href="/tags/Malware/">Malware</a>
                  
                </div>
                
              </div>

              <div class="post-metas mb-3">
                <a class="hover-with-bg" style="display: flex;" href="/author">
                  <div class="link-avatar-page">
                    <img src="/img/profile_OUYA77.jpg" srcset="/img/loading.gif" alt="OUYA77">
                  </div>

                  <div class="link-text">
                    <div class="link-title">OUYA77</div>
                  </div>
                </a>
                <div class="link-text">
                  <div class="link-more">
                    <a href="/tags/OUYA77">
                      Read more
                      <i class="iconfont icon-arrowdown"></i>
                    </a>
                  </div>
                </div>
              </div>

              <hr>
              <!--<script data-ad-client="ca-pub-3672652207808168" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
              
              <!--  -->
              <p class="note note-warning">본 글은 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer">CC BY-SA 4.0</a> 라이선스로 배포됩니다. 공유 또는 변경 시 반드시 출처를 남겨주시기 바랍니다.</p>
              
              
              
              <div class="post-prevnext row">
                <article class="post-prev col-6">
                  
                  
                  <a href="/2025/01/01/clalxk/CVE-2024-8534/">
                    <i class="iconfont icon-arrowleft"></i>
                    <span class="hidden-mobile">[하루한줄] CVE-2024-8534:Citrix NetScaler RDP Proxy DoS</span>
                    <span class="visible-mobile">Previous</span>
                  </a>
                  
                </article>
                <article class="post-next col-6">
                  
                  
                  <a href="/2024/12/29/OUYA77/Anti_part1/kr/">
                    <span class="hidden-mobile">[Research] Anti-Debugging Part 1(KR)</span>
                    <span class="visible-mobile">Next</span>
                    <i class="iconfont icon-arrowright"></i>
                  </a>
                  
                </article>
              </div>
              
            </div>
            
            <!-- Embed Section -->
            <div style="width: 100%; height: 210px; margin-bottom: 50px; overflow: hidden;">
              <iframe src="https://maily.so/hackyboiz/embed?src=embed" style="width: 100%; height: 100%; border: none;" frameborder="0"></iframe>
            </div>            

            
            <!-- Comments -->
            <article class="comments" id="comments">
              
              
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hackyboiz.github.io/2024/12/29/OUYA77/Anti_part1/en/';
        this.page.identifier = '/2024/12/29/OUYA77/Anti_part1/en/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hackyboiz' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a>
    </noscript>
  </div>


            </article>
            
          </article>
        </div>
      </div>
    </div>
    
    <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
      <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

    </div>
    
  </div>
</div>

<!-- Custom -->

    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>







  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "[Research] Anti-Debugging Part 1(EN)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  













  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-177243668-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177243668-2"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177243668-2');
    </script>
  

  

  

  





</body>
</html>
