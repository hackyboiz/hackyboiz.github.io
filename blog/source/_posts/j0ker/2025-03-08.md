---
title: "[하루한줄] CVE-2024-53104: Linux Kernel의 Out-Of-Bounds(OOB) Write 취약점"
author: j0ker
tags: [Linux, Kernel, CVE-2024-53104, Out-Of-Bounds, OOB, OOB Write, uvc_parse_format, ftype, j0ker]
categories: [1day1line]
date: 2025-03-08 17:00:00
cc: true
index_img: /img/1day1line.png
---

## URL

- https://nvd.nist.gov/vuln/detail/CVE-2024-53104


## Explain

이 취약점은 UVC (USB Video Class) 드라이버의 `uvc_parse_format` 함수에서 발생합니다. 문제는 프레임 디스크립터를 파싱할 때, 정의되지 않은 프레임 타입(예, UVC_VS_UNDEFINED, 실제 코드에서는 `ftype`이 0인 경우)을 제대로 처리하지 않아 Out-Of-Bounds Write가 발생할 수 있다는 점입니다.

- **패치 전 코드**
    - 프레임 디스크립터를 파싱하는 while 루프의 조건은 다음과 같습니다:
        
        ```c
        while (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
               buffer[2] == ftype) {
            // 프레임 파싱 처리...
        }
        ```
        
        `ftype`은 파싱할 프레임의 타입을 나타내며, UVC_VS_FRAME_UNCOMPRESSED, UVC_VS_FRAME_FRAME_BASED, UVC_VS_FRAME_MJPEG 등으로 설정됩니다. 특정 포맷(예: DV 포맷)의 경우 `ftype`을 0으로 설정하는데, 이는 실제 프레임 디스크립터가 존재하지 않음을 의미합니다.
        
    - 문제는 만약 `ftype` 값이 0(즉, UVC_VS_UNDEFINED)이면, 조건 `buffer[2] == 0`이 참이 되어 루프가 실행되고, 계산된 프레임 버퍼 크기가 부정확해질 수 있습니다.

패치 전에는 `ftype`이 0인 상황에서도 루프가 조건에 맞게 실행되어, 프레임 디스크립터의 크기나 버퍼 계산에 포함되게 됩니다. 이로 인해 정의되지 않은 프레임 타입에 대해 잘못된 메모리 접근이 이루어지고, 버퍼의 OOB Write가 발생할 위험이 생깁니다. 이 취약점을 악용할 경우, 공격자는 커널 메모리를 변조하여 시스템의 안정성을 해치거나, 심각한 경우 권한 상승 및 원격 코드 실행 등 치명적인 보안 문제를 일으킬 수 있습니다.

- **패치 후 코드**
    - while 루프의 조건에 `ftype` 값에 대한 추가 검증(`ftype &&`)이 들어갔습니다:
        
        ```c
        while (ftype && buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
               buffer[2] == ftype) {
            // 프레임 파싱 처리...
        }
        ```
        
    - 이로써 `ftype`이 0인 경우(즉, 정의되지 않은 프레임 타입)에는 루프가 실행되지 않아, 잘못된 파싱을 방지합니다.

패치에서는 while 루프의 조건에 `ftype` 검증을 추가하여, `ftype` 값이 0(정의되지 않은 상태)인 경우 프레임 디스크립터 파싱을 아예 건너뛰도록 수정했습니다. 이 변경을 통해, 잘못된 프레임 타입(예, UVC_VS_UNDEFINED)으로 인한 버퍼 크기 계산 오류가 발생하지 않고, 따라서 버퍼의 OOB Write를 시도하는 상황을 미연에 방지할 수 있습니다. 결과적으로, 메모리 오염 및 악의적 코드 실행의 위험이 크게 감소합니다.