---
title: "[하루한줄] CVE-2024-20017 : wappd의 OOB Write로 인한 Remote Code Execution 취약점"
author: j0ker
tags: [mediatek, CVE-2024-20017, oob write, j0ker, wappd, Netgear, WAX206]
categories: [1day1line]
date: 2024-08-31 19:00:00
cc: true
index_img: /img/1day1line.png
---

## URL

- [4 exploits, 1 bug: exploiting cve-2024-20017 4 different ways](https://blog.coffinsec.com/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html)

## Target

- Affected Chipsets: MediaTek MT6890, MT7915, MT7916, MT7981, MT7986
- Affected Software Versions: SDK version 7.4.0.1 and before (for MT7915) / SDK version 7.6.7.0 and before (for MT7916, MT7981 and MT7986) / OpenWrt 19.07, 21.02

## Explain

CVE-2024-20017은 미디어텍 wlan 서비스에서 발견된 Out of Bound Write 취약점입니다. 구체적으로는 MediaTek MT7622/MT7915 SDK 및 RTxxxx SoftAp 드라이버 번들 중 네트워크 데몬인 wappd에서발생한 취약점이며, Ubiquiti, Xiaomi, Netgear 등 Wi-Fi6를 지원하는 임베디드 플랫폼에서 사용된다고 합니다. 취약점 제보자는 Netgear WAX206에서 익스플로잇을 했다고 합니다. 익스플로잇이 궁금하시면 [원글](https://blog.coffinsec.com/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html)을 참고해주세요.

취약점은 디바이스에서 UDP 패킷을 수신하면서 발생합니다. 패킷이 수신되면 `IAPP_RcvHandler()`는 `IAPP_RcvHandlerUdp()`를 호출하여 수신된 데이터를 저장할 `pPktBuf` 포인터를전달합니다. `IAPP_RcvHandler()`는 `recvfrom()`를 호출하여 UDP 소켓에서 데이터를 읽고 데이터가 제대로 읽혔다면 데이터를 `struct IappHdr`로 캐스팅하고 command 필드를 확인합니다. 값이 0x50인 경우, `IAPP_RcvHandlerSSB()`가 호출되어 요청을 처리합니다.

```cpp
pSendSB = (RT_IAPP_SEND_SECURITY_BLOCK *) pPktBuf; // 원시 데이터 포인터 캐스팅

BufLen = sizeof(OID_REQ);
pSendSB->Length = NTOH_S(pSendSB->Length);
BufLen += FT_IP_ADDRESS_SIZE + IAPP_SB_INIT_VEC_SIZE + pSendSB->Length;

IAPP_CMD_BUF_ALLOCATE(pCmdBuf, pBufMsg, BufLen); // 페이로드 복사
if (pBufMsg == NULL)
  return;
/* End of if */

/* command to notify that a Key Req is received */
DBGPRINT(RT_DEBUG_TRACE, "iapp> IAPP_RcvHandlerSSB\n");

OidReq = (POID_REQ) pBufMsg;
OidReq->OID = (RT_SET_FT_KEY_REQ | OID_GET_SET_TOGGLE);

/* peer IP address */
IAPP_MEM_MOVE(OidReq->Buf, &PeerIP, FT_IP_ADDRESS_SIZE);

/* nonce & security block */
IAPP_MEM_MOVE(OidReq->Buf+FT_IP_ADDRESS_SIZE,
      pSendSB->InitVec, IAPP_SB_INIT_VEC_SIZE);
IAPP_MEM_MOVE(OidReq->Buf+FT_IP_ADDRESS_SIZE+IAPP_SB_INIT_VEC_SIZE,
      pSendSB->SB, pSendSB->Length);
// BUG: overflow occurs here
IAPP_MEM_MOVE(&kdp_info, pSendSB->SB, pSendSB->Length);
```

전달받은 데이터를 `pSendSB`로 캐스팅합니다. 패킷 내 데이터와 길이는 공격자가 제어 가능합니다. 따라서 `pSendSB->Length`와 `pSendSB->SB`를 제어할 수 있습니다. 이를 통해 코드 마지막에서 원하는 길이만큼 `kdp_info`에 쓸 수 있습니다. `kdp_info`의 크기는 167 바이트로 고정되어 있으며 이 코드 이전에 패킷 크기에 대한 검증은 1600 바이트보다 큰지만 검사합니다. 따라서 이 부분에서 `kdp_info`의 크기 보다 크게 써 다른 데이터를 조작할 수 있습니다.