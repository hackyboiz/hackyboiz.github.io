---
title: "[하루한줄] CVE-2025-21333: Windows Hyper-V 구성요소의 heap buffer overflow로 인한 권한상승 취약점"
author: L0ch
tags: [L0ch, windows, hyper-v, lpe, heap buffer overflow, kernel exploit, ioring]
categories: [1day1line]
date: 2025-03-01 17:00:00
cc: true
index_img: /img/1day1line.png
---
## URL

- https://github.com/MrAle98/CVE-2025-21333-POC

## Target

- Windows < 2025년 1월 누적 업데이트

## Explain
Windows Hyper-V NT Kernel Integration VSP 구성 요소에서 발견된 heap buffer overflow로 인한 권한 상승 취약점의 PoC가 공개되었습니다.

취약점은 [Windows 10 1903부터 추가된](https://x.com/j00ru/status/1125321636620562432) CrossVmEvent 객체 관련 syscall인 `NtCreateCrossVmEvent` 에서 발생하나 MS Advisory에 따르면 영향받는 Windows 버전은 Windows 10 21H2 ~ Windows 11 24H2입니다.

취약점을 트리거하기 위해서는 windows sandbox 기능이 활성화되어 있어야 합니다.

> CrossVmEvent는 호스트와 게스트 머신 간 효율적인 리소스 관리, 통신을 처리하는 Virtual Service Provider 관련 객체임
> 

해당 syscall을 처리하는 `vkrnlintvsp.sys` 드라이버는 `VkiRootAdjustSecurityDescriptorForVmwp` 함수에서 객체의 DACL 문자열을 수정합니다.

```c
__int64 __fastcall VkiRootAdjustSecurityDescriptorForVmwp(void *a1, char a2)
//...

   if ( ObjectSecurity >= 0 )
      {
        ObjectSecurity = SeConvertStringSidToSid(
                           L"S-1-15-3-1024-2268835264-3721307629-241982045-173645152-1490879176-104643441-2915960892-1612460704",
                           &P);
        if ( ObjectSecurity >= 0 )
        {
        // Patched Code
          if ( (Feature_2878879035__private_IsEnabledDeviceUsage)(v6) )
          {
            v7 = RtlLengthSid(Sid);
            v8 = RtlLengthSid(P) + 16 + v7;
            v9 = Dacl->AclSize + v8;
            if ( v9 < v8 )
            {
              ObjectSecurity = 0xC0000095;
              goto LABEL_20;
            }
          }
         // Vulnable Code
          else
          {
            SidLength = RtlLengthSid(Sid) + RtlLengthSid(P);
            dwAclSize = Dacl->AclSize + SidLength + 16;
          }
          Pool2 = ExAllocatePool2(256i64, dwAclSize, 1867671894i64);
          v4 = Pool2;
          if ( Pool2 )
          {
            memmove(Pool2, Dacl, Dacl->AclSize);
//...
```

패치 전 코드는 유저가 컨트롤 가능한 객체의 DACL에 SID를 추가하는 과정에서 Pool에 할당할 사이즈 계산 시 integer overflow가 발생하지만 적절한 bound check가 존재하지 않아 예상보다 작은 `dwAclSize`만큼 할당하게 됩니다. 

결과적으로 예상보다 작게 할당된 Pool Buffer에 `AclSize`만큼 복사하는 memmove 호출에서 `0xfff0` 크기의 overflow가 가능합니다. 

poc는 해당 취약점 트리거 이후 I/O Ring Exploit 기법을 사용합니다. 페이지 풀에 `_IOP_MC_BUFFER_ENTRY` 포인터 배열을 할당하고, 유저랜드에 할당한 fake `IOP_MC_BUFFER_ENTRY` 객체를 취약점을 이용해 스프레이해 덮어씁니다. 이후 `BuildIoRingWriteFile()` 와 `BuildIoRingReadFile()` 를 사용해 커널 임의 읽기/쓰기를 얻어 권한 상승을 수행합니다.

취약점의 패치는 위와 같이 `AclSize`와 `Sid` 사이즈 연산 결과가 `Sid` 사이즈보다 작은 경우 복사를 중단하는 것으로 이루어졌습니다.
