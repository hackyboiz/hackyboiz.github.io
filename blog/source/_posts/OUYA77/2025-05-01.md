---
title: "[하루한줄] CVE-2025-25372: cFS 메모리 관리 모듈의 부적절한 메모리 접근 검증으로 인한 서비스 거부 취약점"
author: OUYA77
tags: [NASA cFS, Memory Management, OUYA77, CVE-2025-25372, DoS]
categories: [1day1line]
date: 2025-05-01 22:05:00
cc: true
index_img: /img/1day1line.png
---


## URL

[https://visionspace.com/nasa-cfs-version-aquila-software-vulnerability-assessment/](https://visionspace.com/nasa-cfs-version-aquila-software-vulnerability-assessment/)

## Target

- cFS version Aquila(Releases)

![image.png](image.png)

## Explain

NASA의 cFS(Core Flight System)는 위성, 우주 탐사선, 기타 임베디드 시스템에서 활용되는 오픈소스 소프트웨어 프레임워크입니다.  최근 cFS의 Memory Management(MM) 모듈에서 서비스 거부(DoS, Denial of Service) 공격이 가능한 취약점이 발견되었습니다. 이 취약점은 MM 모듈이 메모리 읽기 또는 쓰기 작업을 수행할 때, 접근하려는 메모리 주소가 유효한지를 적절히 검증하지 않아 발생합니다.

취약한 주요 함수는 다음과 같습니다:

- **`MM_Load`**: 메모리 읽기 관련 함수
- **`MM_Dump`**: 메모리 쓰기 관련 함수

이 두 함수 모두 외부 입력이나 명령에 따라 메모리에 직접 접근하게 되며, 검증되지 않은 주소 접근 시 **Segmentation fault**를 유발할 수 있습니다.

### Proof of Concept

일반적인 상황에서 **`MM_DUMP_MEM_TO_FILE_CC`** 명령은 메모리 위치에서 지정된 수의 바이트를 파일에 덤프하는 역할을 합니다.

![image.png](image%201.png)

이 함수는 소스 주소, 주소 범위, 요청된 데이터 크기, 그리고 저장될 파일 경로를 검증해야 합니다. 그러나 이러한 모든 검증이 올바르게 수행되지 않아 **cFS** 인스턴스가 중단되어 서비스 거부가 발생하는 것으로 확인되었습니다.

명령 구조는 **mm/fsw/inc/mm_msg.h** 에 정의되어 있습니다 :

![image.png](image%202.png)

이 구조는 **MM_DumpMemToFileCmd** (mm/fsw/src/mm_dump.c)에서 입력을 검증하기 전에 각 필드를 추출하는 데 사용됩니다.

첫 번째 검증은 메모리를 덤프할 심볼릭 주소에서 일어납니다.

![image.png](image%203.png)

**MM_ResolveSymAddr** 함수 내부를 보면 다음과 같습니다.

![image.png](image%204.png)

오프셋이 포함된 경우 이 함수는 항상 **Valid = True**를 ****반환합니다. 525~526행에서 심볼 이름이 널 문자열이면 입력된 오프셋을 절대 주소로 사용하여 True를 **반환합니다. 그렇지 않으면 입력으로 전송된 심볼의 주소와 오프셋을 더한 값을 반환합니다.

그런 다음 **MM_VerifyLoadDumpParams**을 사용하여 매개변수를 확인합니다.

![image.png](image%205.png)

이 함수는 먼저 선택된 메모리 유형이 유효한지, 요청된 바이트 수가 해당 메모리 유형의 최대 크기보다 작은지 확인한 후 **CFE_PSP_MemValidateRange**를 호출하여 주소가 PSP 메모리 테이블에 정의된 유효한 메모리 범위에 속하는지 확인합니다.

PSP 테이블은 부팅 시 **CFE_PSP_SetupReservedMemoryMap**에 의해 정의됩니다**.** Linux 시스템의 경우, 기본 설정은 전체 메모리 공간을 읽기/쓰기 작업에 유효한 것으로 정의합니다. 아래 사진은 PSP의 기본적인 메모리 테이블 설정입니다.

![image.png](image%206.png)

- **`MMFileHeader.SymAddress.Offset = SrcAddress;`**:
    - 덤프할 메모리의 시작 주소(`SrcAddress`)가 파일 헤더의 `SymAddress` 구조체 내 `Offset` 필드에 저장됩니다.
- **`MMFileHeader.MemType = CmdPtr->Payload.MemType;`**:
    - 덤프할 메모리의 타입**(**`MemType`**)** (예: RAM, EEPROM)이 명령 페이로드로부터 추출되어 파일 헤더에 저장됩니다.
- **`MMFileHeader.NumOfBytes = CmdPtr->Payload.NumOfBytes;`**:
    - 덤프할 데이터의 크기(`NumOfBytes`)가 명령 페이로드로부터 추출되어 파일 헤더에 저장됩니다.

이는 다른 운영 체제에도 해당되는데, 여기서는 mcp750-vxworks만이 기본적으로 제한된 메모리 공간을 정의합니다.

> Linux와 대조적으로, 언급된 mcp750-vxworks와 같은 특정 운영체제 환경에서는 PSP 메모리 테이블이 기본적으로 **더욱 제한적인 메모리 공간만을 유효한 영역으로 정의**합니다. 이는 잠재적으로 잘못된 메모리 접근이 가능함을 의미합니다.
> 

**MM_DumpMemToFileCmd**에서 입력된 모든 RAM 주소는 검증을 통과하고 실행이 계속됩니다.

이 메모리 주소는 메모리 덤프를 안내하는 데 사용될 파일 헤더를 정의하는 데 사용됩니다.

명령에서 선택한 메모리 유형이 **MM_RAM** 또는 **MM_EEPROM**이면 , 이전에 정의된 파일 헤더를 사용하여 **MM_DumpMemToFile을** 호출합니다.

![image.png](image%207.png)

 이때 파일 헤더에 정의된 오프셋을 `memcpy`의 소스 포인터로 사용합니다. 그렇기에 `memcpy` 작업에서 프로세스 범위 외부에서 보호된 메모리를 복사하려고 시도하여 세그먼테이션 오류가 발생합니다.

cmdUtil과 같은 도구를 사용하여 MM_DUMP_MEM_TO_FILE_CC 명령을 호출하면 **Segmentation fault**를 확인할 수 있습니다.

![](https://visionspace.com/wp-content/uploads/2025/03/image-57-1024x627.png)

화면 상단에서 실행 중이던 **cSF** 인스턴스가 유효하지 않은 주소인 0x40 주소에서 메모리 덤프 요청을 받자 종료되었습니다.

## Reference

[https://nvd.nist.gov/vuln/detail/CVE-2025-25372](https://nvd.nist.gov/vuln/detail/CVE-2025-25372)